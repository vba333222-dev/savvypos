// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'database.dart';

// ignore_for_file: type=lint
class $ZoneTableTable extends ZoneTable
    with TableInfo<$ZoneTableTable, ZoneTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ZoneTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _widthMeta = const VerificationMeta('width');
  @override
  late final GeneratedColumn<double> width = GeneratedColumn<double>(
      'width', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: false,
      defaultValue: const Constant(1000));
  static const VerificationMeta _heightMeta = const VerificationMeta('height');
  @override
  late final GeneratedColumn<double> height = GeneratedColumn<double>(
      'height', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: false,
      defaultValue: const Constant(1000));
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  @override
  List<GeneratedColumn> get $columns =>
      [id, uuid, name, width, height, updatedAt, isDeleted];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'zone_table';
  @override
  VerificationContext validateIntegrity(Insertable<ZoneTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('width')) {
      context.handle(
          _widthMeta, width.isAcceptableOrUnknown(data['width']!, _widthMeta));
    }
    if (data.containsKey('height')) {
      context.handle(_heightMeta,
          height.isAcceptableOrUnknown(data['height']!, _heightMeta));
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  ZoneTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ZoneTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
      width: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}width'])!,
      height: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}height'])!,
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted'])!,
    );
  }

  @override
  $ZoneTableTable createAlias(String alias) {
    return $ZoneTableTable(attachedDatabase, alias);
  }
}

class ZoneTableData extends DataClass implements Insertable<ZoneTableData> {
  final int id;
  final String uuid;
  final String name;
  final double width;
  final double height;
  final DateTime updatedAt;
  final bool isDeleted;
  const ZoneTableData(
      {required this.id,
      required this.uuid,
      required this.name,
      required this.width,
      required this.height,
      required this.updatedAt,
      required this.isDeleted});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    map['name'] = Variable<String>(name);
    map['width'] = Variable<double>(width);
    map['height'] = Variable<double>(height);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    map['is_deleted'] = Variable<bool>(isDeleted);
    return map;
  }

  ZoneTableCompanion toCompanion(bool nullToAbsent) {
    return ZoneTableCompanion(
      id: Value(id),
      uuid: Value(uuid),
      name: Value(name),
      width: Value(width),
      height: Value(height),
      updatedAt: Value(updatedAt),
      isDeleted: Value(isDeleted),
    );
  }

  factory ZoneTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ZoneTableData(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      name: serializer.fromJson<String>(json['name']),
      width: serializer.fromJson<double>(json['width']),
      height: serializer.fromJson<double>(json['height']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'name': serializer.toJson<String>(name),
      'width': serializer.toJson<double>(width),
      'height': serializer.toJson<double>(height),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
      'isDeleted': serializer.toJson<bool>(isDeleted),
    };
  }

  ZoneTableData copyWith(
          {int? id,
          String? uuid,
          String? name,
          double? width,
          double? height,
          DateTime? updatedAt,
          bool? isDeleted}) =>
      ZoneTableData(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        name: name ?? this.name,
        width: width ?? this.width,
        height: height ?? this.height,
        updatedAt: updatedAt ?? this.updatedAt,
        isDeleted: isDeleted ?? this.isDeleted,
      );
  ZoneTableData copyWithCompanion(ZoneTableCompanion data) {
    return ZoneTableData(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      name: data.name.present ? data.name.value : this.name,
      width: data.width.present ? data.width.value : this.width,
      height: data.height.present ? data.height.value : this.height,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      isDeleted: data.isDeleted.present ? data.isDeleted.value : this.isDeleted,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ZoneTableData(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('width: $width, ')
          ..write('height: $height, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('isDeleted: $isDeleted')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, uuid, name, width, height, updatedAt, isDeleted);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ZoneTableData &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.name == this.name &&
          other.width == this.width &&
          other.height == this.height &&
          other.updatedAt == this.updatedAt &&
          other.isDeleted == this.isDeleted);
}

class ZoneTableCompanion extends UpdateCompanion<ZoneTableData> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String> name;
  final Value<double> width;
  final Value<double> height;
  final Value<DateTime> updatedAt;
  final Value<bool> isDeleted;
  const ZoneTableCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.name = const Value.absent(),
    this.width = const Value.absent(),
    this.height = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.isDeleted = const Value.absent(),
  });
  ZoneTableCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    required String name,
    this.width = const Value.absent(),
    this.height = const Value.absent(),
    required DateTime updatedAt,
    this.isDeleted = const Value.absent(),
  })  : uuid = Value(uuid),
        name = Value(name),
        updatedAt = Value(updatedAt);
  static Insertable<ZoneTableData> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? name,
    Expression<double>? width,
    Expression<double>? height,
    Expression<DateTime>? updatedAt,
    Expression<bool>? isDeleted,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (name != null) 'name': name,
      if (width != null) 'width': width,
      if (height != null) 'height': height,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (isDeleted != null) 'is_deleted': isDeleted,
    });
  }

  ZoneTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String>? name,
      Value<double>? width,
      Value<double>? height,
      Value<DateTime>? updatedAt,
      Value<bool>? isDeleted}) {
    return ZoneTableCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      name: name ?? this.name,
      width: width ?? this.width,
      height: height ?? this.height,
      updatedAt: updatedAt ?? this.updatedAt,
      isDeleted: isDeleted ?? this.isDeleted,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (width.present) {
      map['width'] = Variable<double>(width.value);
    }
    if (height.present) {
      map['height'] = Variable<double>(height.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ZoneTableCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('width: $width, ')
          ..write('height: $height, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('isDeleted: $isDeleted')
          ..write(')'))
        .toString();
  }
}

class $TenantConfigTableTable extends TenantConfigTable
    with TableInfo<$TenantConfigTableTable, TenantConfigTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $TenantConfigTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _outletNameMeta =
      const VerificationMeta('outletName');
  @override
  late final GeneratedColumn<String> outletName = GeneratedColumn<String>(
      'outlet_name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _addressMeta =
      const VerificationMeta('address');
  @override
  late final GeneratedColumn<String> address = GeneratedColumn<String>(
      'address', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _currencySymbolMeta =
      const VerificationMeta('currencySymbol');
  @override
  late final GeneratedColumn<String> currencySymbol = GeneratedColumn<String>(
      'currency_symbol', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _tierMeta = const VerificationMeta('tier');
  @override
  late final GeneratedColumn<int> tier = GeneratedColumn<int>(
      'tier', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _subscriptionExpiryMeta =
      const VerificationMeta('subscriptionExpiry');
  @override
  late final GeneratedColumn<DateTime> subscriptionExpiry =
      GeneratedColumn<DateTime>('subscription_expiry', aliasedName, true,
          type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _isAdsEnabledMeta =
      const VerificationMeta('isAdsEnabled');
  @override
  late final GeneratedColumn<bool> isAdsEnabled = GeneratedColumn<bool>(
      'is_ads_enabled', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("is_ads_enabled" IN (0, 1))'));
  static const VerificationMeta _managerPinHashMeta =
      const VerificationMeta('managerPinHash');
  @override
  late final GeneratedColumn<String> managerPinHash = GeneratedColumn<String>(
      'manager_pin_hash', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        tenantId,
        outletName,
        address,
        currencySymbol,
        tier,
        subscriptionExpiry,
        isAdsEnabled,
        managerPinHash,
        updatedAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'tenant_config_table';
  @override
  VerificationContext validateIntegrity(
      Insertable<TenantConfigTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    } else if (isInserting) {
      context.missing(_tenantIdMeta);
    }
    if (data.containsKey('outlet_name')) {
      context.handle(
          _outletNameMeta,
          outletName.isAcceptableOrUnknown(
              data['outlet_name']!, _outletNameMeta));
    } else if (isInserting) {
      context.missing(_outletNameMeta);
    }
    if (data.containsKey('address')) {
      context.handle(_addressMeta,
          address.isAcceptableOrUnknown(data['address']!, _addressMeta));
    } else if (isInserting) {
      context.missing(_addressMeta);
    }
    if (data.containsKey('currency_symbol')) {
      context.handle(
          _currencySymbolMeta,
          currencySymbol.isAcceptableOrUnknown(
              data['currency_symbol']!, _currencySymbolMeta));
    } else if (isInserting) {
      context.missing(_currencySymbolMeta);
    }
    if (data.containsKey('tier')) {
      context.handle(
          _tierMeta, tier.isAcceptableOrUnknown(data['tier']!, _tierMeta));
    } else if (isInserting) {
      context.missing(_tierMeta);
    }
    if (data.containsKey('subscription_expiry')) {
      context.handle(
          _subscriptionExpiryMeta,
          subscriptionExpiry.isAcceptableOrUnknown(
              data['subscription_expiry']!, _subscriptionExpiryMeta));
    }
    if (data.containsKey('is_ads_enabled')) {
      context.handle(
          _isAdsEnabledMeta,
          isAdsEnabled.isAcceptableOrUnknown(
              data['is_ads_enabled']!, _isAdsEnabledMeta));
    } else if (isInserting) {
      context.missing(_isAdsEnabledMeta);
    }
    if (data.containsKey('manager_pin_hash')) {
      context.handle(
          _managerPinHashMeta,
          managerPinHash.isAcceptableOrUnknown(
              data['manager_pin_hash']!, _managerPinHashMeta));
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  TenantConfigTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return TenantConfigTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id'])!,
      outletName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}outlet_name'])!,
      address: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}address'])!,
      currencySymbol: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}currency_symbol'])!,
      tier: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}tier'])!,
      subscriptionExpiry: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}subscription_expiry']),
      isAdsEnabled: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_ads_enabled'])!,
      managerPinHash: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}manager_pin_hash']),
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $TenantConfigTableTable createAlias(String alias) {
    return $TenantConfigTableTable(attachedDatabase, alias);
  }
}

class TenantConfigTableData extends DataClass
    implements Insertable<TenantConfigTableData> {
  final int id;
  final String tenantId;
  final String outletName;
  final String address;
  final String currencySymbol;
  final int tier;
  final DateTime? subscriptionExpiry;
  final bool isAdsEnabled;
  final String? managerPinHash;
  final DateTime updatedAt;
  const TenantConfigTableData(
      {required this.id,
      required this.tenantId,
      required this.outletName,
      required this.address,
      required this.currencySymbol,
      required this.tier,
      this.subscriptionExpiry,
      required this.isAdsEnabled,
      this.managerPinHash,
      required this.updatedAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['tenant_id'] = Variable<String>(tenantId);
    map['outlet_name'] = Variable<String>(outletName);
    map['address'] = Variable<String>(address);
    map['currency_symbol'] = Variable<String>(currencySymbol);
    map['tier'] = Variable<int>(tier);
    if (!nullToAbsent || subscriptionExpiry != null) {
      map['subscription_expiry'] = Variable<DateTime>(subscriptionExpiry);
    }
    map['is_ads_enabled'] = Variable<bool>(isAdsEnabled);
    if (!nullToAbsent || managerPinHash != null) {
      map['manager_pin_hash'] = Variable<String>(managerPinHash);
    }
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  TenantConfigTableCompanion toCompanion(bool nullToAbsent) {
    return TenantConfigTableCompanion(
      id: Value(id),
      tenantId: Value(tenantId),
      outletName: Value(outletName),
      address: Value(address),
      currencySymbol: Value(currencySymbol),
      tier: Value(tier),
      subscriptionExpiry: subscriptionExpiry == null && nullToAbsent
          ? const Value.absent()
          : Value(subscriptionExpiry),
      isAdsEnabled: Value(isAdsEnabled),
      managerPinHash: managerPinHash == null && nullToAbsent
          ? const Value.absent()
          : Value(managerPinHash),
      updatedAt: Value(updatedAt),
    );
  }

  factory TenantConfigTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return TenantConfigTableData(
      id: serializer.fromJson<int>(json['id']),
      tenantId: serializer.fromJson<String>(json['tenantId']),
      outletName: serializer.fromJson<String>(json['outletName']),
      address: serializer.fromJson<String>(json['address']),
      currencySymbol: serializer.fromJson<String>(json['currencySymbol']),
      tier: serializer.fromJson<int>(json['tier']),
      subscriptionExpiry:
          serializer.fromJson<DateTime?>(json['subscriptionExpiry']),
      isAdsEnabled: serializer.fromJson<bool>(json['isAdsEnabled']),
      managerPinHash: serializer.fromJson<String?>(json['managerPinHash']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'tenantId': serializer.toJson<String>(tenantId),
      'outletName': serializer.toJson<String>(outletName),
      'address': serializer.toJson<String>(address),
      'currencySymbol': serializer.toJson<String>(currencySymbol),
      'tier': serializer.toJson<int>(tier),
      'subscriptionExpiry': serializer.toJson<DateTime?>(subscriptionExpiry),
      'isAdsEnabled': serializer.toJson<bool>(isAdsEnabled),
      'managerPinHash': serializer.toJson<String?>(managerPinHash),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  TenantConfigTableData copyWith(
          {int? id,
          String? tenantId,
          String? outletName,
          String? address,
          String? currencySymbol,
          int? tier,
          Value<DateTime?> subscriptionExpiry = const Value.absent(),
          bool? isAdsEnabled,
          Value<String?> managerPinHash = const Value.absent(),
          DateTime? updatedAt}) =>
      TenantConfigTableData(
        id: id ?? this.id,
        tenantId: tenantId ?? this.tenantId,
        outletName: outletName ?? this.outletName,
        address: address ?? this.address,
        currencySymbol: currencySymbol ?? this.currencySymbol,
        tier: tier ?? this.tier,
        subscriptionExpiry: subscriptionExpiry.present
            ? subscriptionExpiry.value
            : this.subscriptionExpiry,
        isAdsEnabled: isAdsEnabled ?? this.isAdsEnabled,
        managerPinHash:
            managerPinHash.present ? managerPinHash.value : this.managerPinHash,
        updatedAt: updatedAt ?? this.updatedAt,
      );
  TenantConfigTableData copyWithCompanion(TenantConfigTableCompanion data) {
    return TenantConfigTableData(
      id: data.id.present ? data.id.value : this.id,
      tenantId: data.tenantId.present ? data.tenantId.value : this.tenantId,
      outletName:
          data.outletName.present ? data.outletName.value : this.outletName,
      address: data.address.present ? data.address.value : this.address,
      currencySymbol: data.currencySymbol.present
          ? data.currencySymbol.value
          : this.currencySymbol,
      tier: data.tier.present ? data.tier.value : this.tier,
      subscriptionExpiry: data.subscriptionExpiry.present
          ? data.subscriptionExpiry.value
          : this.subscriptionExpiry,
      isAdsEnabled: data.isAdsEnabled.present
          ? data.isAdsEnabled.value
          : this.isAdsEnabled,
      managerPinHash: data.managerPinHash.present
          ? data.managerPinHash.value
          : this.managerPinHash,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('TenantConfigTableData(')
          ..write('id: $id, ')
          ..write('tenantId: $tenantId, ')
          ..write('outletName: $outletName, ')
          ..write('address: $address, ')
          ..write('currencySymbol: $currencySymbol, ')
          ..write('tier: $tier, ')
          ..write('subscriptionExpiry: $subscriptionExpiry, ')
          ..write('isAdsEnabled: $isAdsEnabled, ')
          ..write('managerPinHash: $managerPinHash, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      tenantId,
      outletName,
      address,
      currencySymbol,
      tier,
      subscriptionExpiry,
      isAdsEnabled,
      managerPinHash,
      updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is TenantConfigTableData &&
          other.id == this.id &&
          other.tenantId == this.tenantId &&
          other.outletName == this.outletName &&
          other.address == this.address &&
          other.currencySymbol == this.currencySymbol &&
          other.tier == this.tier &&
          other.subscriptionExpiry == this.subscriptionExpiry &&
          other.isAdsEnabled == this.isAdsEnabled &&
          other.managerPinHash == this.managerPinHash &&
          other.updatedAt == this.updatedAt);
}

class TenantConfigTableCompanion
    extends UpdateCompanion<TenantConfigTableData> {
  final Value<int> id;
  final Value<String> tenantId;
  final Value<String> outletName;
  final Value<String> address;
  final Value<String> currencySymbol;
  final Value<int> tier;
  final Value<DateTime?> subscriptionExpiry;
  final Value<bool> isAdsEnabled;
  final Value<String?> managerPinHash;
  final Value<DateTime> updatedAt;
  const TenantConfigTableCompanion({
    this.id = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.outletName = const Value.absent(),
    this.address = const Value.absent(),
    this.currencySymbol = const Value.absent(),
    this.tier = const Value.absent(),
    this.subscriptionExpiry = const Value.absent(),
    this.isAdsEnabled = const Value.absent(),
    this.managerPinHash = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  TenantConfigTableCompanion.insert({
    this.id = const Value.absent(),
    required String tenantId,
    required String outletName,
    required String address,
    required String currencySymbol,
    required int tier,
    this.subscriptionExpiry = const Value.absent(),
    required bool isAdsEnabled,
    this.managerPinHash = const Value.absent(),
    required DateTime updatedAt,
  })  : tenantId = Value(tenantId),
        outletName = Value(outletName),
        address = Value(address),
        currencySymbol = Value(currencySymbol),
        tier = Value(tier),
        isAdsEnabled = Value(isAdsEnabled),
        updatedAt = Value(updatedAt);
  static Insertable<TenantConfigTableData> custom({
    Expression<int>? id,
    Expression<String>? tenantId,
    Expression<String>? outletName,
    Expression<String>? address,
    Expression<String>? currencySymbol,
    Expression<int>? tier,
    Expression<DateTime>? subscriptionExpiry,
    Expression<bool>? isAdsEnabled,
    Expression<String>? managerPinHash,
    Expression<DateTime>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (tenantId != null) 'tenant_id': tenantId,
      if (outletName != null) 'outlet_name': outletName,
      if (address != null) 'address': address,
      if (currencySymbol != null) 'currency_symbol': currencySymbol,
      if (tier != null) 'tier': tier,
      if (subscriptionExpiry != null) 'subscription_expiry': subscriptionExpiry,
      if (isAdsEnabled != null) 'is_ads_enabled': isAdsEnabled,
      if (managerPinHash != null) 'manager_pin_hash': managerPinHash,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  TenantConfigTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? tenantId,
      Value<String>? outletName,
      Value<String>? address,
      Value<String>? currencySymbol,
      Value<int>? tier,
      Value<DateTime?>? subscriptionExpiry,
      Value<bool>? isAdsEnabled,
      Value<String?>? managerPinHash,
      Value<DateTime>? updatedAt}) {
    return TenantConfigTableCompanion(
      id: id ?? this.id,
      tenantId: tenantId ?? this.tenantId,
      outletName: outletName ?? this.outletName,
      address: address ?? this.address,
      currencySymbol: currencySymbol ?? this.currencySymbol,
      tier: tier ?? this.tier,
      subscriptionExpiry: subscriptionExpiry ?? this.subscriptionExpiry,
      isAdsEnabled: isAdsEnabled ?? this.isAdsEnabled,
      managerPinHash: managerPinHash ?? this.managerPinHash,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (outletName.present) {
      map['outlet_name'] = Variable<String>(outletName.value);
    }
    if (address.present) {
      map['address'] = Variable<String>(address.value);
    }
    if (currencySymbol.present) {
      map['currency_symbol'] = Variable<String>(currencySymbol.value);
    }
    if (tier.present) {
      map['tier'] = Variable<int>(tier.value);
    }
    if (subscriptionExpiry.present) {
      map['subscription_expiry'] = Variable<DateTime>(subscriptionExpiry.value);
    }
    if (isAdsEnabled.present) {
      map['is_ads_enabled'] = Variable<bool>(isAdsEnabled.value);
    }
    if (managerPinHash.present) {
      map['manager_pin_hash'] = Variable<String>(managerPinHash.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('TenantConfigTableCompanion(')
          ..write('id: $id, ')
          ..write('tenantId: $tenantId, ')
          ..write('outletName: $outletName, ')
          ..write('address: $address, ')
          ..write('currencySymbol: $currencySymbol, ')
          ..write('tier: $tier, ')
          ..write('subscriptionExpiry: $subscriptionExpiry, ')
          ..write('isAdsEnabled: $isAdsEnabled, ')
          ..write('managerPinHash: $managerPinHash, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class $RestaurantTableTable extends RestaurantTable
    with TableInfo<$RestaurantTableTable, RestaurantTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $RestaurantTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _capacityMeta =
      const VerificationMeta('capacity');
  @override
  late final GeneratedColumn<int> capacity = GeneratedColumn<int>(
      'capacity', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultValue: const Constant(4));
  static const VerificationMeta _xMeta = const VerificationMeta('x');
  @override
  late final GeneratedColumn<double> x = GeneratedColumn<double>(
      'x', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: false,
      defaultValue: const Constant(0));
  static const VerificationMeta _yMeta = const VerificationMeta('y');
  @override
  late final GeneratedColumn<double> y = GeneratedColumn<double>(
      'y', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: false,
      defaultValue: const Constant(0));
  static const VerificationMeta _widthMeta = const VerificationMeta('width');
  @override
  late final GeneratedColumn<double> width = GeneratedColumn<double>(
      'width', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: false,
      defaultValue: const Constant(100));
  static const VerificationMeta _heightMeta = const VerificationMeta('height');
  @override
  late final GeneratedColumn<double> height = GeneratedColumn<double>(
      'height', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: false,
      defaultValue: const Constant(100));
  static const VerificationMeta _rotationMeta =
      const VerificationMeta('rotation');
  @override
  late final GeneratedColumn<double> rotation = GeneratedColumn<double>(
      'rotation', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: false,
      defaultValue: const Constant(0));
  static const VerificationMeta _shapeMeta = const VerificationMeta('shape');
  @override
  late final GeneratedColumn<String> shape = GeneratedColumn<String>(
      'shape', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultValue: const Constant('rectangle'));
  static const VerificationMeta _zoneUuidMeta =
      const VerificationMeta('zoneUuid');
  @override
  late final GeneratedColumn<String> zoneUuid = GeneratedColumn<String>(
      'zone_uuid', aliasedName, true,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES zone_table (uuid)'));
  static const VerificationMeta _isOccupiedMeta =
      const VerificationMeta('isOccupied');
  @override
  late final GeneratedColumn<bool> isOccupied = GeneratedColumn<bool>(
      'is_occupied', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_occupied" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _currentOrderUuidMeta =
      const VerificationMeta('currentOrderUuid');
  @override
  late final GeneratedColumn<String> currentOrderUuid = GeneratedColumn<String>(
      'current_order_uuid', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _currentSessionTokenMeta =
      const VerificationMeta('currentSessionToken');
  @override
  late final GeneratedColumn<String> currentSessionToken =
      GeneratedColumn<String>('current_session_token', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _qrCodeUrlMeta =
      const VerificationMeta('qrCodeUrl');
  @override
  late final GeneratedColumn<String> qrCodeUrl = GeneratedColumn<String>(
      'qr_code_url', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _sessionStatusMeta =
      const VerificationMeta('sessionStatus');
  @override
  late final GeneratedColumn<String> sessionStatus = GeneratedColumn<String>(
      'session_status', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultValue: const Constant('LOCKED'));
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _versionMeta =
      const VerificationMeta('version');
  @override
  late final GeneratedColumn<int> version = GeneratedColumn<int>(
      'version', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultValue: const Constant(1));
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        name,
        capacity,
        x,
        y,
        width,
        height,
        rotation,
        shape,
        zoneUuid,
        isOccupied,
        currentOrderUuid,
        currentSessionToken,
        qrCodeUrl,
        sessionStatus,
        updatedAt,
        isDeleted,
        version
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'restaurant_table';
  @override
  VerificationContext validateIntegrity(
      Insertable<RestaurantTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('capacity')) {
      context.handle(_capacityMeta,
          capacity.isAcceptableOrUnknown(data['capacity']!, _capacityMeta));
    }
    if (data.containsKey('x')) {
      context.handle(_xMeta, x.isAcceptableOrUnknown(data['x']!, _xMeta));
    }
    if (data.containsKey('y')) {
      context.handle(_yMeta, y.isAcceptableOrUnknown(data['y']!, _yMeta));
    }
    if (data.containsKey('width')) {
      context.handle(
          _widthMeta, width.isAcceptableOrUnknown(data['width']!, _widthMeta));
    }
    if (data.containsKey('height')) {
      context.handle(_heightMeta,
          height.isAcceptableOrUnknown(data['height']!, _heightMeta));
    }
    if (data.containsKey('rotation')) {
      context.handle(_rotationMeta,
          rotation.isAcceptableOrUnknown(data['rotation']!, _rotationMeta));
    }
    if (data.containsKey('shape')) {
      context.handle(
          _shapeMeta, shape.isAcceptableOrUnknown(data['shape']!, _shapeMeta));
    }
    if (data.containsKey('zone_uuid')) {
      context.handle(_zoneUuidMeta,
          zoneUuid.isAcceptableOrUnknown(data['zone_uuid']!, _zoneUuidMeta));
    }
    if (data.containsKey('is_occupied')) {
      context.handle(
          _isOccupiedMeta,
          isOccupied.isAcceptableOrUnknown(
              data['is_occupied']!, _isOccupiedMeta));
    }
    if (data.containsKey('current_order_uuid')) {
      context.handle(
          _currentOrderUuidMeta,
          currentOrderUuid.isAcceptableOrUnknown(
              data['current_order_uuid']!, _currentOrderUuidMeta));
    }
    if (data.containsKey('current_session_token')) {
      context.handle(
          _currentSessionTokenMeta,
          currentSessionToken.isAcceptableOrUnknown(
              data['current_session_token']!, _currentSessionTokenMeta));
    }
    if (data.containsKey('qr_code_url')) {
      context.handle(
          _qrCodeUrlMeta,
          qrCodeUrl.isAcceptableOrUnknown(
              data['qr_code_url']!, _qrCodeUrlMeta));
    }
    if (data.containsKey('session_status')) {
      context.handle(
          _sessionStatusMeta,
          sessionStatus.isAcceptableOrUnknown(
              data['session_status']!, _sessionStatusMeta));
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('version')) {
      context.handle(_versionMeta,
          version.isAcceptableOrUnknown(data['version']!, _versionMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  RestaurantTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return RestaurantTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
      capacity: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}capacity'])!,
      x: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}x'])!,
      y: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}y'])!,
      width: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}width'])!,
      height: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}height'])!,
      rotation: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}rotation'])!,
      shape: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}shape'])!,
      zoneUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}zone_uuid']),
      isOccupied: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_occupied'])!,
      currentOrderUuid: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}current_order_uuid']),
      currentSessionToken: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}current_session_token']),
      qrCodeUrl: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}qr_code_url']),
      sessionStatus: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}session_status'])!,
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted'])!,
      version: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}version'])!,
    );
  }

  @override
  $RestaurantTableTable createAlias(String alias) {
    return $RestaurantTableTable(attachedDatabase, alias);
  }
}

class RestaurantTableData extends DataClass
    implements Insertable<RestaurantTableData> {
  final int id;
  final String uuid;
  final String name;
  final int capacity;
  final double x;
  final double y;
  final double width;
  final double height;
  final double rotation;
  final String shape;
  final String? zoneUuid;
  final bool isOccupied;
  final String? currentOrderUuid;
  final String? currentSessionToken;
  final String? qrCodeUrl;
  final String sessionStatus;
  final DateTime updatedAt;
  final bool isDeleted;
  final int version;
  const RestaurantTableData(
      {required this.id,
      required this.uuid,
      required this.name,
      required this.capacity,
      required this.x,
      required this.y,
      required this.width,
      required this.height,
      required this.rotation,
      required this.shape,
      this.zoneUuid,
      required this.isOccupied,
      this.currentOrderUuid,
      this.currentSessionToken,
      this.qrCodeUrl,
      required this.sessionStatus,
      required this.updatedAt,
      required this.isDeleted,
      required this.version});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    map['name'] = Variable<String>(name);
    map['capacity'] = Variable<int>(capacity);
    map['x'] = Variable<double>(x);
    map['y'] = Variable<double>(y);
    map['width'] = Variable<double>(width);
    map['height'] = Variable<double>(height);
    map['rotation'] = Variable<double>(rotation);
    map['shape'] = Variable<String>(shape);
    if (!nullToAbsent || zoneUuid != null) {
      map['zone_uuid'] = Variable<String>(zoneUuid);
    }
    map['is_occupied'] = Variable<bool>(isOccupied);
    if (!nullToAbsent || currentOrderUuid != null) {
      map['current_order_uuid'] = Variable<String>(currentOrderUuid);
    }
    if (!nullToAbsent || currentSessionToken != null) {
      map['current_session_token'] = Variable<String>(currentSessionToken);
    }
    if (!nullToAbsent || qrCodeUrl != null) {
      map['qr_code_url'] = Variable<String>(qrCodeUrl);
    }
    map['session_status'] = Variable<String>(sessionStatus);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    map['is_deleted'] = Variable<bool>(isDeleted);
    map['version'] = Variable<int>(version);
    return map;
  }

  RestaurantTableCompanion toCompanion(bool nullToAbsent) {
    return RestaurantTableCompanion(
      id: Value(id),
      uuid: Value(uuid),
      name: Value(name),
      capacity: Value(capacity),
      x: Value(x),
      y: Value(y),
      width: Value(width),
      height: Value(height),
      rotation: Value(rotation),
      shape: Value(shape),
      zoneUuid: zoneUuid == null && nullToAbsent
          ? const Value.absent()
          : Value(zoneUuid),
      isOccupied: Value(isOccupied),
      currentOrderUuid: currentOrderUuid == null && nullToAbsent
          ? const Value.absent()
          : Value(currentOrderUuid),
      currentSessionToken: currentSessionToken == null && nullToAbsent
          ? const Value.absent()
          : Value(currentSessionToken),
      qrCodeUrl: qrCodeUrl == null && nullToAbsent
          ? const Value.absent()
          : Value(qrCodeUrl),
      sessionStatus: Value(sessionStatus),
      updatedAt: Value(updatedAt),
      isDeleted: Value(isDeleted),
      version: Value(version),
    );
  }

  factory RestaurantTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return RestaurantTableData(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      name: serializer.fromJson<String>(json['name']),
      capacity: serializer.fromJson<int>(json['capacity']),
      x: serializer.fromJson<double>(json['x']),
      y: serializer.fromJson<double>(json['y']),
      width: serializer.fromJson<double>(json['width']),
      height: serializer.fromJson<double>(json['height']),
      rotation: serializer.fromJson<double>(json['rotation']),
      shape: serializer.fromJson<String>(json['shape']),
      zoneUuid: serializer.fromJson<String?>(json['zoneUuid']),
      isOccupied: serializer.fromJson<bool>(json['isOccupied']),
      currentOrderUuid: serializer.fromJson<String?>(json['currentOrderUuid']),
      currentSessionToken:
          serializer.fromJson<String?>(json['currentSessionToken']),
      qrCodeUrl: serializer.fromJson<String?>(json['qrCodeUrl']),
      sessionStatus: serializer.fromJson<String>(json['sessionStatus']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      version: serializer.fromJson<int>(json['version']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'name': serializer.toJson<String>(name),
      'capacity': serializer.toJson<int>(capacity),
      'x': serializer.toJson<double>(x),
      'y': serializer.toJson<double>(y),
      'width': serializer.toJson<double>(width),
      'height': serializer.toJson<double>(height),
      'rotation': serializer.toJson<double>(rotation),
      'shape': serializer.toJson<String>(shape),
      'zoneUuid': serializer.toJson<String?>(zoneUuid),
      'isOccupied': serializer.toJson<bool>(isOccupied),
      'currentOrderUuid': serializer.toJson<String?>(currentOrderUuid),
      'currentSessionToken': serializer.toJson<String?>(currentSessionToken),
      'qrCodeUrl': serializer.toJson<String?>(qrCodeUrl),
      'sessionStatus': serializer.toJson<String>(sessionStatus),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'version': serializer.toJson<int>(version),
    };
  }

  RestaurantTableData copyWith(
          {int? id,
          String? uuid,
          String? name,
          int? capacity,
          double? x,
          double? y,
          double? width,
          double? height,
          double? rotation,
          String? shape,
          Value<String?> zoneUuid = const Value.absent(),
          bool? isOccupied,
          Value<String?> currentOrderUuid = const Value.absent(),
          Value<String?> currentSessionToken = const Value.absent(),
          Value<String?> qrCodeUrl = const Value.absent(),
          String? sessionStatus,
          DateTime? updatedAt,
          bool? isDeleted,
          int? version}) =>
      RestaurantTableData(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        name: name ?? this.name,
        capacity: capacity ?? this.capacity,
        x: x ?? this.x,
        y: y ?? this.y,
        width: width ?? this.width,
        height: height ?? this.height,
        rotation: rotation ?? this.rotation,
        shape: shape ?? this.shape,
        zoneUuid: zoneUuid.present ? zoneUuid.value : this.zoneUuid,
        isOccupied: isOccupied ?? this.isOccupied,
        currentOrderUuid: currentOrderUuid.present
            ? currentOrderUuid.value
            : this.currentOrderUuid,
        currentSessionToken: currentSessionToken.present
            ? currentSessionToken.value
            : this.currentSessionToken,
        qrCodeUrl: qrCodeUrl.present ? qrCodeUrl.value : this.qrCodeUrl,
        sessionStatus: sessionStatus ?? this.sessionStatus,
        updatedAt: updatedAt ?? this.updatedAt,
        isDeleted: isDeleted ?? this.isDeleted,
        version: version ?? this.version,
      );
  RestaurantTableData copyWithCompanion(RestaurantTableCompanion data) {
    return RestaurantTableData(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      name: data.name.present ? data.name.value : this.name,
      capacity: data.capacity.present ? data.capacity.value : this.capacity,
      x: data.x.present ? data.x.value : this.x,
      y: data.y.present ? data.y.value : this.y,
      width: data.width.present ? data.width.value : this.width,
      height: data.height.present ? data.height.value : this.height,
      rotation: data.rotation.present ? data.rotation.value : this.rotation,
      shape: data.shape.present ? data.shape.value : this.shape,
      zoneUuid: data.zoneUuid.present ? data.zoneUuid.value : this.zoneUuid,
      isOccupied:
          data.isOccupied.present ? data.isOccupied.value : this.isOccupied,
      currentOrderUuid: data.currentOrderUuid.present
          ? data.currentOrderUuid.value
          : this.currentOrderUuid,
      currentSessionToken: data.currentSessionToken.present
          ? data.currentSessionToken.value
          : this.currentSessionToken,
      qrCodeUrl: data.qrCodeUrl.present ? data.qrCodeUrl.value : this.qrCodeUrl,
      sessionStatus: data.sessionStatus.present
          ? data.sessionStatus.value
          : this.sessionStatus,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      isDeleted: data.isDeleted.present ? data.isDeleted.value : this.isDeleted,
      version: data.version.present ? data.version.value : this.version,
    );
  }

  @override
  String toString() {
    return (StringBuffer('RestaurantTableData(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('capacity: $capacity, ')
          ..write('x: $x, ')
          ..write('y: $y, ')
          ..write('width: $width, ')
          ..write('height: $height, ')
          ..write('rotation: $rotation, ')
          ..write('shape: $shape, ')
          ..write('zoneUuid: $zoneUuid, ')
          ..write('isOccupied: $isOccupied, ')
          ..write('currentOrderUuid: $currentOrderUuid, ')
          ..write('currentSessionToken: $currentSessionToken, ')
          ..write('qrCodeUrl: $qrCodeUrl, ')
          ..write('sessionStatus: $sessionStatus, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('version: $version')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      uuid,
      name,
      capacity,
      x,
      y,
      width,
      height,
      rotation,
      shape,
      zoneUuid,
      isOccupied,
      currentOrderUuid,
      currentSessionToken,
      qrCodeUrl,
      sessionStatus,
      updatedAt,
      isDeleted,
      version);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is RestaurantTableData &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.name == this.name &&
          other.capacity == this.capacity &&
          other.x == this.x &&
          other.y == this.y &&
          other.width == this.width &&
          other.height == this.height &&
          other.rotation == this.rotation &&
          other.shape == this.shape &&
          other.zoneUuid == this.zoneUuid &&
          other.isOccupied == this.isOccupied &&
          other.currentOrderUuid == this.currentOrderUuid &&
          other.currentSessionToken == this.currentSessionToken &&
          other.qrCodeUrl == this.qrCodeUrl &&
          other.sessionStatus == this.sessionStatus &&
          other.updatedAt == this.updatedAt &&
          other.isDeleted == this.isDeleted &&
          other.version == this.version);
}

class RestaurantTableCompanion extends UpdateCompanion<RestaurantTableData> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String> name;
  final Value<int> capacity;
  final Value<double> x;
  final Value<double> y;
  final Value<double> width;
  final Value<double> height;
  final Value<double> rotation;
  final Value<String> shape;
  final Value<String?> zoneUuid;
  final Value<bool> isOccupied;
  final Value<String?> currentOrderUuid;
  final Value<String?> currentSessionToken;
  final Value<String?> qrCodeUrl;
  final Value<String> sessionStatus;
  final Value<DateTime> updatedAt;
  final Value<bool> isDeleted;
  final Value<int> version;
  const RestaurantTableCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.name = const Value.absent(),
    this.capacity = const Value.absent(),
    this.x = const Value.absent(),
    this.y = const Value.absent(),
    this.width = const Value.absent(),
    this.height = const Value.absent(),
    this.rotation = const Value.absent(),
    this.shape = const Value.absent(),
    this.zoneUuid = const Value.absent(),
    this.isOccupied = const Value.absent(),
    this.currentOrderUuid = const Value.absent(),
    this.currentSessionToken = const Value.absent(),
    this.qrCodeUrl = const Value.absent(),
    this.sessionStatus = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.version = const Value.absent(),
  });
  RestaurantTableCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    required String name,
    this.capacity = const Value.absent(),
    this.x = const Value.absent(),
    this.y = const Value.absent(),
    this.width = const Value.absent(),
    this.height = const Value.absent(),
    this.rotation = const Value.absent(),
    this.shape = const Value.absent(),
    this.zoneUuid = const Value.absent(),
    this.isOccupied = const Value.absent(),
    this.currentOrderUuid = const Value.absent(),
    this.currentSessionToken = const Value.absent(),
    this.qrCodeUrl = const Value.absent(),
    this.sessionStatus = const Value.absent(),
    required DateTime updatedAt,
    this.isDeleted = const Value.absent(),
    this.version = const Value.absent(),
  })  : uuid = Value(uuid),
        name = Value(name),
        updatedAt = Value(updatedAt);
  static Insertable<RestaurantTableData> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? name,
    Expression<int>? capacity,
    Expression<double>? x,
    Expression<double>? y,
    Expression<double>? width,
    Expression<double>? height,
    Expression<double>? rotation,
    Expression<String>? shape,
    Expression<String>? zoneUuid,
    Expression<bool>? isOccupied,
    Expression<String>? currentOrderUuid,
    Expression<String>? currentSessionToken,
    Expression<String>? qrCodeUrl,
    Expression<String>? sessionStatus,
    Expression<DateTime>? updatedAt,
    Expression<bool>? isDeleted,
    Expression<int>? version,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (name != null) 'name': name,
      if (capacity != null) 'capacity': capacity,
      if (x != null) 'x': x,
      if (y != null) 'y': y,
      if (width != null) 'width': width,
      if (height != null) 'height': height,
      if (rotation != null) 'rotation': rotation,
      if (shape != null) 'shape': shape,
      if (zoneUuid != null) 'zone_uuid': zoneUuid,
      if (isOccupied != null) 'is_occupied': isOccupied,
      if (currentOrderUuid != null) 'current_order_uuid': currentOrderUuid,
      if (currentSessionToken != null)
        'current_session_token': currentSessionToken,
      if (qrCodeUrl != null) 'qr_code_url': qrCodeUrl,
      if (sessionStatus != null) 'session_status': sessionStatus,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (version != null) 'version': version,
    });
  }

  RestaurantTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String>? name,
      Value<int>? capacity,
      Value<double>? x,
      Value<double>? y,
      Value<double>? width,
      Value<double>? height,
      Value<double>? rotation,
      Value<String>? shape,
      Value<String?>? zoneUuid,
      Value<bool>? isOccupied,
      Value<String?>? currentOrderUuid,
      Value<String?>? currentSessionToken,
      Value<String?>? qrCodeUrl,
      Value<String>? sessionStatus,
      Value<DateTime>? updatedAt,
      Value<bool>? isDeleted,
      Value<int>? version}) {
    return RestaurantTableCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      name: name ?? this.name,
      capacity: capacity ?? this.capacity,
      x: x ?? this.x,
      y: y ?? this.y,
      width: width ?? this.width,
      height: height ?? this.height,
      rotation: rotation ?? this.rotation,
      shape: shape ?? this.shape,
      zoneUuid: zoneUuid ?? this.zoneUuid,
      isOccupied: isOccupied ?? this.isOccupied,
      currentOrderUuid: currentOrderUuid ?? this.currentOrderUuid,
      currentSessionToken: currentSessionToken ?? this.currentSessionToken,
      qrCodeUrl: qrCodeUrl ?? this.qrCodeUrl,
      sessionStatus: sessionStatus ?? this.sessionStatus,
      updatedAt: updatedAt ?? this.updatedAt,
      isDeleted: isDeleted ?? this.isDeleted,
      version: version ?? this.version,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (capacity.present) {
      map['capacity'] = Variable<int>(capacity.value);
    }
    if (x.present) {
      map['x'] = Variable<double>(x.value);
    }
    if (y.present) {
      map['y'] = Variable<double>(y.value);
    }
    if (width.present) {
      map['width'] = Variable<double>(width.value);
    }
    if (height.present) {
      map['height'] = Variable<double>(height.value);
    }
    if (rotation.present) {
      map['rotation'] = Variable<double>(rotation.value);
    }
    if (shape.present) {
      map['shape'] = Variable<String>(shape.value);
    }
    if (zoneUuid.present) {
      map['zone_uuid'] = Variable<String>(zoneUuid.value);
    }
    if (isOccupied.present) {
      map['is_occupied'] = Variable<bool>(isOccupied.value);
    }
    if (currentOrderUuid.present) {
      map['current_order_uuid'] = Variable<String>(currentOrderUuid.value);
    }
    if (currentSessionToken.present) {
      map['current_session_token'] =
          Variable<String>(currentSessionToken.value);
    }
    if (qrCodeUrl.present) {
      map['qr_code_url'] = Variable<String>(qrCodeUrl.value);
    }
    if (sessionStatus.present) {
      map['session_status'] = Variable<String>(sessionStatus.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (version.present) {
      map['version'] = Variable<int>(version.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('RestaurantTableCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('capacity: $capacity, ')
          ..write('x: $x, ')
          ..write('y: $y, ')
          ..write('width: $width, ')
          ..write('height: $height, ')
          ..write('rotation: $rotation, ')
          ..write('shape: $shape, ')
          ..write('zoneUuid: $zoneUuid, ')
          ..write('isOccupied: $isOccupied, ')
          ..write('currentOrderUuid: $currentOrderUuid, ')
          ..write('currentSessionToken: $currentSessionToken, ')
          ..write('qrCodeUrl: $qrCodeUrl, ')
          ..write('sessionStatus: $sessionStatus, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('version: $version')
          ..write(')'))
        .toString();
  }
}

class $ReservationTableTable extends ReservationTable
    with TableInfo<$ReservationTableTable, ReservationTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ReservationTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _customerNameMeta =
      const VerificationMeta('customerName');
  @override
  late final GeneratedColumn<String> customerName = GeneratedColumn<String>(
      'customer_name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _phoneMeta = const VerificationMeta('phone');
  @override
  late final GeneratedColumn<String> phone = GeneratedColumn<String>(
      'phone', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _paxMeta = const VerificationMeta('pax');
  @override
  late final GeneratedColumn<int> pax = GeneratedColumn<int>(
      'pax', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _reservationTimeMeta =
      const VerificationMeta('reservationTime');
  @override
  late final GeneratedColumn<DateTime> reservationTime =
      GeneratedColumn<DateTime>('reservation_time', aliasedName, false,
          type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _tableUuidMeta =
      const VerificationMeta('tableUuid');
  @override
  late final GeneratedColumn<String> tableUuid = GeneratedColumn<String>(
      'table_uuid', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
      'status', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultValue: const Constant('PENDING'));
  static const VerificationMeta _noteMeta = const VerificationMeta('note');
  @override
  late final GeneratedColumn<String> note = GeneratedColumn<String>(
      'note', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        customerName,
        phone,
        pax,
        reservationTime,
        tableUuid,
        status,
        note,
        createdAt,
        updatedAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'reservation_table';
  @override
  VerificationContext validateIntegrity(
      Insertable<ReservationTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('customer_name')) {
      context.handle(
          _customerNameMeta,
          customerName.isAcceptableOrUnknown(
              data['customer_name']!, _customerNameMeta));
    } else if (isInserting) {
      context.missing(_customerNameMeta);
    }
    if (data.containsKey('phone')) {
      context.handle(
          _phoneMeta, phone.isAcceptableOrUnknown(data['phone']!, _phoneMeta));
    }
    if (data.containsKey('pax')) {
      context.handle(
          _paxMeta, pax.isAcceptableOrUnknown(data['pax']!, _paxMeta));
    } else if (isInserting) {
      context.missing(_paxMeta);
    }
    if (data.containsKey('reservation_time')) {
      context.handle(
          _reservationTimeMeta,
          reservationTime.isAcceptableOrUnknown(
              data['reservation_time']!, _reservationTimeMeta));
    } else if (isInserting) {
      context.missing(_reservationTimeMeta);
    }
    if (data.containsKey('table_uuid')) {
      context.handle(_tableUuidMeta,
          tableUuid.isAcceptableOrUnknown(data['table_uuid']!, _tableUuidMeta));
    }
    if (data.containsKey('status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['status']!, _statusMeta));
    }
    if (data.containsKey('note')) {
      context.handle(
          _noteMeta, note.isAcceptableOrUnknown(data['note']!, _noteMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  ReservationTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ReservationTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      customerName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}customer_name'])!,
      phone: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}phone']),
      pax: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}pax'])!,
      reservationTime: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}reservation_time'])!,
      tableUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}table_uuid']),
      status: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}status'])!,
      note: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}note']),
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $ReservationTableTable createAlias(String alias) {
    return $ReservationTableTable(attachedDatabase, alias);
  }
}

class ReservationTableData extends DataClass
    implements Insertable<ReservationTableData> {
  final int id;
  final String uuid;
  final String customerName;
  final String? phone;
  final int pax;
  final DateTime reservationTime;
  final String? tableUuid;
  final String status;
  final String? note;
  final DateTime createdAt;
  final DateTime updatedAt;
  const ReservationTableData(
      {required this.id,
      required this.uuid,
      required this.customerName,
      this.phone,
      required this.pax,
      required this.reservationTime,
      this.tableUuid,
      required this.status,
      this.note,
      required this.createdAt,
      required this.updatedAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    map['customer_name'] = Variable<String>(customerName);
    if (!nullToAbsent || phone != null) {
      map['phone'] = Variable<String>(phone);
    }
    map['pax'] = Variable<int>(pax);
    map['reservation_time'] = Variable<DateTime>(reservationTime);
    if (!nullToAbsent || tableUuid != null) {
      map['table_uuid'] = Variable<String>(tableUuid);
    }
    map['status'] = Variable<String>(status);
    if (!nullToAbsent || note != null) {
      map['note'] = Variable<String>(note);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  ReservationTableCompanion toCompanion(bool nullToAbsent) {
    return ReservationTableCompanion(
      id: Value(id),
      uuid: Value(uuid),
      customerName: Value(customerName),
      phone:
          phone == null && nullToAbsent ? const Value.absent() : Value(phone),
      pax: Value(pax),
      reservationTime: Value(reservationTime),
      tableUuid: tableUuid == null && nullToAbsent
          ? const Value.absent()
          : Value(tableUuid),
      status: Value(status),
      note: note == null && nullToAbsent ? const Value.absent() : Value(note),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory ReservationTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ReservationTableData(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      customerName: serializer.fromJson<String>(json['customerName']),
      phone: serializer.fromJson<String?>(json['phone']),
      pax: serializer.fromJson<int>(json['pax']),
      reservationTime: serializer.fromJson<DateTime>(json['reservationTime']),
      tableUuid: serializer.fromJson<String?>(json['tableUuid']),
      status: serializer.fromJson<String>(json['status']),
      note: serializer.fromJson<String?>(json['note']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'customerName': serializer.toJson<String>(customerName),
      'phone': serializer.toJson<String?>(phone),
      'pax': serializer.toJson<int>(pax),
      'reservationTime': serializer.toJson<DateTime>(reservationTime),
      'tableUuid': serializer.toJson<String?>(tableUuid),
      'status': serializer.toJson<String>(status),
      'note': serializer.toJson<String?>(note),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  ReservationTableData copyWith(
          {int? id,
          String? uuid,
          String? customerName,
          Value<String?> phone = const Value.absent(),
          int? pax,
          DateTime? reservationTime,
          Value<String?> tableUuid = const Value.absent(),
          String? status,
          Value<String?> note = const Value.absent(),
          DateTime? createdAt,
          DateTime? updatedAt}) =>
      ReservationTableData(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        customerName: customerName ?? this.customerName,
        phone: phone.present ? phone.value : this.phone,
        pax: pax ?? this.pax,
        reservationTime: reservationTime ?? this.reservationTime,
        tableUuid: tableUuid.present ? tableUuid.value : this.tableUuid,
        status: status ?? this.status,
        note: note.present ? note.value : this.note,
        createdAt: createdAt ?? this.createdAt,
        updatedAt: updatedAt ?? this.updatedAt,
      );
  ReservationTableData copyWithCompanion(ReservationTableCompanion data) {
    return ReservationTableData(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      customerName: data.customerName.present
          ? data.customerName.value
          : this.customerName,
      phone: data.phone.present ? data.phone.value : this.phone,
      pax: data.pax.present ? data.pax.value : this.pax,
      reservationTime: data.reservationTime.present
          ? data.reservationTime.value
          : this.reservationTime,
      tableUuid: data.tableUuid.present ? data.tableUuid.value : this.tableUuid,
      status: data.status.present ? data.status.value : this.status,
      note: data.note.present ? data.note.value : this.note,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ReservationTableData(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('customerName: $customerName, ')
          ..write('phone: $phone, ')
          ..write('pax: $pax, ')
          ..write('reservationTime: $reservationTime, ')
          ..write('tableUuid: $tableUuid, ')
          ..write('status: $status, ')
          ..write('note: $note, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, uuid, customerName, phone, pax,
      reservationTime, tableUuid, status, note, createdAt, updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ReservationTableData &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.customerName == this.customerName &&
          other.phone == this.phone &&
          other.pax == this.pax &&
          other.reservationTime == this.reservationTime &&
          other.tableUuid == this.tableUuid &&
          other.status == this.status &&
          other.note == this.note &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class ReservationTableCompanion extends UpdateCompanion<ReservationTableData> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String> customerName;
  final Value<String?> phone;
  final Value<int> pax;
  final Value<DateTime> reservationTime;
  final Value<String?> tableUuid;
  final Value<String> status;
  final Value<String?> note;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  const ReservationTableCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.customerName = const Value.absent(),
    this.phone = const Value.absent(),
    this.pax = const Value.absent(),
    this.reservationTime = const Value.absent(),
    this.tableUuid = const Value.absent(),
    this.status = const Value.absent(),
    this.note = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  ReservationTableCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    required String customerName,
    this.phone = const Value.absent(),
    required int pax,
    required DateTime reservationTime,
    this.tableUuid = const Value.absent(),
    this.status = const Value.absent(),
    this.note = const Value.absent(),
    required DateTime createdAt,
    required DateTime updatedAt,
  })  : uuid = Value(uuid),
        customerName = Value(customerName),
        pax = Value(pax),
        reservationTime = Value(reservationTime),
        createdAt = Value(createdAt),
        updatedAt = Value(updatedAt);
  static Insertable<ReservationTableData> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? customerName,
    Expression<String>? phone,
    Expression<int>? pax,
    Expression<DateTime>? reservationTime,
    Expression<String>? tableUuid,
    Expression<String>? status,
    Expression<String>? note,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (customerName != null) 'customer_name': customerName,
      if (phone != null) 'phone': phone,
      if (pax != null) 'pax': pax,
      if (reservationTime != null) 'reservation_time': reservationTime,
      if (tableUuid != null) 'table_uuid': tableUuid,
      if (status != null) 'status': status,
      if (note != null) 'note': note,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  ReservationTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String>? customerName,
      Value<String?>? phone,
      Value<int>? pax,
      Value<DateTime>? reservationTime,
      Value<String?>? tableUuid,
      Value<String>? status,
      Value<String?>? note,
      Value<DateTime>? createdAt,
      Value<DateTime>? updatedAt}) {
    return ReservationTableCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      customerName: customerName ?? this.customerName,
      phone: phone ?? this.phone,
      pax: pax ?? this.pax,
      reservationTime: reservationTime ?? this.reservationTime,
      tableUuid: tableUuid ?? this.tableUuid,
      status: status ?? this.status,
      note: note ?? this.note,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (customerName.present) {
      map['customer_name'] = Variable<String>(customerName.value);
    }
    if (phone.present) {
      map['phone'] = Variable<String>(phone.value);
    }
    if (pax.present) {
      map['pax'] = Variable<int>(pax.value);
    }
    if (reservationTime.present) {
      map['reservation_time'] = Variable<DateTime>(reservationTime.value);
    }
    if (tableUuid.present) {
      map['table_uuid'] = Variable<String>(tableUuid.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (note.present) {
      map['note'] = Variable<String>(note.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ReservationTableCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('customerName: $customerName, ')
          ..write('phone: $phone, ')
          ..write('pax: $pax, ')
          ..write('reservationTime: $reservationTime, ')
          ..write('tableUuid: $tableUuid, ')
          ..write('status: $status, ')
          ..write('note: $note, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class $EmployeeTableTable extends EmployeeTable
    with TableInfo<$EmployeeTableTable, EmployeeTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $EmployeeTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _pinMeta = const VerificationMeta('pin');
  @override
  late final GeneratedColumn<String> pin = GeneratedColumn<String>(
      'pin', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _roleMeta = const VerificationMeta('role');
  @override
  late final GeneratedColumn<String> role = GeneratedColumn<String>(
      'role', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _isActiveMeta =
      const VerificationMeta('isActive');
  @override
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
      'is_active', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_active" IN (0, 1))'),
      defaultValue: const Constant(true));
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns =>
      [id, uuid, name, pin, role, isActive, createdAt, updatedAt];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'employee_table';
  @override
  VerificationContext validateIntegrity(Insertable<EmployeeTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('pin')) {
      context.handle(
          _pinMeta, pin.isAcceptableOrUnknown(data['pin']!, _pinMeta));
    } else if (isInserting) {
      context.missing(_pinMeta);
    }
    if (data.containsKey('role')) {
      context.handle(
          _roleMeta, role.isAcceptableOrUnknown(data['role']!, _roleMeta));
    } else if (isInserting) {
      context.missing(_roleMeta);
    }
    if (data.containsKey('is_active')) {
      context.handle(_isActiveMeta,
          isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  EmployeeTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return EmployeeTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
      pin: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}pin'])!,
      role: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}role'])!,
      isActive: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_active'])!,
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at']),
    );
  }

  @override
  $EmployeeTableTable createAlias(String alias) {
    return $EmployeeTableTable(attachedDatabase, alias);
  }
}

class EmployeeTableData extends DataClass
    implements Insertable<EmployeeTableData> {
  final int id;
  final String uuid;
  final String name;
  final String pin;
  final String role;
  final bool isActive;
  final DateTime createdAt;
  final DateTime? updatedAt;
  const EmployeeTableData(
      {required this.id,
      required this.uuid,
      required this.name,
      required this.pin,
      required this.role,
      required this.isActive,
      required this.createdAt,
      this.updatedAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    map['name'] = Variable<String>(name);
    map['pin'] = Variable<String>(pin);
    map['role'] = Variable<String>(role);
    map['is_active'] = Variable<bool>(isActive);
    map['created_at'] = Variable<DateTime>(createdAt);
    if (!nullToAbsent || updatedAt != null) {
      map['updated_at'] = Variable<DateTime>(updatedAt);
    }
    return map;
  }

  EmployeeTableCompanion toCompanion(bool nullToAbsent) {
    return EmployeeTableCompanion(
      id: Value(id),
      uuid: Value(uuid),
      name: Value(name),
      pin: Value(pin),
      role: Value(role),
      isActive: Value(isActive),
      createdAt: Value(createdAt),
      updatedAt: updatedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(updatedAt),
    );
  }

  factory EmployeeTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return EmployeeTableData(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      name: serializer.fromJson<String>(json['name']),
      pin: serializer.fromJson<String>(json['pin']),
      role: serializer.fromJson<String>(json['role']),
      isActive: serializer.fromJson<bool>(json['isActive']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime?>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'name': serializer.toJson<String>(name),
      'pin': serializer.toJson<String>(pin),
      'role': serializer.toJson<String>(role),
      'isActive': serializer.toJson<bool>(isActive),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime?>(updatedAt),
    };
  }

  EmployeeTableData copyWith(
          {int? id,
          String? uuid,
          String? name,
          String? pin,
          String? role,
          bool? isActive,
          DateTime? createdAt,
          Value<DateTime?> updatedAt = const Value.absent()}) =>
      EmployeeTableData(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        name: name ?? this.name,
        pin: pin ?? this.pin,
        role: role ?? this.role,
        isActive: isActive ?? this.isActive,
        createdAt: createdAt ?? this.createdAt,
        updatedAt: updatedAt.present ? updatedAt.value : this.updatedAt,
      );
  EmployeeTableData copyWithCompanion(EmployeeTableCompanion data) {
    return EmployeeTableData(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      name: data.name.present ? data.name.value : this.name,
      pin: data.pin.present ? data.pin.value : this.pin,
      role: data.role.present ? data.role.value : this.role,
      isActive: data.isActive.present ? data.isActive.value : this.isActive,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('EmployeeTableData(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('pin: $pin, ')
          ..write('role: $role, ')
          ..write('isActive: $isActive, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, uuid, name, pin, role, isActive, createdAt, updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is EmployeeTableData &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.name == this.name &&
          other.pin == this.pin &&
          other.role == this.role &&
          other.isActive == this.isActive &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class EmployeeTableCompanion extends UpdateCompanion<EmployeeTableData> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String> name;
  final Value<String> pin;
  final Value<String> role;
  final Value<bool> isActive;
  final Value<DateTime> createdAt;
  final Value<DateTime?> updatedAt;
  const EmployeeTableCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.name = const Value.absent(),
    this.pin = const Value.absent(),
    this.role = const Value.absent(),
    this.isActive = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  EmployeeTableCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    required String name,
    required String pin,
    required String role,
    this.isActive = const Value.absent(),
    required DateTime createdAt,
    this.updatedAt = const Value.absent(),
  })  : uuid = Value(uuid),
        name = Value(name),
        pin = Value(pin),
        role = Value(role),
        createdAt = Value(createdAt);
  static Insertable<EmployeeTableData> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? name,
    Expression<String>? pin,
    Expression<String>? role,
    Expression<bool>? isActive,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (name != null) 'name': name,
      if (pin != null) 'pin': pin,
      if (role != null) 'role': role,
      if (isActive != null) 'is_active': isActive,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  EmployeeTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String>? name,
      Value<String>? pin,
      Value<String>? role,
      Value<bool>? isActive,
      Value<DateTime>? createdAt,
      Value<DateTime?>? updatedAt}) {
    return EmployeeTableCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      name: name ?? this.name,
      pin: pin ?? this.pin,
      role: role ?? this.role,
      isActive: isActive ?? this.isActive,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (pin.present) {
      map['pin'] = Variable<String>(pin.value);
    }
    if (role.present) {
      map['role'] = Variable<String>(role.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('EmployeeTableCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('pin: $pin, ')
          ..write('role: $role, ')
          ..write('isActive: $isActive, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class $CategoryTableTable extends CategoryTable
    with TableInfo<$CategoryTableTable, CategoryTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $CategoryTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _colorHexMeta =
      const VerificationMeta('colorHex');
  @override
  late final GeneratedColumn<String> colorHex = GeneratedColumn<String>(
      'color_hex', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  @override
  List<GeneratedColumn> get $columns =>
      [id, uuid, name, colorHex, createdAt, updatedAt, isDeleted];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'category_table';
  @override
  VerificationContext validateIntegrity(Insertable<CategoryTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('color_hex')) {
      context.handle(_colorHexMeta,
          colorHex.isAcceptableOrUnknown(data['color_hex']!, _colorHexMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  CategoryTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return CategoryTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
      colorHex: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}color_hex']),
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted'])!,
    );
  }

  @override
  $CategoryTableTable createAlias(String alias) {
    return $CategoryTableTable(attachedDatabase, alias);
  }
}

class CategoryTableData extends DataClass
    implements Insertable<CategoryTableData> {
  final int id;
  final String uuid;
  final String name;
  final String? colorHex;
  final DateTime createdAt;
  final DateTime updatedAt;
  final bool isDeleted;
  const CategoryTableData(
      {required this.id,
      required this.uuid,
      required this.name,
      this.colorHex,
      required this.createdAt,
      required this.updatedAt,
      required this.isDeleted});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || colorHex != null) {
      map['color_hex'] = Variable<String>(colorHex);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    map['is_deleted'] = Variable<bool>(isDeleted);
    return map;
  }

  CategoryTableCompanion toCompanion(bool nullToAbsent) {
    return CategoryTableCompanion(
      id: Value(id),
      uuid: Value(uuid),
      name: Value(name),
      colorHex: colorHex == null && nullToAbsent
          ? const Value.absent()
          : Value(colorHex),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
      isDeleted: Value(isDeleted),
    );
  }

  factory CategoryTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return CategoryTableData(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      name: serializer.fromJson<String>(json['name']),
      colorHex: serializer.fromJson<String?>(json['colorHex']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'name': serializer.toJson<String>(name),
      'colorHex': serializer.toJson<String?>(colorHex),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
      'isDeleted': serializer.toJson<bool>(isDeleted),
    };
  }

  CategoryTableData copyWith(
          {int? id,
          String? uuid,
          String? name,
          Value<String?> colorHex = const Value.absent(),
          DateTime? createdAt,
          DateTime? updatedAt,
          bool? isDeleted}) =>
      CategoryTableData(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        name: name ?? this.name,
        colorHex: colorHex.present ? colorHex.value : this.colorHex,
        createdAt: createdAt ?? this.createdAt,
        updatedAt: updatedAt ?? this.updatedAt,
        isDeleted: isDeleted ?? this.isDeleted,
      );
  CategoryTableData copyWithCompanion(CategoryTableCompanion data) {
    return CategoryTableData(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      name: data.name.present ? data.name.value : this.name,
      colorHex: data.colorHex.present ? data.colorHex.value : this.colorHex,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      isDeleted: data.isDeleted.present ? data.isDeleted.value : this.isDeleted,
    );
  }

  @override
  String toString() {
    return (StringBuffer('CategoryTableData(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('colorHex: $colorHex, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('isDeleted: $isDeleted')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, uuid, name, colorHex, createdAt, updatedAt, isDeleted);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is CategoryTableData &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.name == this.name &&
          other.colorHex == this.colorHex &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt &&
          other.isDeleted == this.isDeleted);
}

class CategoryTableCompanion extends UpdateCompanion<CategoryTableData> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String> name;
  final Value<String?> colorHex;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<bool> isDeleted;
  const CategoryTableCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.name = const Value.absent(),
    this.colorHex = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.isDeleted = const Value.absent(),
  });
  CategoryTableCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    required String name,
    this.colorHex = const Value.absent(),
    required DateTime createdAt,
    required DateTime updatedAt,
    this.isDeleted = const Value.absent(),
  })  : uuid = Value(uuid),
        name = Value(name),
        createdAt = Value(createdAt),
        updatedAt = Value(updatedAt);
  static Insertable<CategoryTableData> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? name,
    Expression<String>? colorHex,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<bool>? isDeleted,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (name != null) 'name': name,
      if (colorHex != null) 'color_hex': colorHex,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (isDeleted != null) 'is_deleted': isDeleted,
    });
  }

  CategoryTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String>? name,
      Value<String?>? colorHex,
      Value<DateTime>? createdAt,
      Value<DateTime>? updatedAt,
      Value<bool>? isDeleted}) {
    return CategoryTableCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      name: name ?? this.name,
      colorHex: colorHex ?? this.colorHex,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      isDeleted: isDeleted ?? this.isDeleted,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (colorHex.present) {
      map['color_hex'] = Variable<String>(colorHex.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('CategoryTableCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('colorHex: $colorHex, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('isDeleted: $isDeleted')
          ..write(')'))
        .toString();
  }
}

class $ProductTableTable extends ProductTable
    with TableInfo<$ProductTableTable, ProductTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ProductTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _skuMeta = const VerificationMeta('sku');
  @override
  late final GeneratedColumn<String> sku = GeneratedColumn<String>(
      'sku', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _barcodeMeta =
      const VerificationMeta('barcode');
  @override
  late final GeneratedColumn<String> barcode = GeneratedColumn<String>(
      'barcode', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _priceMeta = const VerificationMeta('price');
  @override
  late final GeneratedColumn<double> price = GeneratedColumn<double>(
      'price', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _costPriceMeta =
      const VerificationMeta('costPrice');
  @override
  late final GeneratedColumn<double> costPrice = GeneratedColumn<double>(
      'cost_price', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _categoryIdMeta =
      const VerificationMeta('categoryId');
  @override
  late final GeneratedColumn<String> categoryId = GeneratedColumn<String>(
      'category_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _trackStockMeta =
      const VerificationMeta('trackStock');
  @override
  late final GeneratedColumn<bool> trackStock = GeneratedColumn<bool>(
      'track_stock', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("track_stock" IN (0, 1))'));
  static const VerificationMeta _isServiceMeta =
      const VerificationMeta('isService');
  @override
  late final GeneratedColumn<bool> isService = GeneratedColumn<bool>(
      'is_service', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_service" IN (0, 1))'));
  static const VerificationMeta _totalSpentMeta =
      const VerificationMeta('totalSpent');
  @override
  late final GeneratedColumn<double> totalSpent = GeneratedColumn<double>(
      'total_spent', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: false,
      defaultValue: const Constant(0));
  static const VerificationMeta _lastVisitAtMeta =
      const VerificationMeta('lastVisitAt');
  @override
  late final GeneratedColumn<DateTime> lastVisitAt = GeneratedColumn<DateTime>(
      'last_visit_at', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _colorHexMeta =
      const VerificationMeta('colorHex');
  @override
  late final GeneratedColumn<String> colorHex = GeneratedColumn<String>(
      'color_hex', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _imageUrlMeta =
      const VerificationMeta('imageUrl');
  @override
  late final GeneratedColumn<String> imageUrl = GeneratedColumn<String>(
      'image_url', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _printerCategoryMeta =
      const VerificationMeta('printerCategory');
  @override
  late final GeneratedColumn<String> printerCategory = GeneratedColumn<String>(
      'printer_category', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultValue: const Constant('OTHER'));
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _isSyncedMeta =
      const VerificationMeta('isSynced');
  @override
  late final GeneratedColumn<bool> isSynced = GeneratedColumn<bool>(
      'is_synced', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_synced" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _versionMeta =
      const VerificationMeta('version');
  @override
  late final GeneratedColumn<int> version = GeneratedColumn<int>(
      'version', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultValue: const Constant(1));
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _outletIdMeta =
      const VerificationMeta('outletId');
  @override
  late final GeneratedColumn<String> outletId = GeneratedColumn<String>(
      'outlet_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isCompositeMeta =
      const VerificationMeta('isComposite');
  @override
  late final GeneratedColumn<bool> isComposite = GeneratedColumn<bool>(
      'is_composite', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("is_composite" IN (0, 1))'),
      defaultValue: const Constant(false));
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        name,
        sku,
        barcode,
        price,
        costPrice,
        categoryId,
        trackStock,
        isService,
        totalSpent,
        lastVisitAt,
        colorHex,
        imageUrl,
        printerCategory,
        updatedAt,
        isSynced,
        version,
        isDeleted,
        outletId,
        isComposite
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'product_table';
  @override
  VerificationContext validateIntegrity(Insertable<ProductTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('sku')) {
      context.handle(
          _skuMeta, sku.isAcceptableOrUnknown(data['sku']!, _skuMeta));
    }
    if (data.containsKey('barcode')) {
      context.handle(_barcodeMeta,
          barcode.isAcceptableOrUnknown(data['barcode']!, _barcodeMeta));
    }
    if (data.containsKey('price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['price']!, _priceMeta));
    } else if (isInserting) {
      context.missing(_priceMeta);
    }
    if (data.containsKey('cost_price')) {
      context.handle(_costPriceMeta,
          costPrice.isAcceptableOrUnknown(data['cost_price']!, _costPriceMeta));
    }
    if (data.containsKey('category_id')) {
      context.handle(
          _categoryIdMeta,
          categoryId.isAcceptableOrUnknown(
              data['category_id']!, _categoryIdMeta));
    } else if (isInserting) {
      context.missing(_categoryIdMeta);
    }
    if (data.containsKey('track_stock')) {
      context.handle(
          _trackStockMeta,
          trackStock.isAcceptableOrUnknown(
              data['track_stock']!, _trackStockMeta));
    } else if (isInserting) {
      context.missing(_trackStockMeta);
    }
    if (data.containsKey('is_service')) {
      context.handle(_isServiceMeta,
          isService.isAcceptableOrUnknown(data['is_service']!, _isServiceMeta));
    } else if (isInserting) {
      context.missing(_isServiceMeta);
    }
    if (data.containsKey('total_spent')) {
      context.handle(
          _totalSpentMeta,
          totalSpent.isAcceptableOrUnknown(
              data['total_spent']!, _totalSpentMeta));
    }
    if (data.containsKey('last_visit_at')) {
      context.handle(
          _lastVisitAtMeta,
          lastVisitAt.isAcceptableOrUnknown(
              data['last_visit_at']!, _lastVisitAtMeta));
    }
    if (data.containsKey('color_hex')) {
      context.handle(_colorHexMeta,
          colorHex.isAcceptableOrUnknown(data['color_hex']!, _colorHexMeta));
    }
    if (data.containsKey('image_url')) {
      context.handle(_imageUrlMeta,
          imageUrl.isAcceptableOrUnknown(data['image_url']!, _imageUrlMeta));
    }
    if (data.containsKey('printer_category')) {
      context.handle(
          _printerCategoryMeta,
          printerCategory.isAcceptableOrUnknown(
              data['printer_category']!, _printerCategoryMeta));
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    if (data.containsKey('is_synced')) {
      context.handle(_isSyncedMeta,
          isSynced.isAcceptableOrUnknown(data['is_synced']!, _isSyncedMeta));
    }
    if (data.containsKey('version')) {
      context.handle(_versionMeta,
          version.isAcceptableOrUnknown(data['version']!, _versionMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('outlet_id')) {
      context.handle(_outletIdMeta,
          outletId.isAcceptableOrUnknown(data['outlet_id']!, _outletIdMeta));
    }
    if (data.containsKey('is_composite')) {
      context.handle(
          _isCompositeMeta,
          isComposite.isAcceptableOrUnknown(
              data['is_composite']!, _isCompositeMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
        {uuid},
      ];
  @override
  ProductTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ProductTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
      sku: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}sku']),
      barcode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}barcode']),
      price: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}price'])!,
      costPrice: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}cost_price']),
      categoryId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}category_id'])!,
      trackStock: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}track_stock'])!,
      isService: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_service'])!,
      totalSpent: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}total_spent'])!,
      lastVisitAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}last_visit_at']),
      colorHex: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}color_hex']),
      imageUrl: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}image_url']),
      printerCategory: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}printer_category'])!,
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
      isSynced: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_synced'])!,
      version: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}version'])!,
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted'])!,
      outletId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}outlet_id']),
      isComposite: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_composite'])!,
    );
  }

  @override
  $ProductTableTable createAlias(String alias) {
    return $ProductTableTable(attachedDatabase, alias);
  }
}

class ProductTableData extends DataClass
    implements Insertable<ProductTableData> {
  final int id;
  final String uuid;
  final String name;
  final String? sku;
  final String? barcode;
  final double price;
  final double? costPrice;
  final String categoryId;
  final bool trackStock;
  final bool isService;
  final double totalSpent;
  final DateTime? lastVisitAt;
  final String? colorHex;
  final String? imageUrl;
  final String printerCategory;
  final DateTime updatedAt;
  final bool isSynced;
  final int version;
  final bool isDeleted;
  final String? outletId;
  final bool isComposite;
  const ProductTableData(
      {required this.id,
      required this.uuid,
      required this.name,
      this.sku,
      this.barcode,
      required this.price,
      this.costPrice,
      required this.categoryId,
      required this.trackStock,
      required this.isService,
      required this.totalSpent,
      this.lastVisitAt,
      this.colorHex,
      this.imageUrl,
      required this.printerCategory,
      required this.updatedAt,
      required this.isSynced,
      required this.version,
      required this.isDeleted,
      this.outletId,
      required this.isComposite});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || sku != null) {
      map['sku'] = Variable<String>(sku);
    }
    if (!nullToAbsent || barcode != null) {
      map['barcode'] = Variable<String>(barcode);
    }
    map['price'] = Variable<double>(price);
    if (!nullToAbsent || costPrice != null) {
      map['cost_price'] = Variable<double>(costPrice);
    }
    map['category_id'] = Variable<String>(categoryId);
    map['track_stock'] = Variable<bool>(trackStock);
    map['is_service'] = Variable<bool>(isService);
    map['total_spent'] = Variable<double>(totalSpent);
    if (!nullToAbsent || lastVisitAt != null) {
      map['last_visit_at'] = Variable<DateTime>(lastVisitAt);
    }
    if (!nullToAbsent || colorHex != null) {
      map['color_hex'] = Variable<String>(colorHex);
    }
    if (!nullToAbsent || imageUrl != null) {
      map['image_url'] = Variable<String>(imageUrl);
    }
    map['printer_category'] = Variable<String>(printerCategory);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    map['is_synced'] = Variable<bool>(isSynced);
    map['version'] = Variable<int>(version);
    map['is_deleted'] = Variable<bool>(isDeleted);
    if (!nullToAbsent || outletId != null) {
      map['outlet_id'] = Variable<String>(outletId);
    }
    map['is_composite'] = Variable<bool>(isComposite);
    return map;
  }

  ProductTableCompanion toCompanion(bool nullToAbsent) {
    return ProductTableCompanion(
      id: Value(id),
      uuid: Value(uuid),
      name: Value(name),
      sku: sku == null && nullToAbsent ? const Value.absent() : Value(sku),
      barcode: barcode == null && nullToAbsent
          ? const Value.absent()
          : Value(barcode),
      price: Value(price),
      costPrice: costPrice == null && nullToAbsent
          ? const Value.absent()
          : Value(costPrice),
      categoryId: Value(categoryId),
      trackStock: Value(trackStock),
      isService: Value(isService),
      totalSpent: Value(totalSpent),
      lastVisitAt: lastVisitAt == null && nullToAbsent
          ? const Value.absent()
          : Value(lastVisitAt),
      colorHex: colorHex == null && nullToAbsent
          ? const Value.absent()
          : Value(colorHex),
      imageUrl: imageUrl == null && nullToAbsent
          ? const Value.absent()
          : Value(imageUrl),
      printerCategory: Value(printerCategory),
      updatedAt: Value(updatedAt),
      isSynced: Value(isSynced),
      version: Value(version),
      isDeleted: Value(isDeleted),
      outletId: outletId == null && nullToAbsent
          ? const Value.absent()
          : Value(outletId),
      isComposite: Value(isComposite),
    );
  }

  factory ProductTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ProductTableData(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      name: serializer.fromJson<String>(json['name']),
      sku: serializer.fromJson<String?>(json['sku']),
      barcode: serializer.fromJson<String?>(json['barcode']),
      price: serializer.fromJson<double>(json['price']),
      costPrice: serializer.fromJson<double?>(json['costPrice']),
      categoryId: serializer.fromJson<String>(json['categoryId']),
      trackStock: serializer.fromJson<bool>(json['trackStock']),
      isService: serializer.fromJson<bool>(json['isService']),
      totalSpent: serializer.fromJson<double>(json['totalSpent']),
      lastVisitAt: serializer.fromJson<DateTime?>(json['lastVisitAt']),
      colorHex: serializer.fromJson<String?>(json['colorHex']),
      imageUrl: serializer.fromJson<String?>(json['imageUrl']),
      printerCategory: serializer.fromJson<String>(json['printerCategory']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
      isSynced: serializer.fromJson<bool>(json['isSynced']),
      version: serializer.fromJson<int>(json['version']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      outletId: serializer.fromJson<String?>(json['outletId']),
      isComposite: serializer.fromJson<bool>(json['isComposite']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'name': serializer.toJson<String>(name),
      'sku': serializer.toJson<String?>(sku),
      'barcode': serializer.toJson<String?>(barcode),
      'price': serializer.toJson<double>(price),
      'costPrice': serializer.toJson<double?>(costPrice),
      'categoryId': serializer.toJson<String>(categoryId),
      'trackStock': serializer.toJson<bool>(trackStock),
      'isService': serializer.toJson<bool>(isService),
      'totalSpent': serializer.toJson<double>(totalSpent),
      'lastVisitAt': serializer.toJson<DateTime?>(lastVisitAt),
      'colorHex': serializer.toJson<String?>(colorHex),
      'imageUrl': serializer.toJson<String?>(imageUrl),
      'printerCategory': serializer.toJson<String>(printerCategory),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
      'isSynced': serializer.toJson<bool>(isSynced),
      'version': serializer.toJson<int>(version),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'outletId': serializer.toJson<String?>(outletId),
      'isComposite': serializer.toJson<bool>(isComposite),
    };
  }

  ProductTableData copyWith(
          {int? id,
          String? uuid,
          String? name,
          Value<String?> sku = const Value.absent(),
          Value<String?> barcode = const Value.absent(),
          double? price,
          Value<double?> costPrice = const Value.absent(),
          String? categoryId,
          bool? trackStock,
          bool? isService,
          double? totalSpent,
          Value<DateTime?> lastVisitAt = const Value.absent(),
          Value<String?> colorHex = const Value.absent(),
          Value<String?> imageUrl = const Value.absent(),
          String? printerCategory,
          DateTime? updatedAt,
          bool? isSynced,
          int? version,
          bool? isDeleted,
          Value<String?> outletId = const Value.absent(),
          bool? isComposite}) =>
      ProductTableData(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        name: name ?? this.name,
        sku: sku.present ? sku.value : this.sku,
        barcode: barcode.present ? barcode.value : this.barcode,
        price: price ?? this.price,
        costPrice: costPrice.present ? costPrice.value : this.costPrice,
        categoryId: categoryId ?? this.categoryId,
        trackStock: trackStock ?? this.trackStock,
        isService: isService ?? this.isService,
        totalSpent: totalSpent ?? this.totalSpent,
        lastVisitAt: lastVisitAt.present ? lastVisitAt.value : this.lastVisitAt,
        colorHex: colorHex.present ? colorHex.value : this.colorHex,
        imageUrl: imageUrl.present ? imageUrl.value : this.imageUrl,
        printerCategory: printerCategory ?? this.printerCategory,
        updatedAt: updatedAt ?? this.updatedAt,
        isSynced: isSynced ?? this.isSynced,
        version: version ?? this.version,
        isDeleted: isDeleted ?? this.isDeleted,
        outletId: outletId.present ? outletId.value : this.outletId,
        isComposite: isComposite ?? this.isComposite,
      );
  ProductTableData copyWithCompanion(ProductTableCompanion data) {
    return ProductTableData(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      name: data.name.present ? data.name.value : this.name,
      sku: data.sku.present ? data.sku.value : this.sku,
      barcode: data.barcode.present ? data.barcode.value : this.barcode,
      price: data.price.present ? data.price.value : this.price,
      costPrice: data.costPrice.present ? data.costPrice.value : this.costPrice,
      categoryId:
          data.categoryId.present ? data.categoryId.value : this.categoryId,
      trackStock:
          data.trackStock.present ? data.trackStock.value : this.trackStock,
      isService: data.isService.present ? data.isService.value : this.isService,
      totalSpent:
          data.totalSpent.present ? data.totalSpent.value : this.totalSpent,
      lastVisitAt:
          data.lastVisitAt.present ? data.lastVisitAt.value : this.lastVisitAt,
      colorHex: data.colorHex.present ? data.colorHex.value : this.colorHex,
      imageUrl: data.imageUrl.present ? data.imageUrl.value : this.imageUrl,
      printerCategory: data.printerCategory.present
          ? data.printerCategory.value
          : this.printerCategory,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      isSynced: data.isSynced.present ? data.isSynced.value : this.isSynced,
      version: data.version.present ? data.version.value : this.version,
      isDeleted: data.isDeleted.present ? data.isDeleted.value : this.isDeleted,
      outletId: data.outletId.present ? data.outletId.value : this.outletId,
      isComposite:
          data.isComposite.present ? data.isComposite.value : this.isComposite,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ProductTableData(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('sku: $sku, ')
          ..write('barcode: $barcode, ')
          ..write('price: $price, ')
          ..write('costPrice: $costPrice, ')
          ..write('categoryId: $categoryId, ')
          ..write('trackStock: $trackStock, ')
          ..write('isService: $isService, ')
          ..write('totalSpent: $totalSpent, ')
          ..write('lastVisitAt: $lastVisitAt, ')
          ..write('colorHex: $colorHex, ')
          ..write('imageUrl: $imageUrl, ')
          ..write('printerCategory: $printerCategory, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('isSynced: $isSynced, ')
          ..write('version: $version, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('outletId: $outletId, ')
          ..write('isComposite: $isComposite')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        id,
        uuid,
        name,
        sku,
        barcode,
        price,
        costPrice,
        categoryId,
        trackStock,
        isService,
        totalSpent,
        lastVisitAt,
        colorHex,
        imageUrl,
        printerCategory,
        updatedAt,
        isSynced,
        version,
        isDeleted,
        outletId,
        isComposite
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ProductTableData &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.name == this.name &&
          other.sku == this.sku &&
          other.barcode == this.barcode &&
          other.price == this.price &&
          other.costPrice == this.costPrice &&
          other.categoryId == this.categoryId &&
          other.trackStock == this.trackStock &&
          other.isService == this.isService &&
          other.totalSpent == this.totalSpent &&
          other.lastVisitAt == this.lastVisitAt &&
          other.colorHex == this.colorHex &&
          other.imageUrl == this.imageUrl &&
          other.printerCategory == this.printerCategory &&
          other.updatedAt == this.updatedAt &&
          other.isSynced == this.isSynced &&
          other.version == this.version &&
          other.isDeleted == this.isDeleted &&
          other.outletId == this.outletId &&
          other.isComposite == this.isComposite);
}

class ProductTableCompanion extends UpdateCompanion<ProductTableData> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String> name;
  final Value<String?> sku;
  final Value<String?> barcode;
  final Value<double> price;
  final Value<double?> costPrice;
  final Value<String> categoryId;
  final Value<bool> trackStock;
  final Value<bool> isService;
  final Value<double> totalSpent;
  final Value<DateTime?> lastVisitAt;
  final Value<String?> colorHex;
  final Value<String?> imageUrl;
  final Value<String> printerCategory;
  final Value<DateTime> updatedAt;
  final Value<bool> isSynced;
  final Value<int> version;
  final Value<bool> isDeleted;
  final Value<String?> outletId;
  final Value<bool> isComposite;
  const ProductTableCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.name = const Value.absent(),
    this.sku = const Value.absent(),
    this.barcode = const Value.absent(),
    this.price = const Value.absent(),
    this.costPrice = const Value.absent(),
    this.categoryId = const Value.absent(),
    this.trackStock = const Value.absent(),
    this.isService = const Value.absent(),
    this.totalSpent = const Value.absent(),
    this.lastVisitAt = const Value.absent(),
    this.colorHex = const Value.absent(),
    this.imageUrl = const Value.absent(),
    this.printerCategory = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.isSynced = const Value.absent(),
    this.version = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.outletId = const Value.absent(),
    this.isComposite = const Value.absent(),
  });
  ProductTableCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    required String name,
    this.sku = const Value.absent(),
    this.barcode = const Value.absent(),
    required double price,
    this.costPrice = const Value.absent(),
    required String categoryId,
    required bool trackStock,
    required bool isService,
    this.totalSpent = const Value.absent(),
    this.lastVisitAt = const Value.absent(),
    this.colorHex = const Value.absent(),
    this.imageUrl = const Value.absent(),
    this.printerCategory = const Value.absent(),
    required DateTime updatedAt,
    this.isSynced = const Value.absent(),
    this.version = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.outletId = const Value.absent(),
    this.isComposite = const Value.absent(),
  })  : uuid = Value(uuid),
        name = Value(name),
        price = Value(price),
        categoryId = Value(categoryId),
        trackStock = Value(trackStock),
        isService = Value(isService),
        updatedAt = Value(updatedAt);
  static Insertable<ProductTableData> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? name,
    Expression<String>? sku,
    Expression<String>? barcode,
    Expression<double>? price,
    Expression<double>? costPrice,
    Expression<String>? categoryId,
    Expression<bool>? trackStock,
    Expression<bool>? isService,
    Expression<double>? totalSpent,
    Expression<DateTime>? lastVisitAt,
    Expression<String>? colorHex,
    Expression<String>? imageUrl,
    Expression<String>? printerCategory,
    Expression<DateTime>? updatedAt,
    Expression<bool>? isSynced,
    Expression<int>? version,
    Expression<bool>? isDeleted,
    Expression<String>? outletId,
    Expression<bool>? isComposite,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (name != null) 'name': name,
      if (sku != null) 'sku': sku,
      if (barcode != null) 'barcode': barcode,
      if (price != null) 'price': price,
      if (costPrice != null) 'cost_price': costPrice,
      if (categoryId != null) 'category_id': categoryId,
      if (trackStock != null) 'track_stock': trackStock,
      if (isService != null) 'is_service': isService,
      if (totalSpent != null) 'total_spent': totalSpent,
      if (lastVisitAt != null) 'last_visit_at': lastVisitAt,
      if (colorHex != null) 'color_hex': colorHex,
      if (imageUrl != null) 'image_url': imageUrl,
      if (printerCategory != null) 'printer_category': printerCategory,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (isSynced != null) 'is_synced': isSynced,
      if (version != null) 'version': version,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (outletId != null) 'outlet_id': outletId,
      if (isComposite != null) 'is_composite': isComposite,
    });
  }

  ProductTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String>? name,
      Value<String?>? sku,
      Value<String?>? barcode,
      Value<double>? price,
      Value<double?>? costPrice,
      Value<String>? categoryId,
      Value<bool>? trackStock,
      Value<bool>? isService,
      Value<double>? totalSpent,
      Value<DateTime?>? lastVisitAt,
      Value<String?>? colorHex,
      Value<String?>? imageUrl,
      Value<String>? printerCategory,
      Value<DateTime>? updatedAt,
      Value<bool>? isSynced,
      Value<int>? version,
      Value<bool>? isDeleted,
      Value<String?>? outletId,
      Value<bool>? isComposite}) {
    return ProductTableCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      name: name ?? this.name,
      sku: sku ?? this.sku,
      barcode: barcode ?? this.barcode,
      price: price ?? this.price,
      costPrice: costPrice ?? this.costPrice,
      categoryId: categoryId ?? this.categoryId,
      trackStock: trackStock ?? this.trackStock,
      isService: isService ?? this.isService,
      totalSpent: totalSpent ?? this.totalSpent,
      lastVisitAt: lastVisitAt ?? this.lastVisitAt,
      colorHex: colorHex ?? this.colorHex,
      imageUrl: imageUrl ?? this.imageUrl,
      printerCategory: printerCategory ?? this.printerCategory,
      updatedAt: updatedAt ?? this.updatedAt,
      isSynced: isSynced ?? this.isSynced,
      version: version ?? this.version,
      isDeleted: isDeleted ?? this.isDeleted,
      outletId: outletId ?? this.outletId,
      isComposite: isComposite ?? this.isComposite,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (sku.present) {
      map['sku'] = Variable<String>(sku.value);
    }
    if (barcode.present) {
      map['barcode'] = Variable<String>(barcode.value);
    }
    if (price.present) {
      map['price'] = Variable<double>(price.value);
    }
    if (costPrice.present) {
      map['cost_price'] = Variable<double>(costPrice.value);
    }
    if (categoryId.present) {
      map['category_id'] = Variable<String>(categoryId.value);
    }
    if (trackStock.present) {
      map['track_stock'] = Variable<bool>(trackStock.value);
    }
    if (isService.present) {
      map['is_service'] = Variable<bool>(isService.value);
    }
    if (totalSpent.present) {
      map['total_spent'] = Variable<double>(totalSpent.value);
    }
    if (lastVisitAt.present) {
      map['last_visit_at'] = Variable<DateTime>(lastVisitAt.value);
    }
    if (colorHex.present) {
      map['color_hex'] = Variable<String>(colorHex.value);
    }
    if (imageUrl.present) {
      map['image_url'] = Variable<String>(imageUrl.value);
    }
    if (printerCategory.present) {
      map['printer_category'] = Variable<String>(printerCategory.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (isSynced.present) {
      map['is_synced'] = Variable<bool>(isSynced.value);
    }
    if (version.present) {
      map['version'] = Variable<int>(version.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (outletId.present) {
      map['outlet_id'] = Variable<String>(outletId.value);
    }
    if (isComposite.present) {
      map['is_composite'] = Variable<bool>(isComposite.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ProductTableCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('sku: $sku, ')
          ..write('barcode: $barcode, ')
          ..write('price: $price, ')
          ..write('costPrice: $costPrice, ')
          ..write('categoryId: $categoryId, ')
          ..write('trackStock: $trackStock, ')
          ..write('isService: $isService, ')
          ..write('totalSpent: $totalSpent, ')
          ..write('lastVisitAt: $lastVisitAt, ')
          ..write('colorHex: $colorHex, ')
          ..write('imageUrl: $imageUrl, ')
          ..write('printerCategory: $printerCategory, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('isSynced: $isSynced, ')
          ..write('version: $version, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('outletId: $outletId, ')
          ..write('isComposite: $isComposite')
          ..write(')'))
        .toString();
  }
}

class $ModifierGroupTableTable extends ModifierGroupTable
    with TableInfo<$ModifierGroupTableTable, ModifierGroupTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ModifierGroupTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _allowMultiSelectMeta =
      const VerificationMeta('allowMultiSelect');
  @override
  late final GeneratedColumn<bool> allowMultiSelect = GeneratedColumn<bool>(
      'allow_multi_select', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("allow_multi_select" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _minSelectionMeta =
      const VerificationMeta('minSelection');
  @override
  late final GeneratedColumn<int> minSelection = GeneratedColumn<int>(
      'min_selection', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultValue: const Constant(0));
  static const VerificationMeta _maxSelectionMeta =
      const VerificationMeta('maxSelection');
  @override
  late final GeneratedColumn<int> maxSelection = GeneratedColumn<int>(
      'max_selection', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        name,
        allowMultiSelect,
        minSelection,
        maxSelection,
        updatedAt,
        isDeleted
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'modifier_group_table';
  @override
  VerificationContext validateIntegrity(
      Insertable<ModifierGroupTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('allow_multi_select')) {
      context.handle(
          _allowMultiSelectMeta,
          allowMultiSelect.isAcceptableOrUnknown(
              data['allow_multi_select']!, _allowMultiSelectMeta));
    }
    if (data.containsKey('min_selection')) {
      context.handle(
          _minSelectionMeta,
          minSelection.isAcceptableOrUnknown(
              data['min_selection']!, _minSelectionMeta));
    }
    if (data.containsKey('max_selection')) {
      context.handle(
          _maxSelectionMeta,
          maxSelection.isAcceptableOrUnknown(
              data['max_selection']!, _maxSelectionMeta));
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  ModifierGroupTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ModifierGroupTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
      allowMultiSelect: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}allow_multi_select'])!,
      minSelection: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}min_selection'])!,
      maxSelection: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}max_selection']),
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted'])!,
    );
  }

  @override
  $ModifierGroupTableTable createAlias(String alias) {
    return $ModifierGroupTableTable(attachedDatabase, alias);
  }
}

class ModifierGroupTableData extends DataClass
    implements Insertable<ModifierGroupTableData> {
  final int id;
  final String uuid;
  final String name;
  final bool allowMultiSelect;
  final int minSelection;
  final int? maxSelection;
  final DateTime updatedAt;
  final bool isDeleted;
  const ModifierGroupTableData(
      {required this.id,
      required this.uuid,
      required this.name,
      required this.allowMultiSelect,
      required this.minSelection,
      this.maxSelection,
      required this.updatedAt,
      required this.isDeleted});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    map['name'] = Variable<String>(name);
    map['allow_multi_select'] = Variable<bool>(allowMultiSelect);
    map['min_selection'] = Variable<int>(minSelection);
    if (!nullToAbsent || maxSelection != null) {
      map['max_selection'] = Variable<int>(maxSelection);
    }
    map['updated_at'] = Variable<DateTime>(updatedAt);
    map['is_deleted'] = Variable<bool>(isDeleted);
    return map;
  }

  ModifierGroupTableCompanion toCompanion(bool nullToAbsent) {
    return ModifierGroupTableCompanion(
      id: Value(id),
      uuid: Value(uuid),
      name: Value(name),
      allowMultiSelect: Value(allowMultiSelect),
      minSelection: Value(minSelection),
      maxSelection: maxSelection == null && nullToAbsent
          ? const Value.absent()
          : Value(maxSelection),
      updatedAt: Value(updatedAt),
      isDeleted: Value(isDeleted),
    );
  }

  factory ModifierGroupTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ModifierGroupTableData(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      name: serializer.fromJson<String>(json['name']),
      allowMultiSelect: serializer.fromJson<bool>(json['allowMultiSelect']),
      minSelection: serializer.fromJson<int>(json['minSelection']),
      maxSelection: serializer.fromJson<int?>(json['maxSelection']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'name': serializer.toJson<String>(name),
      'allowMultiSelect': serializer.toJson<bool>(allowMultiSelect),
      'minSelection': serializer.toJson<int>(minSelection),
      'maxSelection': serializer.toJson<int?>(maxSelection),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
      'isDeleted': serializer.toJson<bool>(isDeleted),
    };
  }

  ModifierGroupTableData copyWith(
          {int? id,
          String? uuid,
          String? name,
          bool? allowMultiSelect,
          int? minSelection,
          Value<int?> maxSelection = const Value.absent(),
          DateTime? updatedAt,
          bool? isDeleted}) =>
      ModifierGroupTableData(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        name: name ?? this.name,
        allowMultiSelect: allowMultiSelect ?? this.allowMultiSelect,
        minSelection: minSelection ?? this.minSelection,
        maxSelection:
            maxSelection.present ? maxSelection.value : this.maxSelection,
        updatedAt: updatedAt ?? this.updatedAt,
        isDeleted: isDeleted ?? this.isDeleted,
      );
  ModifierGroupTableData copyWithCompanion(ModifierGroupTableCompanion data) {
    return ModifierGroupTableData(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      name: data.name.present ? data.name.value : this.name,
      allowMultiSelect: data.allowMultiSelect.present
          ? data.allowMultiSelect.value
          : this.allowMultiSelect,
      minSelection: data.minSelection.present
          ? data.minSelection.value
          : this.minSelection,
      maxSelection: data.maxSelection.present
          ? data.maxSelection.value
          : this.maxSelection,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      isDeleted: data.isDeleted.present ? data.isDeleted.value : this.isDeleted,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ModifierGroupTableData(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('allowMultiSelect: $allowMultiSelect, ')
          ..write('minSelection: $minSelection, ')
          ..write('maxSelection: $maxSelection, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('isDeleted: $isDeleted')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, uuid, name, allowMultiSelect,
      minSelection, maxSelection, updatedAt, isDeleted);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ModifierGroupTableData &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.name == this.name &&
          other.allowMultiSelect == this.allowMultiSelect &&
          other.minSelection == this.minSelection &&
          other.maxSelection == this.maxSelection &&
          other.updatedAt == this.updatedAt &&
          other.isDeleted == this.isDeleted);
}

class ModifierGroupTableCompanion
    extends UpdateCompanion<ModifierGroupTableData> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String> name;
  final Value<bool> allowMultiSelect;
  final Value<int> minSelection;
  final Value<int?> maxSelection;
  final Value<DateTime> updatedAt;
  final Value<bool> isDeleted;
  const ModifierGroupTableCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.name = const Value.absent(),
    this.allowMultiSelect = const Value.absent(),
    this.minSelection = const Value.absent(),
    this.maxSelection = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.isDeleted = const Value.absent(),
  });
  ModifierGroupTableCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    required String name,
    this.allowMultiSelect = const Value.absent(),
    this.minSelection = const Value.absent(),
    this.maxSelection = const Value.absent(),
    required DateTime updatedAt,
    this.isDeleted = const Value.absent(),
  })  : uuid = Value(uuid),
        name = Value(name),
        updatedAt = Value(updatedAt);
  static Insertable<ModifierGroupTableData> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? name,
    Expression<bool>? allowMultiSelect,
    Expression<int>? minSelection,
    Expression<int>? maxSelection,
    Expression<DateTime>? updatedAt,
    Expression<bool>? isDeleted,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (name != null) 'name': name,
      if (allowMultiSelect != null) 'allow_multi_select': allowMultiSelect,
      if (minSelection != null) 'min_selection': minSelection,
      if (maxSelection != null) 'max_selection': maxSelection,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (isDeleted != null) 'is_deleted': isDeleted,
    });
  }

  ModifierGroupTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String>? name,
      Value<bool>? allowMultiSelect,
      Value<int>? minSelection,
      Value<int?>? maxSelection,
      Value<DateTime>? updatedAt,
      Value<bool>? isDeleted}) {
    return ModifierGroupTableCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      name: name ?? this.name,
      allowMultiSelect: allowMultiSelect ?? this.allowMultiSelect,
      minSelection: minSelection ?? this.minSelection,
      maxSelection: maxSelection ?? this.maxSelection,
      updatedAt: updatedAt ?? this.updatedAt,
      isDeleted: isDeleted ?? this.isDeleted,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (allowMultiSelect.present) {
      map['allow_multi_select'] = Variable<bool>(allowMultiSelect.value);
    }
    if (minSelection.present) {
      map['min_selection'] = Variable<int>(minSelection.value);
    }
    if (maxSelection.present) {
      map['max_selection'] = Variable<int>(maxSelection.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ModifierGroupTableCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('allowMultiSelect: $allowMultiSelect, ')
          ..write('minSelection: $minSelection, ')
          ..write('maxSelection: $maxSelection, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('isDeleted: $isDeleted')
          ..write(')'))
        .toString();
  }
}

class $ModifierItemTableTable extends ModifierItemTable
    with TableInfo<$ModifierItemTableTable, ModifierItemTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ModifierItemTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _groupUuidMeta =
      const VerificationMeta('groupUuid');
  @override
  late final GeneratedColumn<String> groupUuid = GeneratedColumn<String>(
      'group_uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES modifier_group_table (uuid) ON DELETE CASCADE'));
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _priceDeltaMeta =
      const VerificationMeta('priceDelta');
  @override
  late final GeneratedColumn<double> priceDelta = GeneratedColumn<double>(
      'price_delta', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: false,
      defaultValue: const Constant(0));
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  @override
  List<GeneratedColumn> get $columns =>
      [id, uuid, groupUuid, name, priceDelta, updatedAt, isDeleted];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'modifier_item_table';
  @override
  VerificationContext validateIntegrity(
      Insertable<ModifierItemTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('group_uuid')) {
      context.handle(_groupUuidMeta,
          groupUuid.isAcceptableOrUnknown(data['group_uuid']!, _groupUuidMeta));
    } else if (isInserting) {
      context.missing(_groupUuidMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('price_delta')) {
      context.handle(
          _priceDeltaMeta,
          priceDelta.isAcceptableOrUnknown(
              data['price_delta']!, _priceDeltaMeta));
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  ModifierItemTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ModifierItemTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      groupUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}group_uuid'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
      priceDelta: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}price_delta'])!,
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted'])!,
    );
  }

  @override
  $ModifierItemTableTable createAlias(String alias) {
    return $ModifierItemTableTable(attachedDatabase, alias);
  }
}

class ModifierItemTableData extends DataClass
    implements Insertable<ModifierItemTableData> {
  final int id;
  final String uuid;
  final String groupUuid;
  final String name;
  final double priceDelta;
  final DateTime updatedAt;
  final bool isDeleted;
  const ModifierItemTableData(
      {required this.id,
      required this.uuid,
      required this.groupUuid,
      required this.name,
      required this.priceDelta,
      required this.updatedAt,
      required this.isDeleted});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    map['group_uuid'] = Variable<String>(groupUuid);
    map['name'] = Variable<String>(name);
    map['price_delta'] = Variable<double>(priceDelta);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    map['is_deleted'] = Variable<bool>(isDeleted);
    return map;
  }

  ModifierItemTableCompanion toCompanion(bool nullToAbsent) {
    return ModifierItemTableCompanion(
      id: Value(id),
      uuid: Value(uuid),
      groupUuid: Value(groupUuid),
      name: Value(name),
      priceDelta: Value(priceDelta),
      updatedAt: Value(updatedAt),
      isDeleted: Value(isDeleted),
    );
  }

  factory ModifierItemTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ModifierItemTableData(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      groupUuid: serializer.fromJson<String>(json['groupUuid']),
      name: serializer.fromJson<String>(json['name']),
      priceDelta: serializer.fromJson<double>(json['priceDelta']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'groupUuid': serializer.toJson<String>(groupUuid),
      'name': serializer.toJson<String>(name),
      'priceDelta': serializer.toJson<double>(priceDelta),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
      'isDeleted': serializer.toJson<bool>(isDeleted),
    };
  }

  ModifierItemTableData copyWith(
          {int? id,
          String? uuid,
          String? groupUuid,
          String? name,
          double? priceDelta,
          DateTime? updatedAt,
          bool? isDeleted}) =>
      ModifierItemTableData(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        groupUuid: groupUuid ?? this.groupUuid,
        name: name ?? this.name,
        priceDelta: priceDelta ?? this.priceDelta,
        updatedAt: updatedAt ?? this.updatedAt,
        isDeleted: isDeleted ?? this.isDeleted,
      );
  ModifierItemTableData copyWithCompanion(ModifierItemTableCompanion data) {
    return ModifierItemTableData(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      groupUuid: data.groupUuid.present ? data.groupUuid.value : this.groupUuid,
      name: data.name.present ? data.name.value : this.name,
      priceDelta:
          data.priceDelta.present ? data.priceDelta.value : this.priceDelta,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      isDeleted: data.isDeleted.present ? data.isDeleted.value : this.isDeleted,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ModifierItemTableData(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('groupUuid: $groupUuid, ')
          ..write('name: $name, ')
          ..write('priceDelta: $priceDelta, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('isDeleted: $isDeleted')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, uuid, groupUuid, name, priceDelta, updatedAt, isDeleted);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ModifierItemTableData &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.groupUuid == this.groupUuid &&
          other.name == this.name &&
          other.priceDelta == this.priceDelta &&
          other.updatedAt == this.updatedAt &&
          other.isDeleted == this.isDeleted);
}

class ModifierItemTableCompanion
    extends UpdateCompanion<ModifierItemTableData> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String> groupUuid;
  final Value<String> name;
  final Value<double> priceDelta;
  final Value<DateTime> updatedAt;
  final Value<bool> isDeleted;
  const ModifierItemTableCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.groupUuid = const Value.absent(),
    this.name = const Value.absent(),
    this.priceDelta = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.isDeleted = const Value.absent(),
  });
  ModifierItemTableCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    required String groupUuid,
    required String name,
    this.priceDelta = const Value.absent(),
    required DateTime updatedAt,
    this.isDeleted = const Value.absent(),
  })  : uuid = Value(uuid),
        groupUuid = Value(groupUuid),
        name = Value(name),
        updatedAt = Value(updatedAt);
  static Insertable<ModifierItemTableData> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? groupUuid,
    Expression<String>? name,
    Expression<double>? priceDelta,
    Expression<DateTime>? updatedAt,
    Expression<bool>? isDeleted,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (groupUuid != null) 'group_uuid': groupUuid,
      if (name != null) 'name': name,
      if (priceDelta != null) 'price_delta': priceDelta,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (isDeleted != null) 'is_deleted': isDeleted,
    });
  }

  ModifierItemTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String>? groupUuid,
      Value<String>? name,
      Value<double>? priceDelta,
      Value<DateTime>? updatedAt,
      Value<bool>? isDeleted}) {
    return ModifierItemTableCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      groupUuid: groupUuid ?? this.groupUuid,
      name: name ?? this.name,
      priceDelta: priceDelta ?? this.priceDelta,
      updatedAt: updatedAt ?? this.updatedAt,
      isDeleted: isDeleted ?? this.isDeleted,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (groupUuid.present) {
      map['group_uuid'] = Variable<String>(groupUuid.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (priceDelta.present) {
      map['price_delta'] = Variable<double>(priceDelta.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ModifierItemTableCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('groupUuid: $groupUuid, ')
          ..write('name: $name, ')
          ..write('priceDelta: $priceDelta, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('isDeleted: $isDeleted')
          ..write(')'))
        .toString();
  }
}

class $ProductModifierLinkTableTable extends ProductModifierLinkTable
    with
        TableInfo<$ProductModifierLinkTableTable,
            ProductModifierLinkTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ProductModifierLinkTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _productUuidMeta =
      const VerificationMeta('productUuid');
  @override
  late final GeneratedColumn<String> productUuid = GeneratedColumn<String>(
      'product_uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES product_table (uuid) ON DELETE CASCADE'));
  static const VerificationMeta _modifierGroupUuidMeta =
      const VerificationMeta('modifierGroupUuid');
  @override
  late final GeneratedColumn<String> modifierGroupUuid =
      GeneratedColumn<String>('modifier_group_uuid', aliasedName, false,
          type: DriftSqlType.string,
          requiredDuringInsert: true,
          defaultConstraints: GeneratedColumn.constraintIsAlways(
              'REFERENCES modifier_group_table (uuid) ON DELETE CASCADE'));
  static const VerificationMeta _sortOrderMeta =
      const VerificationMeta('sortOrder');
  @override
  late final GeneratedColumn<int> sortOrder = GeneratedColumn<int>(
      'sort_order', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultValue: const Constant(0));
  @override
  List<GeneratedColumn> get $columns =>
      [id, productUuid, modifierGroupUuid, sortOrder];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'product_modifier_link_table';
  @override
  VerificationContext validateIntegrity(
      Insertable<ProductModifierLinkTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('product_uuid')) {
      context.handle(
          _productUuidMeta,
          productUuid.isAcceptableOrUnknown(
              data['product_uuid']!, _productUuidMeta));
    } else if (isInserting) {
      context.missing(_productUuidMeta);
    }
    if (data.containsKey('modifier_group_uuid')) {
      context.handle(
          _modifierGroupUuidMeta,
          modifierGroupUuid.isAcceptableOrUnknown(
              data['modifier_group_uuid']!, _modifierGroupUuidMeta));
    } else if (isInserting) {
      context.missing(_modifierGroupUuidMeta);
    }
    if (data.containsKey('sort_order')) {
      context.handle(_sortOrderMeta,
          sortOrder.isAcceptableOrUnknown(data['sort_order']!, _sortOrderMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  ProductModifierLinkTableData map(Map<String, dynamic> data,
      {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ProductModifierLinkTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      productUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}product_uuid'])!,
      modifierGroupUuid: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}modifier_group_uuid'])!,
      sortOrder: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}sort_order'])!,
    );
  }

  @override
  $ProductModifierLinkTableTable createAlias(String alias) {
    return $ProductModifierLinkTableTable(attachedDatabase, alias);
  }
}

class ProductModifierLinkTableData extends DataClass
    implements Insertable<ProductModifierLinkTableData> {
  final int id;
  final String productUuid;
  final String modifierGroupUuid;
  final int sortOrder;
  const ProductModifierLinkTableData(
      {required this.id,
      required this.productUuid,
      required this.modifierGroupUuid,
      required this.sortOrder});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['product_uuid'] = Variable<String>(productUuid);
    map['modifier_group_uuid'] = Variable<String>(modifierGroupUuid);
    map['sort_order'] = Variable<int>(sortOrder);
    return map;
  }

  ProductModifierLinkTableCompanion toCompanion(bool nullToAbsent) {
    return ProductModifierLinkTableCompanion(
      id: Value(id),
      productUuid: Value(productUuid),
      modifierGroupUuid: Value(modifierGroupUuid),
      sortOrder: Value(sortOrder),
    );
  }

  factory ProductModifierLinkTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ProductModifierLinkTableData(
      id: serializer.fromJson<int>(json['id']),
      productUuid: serializer.fromJson<String>(json['productUuid']),
      modifierGroupUuid: serializer.fromJson<String>(json['modifierGroupUuid']),
      sortOrder: serializer.fromJson<int>(json['sortOrder']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'productUuid': serializer.toJson<String>(productUuid),
      'modifierGroupUuid': serializer.toJson<String>(modifierGroupUuid),
      'sortOrder': serializer.toJson<int>(sortOrder),
    };
  }

  ProductModifierLinkTableData copyWith(
          {int? id,
          String? productUuid,
          String? modifierGroupUuid,
          int? sortOrder}) =>
      ProductModifierLinkTableData(
        id: id ?? this.id,
        productUuid: productUuid ?? this.productUuid,
        modifierGroupUuid: modifierGroupUuid ?? this.modifierGroupUuid,
        sortOrder: sortOrder ?? this.sortOrder,
      );
  ProductModifierLinkTableData copyWithCompanion(
      ProductModifierLinkTableCompanion data) {
    return ProductModifierLinkTableData(
      id: data.id.present ? data.id.value : this.id,
      productUuid:
          data.productUuid.present ? data.productUuid.value : this.productUuid,
      modifierGroupUuid: data.modifierGroupUuid.present
          ? data.modifierGroupUuid.value
          : this.modifierGroupUuid,
      sortOrder: data.sortOrder.present ? data.sortOrder.value : this.sortOrder,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ProductModifierLinkTableData(')
          ..write('id: $id, ')
          ..write('productUuid: $productUuid, ')
          ..write('modifierGroupUuid: $modifierGroupUuid, ')
          ..write('sortOrder: $sortOrder')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, productUuid, modifierGroupUuid, sortOrder);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ProductModifierLinkTableData &&
          other.id == this.id &&
          other.productUuid == this.productUuid &&
          other.modifierGroupUuid == this.modifierGroupUuid &&
          other.sortOrder == this.sortOrder);
}

class ProductModifierLinkTableCompanion
    extends UpdateCompanion<ProductModifierLinkTableData> {
  final Value<int> id;
  final Value<String> productUuid;
  final Value<String> modifierGroupUuid;
  final Value<int> sortOrder;
  const ProductModifierLinkTableCompanion({
    this.id = const Value.absent(),
    this.productUuid = const Value.absent(),
    this.modifierGroupUuid = const Value.absent(),
    this.sortOrder = const Value.absent(),
  });
  ProductModifierLinkTableCompanion.insert({
    this.id = const Value.absent(),
    required String productUuid,
    required String modifierGroupUuid,
    this.sortOrder = const Value.absent(),
  })  : productUuid = Value(productUuid),
        modifierGroupUuid = Value(modifierGroupUuid);
  static Insertable<ProductModifierLinkTableData> custom({
    Expression<int>? id,
    Expression<String>? productUuid,
    Expression<String>? modifierGroupUuid,
    Expression<int>? sortOrder,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (productUuid != null) 'product_uuid': productUuid,
      if (modifierGroupUuid != null) 'modifier_group_uuid': modifierGroupUuid,
      if (sortOrder != null) 'sort_order': sortOrder,
    });
  }

  ProductModifierLinkTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? productUuid,
      Value<String>? modifierGroupUuid,
      Value<int>? sortOrder}) {
    return ProductModifierLinkTableCompanion(
      id: id ?? this.id,
      productUuid: productUuid ?? this.productUuid,
      modifierGroupUuid: modifierGroupUuid ?? this.modifierGroupUuid,
      sortOrder: sortOrder ?? this.sortOrder,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (productUuid.present) {
      map['product_uuid'] = Variable<String>(productUuid.value);
    }
    if (modifierGroupUuid.present) {
      map['modifier_group_uuid'] = Variable<String>(modifierGroupUuid.value);
    }
    if (sortOrder.present) {
      map['sort_order'] = Variable<int>(sortOrder.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ProductModifierLinkTableCompanion(')
          ..write('id: $id, ')
          ..write('productUuid: $productUuid, ')
          ..write('modifierGroupUuid: $modifierGroupUuid, ')
          ..write('sortOrder: $sortOrder')
          ..write(')'))
        .toString();
  }
}

class $IngredientTableTable extends IngredientTable
    with TableInfo<$IngredientTableTable, IngredientTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $IngredientTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _unitMeta = const VerificationMeta('unit');
  @override
  late final GeneratedColumn<String> unit = GeneratedColumn<String>(
      'unit', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _currentStockMeta =
      const VerificationMeta('currentStock');
  @override
  late final GeneratedColumn<double> currentStock = GeneratedColumn<double>(
      'current_stock', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: false,
      defaultValue: const Constant(0));
  static const VerificationMeta _costPerUnitMeta =
      const VerificationMeta('costPerUnit');
  @override
  late final GeneratedColumn<double> costPerUnit = GeneratedColumn<double>(
      'cost_per_unit', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: false,
      defaultValue: const Constant(0));
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  @override
  List<GeneratedColumn> get $columns =>
      [id, uuid, name, unit, currentStock, costPerUnit, updatedAt, isDeleted];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'ingredient_table';
  @override
  VerificationContext validateIntegrity(
      Insertable<IngredientTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('unit')) {
      context.handle(
          _unitMeta, unit.isAcceptableOrUnknown(data['unit']!, _unitMeta));
    } else if (isInserting) {
      context.missing(_unitMeta);
    }
    if (data.containsKey('current_stock')) {
      context.handle(
          _currentStockMeta,
          currentStock.isAcceptableOrUnknown(
              data['current_stock']!, _currentStockMeta));
    }
    if (data.containsKey('cost_per_unit')) {
      context.handle(
          _costPerUnitMeta,
          costPerUnit.isAcceptableOrUnknown(
              data['cost_per_unit']!, _costPerUnitMeta));
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  IngredientTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return IngredientTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
      unit: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}unit'])!,
      currentStock: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}current_stock'])!,
      costPerUnit: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}cost_per_unit'])!,
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted'])!,
    );
  }

  @override
  $IngredientTableTable createAlias(String alias) {
    return $IngredientTableTable(attachedDatabase, alias);
  }
}

class IngredientTableData extends DataClass
    implements Insertable<IngredientTableData> {
  final int id;
  final String uuid;
  final String name;
  final String unit;
  final double currentStock;
  final double costPerUnit;
  final DateTime updatedAt;
  final bool isDeleted;
  const IngredientTableData(
      {required this.id,
      required this.uuid,
      required this.name,
      required this.unit,
      required this.currentStock,
      required this.costPerUnit,
      required this.updatedAt,
      required this.isDeleted});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    map['name'] = Variable<String>(name);
    map['unit'] = Variable<String>(unit);
    map['current_stock'] = Variable<double>(currentStock);
    map['cost_per_unit'] = Variable<double>(costPerUnit);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    map['is_deleted'] = Variable<bool>(isDeleted);
    return map;
  }

  IngredientTableCompanion toCompanion(bool nullToAbsent) {
    return IngredientTableCompanion(
      id: Value(id),
      uuid: Value(uuid),
      name: Value(name),
      unit: Value(unit),
      currentStock: Value(currentStock),
      costPerUnit: Value(costPerUnit),
      updatedAt: Value(updatedAt),
      isDeleted: Value(isDeleted),
    );
  }

  factory IngredientTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return IngredientTableData(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      name: serializer.fromJson<String>(json['name']),
      unit: serializer.fromJson<String>(json['unit']),
      currentStock: serializer.fromJson<double>(json['currentStock']),
      costPerUnit: serializer.fromJson<double>(json['costPerUnit']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'name': serializer.toJson<String>(name),
      'unit': serializer.toJson<String>(unit),
      'currentStock': serializer.toJson<double>(currentStock),
      'costPerUnit': serializer.toJson<double>(costPerUnit),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
      'isDeleted': serializer.toJson<bool>(isDeleted),
    };
  }

  IngredientTableData copyWith(
          {int? id,
          String? uuid,
          String? name,
          String? unit,
          double? currentStock,
          double? costPerUnit,
          DateTime? updatedAt,
          bool? isDeleted}) =>
      IngredientTableData(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        name: name ?? this.name,
        unit: unit ?? this.unit,
        currentStock: currentStock ?? this.currentStock,
        costPerUnit: costPerUnit ?? this.costPerUnit,
        updatedAt: updatedAt ?? this.updatedAt,
        isDeleted: isDeleted ?? this.isDeleted,
      );
  IngredientTableData copyWithCompanion(IngredientTableCompanion data) {
    return IngredientTableData(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      name: data.name.present ? data.name.value : this.name,
      unit: data.unit.present ? data.unit.value : this.unit,
      currentStock: data.currentStock.present
          ? data.currentStock.value
          : this.currentStock,
      costPerUnit:
          data.costPerUnit.present ? data.costPerUnit.value : this.costPerUnit,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      isDeleted: data.isDeleted.present ? data.isDeleted.value : this.isDeleted,
    );
  }

  @override
  String toString() {
    return (StringBuffer('IngredientTableData(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('unit: $unit, ')
          ..write('currentStock: $currentStock, ')
          ..write('costPerUnit: $costPerUnit, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('isDeleted: $isDeleted')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id, uuid, name, unit, currentStock, costPerUnit, updatedAt, isDeleted);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is IngredientTableData &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.name == this.name &&
          other.unit == this.unit &&
          other.currentStock == this.currentStock &&
          other.costPerUnit == this.costPerUnit &&
          other.updatedAt == this.updatedAt &&
          other.isDeleted == this.isDeleted);
}

class IngredientTableCompanion extends UpdateCompanion<IngredientTableData> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String> name;
  final Value<String> unit;
  final Value<double> currentStock;
  final Value<double> costPerUnit;
  final Value<DateTime> updatedAt;
  final Value<bool> isDeleted;
  const IngredientTableCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.name = const Value.absent(),
    this.unit = const Value.absent(),
    this.currentStock = const Value.absent(),
    this.costPerUnit = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.isDeleted = const Value.absent(),
  });
  IngredientTableCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    required String name,
    required String unit,
    this.currentStock = const Value.absent(),
    this.costPerUnit = const Value.absent(),
    required DateTime updatedAt,
    this.isDeleted = const Value.absent(),
  })  : uuid = Value(uuid),
        name = Value(name),
        unit = Value(unit),
        updatedAt = Value(updatedAt);
  static Insertable<IngredientTableData> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? name,
    Expression<String>? unit,
    Expression<double>? currentStock,
    Expression<double>? costPerUnit,
    Expression<DateTime>? updatedAt,
    Expression<bool>? isDeleted,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (name != null) 'name': name,
      if (unit != null) 'unit': unit,
      if (currentStock != null) 'current_stock': currentStock,
      if (costPerUnit != null) 'cost_per_unit': costPerUnit,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (isDeleted != null) 'is_deleted': isDeleted,
    });
  }

  IngredientTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String>? name,
      Value<String>? unit,
      Value<double>? currentStock,
      Value<double>? costPerUnit,
      Value<DateTime>? updatedAt,
      Value<bool>? isDeleted}) {
    return IngredientTableCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      name: name ?? this.name,
      unit: unit ?? this.unit,
      currentStock: currentStock ?? this.currentStock,
      costPerUnit: costPerUnit ?? this.costPerUnit,
      updatedAt: updatedAt ?? this.updatedAt,
      isDeleted: isDeleted ?? this.isDeleted,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (unit.present) {
      map['unit'] = Variable<String>(unit.value);
    }
    if (currentStock.present) {
      map['current_stock'] = Variable<double>(currentStock.value);
    }
    if (costPerUnit.present) {
      map['cost_per_unit'] = Variable<double>(costPerUnit.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('IngredientTableCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('unit: $unit, ')
          ..write('currentStock: $currentStock, ')
          ..write('costPerUnit: $costPerUnit, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('isDeleted: $isDeleted')
          ..write(')'))
        .toString();
  }
}

class $RecipeTableTable extends RecipeTable
    with TableInfo<$RecipeTableTable, RecipeTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $RecipeTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _productUuidMeta =
      const VerificationMeta('productUuid');
  @override
  late final GeneratedColumn<String> productUuid = GeneratedColumn<String>(
      'product_uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES product_table (uuid) ON DELETE CASCADE'));
  static const VerificationMeta _ingredientUuidMeta =
      const VerificationMeta('ingredientUuid');
  @override
  late final GeneratedColumn<String> ingredientUuid = GeneratedColumn<String>(
      'ingredient_uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES ingredient_table (uuid) ON DELETE CASCADE'));
  static const VerificationMeta _quantityRequiredMeta =
      const VerificationMeta('quantityRequired');
  @override
  late final GeneratedColumn<double> quantityRequired = GeneratedColumn<double>(
      'quantity_required', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns =>
      [id, productUuid, ingredientUuid, quantityRequired];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'recipe_table';
  @override
  VerificationContext validateIntegrity(Insertable<RecipeTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('product_uuid')) {
      context.handle(
          _productUuidMeta,
          productUuid.isAcceptableOrUnknown(
              data['product_uuid']!, _productUuidMeta));
    } else if (isInserting) {
      context.missing(_productUuidMeta);
    }
    if (data.containsKey('ingredient_uuid')) {
      context.handle(
          _ingredientUuidMeta,
          ingredientUuid.isAcceptableOrUnknown(
              data['ingredient_uuid']!, _ingredientUuidMeta));
    } else if (isInserting) {
      context.missing(_ingredientUuidMeta);
    }
    if (data.containsKey('quantity_required')) {
      context.handle(
          _quantityRequiredMeta,
          quantityRequired.isAcceptableOrUnknown(
              data['quantity_required']!, _quantityRequiredMeta));
    } else if (isInserting) {
      context.missing(_quantityRequiredMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  RecipeTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return RecipeTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      productUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}product_uuid'])!,
      ingredientUuid: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}ingredient_uuid'])!,
      quantityRequired: attachedDatabase.typeMapping.read(
          DriftSqlType.double, data['${effectivePrefix}quantity_required'])!,
    );
  }

  @override
  $RecipeTableTable createAlias(String alias) {
    return $RecipeTableTable(attachedDatabase, alias);
  }
}

class RecipeTableData extends DataClass implements Insertable<RecipeTableData> {
  final int id;
  final String productUuid;
  final String ingredientUuid;
  final double quantityRequired;
  const RecipeTableData(
      {required this.id,
      required this.productUuid,
      required this.ingredientUuid,
      required this.quantityRequired});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['product_uuid'] = Variable<String>(productUuid);
    map['ingredient_uuid'] = Variable<String>(ingredientUuid);
    map['quantity_required'] = Variable<double>(quantityRequired);
    return map;
  }

  RecipeTableCompanion toCompanion(bool nullToAbsent) {
    return RecipeTableCompanion(
      id: Value(id),
      productUuid: Value(productUuid),
      ingredientUuid: Value(ingredientUuid),
      quantityRequired: Value(quantityRequired),
    );
  }

  factory RecipeTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return RecipeTableData(
      id: serializer.fromJson<int>(json['id']),
      productUuid: serializer.fromJson<String>(json['productUuid']),
      ingredientUuid: serializer.fromJson<String>(json['ingredientUuid']),
      quantityRequired: serializer.fromJson<double>(json['quantityRequired']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'productUuid': serializer.toJson<String>(productUuid),
      'ingredientUuid': serializer.toJson<String>(ingredientUuid),
      'quantityRequired': serializer.toJson<double>(quantityRequired),
    };
  }

  RecipeTableData copyWith(
          {int? id,
          String? productUuid,
          String? ingredientUuid,
          double? quantityRequired}) =>
      RecipeTableData(
        id: id ?? this.id,
        productUuid: productUuid ?? this.productUuid,
        ingredientUuid: ingredientUuid ?? this.ingredientUuid,
        quantityRequired: quantityRequired ?? this.quantityRequired,
      );
  RecipeTableData copyWithCompanion(RecipeTableCompanion data) {
    return RecipeTableData(
      id: data.id.present ? data.id.value : this.id,
      productUuid:
          data.productUuid.present ? data.productUuid.value : this.productUuid,
      ingredientUuid: data.ingredientUuid.present
          ? data.ingredientUuid.value
          : this.ingredientUuid,
      quantityRequired: data.quantityRequired.present
          ? data.quantityRequired.value
          : this.quantityRequired,
    );
  }

  @override
  String toString() {
    return (StringBuffer('RecipeTableData(')
          ..write('id: $id, ')
          ..write('productUuid: $productUuid, ')
          ..write('ingredientUuid: $ingredientUuid, ')
          ..write('quantityRequired: $quantityRequired')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, productUuid, ingredientUuid, quantityRequired);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is RecipeTableData &&
          other.id == this.id &&
          other.productUuid == this.productUuid &&
          other.ingredientUuid == this.ingredientUuid &&
          other.quantityRequired == this.quantityRequired);
}

class RecipeTableCompanion extends UpdateCompanion<RecipeTableData> {
  final Value<int> id;
  final Value<String> productUuid;
  final Value<String> ingredientUuid;
  final Value<double> quantityRequired;
  const RecipeTableCompanion({
    this.id = const Value.absent(),
    this.productUuid = const Value.absent(),
    this.ingredientUuid = const Value.absent(),
    this.quantityRequired = const Value.absent(),
  });
  RecipeTableCompanion.insert({
    this.id = const Value.absent(),
    required String productUuid,
    required String ingredientUuid,
    required double quantityRequired,
  })  : productUuid = Value(productUuid),
        ingredientUuid = Value(ingredientUuid),
        quantityRequired = Value(quantityRequired);
  static Insertable<RecipeTableData> custom({
    Expression<int>? id,
    Expression<String>? productUuid,
    Expression<String>? ingredientUuid,
    Expression<double>? quantityRequired,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (productUuid != null) 'product_uuid': productUuid,
      if (ingredientUuid != null) 'ingredient_uuid': ingredientUuid,
      if (quantityRequired != null) 'quantity_required': quantityRequired,
    });
  }

  RecipeTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? productUuid,
      Value<String>? ingredientUuid,
      Value<double>? quantityRequired}) {
    return RecipeTableCompanion(
      id: id ?? this.id,
      productUuid: productUuid ?? this.productUuid,
      ingredientUuid: ingredientUuid ?? this.ingredientUuid,
      quantityRequired: quantityRequired ?? this.quantityRequired,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (productUuid.present) {
      map['product_uuid'] = Variable<String>(productUuid.value);
    }
    if (ingredientUuid.present) {
      map['ingredient_uuid'] = Variable<String>(ingredientUuid.value);
    }
    if (quantityRequired.present) {
      map['quantity_required'] = Variable<double>(quantityRequired.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('RecipeTableCompanion(')
          ..write('id: $id, ')
          ..write('productUuid: $productUuid, ')
          ..write('ingredientUuid: $ingredientUuid, ')
          ..write('quantityRequired: $quantityRequired')
          ..write(')'))
        .toString();
  }
}

class $CustomerTableTable extends CustomerTable
    with TableInfo<$CustomerTableTable, CustomerTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $CustomerTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _phoneMeta = const VerificationMeta('phone');
  @override
  late final GeneratedColumn<String> phone = GeneratedColumn<String>(
      'phone', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _emailMeta = const VerificationMeta('email');
  @override
  late final GeneratedColumn<String> email = GeneratedColumn<String>(
      'email', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _totalPointsMeta =
      const VerificationMeta('totalPoints');
  @override
  late final GeneratedColumn<double> totalPoints = GeneratedColumn<double>(
      'total_points', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: false,
      defaultValue: const Constant(0));
  static const VerificationMeta _lastVisitAtMeta =
      const VerificationMeta('lastVisitAt');
  @override
  late final GeneratedColumn<DateTime> lastVisitAt = GeneratedColumn<DateTime>(
      'last_visit_at', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _isSyncedMeta =
      const VerificationMeta('isSynced');
  @override
  late final GeneratedColumn<bool> isSynced = GeneratedColumn<bool>(
      'is_synced', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_synced" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _versionMeta =
      const VerificationMeta('version');
  @override
  late final GeneratedColumn<int> version = GeneratedColumn<int>(
      'version', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultValue: const Constant(1));
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        name,
        phone,
        email,
        totalPoints,
        lastVisitAt,
        updatedAt,
        isSynced,
        version,
        isDeleted
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'customer_table';
  @override
  VerificationContext validateIntegrity(Insertable<CustomerTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('phone')) {
      context.handle(
          _phoneMeta, phone.isAcceptableOrUnknown(data['phone']!, _phoneMeta));
    }
    if (data.containsKey('email')) {
      context.handle(
          _emailMeta, email.isAcceptableOrUnknown(data['email']!, _emailMeta));
    }
    if (data.containsKey('total_points')) {
      context.handle(
          _totalPointsMeta,
          totalPoints.isAcceptableOrUnknown(
              data['total_points']!, _totalPointsMeta));
    }
    if (data.containsKey('last_visit_at')) {
      context.handle(
          _lastVisitAtMeta,
          lastVisitAt.isAcceptableOrUnknown(
              data['last_visit_at']!, _lastVisitAtMeta));
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    if (data.containsKey('is_synced')) {
      context.handle(_isSyncedMeta,
          isSynced.isAcceptableOrUnknown(data['is_synced']!, _isSyncedMeta));
    }
    if (data.containsKey('version')) {
      context.handle(_versionMeta,
          version.isAcceptableOrUnknown(data['version']!, _versionMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  CustomerTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return CustomerTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
      phone: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}phone']),
      email: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}email']),
      totalPoints: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}total_points'])!,
      lastVisitAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}last_visit_at']),
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
      isSynced: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_synced'])!,
      version: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}version'])!,
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted'])!,
    );
  }

  @override
  $CustomerTableTable createAlias(String alias) {
    return $CustomerTableTable(attachedDatabase, alias);
  }
}

class CustomerTableData extends DataClass
    implements Insertable<CustomerTableData> {
  final int id;
  final String uuid;
  final String name;
  final String? phone;
  final String? email;
  final double totalPoints;
  final DateTime? lastVisitAt;
  final DateTime updatedAt;
  final bool isSynced;
  final int version;
  final bool isDeleted;
  const CustomerTableData(
      {required this.id,
      required this.uuid,
      required this.name,
      this.phone,
      this.email,
      required this.totalPoints,
      this.lastVisitAt,
      required this.updatedAt,
      required this.isSynced,
      required this.version,
      required this.isDeleted});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || phone != null) {
      map['phone'] = Variable<String>(phone);
    }
    if (!nullToAbsent || email != null) {
      map['email'] = Variable<String>(email);
    }
    map['total_points'] = Variable<double>(totalPoints);
    if (!nullToAbsent || lastVisitAt != null) {
      map['last_visit_at'] = Variable<DateTime>(lastVisitAt);
    }
    map['updated_at'] = Variable<DateTime>(updatedAt);
    map['is_synced'] = Variable<bool>(isSynced);
    map['version'] = Variable<int>(version);
    map['is_deleted'] = Variable<bool>(isDeleted);
    return map;
  }

  CustomerTableCompanion toCompanion(bool nullToAbsent) {
    return CustomerTableCompanion(
      id: Value(id),
      uuid: Value(uuid),
      name: Value(name),
      phone:
          phone == null && nullToAbsent ? const Value.absent() : Value(phone),
      email:
          email == null && nullToAbsent ? const Value.absent() : Value(email),
      totalPoints: Value(totalPoints),
      lastVisitAt: lastVisitAt == null && nullToAbsent
          ? const Value.absent()
          : Value(lastVisitAt),
      updatedAt: Value(updatedAt),
      isSynced: Value(isSynced),
      version: Value(version),
      isDeleted: Value(isDeleted),
    );
  }

  factory CustomerTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return CustomerTableData(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      name: serializer.fromJson<String>(json['name']),
      phone: serializer.fromJson<String?>(json['phone']),
      email: serializer.fromJson<String?>(json['email']),
      totalPoints: serializer.fromJson<double>(json['totalPoints']),
      lastVisitAt: serializer.fromJson<DateTime?>(json['lastVisitAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
      isSynced: serializer.fromJson<bool>(json['isSynced']),
      version: serializer.fromJson<int>(json['version']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'name': serializer.toJson<String>(name),
      'phone': serializer.toJson<String?>(phone),
      'email': serializer.toJson<String?>(email),
      'totalPoints': serializer.toJson<double>(totalPoints),
      'lastVisitAt': serializer.toJson<DateTime?>(lastVisitAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
      'isSynced': serializer.toJson<bool>(isSynced),
      'version': serializer.toJson<int>(version),
      'isDeleted': serializer.toJson<bool>(isDeleted),
    };
  }

  CustomerTableData copyWith(
          {int? id,
          String? uuid,
          String? name,
          Value<String?> phone = const Value.absent(),
          Value<String?> email = const Value.absent(),
          double? totalPoints,
          Value<DateTime?> lastVisitAt = const Value.absent(),
          DateTime? updatedAt,
          bool? isSynced,
          int? version,
          bool? isDeleted}) =>
      CustomerTableData(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        name: name ?? this.name,
        phone: phone.present ? phone.value : this.phone,
        email: email.present ? email.value : this.email,
        totalPoints: totalPoints ?? this.totalPoints,
        lastVisitAt: lastVisitAt.present ? lastVisitAt.value : this.lastVisitAt,
        updatedAt: updatedAt ?? this.updatedAt,
        isSynced: isSynced ?? this.isSynced,
        version: version ?? this.version,
        isDeleted: isDeleted ?? this.isDeleted,
      );
  CustomerTableData copyWithCompanion(CustomerTableCompanion data) {
    return CustomerTableData(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      name: data.name.present ? data.name.value : this.name,
      phone: data.phone.present ? data.phone.value : this.phone,
      email: data.email.present ? data.email.value : this.email,
      totalPoints:
          data.totalPoints.present ? data.totalPoints.value : this.totalPoints,
      lastVisitAt:
          data.lastVisitAt.present ? data.lastVisitAt.value : this.lastVisitAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      isSynced: data.isSynced.present ? data.isSynced.value : this.isSynced,
      version: data.version.present ? data.version.value : this.version,
      isDeleted: data.isDeleted.present ? data.isDeleted.value : this.isDeleted,
    );
  }

  @override
  String toString() {
    return (StringBuffer('CustomerTableData(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('phone: $phone, ')
          ..write('email: $email, ')
          ..write('totalPoints: $totalPoints, ')
          ..write('lastVisitAt: $lastVisitAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('isSynced: $isSynced, ')
          ..write('version: $version, ')
          ..write('isDeleted: $isDeleted')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, uuid, name, phone, email, totalPoints,
      lastVisitAt, updatedAt, isSynced, version, isDeleted);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is CustomerTableData &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.name == this.name &&
          other.phone == this.phone &&
          other.email == this.email &&
          other.totalPoints == this.totalPoints &&
          other.lastVisitAt == this.lastVisitAt &&
          other.updatedAt == this.updatedAt &&
          other.isSynced == this.isSynced &&
          other.version == this.version &&
          other.isDeleted == this.isDeleted);
}

class CustomerTableCompanion extends UpdateCompanion<CustomerTableData> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String> name;
  final Value<String?> phone;
  final Value<String?> email;
  final Value<double> totalPoints;
  final Value<DateTime?> lastVisitAt;
  final Value<DateTime> updatedAt;
  final Value<bool> isSynced;
  final Value<int> version;
  final Value<bool> isDeleted;
  const CustomerTableCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.name = const Value.absent(),
    this.phone = const Value.absent(),
    this.email = const Value.absent(),
    this.totalPoints = const Value.absent(),
    this.lastVisitAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.isSynced = const Value.absent(),
    this.version = const Value.absent(),
    this.isDeleted = const Value.absent(),
  });
  CustomerTableCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    required String name,
    this.phone = const Value.absent(),
    this.email = const Value.absent(),
    this.totalPoints = const Value.absent(),
    this.lastVisitAt = const Value.absent(),
    required DateTime updatedAt,
    this.isSynced = const Value.absent(),
    this.version = const Value.absent(),
    this.isDeleted = const Value.absent(),
  })  : uuid = Value(uuid),
        name = Value(name),
        updatedAt = Value(updatedAt);
  static Insertable<CustomerTableData> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? name,
    Expression<String>? phone,
    Expression<String>? email,
    Expression<double>? totalPoints,
    Expression<DateTime>? lastVisitAt,
    Expression<DateTime>? updatedAt,
    Expression<bool>? isSynced,
    Expression<int>? version,
    Expression<bool>? isDeleted,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (name != null) 'name': name,
      if (phone != null) 'phone': phone,
      if (email != null) 'email': email,
      if (totalPoints != null) 'total_points': totalPoints,
      if (lastVisitAt != null) 'last_visit_at': lastVisitAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (isSynced != null) 'is_synced': isSynced,
      if (version != null) 'version': version,
      if (isDeleted != null) 'is_deleted': isDeleted,
    });
  }

  CustomerTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String>? name,
      Value<String?>? phone,
      Value<String?>? email,
      Value<double>? totalPoints,
      Value<DateTime?>? lastVisitAt,
      Value<DateTime>? updatedAt,
      Value<bool>? isSynced,
      Value<int>? version,
      Value<bool>? isDeleted}) {
    return CustomerTableCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      name: name ?? this.name,
      phone: phone ?? this.phone,
      email: email ?? this.email,
      totalPoints: totalPoints ?? this.totalPoints,
      lastVisitAt: lastVisitAt ?? this.lastVisitAt,
      updatedAt: updatedAt ?? this.updatedAt,
      isSynced: isSynced ?? this.isSynced,
      version: version ?? this.version,
      isDeleted: isDeleted ?? this.isDeleted,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (phone.present) {
      map['phone'] = Variable<String>(phone.value);
    }
    if (email.present) {
      map['email'] = Variable<String>(email.value);
    }
    if (totalPoints.present) {
      map['total_points'] = Variable<double>(totalPoints.value);
    }
    if (lastVisitAt.present) {
      map['last_visit_at'] = Variable<DateTime>(lastVisitAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (isSynced.present) {
      map['is_synced'] = Variable<bool>(isSynced.value);
    }
    if (version.present) {
      map['version'] = Variable<int>(version.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('CustomerTableCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('phone: $phone, ')
          ..write('email: $email, ')
          ..write('totalPoints: $totalPoints, ')
          ..write('lastVisitAt: $lastVisitAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('isSynced: $isSynced, ')
          ..write('version: $version, ')
          ..write('isDeleted: $isDeleted')
          ..write(')'))
        .toString();
  }
}

class $OrderTableTable extends OrderTable
    with TableInfo<$OrderTableTable, OrderTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $OrderTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _orderNumberMeta =
      const VerificationMeta('orderNumber');
  @override
  late final GeneratedColumn<String> orderNumber = GeneratedColumn<String>(
      'order_number', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _shiftUuidMeta =
      const VerificationMeta('shiftUuid');
  @override
  late final GeneratedColumn<String> shiftUuid = GeneratedColumn<String>(
      'shift_uuid', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _customerUuidMeta =
      const VerificationMeta('customerUuid');
  @override
  late final GeneratedColumn<String> customerUuid = GeneratedColumn<String>(
      'customer_uuid', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _outletIdMeta =
      const VerificationMeta('outletId');
  @override
  late final GeneratedColumn<String> outletId = GeneratedColumn<String>(
      'outlet_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
      'status', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultValue: const Constant('COMPLETED'));
  static const VerificationMeta _paymentStatusMeta =
      const VerificationMeta('paymentStatus');
  @override
  late final GeneratedColumn<String> paymentStatus = GeneratedColumn<String>(
      'payment_status', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultValue: const Constant('PAID'));
  static const VerificationMeta _transactionDateMeta =
      const VerificationMeta('transactionDate');
  @override
  late final GeneratedColumn<DateTime> transactionDate =
      GeneratedColumn<DateTime>('transaction_date', aliasedName, false,
          type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _subtotalMeta =
      const VerificationMeta('subtotal');
  @override
  late final GeneratedColumn<double> subtotal = GeneratedColumn<double>(
      'subtotal', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _discountTotalMeta =
      const VerificationMeta('discountTotal');
  @override
  late final GeneratedColumn<double> discountTotal = GeneratedColumn<double>(
      'discount_total', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _taxTotalMeta =
      const VerificationMeta('taxTotal');
  @override
  late final GeneratedColumn<double> taxTotal = GeneratedColumn<double>(
      'tax_total', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _grandTotalMeta =
      const VerificationMeta('grandTotal');
  @override
  late final GeneratedColumn<double> grandTotal = GeneratedColumn<double>(
      'grand_total', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _paymentMethodMeta =
      const VerificationMeta('paymentMethod');
  @override
  late final GeneratedColumn<String> paymentMethod = GeneratedColumn<String>(
      'payment_method', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _tenderedAmountMeta =
      const VerificationMeta('tenderedAmount');
  @override
  late final GeneratedColumn<double> tenderedAmount = GeneratedColumn<double>(
      'tendered_amount', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _changeAmountMeta =
      const VerificationMeta('changeAmount');
  @override
  late final GeneratedColumn<double> changeAmount = GeneratedColumn<double>(
      'change_amount', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  static const VerificationMeta _isSyncedMeta =
      const VerificationMeta('isSynced');
  @override
  late final GeneratedColumn<bool> isSynced = GeneratedColumn<bool>(
      'is_synced', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_synced" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _versionMeta =
      const VerificationMeta('version');
  @override
  late final GeneratedColumn<int> version = GeneratedColumn<int>(
      'version', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultValue: const Constant(1));
  static const VerificationMeta _syncAttemptsMeta =
      const VerificationMeta('syncAttempts');
  @override
  late final GeneratedColumn<int> syncAttempts = GeneratedColumn<int>(
      'sync_attempts', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultValue: const Constant(0));
  static const VerificationMeta _isFulfilledMeta =
      const VerificationMeta('isFulfilled');
  @override
  late final GeneratedColumn<bool> isFulfilled = GeneratedColumn<bool>(
      'is_fulfilled', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("is_fulfilled" IN (0, 1))'),
      defaultValue: const Constant(false));
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        orderNumber,
        shiftUuid,
        customerUuid,
        tenantId,
        outletId,
        status,
        paymentStatus,
        transactionDate,
        subtotal,
        discountTotal,
        taxTotal,
        grandTotal,
        paymentMethod,
        tenderedAmount,
        changeAmount,
        updatedAt,
        isSynced,
        version,
        syncAttempts,
        isFulfilled
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'order_table';
  @override
  VerificationContext validateIntegrity(Insertable<OrderTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('order_number')) {
      context.handle(
          _orderNumberMeta,
          orderNumber.isAcceptableOrUnknown(
              data['order_number']!, _orderNumberMeta));
    } else if (isInserting) {
      context.missing(_orderNumberMeta);
    }
    if (data.containsKey('shift_uuid')) {
      context.handle(_shiftUuidMeta,
          shiftUuid.isAcceptableOrUnknown(data['shift_uuid']!, _shiftUuidMeta));
    }
    if (data.containsKey('customer_uuid')) {
      context.handle(
          _customerUuidMeta,
          customerUuid.isAcceptableOrUnknown(
              data['customer_uuid']!, _customerUuidMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('outlet_id')) {
      context.handle(_outletIdMeta,
          outletId.isAcceptableOrUnknown(data['outlet_id']!, _outletIdMeta));
    }
    if (data.containsKey('status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['status']!, _statusMeta));
    }
    if (data.containsKey('payment_status')) {
      context.handle(
          _paymentStatusMeta,
          paymentStatus.isAcceptableOrUnknown(
              data['payment_status']!, _paymentStatusMeta));
    }
    if (data.containsKey('transaction_date')) {
      context.handle(
          _transactionDateMeta,
          transactionDate.isAcceptableOrUnknown(
              data['transaction_date']!, _transactionDateMeta));
    } else if (isInserting) {
      context.missing(_transactionDateMeta);
    }
    if (data.containsKey('subtotal')) {
      context.handle(_subtotalMeta,
          subtotal.isAcceptableOrUnknown(data['subtotal']!, _subtotalMeta));
    } else if (isInserting) {
      context.missing(_subtotalMeta);
    }
    if (data.containsKey('discount_total')) {
      context.handle(
          _discountTotalMeta,
          discountTotal.isAcceptableOrUnknown(
              data['discount_total']!, _discountTotalMeta));
    } else if (isInserting) {
      context.missing(_discountTotalMeta);
    }
    if (data.containsKey('tax_total')) {
      context.handle(_taxTotalMeta,
          taxTotal.isAcceptableOrUnknown(data['tax_total']!, _taxTotalMeta));
    } else if (isInserting) {
      context.missing(_taxTotalMeta);
    }
    if (data.containsKey('grand_total')) {
      context.handle(
          _grandTotalMeta,
          grandTotal.isAcceptableOrUnknown(
              data['grand_total']!, _grandTotalMeta));
    } else if (isInserting) {
      context.missing(_grandTotalMeta);
    }
    if (data.containsKey('payment_method')) {
      context.handle(
          _paymentMethodMeta,
          paymentMethod.isAcceptableOrUnknown(
              data['payment_method']!, _paymentMethodMeta));
    }
    if (data.containsKey('tendered_amount')) {
      context.handle(
          _tenderedAmountMeta,
          tenderedAmount.isAcceptableOrUnknown(
              data['tendered_amount']!, _tenderedAmountMeta));
    }
    if (data.containsKey('change_amount')) {
      context.handle(
          _changeAmountMeta,
          changeAmount.isAcceptableOrUnknown(
              data['change_amount']!, _changeAmountMeta));
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    }
    if (data.containsKey('is_synced')) {
      context.handle(_isSyncedMeta,
          isSynced.isAcceptableOrUnknown(data['is_synced']!, _isSyncedMeta));
    }
    if (data.containsKey('version')) {
      context.handle(_versionMeta,
          version.isAcceptableOrUnknown(data['version']!, _versionMeta));
    }
    if (data.containsKey('sync_attempts')) {
      context.handle(
          _syncAttemptsMeta,
          syncAttempts.isAcceptableOrUnknown(
              data['sync_attempts']!, _syncAttemptsMeta));
    }
    if (data.containsKey('is_fulfilled')) {
      context.handle(
          _isFulfilledMeta,
          isFulfilled.isAcceptableOrUnknown(
              data['is_fulfilled']!, _isFulfilledMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  OrderTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return OrderTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      orderNumber: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}order_number'])!,
      shiftUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}shift_uuid']),
      customerUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}customer_uuid']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      outletId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}outlet_id']),
      status: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}status'])!,
      paymentStatus: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}payment_status'])!,
      transactionDate: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}transaction_date'])!,
      subtotal: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}subtotal'])!,
      discountTotal: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}discount_total'])!,
      taxTotal: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}tax_total'])!,
      grandTotal: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}grand_total'])!,
      paymentMethod: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}payment_method']),
      tenderedAmount: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}tendered_amount']),
      changeAmount: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}change_amount']),
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
      isSynced: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_synced'])!,
      version: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}version'])!,
      syncAttempts: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}sync_attempts'])!,
      isFulfilled: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_fulfilled'])!,
    );
  }

  @override
  $OrderTableTable createAlias(String alias) {
    return $OrderTableTable(attachedDatabase, alias);
  }
}

class OrderTableData extends DataClass implements Insertable<OrderTableData> {
  final int id;
  final String uuid;
  final String orderNumber;
  final String? shiftUuid;
  final String? customerUuid;
  final String? tenantId;
  final String? outletId;
  final String status;
  final String paymentStatus;
  final DateTime transactionDate;
  final double subtotal;
  final double discountTotal;
  final double taxTotal;
  final double grandTotal;
  final String? paymentMethod;
  final double? tenderedAmount;
  final double? changeAmount;
  final DateTime updatedAt;
  final bool isSynced;
  final int version;
  final int syncAttempts;
  final bool isFulfilled;
  const OrderTableData(
      {required this.id,
      required this.uuid,
      required this.orderNumber,
      this.shiftUuid,
      this.customerUuid,
      this.tenantId,
      this.outletId,
      required this.status,
      required this.paymentStatus,
      required this.transactionDate,
      required this.subtotal,
      required this.discountTotal,
      required this.taxTotal,
      required this.grandTotal,
      this.paymentMethod,
      this.tenderedAmount,
      this.changeAmount,
      required this.updatedAt,
      required this.isSynced,
      required this.version,
      required this.syncAttempts,
      required this.isFulfilled});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    map['order_number'] = Variable<String>(orderNumber);
    if (!nullToAbsent || shiftUuid != null) {
      map['shift_uuid'] = Variable<String>(shiftUuid);
    }
    if (!nullToAbsent || customerUuid != null) {
      map['customer_uuid'] = Variable<String>(customerUuid);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || outletId != null) {
      map['outlet_id'] = Variable<String>(outletId);
    }
    map['status'] = Variable<String>(status);
    map['payment_status'] = Variable<String>(paymentStatus);
    map['transaction_date'] = Variable<DateTime>(transactionDate);
    map['subtotal'] = Variable<double>(subtotal);
    map['discount_total'] = Variable<double>(discountTotal);
    map['tax_total'] = Variable<double>(taxTotal);
    map['grand_total'] = Variable<double>(grandTotal);
    if (!nullToAbsent || paymentMethod != null) {
      map['payment_method'] = Variable<String>(paymentMethod);
    }
    if (!nullToAbsent || tenderedAmount != null) {
      map['tendered_amount'] = Variable<double>(tenderedAmount);
    }
    if (!nullToAbsent || changeAmount != null) {
      map['change_amount'] = Variable<double>(changeAmount);
    }
    map['updated_at'] = Variable<DateTime>(updatedAt);
    map['is_synced'] = Variable<bool>(isSynced);
    map['version'] = Variable<int>(version);
    map['sync_attempts'] = Variable<int>(syncAttempts);
    map['is_fulfilled'] = Variable<bool>(isFulfilled);
    return map;
  }

  OrderTableCompanion toCompanion(bool nullToAbsent) {
    return OrderTableCompanion(
      id: Value(id),
      uuid: Value(uuid),
      orderNumber: Value(orderNumber),
      shiftUuid: shiftUuid == null && nullToAbsent
          ? const Value.absent()
          : Value(shiftUuid),
      customerUuid: customerUuid == null && nullToAbsent
          ? const Value.absent()
          : Value(customerUuid),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      outletId: outletId == null && nullToAbsent
          ? const Value.absent()
          : Value(outletId),
      status: Value(status),
      paymentStatus: Value(paymentStatus),
      transactionDate: Value(transactionDate),
      subtotal: Value(subtotal),
      discountTotal: Value(discountTotal),
      taxTotal: Value(taxTotal),
      grandTotal: Value(grandTotal),
      paymentMethod: paymentMethod == null && nullToAbsent
          ? const Value.absent()
          : Value(paymentMethod),
      tenderedAmount: tenderedAmount == null && nullToAbsent
          ? const Value.absent()
          : Value(tenderedAmount),
      changeAmount: changeAmount == null && nullToAbsent
          ? const Value.absent()
          : Value(changeAmount),
      updatedAt: Value(updatedAt),
      isSynced: Value(isSynced),
      version: Value(version),
      syncAttempts: Value(syncAttempts),
      isFulfilled: Value(isFulfilled),
    );
  }

  factory OrderTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return OrderTableData(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      orderNumber: serializer.fromJson<String>(json['orderNumber']),
      shiftUuid: serializer.fromJson<String?>(json['shiftUuid']),
      customerUuid: serializer.fromJson<String?>(json['customerUuid']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      outletId: serializer.fromJson<String?>(json['outletId']),
      status: serializer.fromJson<String>(json['status']),
      paymentStatus: serializer.fromJson<String>(json['paymentStatus']),
      transactionDate: serializer.fromJson<DateTime>(json['transactionDate']),
      subtotal: serializer.fromJson<double>(json['subtotal']),
      discountTotal: serializer.fromJson<double>(json['discountTotal']),
      taxTotal: serializer.fromJson<double>(json['taxTotal']),
      grandTotal: serializer.fromJson<double>(json['grandTotal']),
      paymentMethod: serializer.fromJson<String?>(json['paymentMethod']),
      tenderedAmount: serializer.fromJson<double?>(json['tenderedAmount']),
      changeAmount: serializer.fromJson<double?>(json['changeAmount']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
      isSynced: serializer.fromJson<bool>(json['isSynced']),
      version: serializer.fromJson<int>(json['version']),
      syncAttempts: serializer.fromJson<int>(json['syncAttempts']),
      isFulfilled: serializer.fromJson<bool>(json['isFulfilled']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'orderNumber': serializer.toJson<String>(orderNumber),
      'shiftUuid': serializer.toJson<String?>(shiftUuid),
      'customerUuid': serializer.toJson<String?>(customerUuid),
      'tenantId': serializer.toJson<String?>(tenantId),
      'outletId': serializer.toJson<String?>(outletId),
      'status': serializer.toJson<String>(status),
      'paymentStatus': serializer.toJson<String>(paymentStatus),
      'transactionDate': serializer.toJson<DateTime>(transactionDate),
      'subtotal': serializer.toJson<double>(subtotal),
      'discountTotal': serializer.toJson<double>(discountTotal),
      'taxTotal': serializer.toJson<double>(taxTotal),
      'grandTotal': serializer.toJson<double>(grandTotal),
      'paymentMethod': serializer.toJson<String?>(paymentMethod),
      'tenderedAmount': serializer.toJson<double?>(tenderedAmount),
      'changeAmount': serializer.toJson<double?>(changeAmount),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
      'isSynced': serializer.toJson<bool>(isSynced),
      'version': serializer.toJson<int>(version),
      'syncAttempts': serializer.toJson<int>(syncAttempts),
      'isFulfilled': serializer.toJson<bool>(isFulfilled),
    };
  }

  OrderTableData copyWith(
          {int? id,
          String? uuid,
          String? orderNumber,
          Value<String?> shiftUuid = const Value.absent(),
          Value<String?> customerUuid = const Value.absent(),
          Value<String?> tenantId = const Value.absent(),
          Value<String?> outletId = const Value.absent(),
          String? status,
          String? paymentStatus,
          DateTime? transactionDate,
          double? subtotal,
          double? discountTotal,
          double? taxTotal,
          double? grandTotal,
          Value<String?> paymentMethod = const Value.absent(),
          Value<double?> tenderedAmount = const Value.absent(),
          Value<double?> changeAmount = const Value.absent(),
          DateTime? updatedAt,
          bool? isSynced,
          int? version,
          int? syncAttempts,
          bool? isFulfilled}) =>
      OrderTableData(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        orderNumber: orderNumber ?? this.orderNumber,
        shiftUuid: shiftUuid.present ? shiftUuid.value : this.shiftUuid,
        customerUuid:
            customerUuid.present ? customerUuid.value : this.customerUuid,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        outletId: outletId.present ? outletId.value : this.outletId,
        status: status ?? this.status,
        paymentStatus: paymentStatus ?? this.paymentStatus,
        transactionDate: transactionDate ?? this.transactionDate,
        subtotal: subtotal ?? this.subtotal,
        discountTotal: discountTotal ?? this.discountTotal,
        taxTotal: taxTotal ?? this.taxTotal,
        grandTotal: grandTotal ?? this.grandTotal,
        paymentMethod:
            paymentMethod.present ? paymentMethod.value : this.paymentMethod,
        tenderedAmount:
            tenderedAmount.present ? tenderedAmount.value : this.tenderedAmount,
        changeAmount:
            changeAmount.present ? changeAmount.value : this.changeAmount,
        updatedAt: updatedAt ?? this.updatedAt,
        isSynced: isSynced ?? this.isSynced,
        version: version ?? this.version,
        syncAttempts: syncAttempts ?? this.syncAttempts,
        isFulfilled: isFulfilled ?? this.isFulfilled,
      );
  OrderTableData copyWithCompanion(OrderTableCompanion data) {
    return OrderTableData(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      orderNumber:
          data.orderNumber.present ? data.orderNumber.value : this.orderNumber,
      shiftUuid: data.shiftUuid.present ? data.shiftUuid.value : this.shiftUuid,
      customerUuid: data.customerUuid.present
          ? data.customerUuid.value
          : this.customerUuid,
      tenantId: data.tenantId.present ? data.tenantId.value : this.tenantId,
      outletId: data.outletId.present ? data.outletId.value : this.outletId,
      status: data.status.present ? data.status.value : this.status,
      paymentStatus: data.paymentStatus.present
          ? data.paymentStatus.value
          : this.paymentStatus,
      transactionDate: data.transactionDate.present
          ? data.transactionDate.value
          : this.transactionDate,
      subtotal: data.subtotal.present ? data.subtotal.value : this.subtotal,
      discountTotal: data.discountTotal.present
          ? data.discountTotal.value
          : this.discountTotal,
      taxTotal: data.taxTotal.present ? data.taxTotal.value : this.taxTotal,
      grandTotal:
          data.grandTotal.present ? data.grandTotal.value : this.grandTotal,
      paymentMethod: data.paymentMethod.present
          ? data.paymentMethod.value
          : this.paymentMethod,
      tenderedAmount: data.tenderedAmount.present
          ? data.tenderedAmount.value
          : this.tenderedAmount,
      changeAmount: data.changeAmount.present
          ? data.changeAmount.value
          : this.changeAmount,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      isSynced: data.isSynced.present ? data.isSynced.value : this.isSynced,
      version: data.version.present ? data.version.value : this.version,
      syncAttempts: data.syncAttempts.present
          ? data.syncAttempts.value
          : this.syncAttempts,
      isFulfilled:
          data.isFulfilled.present ? data.isFulfilled.value : this.isFulfilled,
    );
  }

  @override
  String toString() {
    return (StringBuffer('OrderTableData(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('orderNumber: $orderNumber, ')
          ..write('shiftUuid: $shiftUuid, ')
          ..write('customerUuid: $customerUuid, ')
          ..write('tenantId: $tenantId, ')
          ..write('outletId: $outletId, ')
          ..write('status: $status, ')
          ..write('paymentStatus: $paymentStatus, ')
          ..write('transactionDate: $transactionDate, ')
          ..write('subtotal: $subtotal, ')
          ..write('discountTotal: $discountTotal, ')
          ..write('taxTotal: $taxTotal, ')
          ..write('grandTotal: $grandTotal, ')
          ..write('paymentMethod: $paymentMethod, ')
          ..write('tenderedAmount: $tenderedAmount, ')
          ..write('changeAmount: $changeAmount, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('isSynced: $isSynced, ')
          ..write('version: $version, ')
          ..write('syncAttempts: $syncAttempts, ')
          ..write('isFulfilled: $isFulfilled')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        id,
        uuid,
        orderNumber,
        shiftUuid,
        customerUuid,
        tenantId,
        outletId,
        status,
        paymentStatus,
        transactionDate,
        subtotal,
        discountTotal,
        taxTotal,
        grandTotal,
        paymentMethod,
        tenderedAmount,
        changeAmount,
        updatedAt,
        isSynced,
        version,
        syncAttempts,
        isFulfilled
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is OrderTableData &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.orderNumber == this.orderNumber &&
          other.shiftUuid == this.shiftUuid &&
          other.customerUuid == this.customerUuid &&
          other.tenantId == this.tenantId &&
          other.outletId == this.outletId &&
          other.status == this.status &&
          other.paymentStatus == this.paymentStatus &&
          other.transactionDate == this.transactionDate &&
          other.subtotal == this.subtotal &&
          other.discountTotal == this.discountTotal &&
          other.taxTotal == this.taxTotal &&
          other.grandTotal == this.grandTotal &&
          other.paymentMethod == this.paymentMethod &&
          other.tenderedAmount == this.tenderedAmount &&
          other.changeAmount == this.changeAmount &&
          other.updatedAt == this.updatedAt &&
          other.isSynced == this.isSynced &&
          other.version == this.version &&
          other.syncAttempts == this.syncAttempts &&
          other.isFulfilled == this.isFulfilled);
}

class OrderTableCompanion extends UpdateCompanion<OrderTableData> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String> orderNumber;
  final Value<String?> shiftUuid;
  final Value<String?> customerUuid;
  final Value<String?> tenantId;
  final Value<String?> outletId;
  final Value<String> status;
  final Value<String> paymentStatus;
  final Value<DateTime> transactionDate;
  final Value<double> subtotal;
  final Value<double> discountTotal;
  final Value<double> taxTotal;
  final Value<double> grandTotal;
  final Value<String?> paymentMethod;
  final Value<double?> tenderedAmount;
  final Value<double?> changeAmount;
  final Value<DateTime> updatedAt;
  final Value<bool> isSynced;
  final Value<int> version;
  final Value<int> syncAttempts;
  final Value<bool> isFulfilled;
  const OrderTableCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.orderNumber = const Value.absent(),
    this.shiftUuid = const Value.absent(),
    this.customerUuid = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.outletId = const Value.absent(),
    this.status = const Value.absent(),
    this.paymentStatus = const Value.absent(),
    this.transactionDate = const Value.absent(),
    this.subtotal = const Value.absent(),
    this.discountTotal = const Value.absent(),
    this.taxTotal = const Value.absent(),
    this.grandTotal = const Value.absent(),
    this.paymentMethod = const Value.absent(),
    this.tenderedAmount = const Value.absent(),
    this.changeAmount = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.isSynced = const Value.absent(),
    this.version = const Value.absent(),
    this.syncAttempts = const Value.absent(),
    this.isFulfilled = const Value.absent(),
  });
  OrderTableCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    required String orderNumber,
    this.shiftUuid = const Value.absent(),
    this.customerUuid = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.outletId = const Value.absent(),
    this.status = const Value.absent(),
    this.paymentStatus = const Value.absent(),
    required DateTime transactionDate,
    required double subtotal,
    required double discountTotal,
    required double taxTotal,
    required double grandTotal,
    this.paymentMethod = const Value.absent(),
    this.tenderedAmount = const Value.absent(),
    this.changeAmount = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.isSynced = const Value.absent(),
    this.version = const Value.absent(),
    this.syncAttempts = const Value.absent(),
    this.isFulfilled = const Value.absent(),
  })  : uuid = Value(uuid),
        orderNumber = Value(orderNumber),
        transactionDate = Value(transactionDate),
        subtotal = Value(subtotal),
        discountTotal = Value(discountTotal),
        taxTotal = Value(taxTotal),
        grandTotal = Value(grandTotal);
  static Insertable<OrderTableData> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? orderNumber,
    Expression<String>? shiftUuid,
    Expression<String>? customerUuid,
    Expression<String>? tenantId,
    Expression<String>? outletId,
    Expression<String>? status,
    Expression<String>? paymentStatus,
    Expression<DateTime>? transactionDate,
    Expression<double>? subtotal,
    Expression<double>? discountTotal,
    Expression<double>? taxTotal,
    Expression<double>? grandTotal,
    Expression<String>? paymentMethod,
    Expression<double>? tenderedAmount,
    Expression<double>? changeAmount,
    Expression<DateTime>? updatedAt,
    Expression<bool>? isSynced,
    Expression<int>? version,
    Expression<int>? syncAttempts,
    Expression<bool>? isFulfilled,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (orderNumber != null) 'order_number': orderNumber,
      if (shiftUuid != null) 'shift_uuid': shiftUuid,
      if (customerUuid != null) 'customer_uuid': customerUuid,
      if (tenantId != null) 'tenant_id': tenantId,
      if (outletId != null) 'outlet_id': outletId,
      if (status != null) 'status': status,
      if (paymentStatus != null) 'payment_status': paymentStatus,
      if (transactionDate != null) 'transaction_date': transactionDate,
      if (subtotal != null) 'subtotal': subtotal,
      if (discountTotal != null) 'discount_total': discountTotal,
      if (taxTotal != null) 'tax_total': taxTotal,
      if (grandTotal != null) 'grand_total': grandTotal,
      if (paymentMethod != null) 'payment_method': paymentMethod,
      if (tenderedAmount != null) 'tendered_amount': tenderedAmount,
      if (changeAmount != null) 'change_amount': changeAmount,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (isSynced != null) 'is_synced': isSynced,
      if (version != null) 'version': version,
      if (syncAttempts != null) 'sync_attempts': syncAttempts,
      if (isFulfilled != null) 'is_fulfilled': isFulfilled,
    });
  }

  OrderTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String>? orderNumber,
      Value<String?>? shiftUuid,
      Value<String?>? customerUuid,
      Value<String?>? tenantId,
      Value<String?>? outletId,
      Value<String>? status,
      Value<String>? paymentStatus,
      Value<DateTime>? transactionDate,
      Value<double>? subtotal,
      Value<double>? discountTotal,
      Value<double>? taxTotal,
      Value<double>? grandTotal,
      Value<String?>? paymentMethod,
      Value<double?>? tenderedAmount,
      Value<double?>? changeAmount,
      Value<DateTime>? updatedAt,
      Value<bool>? isSynced,
      Value<int>? version,
      Value<int>? syncAttempts,
      Value<bool>? isFulfilled}) {
    return OrderTableCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      orderNumber: orderNumber ?? this.orderNumber,
      shiftUuid: shiftUuid ?? this.shiftUuid,
      customerUuid: customerUuid ?? this.customerUuid,
      tenantId: tenantId ?? this.tenantId,
      outletId: outletId ?? this.outletId,
      status: status ?? this.status,
      paymentStatus: paymentStatus ?? this.paymentStatus,
      transactionDate: transactionDate ?? this.transactionDate,
      subtotal: subtotal ?? this.subtotal,
      discountTotal: discountTotal ?? this.discountTotal,
      taxTotal: taxTotal ?? this.taxTotal,
      grandTotal: grandTotal ?? this.grandTotal,
      paymentMethod: paymentMethod ?? this.paymentMethod,
      tenderedAmount: tenderedAmount ?? this.tenderedAmount,
      changeAmount: changeAmount ?? this.changeAmount,
      updatedAt: updatedAt ?? this.updatedAt,
      isSynced: isSynced ?? this.isSynced,
      version: version ?? this.version,
      syncAttempts: syncAttempts ?? this.syncAttempts,
      isFulfilled: isFulfilled ?? this.isFulfilled,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (orderNumber.present) {
      map['order_number'] = Variable<String>(orderNumber.value);
    }
    if (shiftUuid.present) {
      map['shift_uuid'] = Variable<String>(shiftUuid.value);
    }
    if (customerUuid.present) {
      map['customer_uuid'] = Variable<String>(customerUuid.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (outletId.present) {
      map['outlet_id'] = Variable<String>(outletId.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (paymentStatus.present) {
      map['payment_status'] = Variable<String>(paymentStatus.value);
    }
    if (transactionDate.present) {
      map['transaction_date'] = Variable<DateTime>(transactionDate.value);
    }
    if (subtotal.present) {
      map['subtotal'] = Variable<double>(subtotal.value);
    }
    if (discountTotal.present) {
      map['discount_total'] = Variable<double>(discountTotal.value);
    }
    if (taxTotal.present) {
      map['tax_total'] = Variable<double>(taxTotal.value);
    }
    if (grandTotal.present) {
      map['grand_total'] = Variable<double>(grandTotal.value);
    }
    if (paymentMethod.present) {
      map['payment_method'] = Variable<String>(paymentMethod.value);
    }
    if (tenderedAmount.present) {
      map['tendered_amount'] = Variable<double>(tenderedAmount.value);
    }
    if (changeAmount.present) {
      map['change_amount'] = Variable<double>(changeAmount.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (isSynced.present) {
      map['is_synced'] = Variable<bool>(isSynced.value);
    }
    if (version.present) {
      map['version'] = Variable<int>(version.value);
    }
    if (syncAttempts.present) {
      map['sync_attempts'] = Variable<int>(syncAttempts.value);
    }
    if (isFulfilled.present) {
      map['is_fulfilled'] = Variable<bool>(isFulfilled.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('OrderTableCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('orderNumber: $orderNumber, ')
          ..write('shiftUuid: $shiftUuid, ')
          ..write('customerUuid: $customerUuid, ')
          ..write('tenantId: $tenantId, ')
          ..write('outletId: $outletId, ')
          ..write('status: $status, ')
          ..write('paymentStatus: $paymentStatus, ')
          ..write('transactionDate: $transactionDate, ')
          ..write('subtotal: $subtotal, ')
          ..write('discountTotal: $discountTotal, ')
          ..write('taxTotal: $taxTotal, ')
          ..write('grandTotal: $grandTotal, ')
          ..write('paymentMethod: $paymentMethod, ')
          ..write('tenderedAmount: $tenderedAmount, ')
          ..write('changeAmount: $changeAmount, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('isSynced: $isSynced, ')
          ..write('version: $version, ')
          ..write('syncAttempts: $syncAttempts, ')
          ..write('isFulfilled: $isFulfilled')
          ..write(')'))
        .toString();
  }
}

class $OrderItemTableTable extends OrderItemTable
    with TableInfo<$OrderItemTableTable, OrderItemTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $OrderItemTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _orderUuidMeta =
      const VerificationMeta('orderUuid');
  @override
  late final GeneratedColumn<String> orderUuid = GeneratedColumn<String>(
      'order_uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES order_table (uuid) ON DELETE CASCADE'));
  static const VerificationMeta _productUuidMeta =
      const VerificationMeta('productUuid');
  @override
  late final GeneratedColumn<String> productUuid = GeneratedColumn<String>(
      'product_uuid', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _priceMeta = const VerificationMeta('price');
  @override
  late final GeneratedColumn<double> price = GeneratedColumn<double>(
      'price', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _quantityMeta =
      const VerificationMeta('quantity');
  @override
  late final GeneratedColumn<double> quantity = GeneratedColumn<double>(
      'quantity', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _paidQtyMeta =
      const VerificationMeta('paidQty');
  @override
  late final GeneratedColumn<double> paidQty = GeneratedColumn<double>(
      'paid_qty', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: false,
      defaultValue: const Constant(0));
  static const VerificationMeta _noteMeta = const VerificationMeta('note');
  @override
  late final GeneratedColumn<String> note = GeneratedColumn<String>(
      'note', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _modifiersJsonMeta =
      const VerificationMeta('modifiersJson');
  @override
  late final GeneratedColumn<String> modifiersJson = GeneratedColumn<String>(
      'modifiers_json', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _totalMeta = const VerificationMeta('total');
  @override
  late final GeneratedColumn<double> total = GeneratedColumn<double>(
      'total', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        orderUuid,
        productUuid,
        name,
        price,
        quantity,
        paidQty,
        note,
        modifiersJson,
        total,
        updatedAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'order_item_table';
  @override
  VerificationContext validateIntegrity(Insertable<OrderItemTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('order_uuid')) {
      context.handle(_orderUuidMeta,
          orderUuid.isAcceptableOrUnknown(data['order_uuid']!, _orderUuidMeta));
    } else if (isInserting) {
      context.missing(_orderUuidMeta);
    }
    if (data.containsKey('product_uuid')) {
      context.handle(
          _productUuidMeta,
          productUuid.isAcceptableOrUnknown(
              data['product_uuid']!, _productUuidMeta));
    } else if (isInserting) {
      context.missing(_productUuidMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['price']!, _priceMeta));
    } else if (isInserting) {
      context.missing(_priceMeta);
    }
    if (data.containsKey('quantity')) {
      context.handle(_quantityMeta,
          quantity.isAcceptableOrUnknown(data['quantity']!, _quantityMeta));
    } else if (isInserting) {
      context.missing(_quantityMeta);
    }
    if (data.containsKey('paid_qty')) {
      context.handle(_paidQtyMeta,
          paidQty.isAcceptableOrUnknown(data['paid_qty']!, _paidQtyMeta));
    }
    if (data.containsKey('note')) {
      context.handle(
          _noteMeta, note.isAcceptableOrUnknown(data['note']!, _noteMeta));
    }
    if (data.containsKey('modifiers_json')) {
      context.handle(
          _modifiersJsonMeta,
          modifiersJson.isAcceptableOrUnknown(
              data['modifiers_json']!, _modifiersJsonMeta));
    }
    if (data.containsKey('total')) {
      context.handle(
          _totalMeta, total.isAcceptableOrUnknown(data['total']!, _totalMeta));
    } else if (isInserting) {
      context.missing(_totalMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  OrderItemTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return OrderItemTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      orderUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}order_uuid'])!,
      productUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}product_uuid'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
      price: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}price'])!,
      quantity: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}quantity'])!,
      paidQty: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}paid_qty'])!,
      note: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}note']),
      modifiersJson: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}modifiers_json']),
      total: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}total'])!,
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $OrderItemTableTable createAlias(String alias) {
    return $OrderItemTableTable(attachedDatabase, alias);
  }
}

class OrderItemTableData extends DataClass
    implements Insertable<OrderItemTableData> {
  final int id;
  final String orderUuid;
  final String productUuid;
  final String name;
  final double price;
  final double quantity;
  final double paidQty;
  final String? note;
  final String? modifiersJson;
  final double total;
  final DateTime updatedAt;
  const OrderItemTableData(
      {required this.id,
      required this.orderUuid,
      required this.productUuid,
      required this.name,
      required this.price,
      required this.quantity,
      required this.paidQty,
      this.note,
      this.modifiersJson,
      required this.total,
      required this.updatedAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['order_uuid'] = Variable<String>(orderUuid);
    map['product_uuid'] = Variable<String>(productUuid);
    map['name'] = Variable<String>(name);
    map['price'] = Variable<double>(price);
    map['quantity'] = Variable<double>(quantity);
    map['paid_qty'] = Variable<double>(paidQty);
    if (!nullToAbsent || note != null) {
      map['note'] = Variable<String>(note);
    }
    if (!nullToAbsent || modifiersJson != null) {
      map['modifiers_json'] = Variable<String>(modifiersJson);
    }
    map['total'] = Variable<double>(total);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  OrderItemTableCompanion toCompanion(bool nullToAbsent) {
    return OrderItemTableCompanion(
      id: Value(id),
      orderUuid: Value(orderUuid),
      productUuid: Value(productUuid),
      name: Value(name),
      price: Value(price),
      quantity: Value(quantity),
      paidQty: Value(paidQty),
      note: note == null && nullToAbsent ? const Value.absent() : Value(note),
      modifiersJson: modifiersJson == null && nullToAbsent
          ? const Value.absent()
          : Value(modifiersJson),
      total: Value(total),
      updatedAt: Value(updatedAt),
    );
  }

  factory OrderItemTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return OrderItemTableData(
      id: serializer.fromJson<int>(json['id']),
      orderUuid: serializer.fromJson<String>(json['orderUuid']),
      productUuid: serializer.fromJson<String>(json['productUuid']),
      name: serializer.fromJson<String>(json['name']),
      price: serializer.fromJson<double>(json['price']),
      quantity: serializer.fromJson<double>(json['quantity']),
      paidQty: serializer.fromJson<double>(json['paidQty']),
      note: serializer.fromJson<String?>(json['note']),
      modifiersJson: serializer.fromJson<String?>(json['modifiersJson']),
      total: serializer.fromJson<double>(json['total']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'orderUuid': serializer.toJson<String>(orderUuid),
      'productUuid': serializer.toJson<String>(productUuid),
      'name': serializer.toJson<String>(name),
      'price': serializer.toJson<double>(price),
      'quantity': serializer.toJson<double>(quantity),
      'paidQty': serializer.toJson<double>(paidQty),
      'note': serializer.toJson<String?>(note),
      'modifiersJson': serializer.toJson<String?>(modifiersJson),
      'total': serializer.toJson<double>(total),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  OrderItemTableData copyWith(
          {int? id,
          String? orderUuid,
          String? productUuid,
          String? name,
          double? price,
          double? quantity,
          double? paidQty,
          Value<String?> note = const Value.absent(),
          Value<String?> modifiersJson = const Value.absent(),
          double? total,
          DateTime? updatedAt}) =>
      OrderItemTableData(
        id: id ?? this.id,
        orderUuid: orderUuid ?? this.orderUuid,
        productUuid: productUuid ?? this.productUuid,
        name: name ?? this.name,
        price: price ?? this.price,
        quantity: quantity ?? this.quantity,
        paidQty: paidQty ?? this.paidQty,
        note: note.present ? note.value : this.note,
        modifiersJson:
            modifiersJson.present ? modifiersJson.value : this.modifiersJson,
        total: total ?? this.total,
        updatedAt: updatedAt ?? this.updatedAt,
      );
  OrderItemTableData copyWithCompanion(OrderItemTableCompanion data) {
    return OrderItemTableData(
      id: data.id.present ? data.id.value : this.id,
      orderUuid: data.orderUuid.present ? data.orderUuid.value : this.orderUuid,
      productUuid:
          data.productUuid.present ? data.productUuid.value : this.productUuid,
      name: data.name.present ? data.name.value : this.name,
      price: data.price.present ? data.price.value : this.price,
      quantity: data.quantity.present ? data.quantity.value : this.quantity,
      paidQty: data.paidQty.present ? data.paidQty.value : this.paidQty,
      note: data.note.present ? data.note.value : this.note,
      modifiersJson: data.modifiersJson.present
          ? data.modifiersJson.value
          : this.modifiersJson,
      total: data.total.present ? data.total.value : this.total,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('OrderItemTableData(')
          ..write('id: $id, ')
          ..write('orderUuid: $orderUuid, ')
          ..write('productUuid: $productUuid, ')
          ..write('name: $name, ')
          ..write('price: $price, ')
          ..write('quantity: $quantity, ')
          ..write('paidQty: $paidQty, ')
          ..write('note: $note, ')
          ..write('modifiersJson: $modifiersJson, ')
          ..write('total: $total, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, orderUuid, productUuid, name, price,
      quantity, paidQty, note, modifiersJson, total, updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is OrderItemTableData &&
          other.id == this.id &&
          other.orderUuid == this.orderUuid &&
          other.productUuid == this.productUuid &&
          other.name == this.name &&
          other.price == this.price &&
          other.quantity == this.quantity &&
          other.paidQty == this.paidQty &&
          other.note == this.note &&
          other.modifiersJson == this.modifiersJson &&
          other.total == this.total &&
          other.updatedAt == this.updatedAt);
}

class OrderItemTableCompanion extends UpdateCompanion<OrderItemTableData> {
  final Value<int> id;
  final Value<String> orderUuid;
  final Value<String> productUuid;
  final Value<String> name;
  final Value<double> price;
  final Value<double> quantity;
  final Value<double> paidQty;
  final Value<String?> note;
  final Value<String?> modifiersJson;
  final Value<double> total;
  final Value<DateTime> updatedAt;
  const OrderItemTableCompanion({
    this.id = const Value.absent(),
    this.orderUuid = const Value.absent(),
    this.productUuid = const Value.absent(),
    this.name = const Value.absent(),
    this.price = const Value.absent(),
    this.quantity = const Value.absent(),
    this.paidQty = const Value.absent(),
    this.note = const Value.absent(),
    this.modifiersJson = const Value.absent(),
    this.total = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  OrderItemTableCompanion.insert({
    this.id = const Value.absent(),
    required String orderUuid,
    required String productUuid,
    required String name,
    required double price,
    required double quantity,
    this.paidQty = const Value.absent(),
    this.note = const Value.absent(),
    this.modifiersJson = const Value.absent(),
    required double total,
    this.updatedAt = const Value.absent(),
  })  : orderUuid = Value(orderUuid),
        productUuid = Value(productUuid),
        name = Value(name),
        price = Value(price),
        quantity = Value(quantity),
        total = Value(total);
  static Insertable<OrderItemTableData> custom({
    Expression<int>? id,
    Expression<String>? orderUuid,
    Expression<String>? productUuid,
    Expression<String>? name,
    Expression<double>? price,
    Expression<double>? quantity,
    Expression<double>? paidQty,
    Expression<String>? note,
    Expression<String>? modifiersJson,
    Expression<double>? total,
    Expression<DateTime>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (orderUuid != null) 'order_uuid': orderUuid,
      if (productUuid != null) 'product_uuid': productUuid,
      if (name != null) 'name': name,
      if (price != null) 'price': price,
      if (quantity != null) 'quantity': quantity,
      if (paidQty != null) 'paid_qty': paidQty,
      if (note != null) 'note': note,
      if (modifiersJson != null) 'modifiers_json': modifiersJson,
      if (total != null) 'total': total,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  OrderItemTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? orderUuid,
      Value<String>? productUuid,
      Value<String>? name,
      Value<double>? price,
      Value<double>? quantity,
      Value<double>? paidQty,
      Value<String?>? note,
      Value<String?>? modifiersJson,
      Value<double>? total,
      Value<DateTime>? updatedAt}) {
    return OrderItemTableCompanion(
      id: id ?? this.id,
      orderUuid: orderUuid ?? this.orderUuid,
      productUuid: productUuid ?? this.productUuid,
      name: name ?? this.name,
      price: price ?? this.price,
      quantity: quantity ?? this.quantity,
      paidQty: paidQty ?? this.paidQty,
      note: note ?? this.note,
      modifiersJson: modifiersJson ?? this.modifiersJson,
      total: total ?? this.total,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (orderUuid.present) {
      map['order_uuid'] = Variable<String>(orderUuid.value);
    }
    if (productUuid.present) {
      map['product_uuid'] = Variable<String>(productUuid.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (price.present) {
      map['price'] = Variable<double>(price.value);
    }
    if (quantity.present) {
      map['quantity'] = Variable<double>(quantity.value);
    }
    if (paidQty.present) {
      map['paid_qty'] = Variable<double>(paidQty.value);
    }
    if (note.present) {
      map['note'] = Variable<String>(note.value);
    }
    if (modifiersJson.present) {
      map['modifiers_json'] = Variable<String>(modifiersJson.value);
    }
    if (total.present) {
      map['total'] = Variable<double>(total.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('OrderItemTableCompanion(')
          ..write('id: $id, ')
          ..write('orderUuid: $orderUuid, ')
          ..write('productUuid: $productUuid, ')
          ..write('name: $name, ')
          ..write('price: $price, ')
          ..write('quantity: $quantity, ')
          ..write('paidQty: $paidQty, ')
          ..write('note: $note, ')
          ..write('modifiersJson: $modifiersJson, ')
          ..write('total: $total, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class $InventoryLedgerTableTable extends InventoryLedgerTable
    with TableInfo<$InventoryLedgerTableTable, InventoryLedgerTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $InventoryLedgerTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _productUuidMeta =
      const VerificationMeta('productUuid');
  @override
  late final GeneratedColumn<String> productUuid = GeneratedColumn<String>(
      'product_uuid', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _quantityChangeMeta =
      const VerificationMeta('quantityChange');
  @override
  late final GeneratedColumn<double> quantityChange = GeneratedColumn<double>(
      'quantity_change', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _referenceIdMeta =
      const VerificationMeta('referenceId');
  @override
  late final GeneratedColumn<String> referenceId = GeneratedColumn<String>(
      'reference_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _typeMeta = const VerificationMeta('type');
  @override
  late final GeneratedColumn<String> type = GeneratedColumn<String>(
      'type', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _timestampMeta =
      const VerificationMeta('timestamp');
  @override
  late final GeneratedColumn<DateTime> timestamp = GeneratedColumn<DateTime>(
      'timestamp', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _isSyncedMeta =
      const VerificationMeta('isSynced');
  @override
  late final GeneratedColumn<bool> isSynced = GeneratedColumn<bool>(
      'is_synced', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_synced" IN (0, 1))'),
      defaultValue: const Constant(false));
  @override
  List<GeneratedColumn> get $columns =>
      [id, productUuid, quantityChange, referenceId, type, timestamp, isSynced];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'inventory_ledger_table';
  @override
  VerificationContext validateIntegrity(
      Insertable<InventoryLedgerTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('product_uuid')) {
      context.handle(
          _productUuidMeta,
          productUuid.isAcceptableOrUnknown(
              data['product_uuid']!, _productUuidMeta));
    } else if (isInserting) {
      context.missing(_productUuidMeta);
    }
    if (data.containsKey('quantity_change')) {
      context.handle(
          _quantityChangeMeta,
          quantityChange.isAcceptableOrUnknown(
              data['quantity_change']!, _quantityChangeMeta));
    } else if (isInserting) {
      context.missing(_quantityChangeMeta);
    }
    if (data.containsKey('reference_id')) {
      context.handle(
          _referenceIdMeta,
          referenceId.isAcceptableOrUnknown(
              data['reference_id']!, _referenceIdMeta));
    } else if (isInserting) {
      context.missing(_referenceIdMeta);
    }
    if (data.containsKey('type')) {
      context.handle(
          _typeMeta, type.isAcceptableOrUnknown(data['type']!, _typeMeta));
    } else if (isInserting) {
      context.missing(_typeMeta);
    }
    if (data.containsKey('timestamp')) {
      context.handle(_timestampMeta,
          timestamp.isAcceptableOrUnknown(data['timestamp']!, _timestampMeta));
    } else if (isInserting) {
      context.missing(_timestampMeta);
    }
    if (data.containsKey('is_synced')) {
      context.handle(_isSyncedMeta,
          isSynced.isAcceptableOrUnknown(data['is_synced']!, _isSyncedMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  InventoryLedgerTableData map(Map<String, dynamic> data,
      {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return InventoryLedgerTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      productUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}product_uuid'])!,
      quantityChange: attachedDatabase.typeMapping.read(
          DriftSqlType.double, data['${effectivePrefix}quantity_change'])!,
      referenceId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}reference_id'])!,
      type: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}type'])!,
      timestamp: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}timestamp'])!,
      isSynced: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_synced'])!,
    );
  }

  @override
  $InventoryLedgerTableTable createAlias(String alias) {
    return $InventoryLedgerTableTable(attachedDatabase, alias);
  }
}

class InventoryLedgerTableData extends DataClass
    implements Insertable<InventoryLedgerTableData> {
  final int id;
  final String productUuid;
  final double quantityChange;
  final String referenceId;
  final String type;
  final DateTime timestamp;
  final bool isSynced;
  const InventoryLedgerTableData(
      {required this.id,
      required this.productUuid,
      required this.quantityChange,
      required this.referenceId,
      required this.type,
      required this.timestamp,
      required this.isSynced});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['product_uuid'] = Variable<String>(productUuid);
    map['quantity_change'] = Variable<double>(quantityChange);
    map['reference_id'] = Variable<String>(referenceId);
    map['type'] = Variable<String>(type);
    map['timestamp'] = Variable<DateTime>(timestamp);
    map['is_synced'] = Variable<bool>(isSynced);
    return map;
  }

  InventoryLedgerTableCompanion toCompanion(bool nullToAbsent) {
    return InventoryLedgerTableCompanion(
      id: Value(id),
      productUuid: Value(productUuid),
      quantityChange: Value(quantityChange),
      referenceId: Value(referenceId),
      type: Value(type),
      timestamp: Value(timestamp),
      isSynced: Value(isSynced),
    );
  }

  factory InventoryLedgerTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return InventoryLedgerTableData(
      id: serializer.fromJson<int>(json['id']),
      productUuid: serializer.fromJson<String>(json['productUuid']),
      quantityChange: serializer.fromJson<double>(json['quantityChange']),
      referenceId: serializer.fromJson<String>(json['referenceId']),
      type: serializer.fromJson<String>(json['type']),
      timestamp: serializer.fromJson<DateTime>(json['timestamp']),
      isSynced: serializer.fromJson<bool>(json['isSynced']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'productUuid': serializer.toJson<String>(productUuid),
      'quantityChange': serializer.toJson<double>(quantityChange),
      'referenceId': serializer.toJson<String>(referenceId),
      'type': serializer.toJson<String>(type),
      'timestamp': serializer.toJson<DateTime>(timestamp),
      'isSynced': serializer.toJson<bool>(isSynced),
    };
  }

  InventoryLedgerTableData copyWith(
          {int? id,
          String? productUuid,
          double? quantityChange,
          String? referenceId,
          String? type,
          DateTime? timestamp,
          bool? isSynced}) =>
      InventoryLedgerTableData(
        id: id ?? this.id,
        productUuid: productUuid ?? this.productUuid,
        quantityChange: quantityChange ?? this.quantityChange,
        referenceId: referenceId ?? this.referenceId,
        type: type ?? this.type,
        timestamp: timestamp ?? this.timestamp,
        isSynced: isSynced ?? this.isSynced,
      );
  InventoryLedgerTableData copyWithCompanion(
      InventoryLedgerTableCompanion data) {
    return InventoryLedgerTableData(
      id: data.id.present ? data.id.value : this.id,
      productUuid:
          data.productUuid.present ? data.productUuid.value : this.productUuid,
      quantityChange: data.quantityChange.present
          ? data.quantityChange.value
          : this.quantityChange,
      referenceId:
          data.referenceId.present ? data.referenceId.value : this.referenceId,
      type: data.type.present ? data.type.value : this.type,
      timestamp: data.timestamp.present ? data.timestamp.value : this.timestamp,
      isSynced: data.isSynced.present ? data.isSynced.value : this.isSynced,
    );
  }

  @override
  String toString() {
    return (StringBuffer('InventoryLedgerTableData(')
          ..write('id: $id, ')
          ..write('productUuid: $productUuid, ')
          ..write('quantityChange: $quantityChange, ')
          ..write('referenceId: $referenceId, ')
          ..write('type: $type, ')
          ..write('timestamp: $timestamp, ')
          ..write('isSynced: $isSynced')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id, productUuid, quantityChange, referenceId, type, timestamp, isSynced);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is InventoryLedgerTableData &&
          other.id == this.id &&
          other.productUuid == this.productUuid &&
          other.quantityChange == this.quantityChange &&
          other.referenceId == this.referenceId &&
          other.type == this.type &&
          other.timestamp == this.timestamp &&
          other.isSynced == this.isSynced);
}

class InventoryLedgerTableCompanion
    extends UpdateCompanion<InventoryLedgerTableData> {
  final Value<int> id;
  final Value<String> productUuid;
  final Value<double> quantityChange;
  final Value<String> referenceId;
  final Value<String> type;
  final Value<DateTime> timestamp;
  final Value<bool> isSynced;
  const InventoryLedgerTableCompanion({
    this.id = const Value.absent(),
    this.productUuid = const Value.absent(),
    this.quantityChange = const Value.absent(),
    this.referenceId = const Value.absent(),
    this.type = const Value.absent(),
    this.timestamp = const Value.absent(),
    this.isSynced = const Value.absent(),
  });
  InventoryLedgerTableCompanion.insert({
    this.id = const Value.absent(),
    required String productUuid,
    required double quantityChange,
    required String referenceId,
    required String type,
    required DateTime timestamp,
    this.isSynced = const Value.absent(),
  })  : productUuid = Value(productUuid),
        quantityChange = Value(quantityChange),
        referenceId = Value(referenceId),
        type = Value(type),
        timestamp = Value(timestamp);
  static Insertable<InventoryLedgerTableData> custom({
    Expression<int>? id,
    Expression<String>? productUuid,
    Expression<double>? quantityChange,
    Expression<String>? referenceId,
    Expression<String>? type,
    Expression<DateTime>? timestamp,
    Expression<bool>? isSynced,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (productUuid != null) 'product_uuid': productUuid,
      if (quantityChange != null) 'quantity_change': quantityChange,
      if (referenceId != null) 'reference_id': referenceId,
      if (type != null) 'type': type,
      if (timestamp != null) 'timestamp': timestamp,
      if (isSynced != null) 'is_synced': isSynced,
    });
  }

  InventoryLedgerTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? productUuid,
      Value<double>? quantityChange,
      Value<String>? referenceId,
      Value<String>? type,
      Value<DateTime>? timestamp,
      Value<bool>? isSynced}) {
    return InventoryLedgerTableCompanion(
      id: id ?? this.id,
      productUuid: productUuid ?? this.productUuid,
      quantityChange: quantityChange ?? this.quantityChange,
      referenceId: referenceId ?? this.referenceId,
      type: type ?? this.type,
      timestamp: timestamp ?? this.timestamp,
      isSynced: isSynced ?? this.isSynced,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (productUuid.present) {
      map['product_uuid'] = Variable<String>(productUuid.value);
    }
    if (quantityChange.present) {
      map['quantity_change'] = Variable<double>(quantityChange.value);
    }
    if (referenceId.present) {
      map['reference_id'] = Variable<String>(referenceId.value);
    }
    if (type.present) {
      map['type'] = Variable<String>(type.value);
    }
    if (timestamp.present) {
      map['timestamp'] = Variable<DateTime>(timestamp.value);
    }
    if (isSynced.present) {
      map['is_synced'] = Variable<bool>(isSynced.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('InventoryLedgerTableCompanion(')
          ..write('id: $id, ')
          ..write('productUuid: $productUuid, ')
          ..write('quantityChange: $quantityChange, ')
          ..write('referenceId: $referenceId, ')
          ..write('type: $type, ')
          ..write('timestamp: $timestamp, ')
          ..write('isSynced: $isSynced')
          ..write(')'))
        .toString();
  }
}

class $InventoryCacheTableTable extends InventoryCacheTable
    with TableInfo<$InventoryCacheTableTable, InventoryCacheTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $InventoryCacheTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _productUuidMeta =
      const VerificationMeta('productUuid');
  @override
  late final GeneratedColumn<String> productUuid = GeneratedColumn<String>(
      'product_uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _serverQuantityMeta =
      const VerificationMeta('serverQuantity');
  @override
  late final GeneratedColumn<double> serverQuantity = GeneratedColumn<double>(
      'server_quantity', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _lastSyncedAtMeta =
      const VerificationMeta('lastSyncedAt');
  @override
  late final GeneratedColumn<DateTime> lastSyncedAt = GeneratedColumn<DateTime>(
      'last_synced_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns =>
      [id, productUuid, serverQuantity, lastSyncedAt];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'inventory_cache_table';
  @override
  VerificationContext validateIntegrity(
      Insertable<InventoryCacheTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('product_uuid')) {
      context.handle(
          _productUuidMeta,
          productUuid.isAcceptableOrUnknown(
              data['product_uuid']!, _productUuidMeta));
    } else if (isInserting) {
      context.missing(_productUuidMeta);
    }
    if (data.containsKey('server_quantity')) {
      context.handle(
          _serverQuantityMeta,
          serverQuantity.isAcceptableOrUnknown(
              data['server_quantity']!, _serverQuantityMeta));
    } else if (isInserting) {
      context.missing(_serverQuantityMeta);
    }
    if (data.containsKey('last_synced_at')) {
      context.handle(
          _lastSyncedAtMeta,
          lastSyncedAt.isAcceptableOrUnknown(
              data['last_synced_at']!, _lastSyncedAtMeta));
    } else if (isInserting) {
      context.missing(_lastSyncedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  InventoryCacheTableData map(Map<String, dynamic> data,
      {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return InventoryCacheTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      productUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}product_uuid'])!,
      serverQuantity: attachedDatabase.typeMapping.read(
          DriftSqlType.double, data['${effectivePrefix}server_quantity'])!,
      lastSyncedAt: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}last_synced_at'])!,
    );
  }

  @override
  $InventoryCacheTableTable createAlias(String alias) {
    return $InventoryCacheTableTable(attachedDatabase, alias);
  }
}

class InventoryCacheTableData extends DataClass
    implements Insertable<InventoryCacheTableData> {
  final int id;
  final String productUuid;
  final double serverQuantity;
  final DateTime lastSyncedAt;
  const InventoryCacheTableData(
      {required this.id,
      required this.productUuid,
      required this.serverQuantity,
      required this.lastSyncedAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['product_uuid'] = Variable<String>(productUuid);
    map['server_quantity'] = Variable<double>(serverQuantity);
    map['last_synced_at'] = Variable<DateTime>(lastSyncedAt);
    return map;
  }

  InventoryCacheTableCompanion toCompanion(bool nullToAbsent) {
    return InventoryCacheTableCompanion(
      id: Value(id),
      productUuid: Value(productUuid),
      serverQuantity: Value(serverQuantity),
      lastSyncedAt: Value(lastSyncedAt),
    );
  }

  factory InventoryCacheTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return InventoryCacheTableData(
      id: serializer.fromJson<int>(json['id']),
      productUuid: serializer.fromJson<String>(json['productUuid']),
      serverQuantity: serializer.fromJson<double>(json['serverQuantity']),
      lastSyncedAt: serializer.fromJson<DateTime>(json['lastSyncedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'productUuid': serializer.toJson<String>(productUuid),
      'serverQuantity': serializer.toJson<double>(serverQuantity),
      'lastSyncedAt': serializer.toJson<DateTime>(lastSyncedAt),
    };
  }

  InventoryCacheTableData copyWith(
          {int? id,
          String? productUuid,
          double? serverQuantity,
          DateTime? lastSyncedAt}) =>
      InventoryCacheTableData(
        id: id ?? this.id,
        productUuid: productUuid ?? this.productUuid,
        serverQuantity: serverQuantity ?? this.serverQuantity,
        lastSyncedAt: lastSyncedAt ?? this.lastSyncedAt,
      );
  InventoryCacheTableData copyWithCompanion(InventoryCacheTableCompanion data) {
    return InventoryCacheTableData(
      id: data.id.present ? data.id.value : this.id,
      productUuid:
          data.productUuid.present ? data.productUuid.value : this.productUuid,
      serverQuantity: data.serverQuantity.present
          ? data.serverQuantity.value
          : this.serverQuantity,
      lastSyncedAt: data.lastSyncedAt.present
          ? data.lastSyncedAt.value
          : this.lastSyncedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('InventoryCacheTableData(')
          ..write('id: $id, ')
          ..write('productUuid: $productUuid, ')
          ..write('serverQuantity: $serverQuantity, ')
          ..write('lastSyncedAt: $lastSyncedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, productUuid, serverQuantity, lastSyncedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is InventoryCacheTableData &&
          other.id == this.id &&
          other.productUuid == this.productUuid &&
          other.serverQuantity == this.serverQuantity &&
          other.lastSyncedAt == this.lastSyncedAt);
}

class InventoryCacheTableCompanion
    extends UpdateCompanion<InventoryCacheTableData> {
  final Value<int> id;
  final Value<String> productUuid;
  final Value<double> serverQuantity;
  final Value<DateTime> lastSyncedAt;
  const InventoryCacheTableCompanion({
    this.id = const Value.absent(),
    this.productUuid = const Value.absent(),
    this.serverQuantity = const Value.absent(),
    this.lastSyncedAt = const Value.absent(),
  });
  InventoryCacheTableCompanion.insert({
    this.id = const Value.absent(),
    required String productUuid,
    required double serverQuantity,
    required DateTime lastSyncedAt,
  })  : productUuid = Value(productUuid),
        serverQuantity = Value(serverQuantity),
        lastSyncedAt = Value(lastSyncedAt);
  static Insertable<InventoryCacheTableData> custom({
    Expression<int>? id,
    Expression<String>? productUuid,
    Expression<double>? serverQuantity,
    Expression<DateTime>? lastSyncedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (productUuid != null) 'product_uuid': productUuid,
      if (serverQuantity != null) 'server_quantity': serverQuantity,
      if (lastSyncedAt != null) 'last_synced_at': lastSyncedAt,
    });
  }

  InventoryCacheTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? productUuid,
      Value<double>? serverQuantity,
      Value<DateTime>? lastSyncedAt}) {
    return InventoryCacheTableCompanion(
      id: id ?? this.id,
      productUuid: productUuid ?? this.productUuid,
      serverQuantity: serverQuantity ?? this.serverQuantity,
      lastSyncedAt: lastSyncedAt ?? this.lastSyncedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (productUuid.present) {
      map['product_uuid'] = Variable<String>(productUuid.value);
    }
    if (serverQuantity.present) {
      map['server_quantity'] = Variable<double>(serverQuantity.value);
    }
    if (lastSyncedAt.present) {
      map['last_synced_at'] = Variable<DateTime>(lastSyncedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('InventoryCacheTableCompanion(')
          ..write('id: $id, ')
          ..write('productUuid: $productUuid, ')
          ..write('serverQuantity: $serverQuantity, ')
          ..write('lastSyncedAt: $lastSyncedAt')
          ..write(')'))
        .toString();
  }
}

class $LocalStocksTableTable extends LocalStocksTable
    with TableInfo<$LocalStocksTableTable, LocalStocksTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $LocalStocksTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _productUuidMeta =
      const VerificationMeta('productUuid');
  @override
  late final GeneratedColumn<String> productUuid = GeneratedColumn<String>(
      'product_uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES product_table (uuid) ON DELETE CASCADE'));
  static const VerificationMeta _warehouseUuidMeta =
      const VerificationMeta('warehouseUuid');
  @override
  late final GeneratedColumn<String> warehouseUuid = GeneratedColumn<String>(
      'warehouse_uuid', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _quantityMeta =
      const VerificationMeta('quantity');
  @override
  late final GeneratedColumn<double> quantity = GeneratedColumn<double>(
      'quantity', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: false,
      defaultValue: const Constant(0));
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _versionMeta =
      const VerificationMeta('version');
  @override
  late final GeneratedColumn<int> version = GeneratedColumn<int>(
      'version', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultValue: const Constant(1));
  @override
  List<GeneratedColumn> get $columns =>
      [id, productUuid, warehouseUuid, quantity, updatedAt, version];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'local_stocks_table';
  @override
  VerificationContext validateIntegrity(
      Insertable<LocalStocksTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('product_uuid')) {
      context.handle(
          _productUuidMeta,
          productUuid.isAcceptableOrUnknown(
              data['product_uuid']!, _productUuidMeta));
    } else if (isInserting) {
      context.missing(_productUuidMeta);
    }
    if (data.containsKey('warehouse_uuid')) {
      context.handle(
          _warehouseUuidMeta,
          warehouseUuid.isAcceptableOrUnknown(
              data['warehouse_uuid']!, _warehouseUuidMeta));
    } else if (isInserting) {
      context.missing(_warehouseUuidMeta);
    }
    if (data.containsKey('quantity')) {
      context.handle(_quantityMeta,
          quantity.isAcceptableOrUnknown(data['quantity']!, _quantityMeta));
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    if (data.containsKey('version')) {
      context.handle(_versionMeta,
          version.isAcceptableOrUnknown(data['version']!, _versionMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
        {productUuid, warehouseUuid},
      ];
  @override
  LocalStocksTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return LocalStocksTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      productUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}product_uuid'])!,
      warehouseUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}warehouse_uuid'])!,
      quantity: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}quantity'])!,
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
      version: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}version'])!,
    );
  }

  @override
  $LocalStocksTableTable createAlias(String alias) {
    return $LocalStocksTableTable(attachedDatabase, alias);
  }
}

class LocalStocksTableData extends DataClass
    implements Insertable<LocalStocksTableData> {
  final int id;
  final String productUuid;
  final String warehouseUuid;
  final double quantity;
  final DateTime updatedAt;
  final int version;
  const LocalStocksTableData(
      {required this.id,
      required this.productUuid,
      required this.warehouseUuid,
      required this.quantity,
      required this.updatedAt,
      required this.version});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['product_uuid'] = Variable<String>(productUuid);
    map['warehouse_uuid'] = Variable<String>(warehouseUuid);
    map['quantity'] = Variable<double>(quantity);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    map['version'] = Variable<int>(version);
    return map;
  }

  LocalStocksTableCompanion toCompanion(bool nullToAbsent) {
    return LocalStocksTableCompanion(
      id: Value(id),
      productUuid: Value(productUuid),
      warehouseUuid: Value(warehouseUuid),
      quantity: Value(quantity),
      updatedAt: Value(updatedAt),
      version: Value(version),
    );
  }

  factory LocalStocksTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return LocalStocksTableData(
      id: serializer.fromJson<int>(json['id']),
      productUuid: serializer.fromJson<String>(json['productUuid']),
      warehouseUuid: serializer.fromJson<String>(json['warehouseUuid']),
      quantity: serializer.fromJson<double>(json['quantity']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
      version: serializer.fromJson<int>(json['version']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'productUuid': serializer.toJson<String>(productUuid),
      'warehouseUuid': serializer.toJson<String>(warehouseUuid),
      'quantity': serializer.toJson<double>(quantity),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
      'version': serializer.toJson<int>(version),
    };
  }

  LocalStocksTableData copyWith(
          {int? id,
          String? productUuid,
          String? warehouseUuid,
          double? quantity,
          DateTime? updatedAt,
          int? version}) =>
      LocalStocksTableData(
        id: id ?? this.id,
        productUuid: productUuid ?? this.productUuid,
        warehouseUuid: warehouseUuid ?? this.warehouseUuid,
        quantity: quantity ?? this.quantity,
        updatedAt: updatedAt ?? this.updatedAt,
        version: version ?? this.version,
      );
  LocalStocksTableData copyWithCompanion(LocalStocksTableCompanion data) {
    return LocalStocksTableData(
      id: data.id.present ? data.id.value : this.id,
      productUuid:
          data.productUuid.present ? data.productUuid.value : this.productUuid,
      warehouseUuid: data.warehouseUuid.present
          ? data.warehouseUuid.value
          : this.warehouseUuid,
      quantity: data.quantity.present ? data.quantity.value : this.quantity,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      version: data.version.present ? data.version.value : this.version,
    );
  }

  @override
  String toString() {
    return (StringBuffer('LocalStocksTableData(')
          ..write('id: $id, ')
          ..write('productUuid: $productUuid, ')
          ..write('warehouseUuid: $warehouseUuid, ')
          ..write('quantity: $quantity, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('version: $version')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, productUuid, warehouseUuid, quantity, updatedAt, version);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is LocalStocksTableData &&
          other.id == this.id &&
          other.productUuid == this.productUuid &&
          other.warehouseUuid == this.warehouseUuid &&
          other.quantity == this.quantity &&
          other.updatedAt == this.updatedAt &&
          other.version == this.version);
}

class LocalStocksTableCompanion extends UpdateCompanion<LocalStocksTableData> {
  final Value<int> id;
  final Value<String> productUuid;
  final Value<String> warehouseUuid;
  final Value<double> quantity;
  final Value<DateTime> updatedAt;
  final Value<int> version;
  const LocalStocksTableCompanion({
    this.id = const Value.absent(),
    this.productUuid = const Value.absent(),
    this.warehouseUuid = const Value.absent(),
    this.quantity = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.version = const Value.absent(),
  });
  LocalStocksTableCompanion.insert({
    this.id = const Value.absent(),
    required String productUuid,
    required String warehouseUuid,
    this.quantity = const Value.absent(),
    required DateTime updatedAt,
    this.version = const Value.absent(),
  })  : productUuid = Value(productUuid),
        warehouseUuid = Value(warehouseUuid),
        updatedAt = Value(updatedAt);
  static Insertable<LocalStocksTableData> custom({
    Expression<int>? id,
    Expression<String>? productUuid,
    Expression<String>? warehouseUuid,
    Expression<double>? quantity,
    Expression<DateTime>? updatedAt,
    Expression<int>? version,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (productUuid != null) 'product_uuid': productUuid,
      if (warehouseUuid != null) 'warehouse_uuid': warehouseUuid,
      if (quantity != null) 'quantity': quantity,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (version != null) 'version': version,
    });
  }

  LocalStocksTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? productUuid,
      Value<String>? warehouseUuid,
      Value<double>? quantity,
      Value<DateTime>? updatedAt,
      Value<int>? version}) {
    return LocalStocksTableCompanion(
      id: id ?? this.id,
      productUuid: productUuid ?? this.productUuid,
      warehouseUuid: warehouseUuid ?? this.warehouseUuid,
      quantity: quantity ?? this.quantity,
      updatedAt: updatedAt ?? this.updatedAt,
      version: version ?? this.version,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (productUuid.present) {
      map['product_uuid'] = Variable<String>(productUuid.value);
    }
    if (warehouseUuid.present) {
      map['warehouse_uuid'] = Variable<String>(warehouseUuid.value);
    }
    if (quantity.present) {
      map['quantity'] = Variable<double>(quantity.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (version.present) {
      map['version'] = Variable<int>(version.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('LocalStocksTableCompanion(')
          ..write('id: $id, ')
          ..write('productUuid: $productUuid, ')
          ..write('warehouseUuid: $warehouseUuid, ')
          ..write('quantity: $quantity, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('version: $version')
          ..write(')'))
        .toString();
  }
}

class $SupplierTableTable extends SupplierTable
    with TableInfo<$SupplierTableTable, SupplierTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SupplierTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _emailMeta = const VerificationMeta('email');
  @override
  late final GeneratedColumn<String> email = GeneratedColumn<String>(
      'email', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _phoneMeta = const VerificationMeta('phone');
  @override
  late final GeneratedColumn<String> phone = GeneratedColumn<String>(
      'phone', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _addressMeta =
      const VerificationMeta('address');
  @override
  late final GeneratedColumn<String> address = GeneratedColumn<String>(
      'address', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _leadTimeDaysMeta =
      const VerificationMeta('leadTimeDays');
  @override
  late final GeneratedColumn<int> leadTimeDays = GeneratedColumn<int>(
      'lead_time_days', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultValue: const Constant(0));
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns =>
      [id, uuid, name, email, phone, address, leadTimeDays, updatedAt];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'supplier_table';
  @override
  VerificationContext validateIntegrity(Insertable<SupplierTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('email')) {
      context.handle(
          _emailMeta, email.isAcceptableOrUnknown(data['email']!, _emailMeta));
    }
    if (data.containsKey('phone')) {
      context.handle(
          _phoneMeta, phone.isAcceptableOrUnknown(data['phone']!, _phoneMeta));
    }
    if (data.containsKey('address')) {
      context.handle(_addressMeta,
          address.isAcceptableOrUnknown(data['address']!, _addressMeta));
    }
    if (data.containsKey('lead_time_days')) {
      context.handle(
          _leadTimeDaysMeta,
          leadTimeDays.isAcceptableOrUnknown(
              data['lead_time_days']!, _leadTimeDaysMeta));
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  SupplierTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SupplierTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
      email: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}email']),
      phone: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}phone']),
      address: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}address']),
      leadTimeDays: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}lead_time_days'])!,
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $SupplierTableTable createAlias(String alias) {
    return $SupplierTableTable(attachedDatabase, alias);
  }
}

class SupplierTableData extends DataClass
    implements Insertable<SupplierTableData> {
  final int id;
  final String uuid;
  final String name;
  final String? email;
  final String? phone;
  final String? address;
  final int leadTimeDays;
  final DateTime updatedAt;
  const SupplierTableData(
      {required this.id,
      required this.uuid,
      required this.name,
      this.email,
      this.phone,
      this.address,
      required this.leadTimeDays,
      required this.updatedAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || email != null) {
      map['email'] = Variable<String>(email);
    }
    if (!nullToAbsent || phone != null) {
      map['phone'] = Variable<String>(phone);
    }
    if (!nullToAbsent || address != null) {
      map['address'] = Variable<String>(address);
    }
    map['lead_time_days'] = Variable<int>(leadTimeDays);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  SupplierTableCompanion toCompanion(bool nullToAbsent) {
    return SupplierTableCompanion(
      id: Value(id),
      uuid: Value(uuid),
      name: Value(name),
      email:
          email == null && nullToAbsent ? const Value.absent() : Value(email),
      phone:
          phone == null && nullToAbsent ? const Value.absent() : Value(phone),
      address: address == null && nullToAbsent
          ? const Value.absent()
          : Value(address),
      leadTimeDays: Value(leadTimeDays),
      updatedAt: Value(updatedAt),
    );
  }

  factory SupplierTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SupplierTableData(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      name: serializer.fromJson<String>(json['name']),
      email: serializer.fromJson<String?>(json['email']),
      phone: serializer.fromJson<String?>(json['phone']),
      address: serializer.fromJson<String?>(json['address']),
      leadTimeDays: serializer.fromJson<int>(json['leadTimeDays']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'name': serializer.toJson<String>(name),
      'email': serializer.toJson<String?>(email),
      'phone': serializer.toJson<String?>(phone),
      'address': serializer.toJson<String?>(address),
      'leadTimeDays': serializer.toJson<int>(leadTimeDays),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  SupplierTableData copyWith(
          {int? id,
          String? uuid,
          String? name,
          Value<String?> email = const Value.absent(),
          Value<String?> phone = const Value.absent(),
          Value<String?> address = const Value.absent(),
          int? leadTimeDays,
          DateTime? updatedAt}) =>
      SupplierTableData(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        name: name ?? this.name,
        email: email.present ? email.value : this.email,
        phone: phone.present ? phone.value : this.phone,
        address: address.present ? address.value : this.address,
        leadTimeDays: leadTimeDays ?? this.leadTimeDays,
        updatedAt: updatedAt ?? this.updatedAt,
      );
  SupplierTableData copyWithCompanion(SupplierTableCompanion data) {
    return SupplierTableData(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      name: data.name.present ? data.name.value : this.name,
      email: data.email.present ? data.email.value : this.email,
      phone: data.phone.present ? data.phone.value : this.phone,
      address: data.address.present ? data.address.value : this.address,
      leadTimeDays: data.leadTimeDays.present
          ? data.leadTimeDays.value
          : this.leadTimeDays,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('SupplierTableData(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('email: $email, ')
          ..write('phone: $phone, ')
          ..write('address: $address, ')
          ..write('leadTimeDays: $leadTimeDays, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id, uuid, name, email, phone, address, leadTimeDays, updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SupplierTableData &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.name == this.name &&
          other.email == this.email &&
          other.phone == this.phone &&
          other.address == this.address &&
          other.leadTimeDays == this.leadTimeDays &&
          other.updatedAt == this.updatedAt);
}

class SupplierTableCompanion extends UpdateCompanion<SupplierTableData> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String> name;
  final Value<String?> email;
  final Value<String?> phone;
  final Value<String?> address;
  final Value<int> leadTimeDays;
  final Value<DateTime> updatedAt;
  const SupplierTableCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.name = const Value.absent(),
    this.email = const Value.absent(),
    this.phone = const Value.absent(),
    this.address = const Value.absent(),
    this.leadTimeDays = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  SupplierTableCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    required String name,
    this.email = const Value.absent(),
    this.phone = const Value.absent(),
    this.address = const Value.absent(),
    this.leadTimeDays = const Value.absent(),
    required DateTime updatedAt,
  })  : uuid = Value(uuid),
        name = Value(name),
        updatedAt = Value(updatedAt);
  static Insertable<SupplierTableData> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? name,
    Expression<String>? email,
    Expression<String>? phone,
    Expression<String>? address,
    Expression<int>? leadTimeDays,
    Expression<DateTime>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (name != null) 'name': name,
      if (email != null) 'email': email,
      if (phone != null) 'phone': phone,
      if (address != null) 'address': address,
      if (leadTimeDays != null) 'lead_time_days': leadTimeDays,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  SupplierTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String>? name,
      Value<String?>? email,
      Value<String?>? phone,
      Value<String?>? address,
      Value<int>? leadTimeDays,
      Value<DateTime>? updatedAt}) {
    return SupplierTableCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      name: name ?? this.name,
      email: email ?? this.email,
      phone: phone ?? this.phone,
      address: address ?? this.address,
      leadTimeDays: leadTimeDays ?? this.leadTimeDays,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (email.present) {
      map['email'] = Variable<String>(email.value);
    }
    if (phone.present) {
      map['phone'] = Variable<String>(phone.value);
    }
    if (address.present) {
      map['address'] = Variable<String>(address.value);
    }
    if (leadTimeDays.present) {
      map['lead_time_days'] = Variable<int>(leadTimeDays.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SupplierTableCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('email: $email, ')
          ..write('phone: $phone, ')
          ..write('address: $address, ')
          ..write('leadTimeDays: $leadTimeDays, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class $ProductSupplierTableTable extends ProductSupplierTable
    with TableInfo<$ProductSupplierTableTable, ProductSupplierTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ProductSupplierTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _productUuidMeta =
      const VerificationMeta('productUuid');
  @override
  late final GeneratedColumn<String> productUuid = GeneratedColumn<String>(
      'product_uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES product_table (uuid) ON DELETE CASCADE'));
  static const VerificationMeta _supplierUuidMeta =
      const VerificationMeta('supplierUuid');
  @override
  late final GeneratedColumn<String> supplierUuid = GeneratedColumn<String>(
      'supplier_uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES supplier_table (uuid) ON DELETE CASCADE'));
  static const VerificationMeta _costPriceMeta =
      const VerificationMeta('costPrice');
  @override
  late final GeneratedColumn<double> costPrice = GeneratedColumn<double>(
      'cost_price', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: false,
      defaultValue: const Constant(0));
  static const VerificationMeta _leadTimeDaysMeta =
      const VerificationMeta('leadTimeDays');
  @override
  late final GeneratedColumn<int> leadTimeDays = GeneratedColumn<int>(
      'lead_time_days', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultValue: const Constant(0));
  static const VerificationMeta _minOrderQtyMeta =
      const VerificationMeta('minOrderQty');
  @override
  late final GeneratedColumn<double> minOrderQty = GeneratedColumn<double>(
      'min_order_qty', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: false,
      defaultValue: const Constant(0));
  @override
  List<GeneratedColumn> get $columns =>
      [id, productUuid, supplierUuid, costPrice, leadTimeDays, minOrderQty];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'product_supplier_table';
  @override
  VerificationContext validateIntegrity(
      Insertable<ProductSupplierTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('product_uuid')) {
      context.handle(
          _productUuidMeta,
          productUuid.isAcceptableOrUnknown(
              data['product_uuid']!, _productUuidMeta));
    } else if (isInserting) {
      context.missing(_productUuidMeta);
    }
    if (data.containsKey('supplier_uuid')) {
      context.handle(
          _supplierUuidMeta,
          supplierUuid.isAcceptableOrUnknown(
              data['supplier_uuid']!, _supplierUuidMeta));
    } else if (isInserting) {
      context.missing(_supplierUuidMeta);
    }
    if (data.containsKey('cost_price')) {
      context.handle(_costPriceMeta,
          costPrice.isAcceptableOrUnknown(data['cost_price']!, _costPriceMeta));
    }
    if (data.containsKey('lead_time_days')) {
      context.handle(
          _leadTimeDaysMeta,
          leadTimeDays.isAcceptableOrUnknown(
              data['lead_time_days']!, _leadTimeDaysMeta));
    }
    if (data.containsKey('min_order_qty')) {
      context.handle(
          _minOrderQtyMeta,
          minOrderQty.isAcceptableOrUnknown(
              data['min_order_qty']!, _minOrderQtyMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
        {productUuid, supplierUuid},
      ];
  @override
  ProductSupplierTableData map(Map<String, dynamic> data,
      {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ProductSupplierTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      productUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}product_uuid'])!,
      supplierUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}supplier_uuid'])!,
      costPrice: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}cost_price'])!,
      leadTimeDays: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}lead_time_days'])!,
      minOrderQty: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}min_order_qty'])!,
    );
  }

  @override
  $ProductSupplierTableTable createAlias(String alias) {
    return $ProductSupplierTableTable(attachedDatabase, alias);
  }
}

class ProductSupplierTableData extends DataClass
    implements Insertable<ProductSupplierTableData> {
  final int id;
  final String productUuid;
  final String supplierUuid;
  final double costPrice;
  final int leadTimeDays;
  final double minOrderQty;
  const ProductSupplierTableData(
      {required this.id,
      required this.productUuid,
      required this.supplierUuid,
      required this.costPrice,
      required this.leadTimeDays,
      required this.minOrderQty});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['product_uuid'] = Variable<String>(productUuid);
    map['supplier_uuid'] = Variable<String>(supplierUuid);
    map['cost_price'] = Variable<double>(costPrice);
    map['lead_time_days'] = Variable<int>(leadTimeDays);
    map['min_order_qty'] = Variable<double>(minOrderQty);
    return map;
  }

  ProductSupplierTableCompanion toCompanion(bool nullToAbsent) {
    return ProductSupplierTableCompanion(
      id: Value(id),
      productUuid: Value(productUuid),
      supplierUuid: Value(supplierUuid),
      costPrice: Value(costPrice),
      leadTimeDays: Value(leadTimeDays),
      minOrderQty: Value(minOrderQty),
    );
  }

  factory ProductSupplierTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ProductSupplierTableData(
      id: serializer.fromJson<int>(json['id']),
      productUuid: serializer.fromJson<String>(json['productUuid']),
      supplierUuid: serializer.fromJson<String>(json['supplierUuid']),
      costPrice: serializer.fromJson<double>(json['costPrice']),
      leadTimeDays: serializer.fromJson<int>(json['leadTimeDays']),
      minOrderQty: serializer.fromJson<double>(json['minOrderQty']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'productUuid': serializer.toJson<String>(productUuid),
      'supplierUuid': serializer.toJson<String>(supplierUuid),
      'costPrice': serializer.toJson<double>(costPrice),
      'leadTimeDays': serializer.toJson<int>(leadTimeDays),
      'minOrderQty': serializer.toJson<double>(minOrderQty),
    };
  }

  ProductSupplierTableData copyWith(
          {int? id,
          String? productUuid,
          String? supplierUuid,
          double? costPrice,
          int? leadTimeDays,
          double? minOrderQty}) =>
      ProductSupplierTableData(
        id: id ?? this.id,
        productUuid: productUuid ?? this.productUuid,
        supplierUuid: supplierUuid ?? this.supplierUuid,
        costPrice: costPrice ?? this.costPrice,
        leadTimeDays: leadTimeDays ?? this.leadTimeDays,
        minOrderQty: minOrderQty ?? this.minOrderQty,
      );
  ProductSupplierTableData copyWithCompanion(
      ProductSupplierTableCompanion data) {
    return ProductSupplierTableData(
      id: data.id.present ? data.id.value : this.id,
      productUuid:
          data.productUuid.present ? data.productUuid.value : this.productUuid,
      supplierUuid: data.supplierUuid.present
          ? data.supplierUuid.value
          : this.supplierUuid,
      costPrice: data.costPrice.present ? data.costPrice.value : this.costPrice,
      leadTimeDays: data.leadTimeDays.present
          ? data.leadTimeDays.value
          : this.leadTimeDays,
      minOrderQty:
          data.minOrderQty.present ? data.minOrderQty.value : this.minOrderQty,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ProductSupplierTableData(')
          ..write('id: $id, ')
          ..write('productUuid: $productUuid, ')
          ..write('supplierUuid: $supplierUuid, ')
          ..write('costPrice: $costPrice, ')
          ..write('leadTimeDays: $leadTimeDays, ')
          ..write('minOrderQty: $minOrderQty')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id, productUuid, supplierUuid, costPrice, leadTimeDays, minOrderQty);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ProductSupplierTableData &&
          other.id == this.id &&
          other.productUuid == this.productUuid &&
          other.supplierUuid == this.supplierUuid &&
          other.costPrice == this.costPrice &&
          other.leadTimeDays == this.leadTimeDays &&
          other.minOrderQty == this.minOrderQty);
}

class ProductSupplierTableCompanion
    extends UpdateCompanion<ProductSupplierTableData> {
  final Value<int> id;
  final Value<String> productUuid;
  final Value<String> supplierUuid;
  final Value<double> costPrice;
  final Value<int> leadTimeDays;
  final Value<double> minOrderQty;
  const ProductSupplierTableCompanion({
    this.id = const Value.absent(),
    this.productUuid = const Value.absent(),
    this.supplierUuid = const Value.absent(),
    this.costPrice = const Value.absent(),
    this.leadTimeDays = const Value.absent(),
    this.minOrderQty = const Value.absent(),
  });
  ProductSupplierTableCompanion.insert({
    this.id = const Value.absent(),
    required String productUuid,
    required String supplierUuid,
    this.costPrice = const Value.absent(),
    this.leadTimeDays = const Value.absent(),
    this.minOrderQty = const Value.absent(),
  })  : productUuid = Value(productUuid),
        supplierUuid = Value(supplierUuid);
  static Insertable<ProductSupplierTableData> custom({
    Expression<int>? id,
    Expression<String>? productUuid,
    Expression<String>? supplierUuid,
    Expression<double>? costPrice,
    Expression<int>? leadTimeDays,
    Expression<double>? minOrderQty,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (productUuid != null) 'product_uuid': productUuid,
      if (supplierUuid != null) 'supplier_uuid': supplierUuid,
      if (costPrice != null) 'cost_price': costPrice,
      if (leadTimeDays != null) 'lead_time_days': leadTimeDays,
      if (minOrderQty != null) 'min_order_qty': minOrderQty,
    });
  }

  ProductSupplierTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? productUuid,
      Value<String>? supplierUuid,
      Value<double>? costPrice,
      Value<int>? leadTimeDays,
      Value<double>? minOrderQty}) {
    return ProductSupplierTableCompanion(
      id: id ?? this.id,
      productUuid: productUuid ?? this.productUuid,
      supplierUuid: supplierUuid ?? this.supplierUuid,
      costPrice: costPrice ?? this.costPrice,
      leadTimeDays: leadTimeDays ?? this.leadTimeDays,
      minOrderQty: minOrderQty ?? this.minOrderQty,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (productUuid.present) {
      map['product_uuid'] = Variable<String>(productUuid.value);
    }
    if (supplierUuid.present) {
      map['supplier_uuid'] = Variable<String>(supplierUuid.value);
    }
    if (costPrice.present) {
      map['cost_price'] = Variable<double>(costPrice.value);
    }
    if (leadTimeDays.present) {
      map['lead_time_days'] = Variable<int>(leadTimeDays.value);
    }
    if (minOrderQty.present) {
      map['min_order_qty'] = Variable<double>(minOrderQty.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ProductSupplierTableCompanion(')
          ..write('id: $id, ')
          ..write('productUuid: $productUuid, ')
          ..write('supplierUuid: $supplierUuid, ')
          ..write('costPrice: $costPrice, ')
          ..write('leadTimeDays: $leadTimeDays, ')
          ..write('minOrderQty: $minOrderQty')
          ..write(')'))
        .toString();
  }
}

class $PurchaseOrderTableTable extends PurchaseOrderTable
    with TableInfo<$PurchaseOrderTableTable, PurchaseOrderTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $PurchaseOrderTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _supplierUuidMeta =
      const VerificationMeta('supplierUuid');
  @override
  late final GeneratedColumn<String> supplierUuid = GeneratedColumn<String>(
      'supplier_uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES supplier_table (uuid) ON DELETE CASCADE'));
  static const VerificationMeta _targetWarehouseUuidMeta =
      const VerificationMeta('targetWarehouseUuid');
  @override
  late final GeneratedColumn<String> targetWarehouseUuid =
      GeneratedColumn<String>('target_warehouse_uuid', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
      'status', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultValue: const Constant('PENDING'));
  static const VerificationMeta _referenceNumberMeta =
      const VerificationMeta('referenceNumber');
  @override
  late final GeneratedColumn<String> referenceNumber = GeneratedColumn<String>(
      'reference_number', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
      'notes', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _totalCostMeta =
      const VerificationMeta('totalCost');
  @override
  late final GeneratedColumn<double> totalCost = GeneratedColumn<double>(
      'total_cost', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: false,
      defaultValue: const Constant(0));
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _isSyncedMeta =
      const VerificationMeta('isSynced');
  @override
  late final GeneratedColumn<bool> isSynced = GeneratedColumn<bool>(
      'is_synced', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_synced" IN (0, 1))'),
      defaultValue: const Constant(false));
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        supplierUuid,
        targetWarehouseUuid,
        status,
        referenceNumber,
        notes,
        totalCost,
        createdAt,
        updatedAt,
        isSynced
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'purchase_order_table';
  @override
  VerificationContext validateIntegrity(
      Insertable<PurchaseOrderTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('supplier_uuid')) {
      context.handle(
          _supplierUuidMeta,
          supplierUuid.isAcceptableOrUnknown(
              data['supplier_uuid']!, _supplierUuidMeta));
    } else if (isInserting) {
      context.missing(_supplierUuidMeta);
    }
    if (data.containsKey('target_warehouse_uuid')) {
      context.handle(
          _targetWarehouseUuidMeta,
          targetWarehouseUuid.isAcceptableOrUnknown(
              data['target_warehouse_uuid']!, _targetWarehouseUuidMeta));
    } else if (isInserting) {
      context.missing(_targetWarehouseUuidMeta);
    }
    if (data.containsKey('status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['status']!, _statusMeta));
    }
    if (data.containsKey('reference_number')) {
      context.handle(
          _referenceNumberMeta,
          referenceNumber.isAcceptableOrUnknown(
              data['reference_number']!, _referenceNumberMeta));
    }
    if (data.containsKey('notes')) {
      context.handle(
          _notesMeta, notes.isAcceptableOrUnknown(data['notes']!, _notesMeta));
    }
    if (data.containsKey('total_cost')) {
      context.handle(_totalCostMeta,
          totalCost.isAcceptableOrUnknown(data['total_cost']!, _totalCostMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    if (data.containsKey('is_synced')) {
      context.handle(_isSyncedMeta,
          isSynced.isAcceptableOrUnknown(data['is_synced']!, _isSyncedMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  PurchaseOrderTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return PurchaseOrderTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      supplierUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}supplier_uuid'])!,
      targetWarehouseUuid: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}target_warehouse_uuid'])!,
      status: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}status'])!,
      referenceNumber: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}reference_number']),
      notes: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}notes']),
      totalCost: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}total_cost'])!,
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
      isSynced: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_synced'])!,
    );
  }

  @override
  $PurchaseOrderTableTable createAlias(String alias) {
    return $PurchaseOrderTableTable(attachedDatabase, alias);
  }
}

class PurchaseOrderTableData extends DataClass
    implements Insertable<PurchaseOrderTableData> {
  final int id;
  final String uuid;
  final String supplierUuid;
  final String targetWarehouseUuid;
  final String status;
  final String? referenceNumber;
  final String? notes;
  final double totalCost;
  final DateTime createdAt;
  final DateTime updatedAt;
  final bool isSynced;
  const PurchaseOrderTableData(
      {required this.id,
      required this.uuid,
      required this.supplierUuid,
      required this.targetWarehouseUuid,
      required this.status,
      this.referenceNumber,
      this.notes,
      required this.totalCost,
      required this.createdAt,
      required this.updatedAt,
      required this.isSynced});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    map['supplier_uuid'] = Variable<String>(supplierUuid);
    map['target_warehouse_uuid'] = Variable<String>(targetWarehouseUuid);
    map['status'] = Variable<String>(status);
    if (!nullToAbsent || referenceNumber != null) {
      map['reference_number'] = Variable<String>(referenceNumber);
    }
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    map['total_cost'] = Variable<double>(totalCost);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    map['is_synced'] = Variable<bool>(isSynced);
    return map;
  }

  PurchaseOrderTableCompanion toCompanion(bool nullToAbsent) {
    return PurchaseOrderTableCompanion(
      id: Value(id),
      uuid: Value(uuid),
      supplierUuid: Value(supplierUuid),
      targetWarehouseUuid: Value(targetWarehouseUuid),
      status: Value(status),
      referenceNumber: referenceNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(referenceNumber),
      notes:
          notes == null && nullToAbsent ? const Value.absent() : Value(notes),
      totalCost: Value(totalCost),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
      isSynced: Value(isSynced),
    );
  }

  factory PurchaseOrderTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return PurchaseOrderTableData(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      supplierUuid: serializer.fromJson<String>(json['supplierUuid']),
      targetWarehouseUuid:
          serializer.fromJson<String>(json['targetWarehouseUuid']),
      status: serializer.fromJson<String>(json['status']),
      referenceNumber: serializer.fromJson<String?>(json['referenceNumber']),
      notes: serializer.fromJson<String?>(json['notes']),
      totalCost: serializer.fromJson<double>(json['totalCost']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
      isSynced: serializer.fromJson<bool>(json['isSynced']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'supplierUuid': serializer.toJson<String>(supplierUuid),
      'targetWarehouseUuid': serializer.toJson<String>(targetWarehouseUuid),
      'status': serializer.toJson<String>(status),
      'referenceNumber': serializer.toJson<String?>(referenceNumber),
      'notes': serializer.toJson<String?>(notes),
      'totalCost': serializer.toJson<double>(totalCost),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
      'isSynced': serializer.toJson<bool>(isSynced),
    };
  }

  PurchaseOrderTableData copyWith(
          {int? id,
          String? uuid,
          String? supplierUuid,
          String? targetWarehouseUuid,
          String? status,
          Value<String?> referenceNumber = const Value.absent(),
          Value<String?> notes = const Value.absent(),
          double? totalCost,
          DateTime? createdAt,
          DateTime? updatedAt,
          bool? isSynced}) =>
      PurchaseOrderTableData(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        supplierUuid: supplierUuid ?? this.supplierUuid,
        targetWarehouseUuid: targetWarehouseUuid ?? this.targetWarehouseUuid,
        status: status ?? this.status,
        referenceNumber: referenceNumber.present
            ? referenceNumber.value
            : this.referenceNumber,
        notes: notes.present ? notes.value : this.notes,
        totalCost: totalCost ?? this.totalCost,
        createdAt: createdAt ?? this.createdAt,
        updatedAt: updatedAt ?? this.updatedAt,
        isSynced: isSynced ?? this.isSynced,
      );
  PurchaseOrderTableData copyWithCompanion(PurchaseOrderTableCompanion data) {
    return PurchaseOrderTableData(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      supplierUuid: data.supplierUuid.present
          ? data.supplierUuid.value
          : this.supplierUuid,
      targetWarehouseUuid: data.targetWarehouseUuid.present
          ? data.targetWarehouseUuid.value
          : this.targetWarehouseUuid,
      status: data.status.present ? data.status.value : this.status,
      referenceNumber: data.referenceNumber.present
          ? data.referenceNumber.value
          : this.referenceNumber,
      notes: data.notes.present ? data.notes.value : this.notes,
      totalCost: data.totalCost.present ? data.totalCost.value : this.totalCost,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      isSynced: data.isSynced.present ? data.isSynced.value : this.isSynced,
    );
  }

  @override
  String toString() {
    return (StringBuffer('PurchaseOrderTableData(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('supplierUuid: $supplierUuid, ')
          ..write('targetWarehouseUuid: $targetWarehouseUuid, ')
          ..write('status: $status, ')
          ..write('referenceNumber: $referenceNumber, ')
          ..write('notes: $notes, ')
          ..write('totalCost: $totalCost, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('isSynced: $isSynced')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      uuid,
      supplierUuid,
      targetWarehouseUuid,
      status,
      referenceNumber,
      notes,
      totalCost,
      createdAt,
      updatedAt,
      isSynced);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is PurchaseOrderTableData &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.supplierUuid == this.supplierUuid &&
          other.targetWarehouseUuid == this.targetWarehouseUuid &&
          other.status == this.status &&
          other.referenceNumber == this.referenceNumber &&
          other.notes == this.notes &&
          other.totalCost == this.totalCost &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt &&
          other.isSynced == this.isSynced);
}

class PurchaseOrderTableCompanion
    extends UpdateCompanion<PurchaseOrderTableData> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String> supplierUuid;
  final Value<String> targetWarehouseUuid;
  final Value<String> status;
  final Value<String?> referenceNumber;
  final Value<String?> notes;
  final Value<double> totalCost;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<bool> isSynced;
  const PurchaseOrderTableCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.supplierUuid = const Value.absent(),
    this.targetWarehouseUuid = const Value.absent(),
    this.status = const Value.absent(),
    this.referenceNumber = const Value.absent(),
    this.notes = const Value.absent(),
    this.totalCost = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.isSynced = const Value.absent(),
  });
  PurchaseOrderTableCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    required String supplierUuid,
    required String targetWarehouseUuid,
    this.status = const Value.absent(),
    this.referenceNumber = const Value.absent(),
    this.notes = const Value.absent(),
    this.totalCost = const Value.absent(),
    required DateTime createdAt,
    required DateTime updatedAt,
    this.isSynced = const Value.absent(),
  })  : uuid = Value(uuid),
        supplierUuid = Value(supplierUuid),
        targetWarehouseUuid = Value(targetWarehouseUuid),
        createdAt = Value(createdAt),
        updatedAt = Value(updatedAt);
  static Insertable<PurchaseOrderTableData> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? supplierUuid,
    Expression<String>? targetWarehouseUuid,
    Expression<String>? status,
    Expression<String>? referenceNumber,
    Expression<String>? notes,
    Expression<double>? totalCost,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<bool>? isSynced,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (supplierUuid != null) 'supplier_uuid': supplierUuid,
      if (targetWarehouseUuid != null)
        'target_warehouse_uuid': targetWarehouseUuid,
      if (status != null) 'status': status,
      if (referenceNumber != null) 'reference_number': referenceNumber,
      if (notes != null) 'notes': notes,
      if (totalCost != null) 'total_cost': totalCost,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (isSynced != null) 'is_synced': isSynced,
    });
  }

  PurchaseOrderTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String>? supplierUuid,
      Value<String>? targetWarehouseUuid,
      Value<String>? status,
      Value<String?>? referenceNumber,
      Value<String?>? notes,
      Value<double>? totalCost,
      Value<DateTime>? createdAt,
      Value<DateTime>? updatedAt,
      Value<bool>? isSynced}) {
    return PurchaseOrderTableCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      supplierUuid: supplierUuid ?? this.supplierUuid,
      targetWarehouseUuid: targetWarehouseUuid ?? this.targetWarehouseUuid,
      status: status ?? this.status,
      referenceNumber: referenceNumber ?? this.referenceNumber,
      notes: notes ?? this.notes,
      totalCost: totalCost ?? this.totalCost,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      isSynced: isSynced ?? this.isSynced,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (supplierUuid.present) {
      map['supplier_uuid'] = Variable<String>(supplierUuid.value);
    }
    if (targetWarehouseUuid.present) {
      map['target_warehouse_uuid'] =
          Variable<String>(targetWarehouseUuid.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (referenceNumber.present) {
      map['reference_number'] = Variable<String>(referenceNumber.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (totalCost.present) {
      map['total_cost'] = Variable<double>(totalCost.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (isSynced.present) {
      map['is_synced'] = Variable<bool>(isSynced.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('PurchaseOrderTableCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('supplierUuid: $supplierUuid, ')
          ..write('targetWarehouseUuid: $targetWarehouseUuid, ')
          ..write('status: $status, ')
          ..write('referenceNumber: $referenceNumber, ')
          ..write('notes: $notes, ')
          ..write('totalCost: $totalCost, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('isSynced: $isSynced')
          ..write(')'))
        .toString();
  }
}

class $PurchaseOrderItemTableTable extends PurchaseOrderItemTable
    with TableInfo<$PurchaseOrderItemTableTable, PurchaseOrderItemTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $PurchaseOrderItemTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _poUuidMeta = const VerificationMeta('poUuid');
  @override
  late final GeneratedColumn<String> poUuid = GeneratedColumn<String>(
      'po_uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES purchase_order_table (uuid) ON DELETE CASCADE'));
  static const VerificationMeta _productUuidMeta =
      const VerificationMeta('productUuid');
  @override
  late final GeneratedColumn<String> productUuid = GeneratedColumn<String>(
      'product_uuid', aliasedName, true,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES product_table (uuid) ON DELETE CASCADE'));
  static const VerificationMeta _ingredientUuidMeta =
      const VerificationMeta('ingredientUuid');
  @override
  late final GeneratedColumn<String> ingredientUuid = GeneratedColumn<String>(
      'ingredient_uuid', aliasedName, true,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES ingredient_table (uuid) ON DELETE CASCADE'));
  static const VerificationMeta _quantityOrderedMeta =
      const VerificationMeta('quantityOrdered');
  @override
  late final GeneratedColumn<double> quantityOrdered = GeneratedColumn<double>(
      'quantity_ordered', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _quantityReceivedMeta =
      const VerificationMeta('quantityReceived');
  @override
  late final GeneratedColumn<double> quantityReceived = GeneratedColumn<double>(
      'quantity_received', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: false,
      defaultValue: const Constant(0));
  static const VerificationMeta _unitCostMeta =
      const VerificationMeta('unitCost');
  @override
  late final GeneratedColumn<double> unitCost = GeneratedColumn<double>(
      'unit_cost', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        poUuid,
        productUuid,
        ingredientUuid,
        quantityOrdered,
        quantityReceived,
        unitCost
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'purchase_order_item_table';
  @override
  VerificationContext validateIntegrity(
      Insertable<PurchaseOrderItemTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('po_uuid')) {
      context.handle(_poUuidMeta,
          poUuid.isAcceptableOrUnknown(data['po_uuid']!, _poUuidMeta));
    } else if (isInserting) {
      context.missing(_poUuidMeta);
    }
    if (data.containsKey('product_uuid')) {
      context.handle(
          _productUuidMeta,
          productUuid.isAcceptableOrUnknown(
              data['product_uuid']!, _productUuidMeta));
    }
    if (data.containsKey('ingredient_uuid')) {
      context.handle(
          _ingredientUuidMeta,
          ingredientUuid.isAcceptableOrUnknown(
              data['ingredient_uuid']!, _ingredientUuidMeta));
    }
    if (data.containsKey('quantity_ordered')) {
      context.handle(
          _quantityOrderedMeta,
          quantityOrdered.isAcceptableOrUnknown(
              data['quantity_ordered']!, _quantityOrderedMeta));
    } else if (isInserting) {
      context.missing(_quantityOrderedMeta);
    }
    if (data.containsKey('quantity_received')) {
      context.handle(
          _quantityReceivedMeta,
          quantityReceived.isAcceptableOrUnknown(
              data['quantity_received']!, _quantityReceivedMeta));
    }
    if (data.containsKey('unit_cost')) {
      context.handle(_unitCostMeta,
          unitCost.isAcceptableOrUnknown(data['unit_cost']!, _unitCostMeta));
    } else if (isInserting) {
      context.missing(_unitCostMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  PurchaseOrderItemTableData map(Map<String, dynamic> data,
      {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return PurchaseOrderItemTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      poUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}po_uuid'])!,
      productUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}product_uuid']),
      ingredientUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}ingredient_uuid']),
      quantityOrdered: attachedDatabase.typeMapping.read(
          DriftSqlType.double, data['${effectivePrefix}quantity_ordered'])!,
      quantityReceived: attachedDatabase.typeMapping.read(
          DriftSqlType.double, data['${effectivePrefix}quantity_received'])!,
      unitCost: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}unit_cost'])!,
    );
  }

  @override
  $PurchaseOrderItemTableTable createAlias(String alias) {
    return $PurchaseOrderItemTableTable(attachedDatabase, alias);
  }
}

class PurchaseOrderItemTableData extends DataClass
    implements Insertable<PurchaseOrderItemTableData> {
  final int id;
  final String poUuid;
  final String? productUuid;
  final String? ingredientUuid;
  final double quantityOrdered;
  final double quantityReceived;
  final double unitCost;
  const PurchaseOrderItemTableData(
      {required this.id,
      required this.poUuid,
      this.productUuid,
      this.ingredientUuid,
      required this.quantityOrdered,
      required this.quantityReceived,
      required this.unitCost});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['po_uuid'] = Variable<String>(poUuid);
    if (!nullToAbsent || productUuid != null) {
      map['product_uuid'] = Variable<String>(productUuid);
    }
    if (!nullToAbsent || ingredientUuid != null) {
      map['ingredient_uuid'] = Variable<String>(ingredientUuid);
    }
    map['quantity_ordered'] = Variable<double>(quantityOrdered);
    map['quantity_received'] = Variable<double>(quantityReceived);
    map['unit_cost'] = Variable<double>(unitCost);
    return map;
  }

  PurchaseOrderItemTableCompanion toCompanion(bool nullToAbsent) {
    return PurchaseOrderItemTableCompanion(
      id: Value(id),
      poUuid: Value(poUuid),
      productUuid: productUuid == null && nullToAbsent
          ? const Value.absent()
          : Value(productUuid),
      ingredientUuid: ingredientUuid == null && nullToAbsent
          ? const Value.absent()
          : Value(ingredientUuid),
      quantityOrdered: Value(quantityOrdered),
      quantityReceived: Value(quantityReceived),
      unitCost: Value(unitCost),
    );
  }

  factory PurchaseOrderItemTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return PurchaseOrderItemTableData(
      id: serializer.fromJson<int>(json['id']),
      poUuid: serializer.fromJson<String>(json['poUuid']),
      productUuid: serializer.fromJson<String?>(json['productUuid']),
      ingredientUuid: serializer.fromJson<String?>(json['ingredientUuid']),
      quantityOrdered: serializer.fromJson<double>(json['quantityOrdered']),
      quantityReceived: serializer.fromJson<double>(json['quantityReceived']),
      unitCost: serializer.fromJson<double>(json['unitCost']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'poUuid': serializer.toJson<String>(poUuid),
      'productUuid': serializer.toJson<String?>(productUuid),
      'ingredientUuid': serializer.toJson<String?>(ingredientUuid),
      'quantityOrdered': serializer.toJson<double>(quantityOrdered),
      'quantityReceived': serializer.toJson<double>(quantityReceived),
      'unitCost': serializer.toJson<double>(unitCost),
    };
  }

  PurchaseOrderItemTableData copyWith(
          {int? id,
          String? poUuid,
          Value<String?> productUuid = const Value.absent(),
          Value<String?> ingredientUuid = const Value.absent(),
          double? quantityOrdered,
          double? quantityReceived,
          double? unitCost}) =>
      PurchaseOrderItemTableData(
        id: id ?? this.id,
        poUuid: poUuid ?? this.poUuid,
        productUuid: productUuid.present ? productUuid.value : this.productUuid,
        ingredientUuid:
            ingredientUuid.present ? ingredientUuid.value : this.ingredientUuid,
        quantityOrdered: quantityOrdered ?? this.quantityOrdered,
        quantityReceived: quantityReceived ?? this.quantityReceived,
        unitCost: unitCost ?? this.unitCost,
      );
  PurchaseOrderItemTableData copyWithCompanion(
      PurchaseOrderItemTableCompanion data) {
    return PurchaseOrderItemTableData(
      id: data.id.present ? data.id.value : this.id,
      poUuid: data.poUuid.present ? data.poUuid.value : this.poUuid,
      productUuid:
          data.productUuid.present ? data.productUuid.value : this.productUuid,
      ingredientUuid: data.ingredientUuid.present
          ? data.ingredientUuid.value
          : this.ingredientUuid,
      quantityOrdered: data.quantityOrdered.present
          ? data.quantityOrdered.value
          : this.quantityOrdered,
      quantityReceived: data.quantityReceived.present
          ? data.quantityReceived.value
          : this.quantityReceived,
      unitCost: data.unitCost.present ? data.unitCost.value : this.unitCost,
    );
  }

  @override
  String toString() {
    return (StringBuffer('PurchaseOrderItemTableData(')
          ..write('id: $id, ')
          ..write('poUuid: $poUuid, ')
          ..write('productUuid: $productUuid, ')
          ..write('ingredientUuid: $ingredientUuid, ')
          ..write('quantityOrdered: $quantityOrdered, ')
          ..write('quantityReceived: $quantityReceived, ')
          ..write('unitCost: $unitCost')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, poUuid, productUuid, ingredientUuid,
      quantityOrdered, quantityReceived, unitCost);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is PurchaseOrderItemTableData &&
          other.id == this.id &&
          other.poUuid == this.poUuid &&
          other.productUuid == this.productUuid &&
          other.ingredientUuid == this.ingredientUuid &&
          other.quantityOrdered == this.quantityOrdered &&
          other.quantityReceived == this.quantityReceived &&
          other.unitCost == this.unitCost);
}

class PurchaseOrderItemTableCompanion
    extends UpdateCompanion<PurchaseOrderItemTableData> {
  final Value<int> id;
  final Value<String> poUuid;
  final Value<String?> productUuid;
  final Value<String?> ingredientUuid;
  final Value<double> quantityOrdered;
  final Value<double> quantityReceived;
  final Value<double> unitCost;
  const PurchaseOrderItemTableCompanion({
    this.id = const Value.absent(),
    this.poUuid = const Value.absent(),
    this.productUuid = const Value.absent(),
    this.ingredientUuid = const Value.absent(),
    this.quantityOrdered = const Value.absent(),
    this.quantityReceived = const Value.absent(),
    this.unitCost = const Value.absent(),
  });
  PurchaseOrderItemTableCompanion.insert({
    this.id = const Value.absent(),
    required String poUuid,
    this.productUuid = const Value.absent(),
    this.ingredientUuid = const Value.absent(),
    required double quantityOrdered,
    this.quantityReceived = const Value.absent(),
    required double unitCost,
  })  : poUuid = Value(poUuid),
        quantityOrdered = Value(quantityOrdered),
        unitCost = Value(unitCost);
  static Insertable<PurchaseOrderItemTableData> custom({
    Expression<int>? id,
    Expression<String>? poUuid,
    Expression<String>? productUuid,
    Expression<String>? ingredientUuid,
    Expression<double>? quantityOrdered,
    Expression<double>? quantityReceived,
    Expression<double>? unitCost,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (poUuid != null) 'po_uuid': poUuid,
      if (productUuid != null) 'product_uuid': productUuid,
      if (ingredientUuid != null) 'ingredient_uuid': ingredientUuid,
      if (quantityOrdered != null) 'quantity_ordered': quantityOrdered,
      if (quantityReceived != null) 'quantity_received': quantityReceived,
      if (unitCost != null) 'unit_cost': unitCost,
    });
  }

  PurchaseOrderItemTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? poUuid,
      Value<String?>? productUuid,
      Value<String?>? ingredientUuid,
      Value<double>? quantityOrdered,
      Value<double>? quantityReceived,
      Value<double>? unitCost}) {
    return PurchaseOrderItemTableCompanion(
      id: id ?? this.id,
      poUuid: poUuid ?? this.poUuid,
      productUuid: productUuid ?? this.productUuid,
      ingredientUuid: ingredientUuid ?? this.ingredientUuid,
      quantityOrdered: quantityOrdered ?? this.quantityOrdered,
      quantityReceived: quantityReceived ?? this.quantityReceived,
      unitCost: unitCost ?? this.unitCost,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (poUuid.present) {
      map['po_uuid'] = Variable<String>(poUuid.value);
    }
    if (productUuid.present) {
      map['product_uuid'] = Variable<String>(productUuid.value);
    }
    if (ingredientUuid.present) {
      map['ingredient_uuid'] = Variable<String>(ingredientUuid.value);
    }
    if (quantityOrdered.present) {
      map['quantity_ordered'] = Variable<double>(quantityOrdered.value);
    }
    if (quantityReceived.present) {
      map['quantity_received'] = Variable<double>(quantityReceived.value);
    }
    if (unitCost.present) {
      map['unit_cost'] = Variable<double>(unitCost.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('PurchaseOrderItemTableCompanion(')
          ..write('id: $id, ')
          ..write('poUuid: $poUuid, ')
          ..write('productUuid: $productUuid, ')
          ..write('ingredientUuid: $ingredientUuid, ')
          ..write('quantityOrdered: $quantityOrdered, ')
          ..write('quantityReceived: $quantityReceived, ')
          ..write('unitCost: $unitCost')
          ..write(')'))
        .toString();
  }
}

class $ShiftSessionTableTable extends ShiftSessionTable
    with TableInfo<$ShiftSessionTableTable, ShiftSessionTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ShiftSessionTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _staffIdMeta =
      const VerificationMeta('staffId');
  @override
  late final GeneratedColumn<String> staffId = GeneratedColumn<String>(
      'staff_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _staffNameMeta =
      const VerificationMeta('staffName');
  @override
  late final GeneratedColumn<String> staffName = GeneratedColumn<String>(
      'staff_name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _outletIdMeta =
      const VerificationMeta('outletId');
  @override
  late final GeneratedColumn<String> outletId = GeneratedColumn<String>(
      'outlet_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _startShiftMeta =
      const VerificationMeta('startShift');
  @override
  late final GeneratedColumn<DateTime> startShift = GeneratedColumn<DateTime>(
      'start_shift', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _endShiftMeta =
      const VerificationMeta('endShift');
  @override
  late final GeneratedColumn<DateTime> endShift = GeneratedColumn<DateTime>(
      'end_shift', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _startCashMeta =
      const VerificationMeta('startCash');
  @override
  late final GeneratedColumn<double> startCash = GeneratedColumn<double>(
      'start_cash', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _expectedCashMeta =
      const VerificationMeta('expectedCash');
  @override
  late final GeneratedColumn<double> expectedCash = GeneratedColumn<double>(
      'expected_cash', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _actualCashMeta =
      const VerificationMeta('actualCash');
  @override
  late final GeneratedColumn<double> actualCash = GeneratedColumn<double>(
      'actual_cash', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _differenceMeta =
      const VerificationMeta('difference');
  @override
  late final GeneratedColumn<double> difference = GeneratedColumn<double>(
      'difference', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _varianceReasonMeta =
      const VerificationMeta('varianceReason');
  @override
  late final GeneratedColumn<String> varianceReason = GeneratedColumn<String>(
      'variance_reason', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isClosedMeta =
      const VerificationMeta('isClosed');
  @override
  late final GeneratedColumn<bool> isClosed = GeneratedColumn<bool>(
      'is_closed', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_closed" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _isSyncedMeta =
      const VerificationMeta('isSynced');
  @override
  late final GeneratedColumn<bool> isSynced = GeneratedColumn<bool>(
      'is_synced', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_synced" IN (0, 1))'),
      defaultValue: const Constant(false));
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        staffId,
        staffName,
        outletId,
        startShift,
        endShift,
        startCash,
        expectedCash,
        actualCash,
        difference,
        varianceReason,
        isClosed,
        isSynced
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'shift_session_table';
  @override
  VerificationContext validateIntegrity(
      Insertable<ShiftSessionTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('staff_id')) {
      context.handle(_staffIdMeta,
          staffId.isAcceptableOrUnknown(data['staff_id']!, _staffIdMeta));
    } else if (isInserting) {
      context.missing(_staffIdMeta);
    }
    if (data.containsKey('staff_name')) {
      context.handle(_staffNameMeta,
          staffName.isAcceptableOrUnknown(data['staff_name']!, _staffNameMeta));
    } else if (isInserting) {
      context.missing(_staffNameMeta);
    }
    if (data.containsKey('outlet_id')) {
      context.handle(_outletIdMeta,
          outletId.isAcceptableOrUnknown(data['outlet_id']!, _outletIdMeta));
    }
    if (data.containsKey('start_shift')) {
      context.handle(
          _startShiftMeta,
          startShift.isAcceptableOrUnknown(
              data['start_shift']!, _startShiftMeta));
    } else if (isInserting) {
      context.missing(_startShiftMeta);
    }
    if (data.containsKey('end_shift')) {
      context.handle(_endShiftMeta,
          endShift.isAcceptableOrUnknown(data['end_shift']!, _endShiftMeta));
    }
    if (data.containsKey('start_cash')) {
      context.handle(_startCashMeta,
          startCash.isAcceptableOrUnknown(data['start_cash']!, _startCashMeta));
    } else if (isInserting) {
      context.missing(_startCashMeta);
    }
    if (data.containsKey('expected_cash')) {
      context.handle(
          _expectedCashMeta,
          expectedCash.isAcceptableOrUnknown(
              data['expected_cash']!, _expectedCashMeta));
    } else if (isInserting) {
      context.missing(_expectedCashMeta);
    }
    if (data.containsKey('actual_cash')) {
      context.handle(
          _actualCashMeta,
          actualCash.isAcceptableOrUnknown(
              data['actual_cash']!, _actualCashMeta));
    } else if (isInserting) {
      context.missing(_actualCashMeta);
    }
    if (data.containsKey('difference')) {
      context.handle(
          _differenceMeta,
          difference.isAcceptableOrUnknown(
              data['difference']!, _differenceMeta));
    } else if (isInserting) {
      context.missing(_differenceMeta);
    }
    if (data.containsKey('variance_reason')) {
      context.handle(
          _varianceReasonMeta,
          varianceReason.isAcceptableOrUnknown(
              data['variance_reason']!, _varianceReasonMeta));
    }
    if (data.containsKey('is_closed')) {
      context.handle(_isClosedMeta,
          isClosed.isAcceptableOrUnknown(data['is_closed']!, _isClosedMeta));
    }
    if (data.containsKey('is_synced')) {
      context.handle(_isSyncedMeta,
          isSynced.isAcceptableOrUnknown(data['is_synced']!, _isSyncedMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  ShiftSessionTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ShiftSessionTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      staffId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}staff_id'])!,
      staffName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}staff_name'])!,
      outletId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}outlet_id']),
      startShift: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}start_shift'])!,
      endShift: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}end_shift']),
      startCash: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}start_cash'])!,
      expectedCash: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}expected_cash'])!,
      actualCash: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}actual_cash'])!,
      difference: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}difference'])!,
      varianceReason: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}variance_reason']),
      isClosed: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_closed'])!,
      isSynced: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_synced'])!,
    );
  }

  @override
  $ShiftSessionTableTable createAlias(String alias) {
    return $ShiftSessionTableTable(attachedDatabase, alias);
  }
}

class ShiftSessionTableData extends DataClass
    implements Insertable<ShiftSessionTableData> {
  final int id;
  final String uuid;
  final String staffId;
  final String staffName;
  final String? outletId;
  final DateTime startShift;
  final DateTime? endShift;
  final double startCash;
  final double expectedCash;
  final double actualCash;
  final double difference;
  final String? varianceReason;
  final bool isClosed;
  final bool isSynced;
  const ShiftSessionTableData(
      {required this.id,
      required this.uuid,
      required this.staffId,
      required this.staffName,
      this.outletId,
      required this.startShift,
      this.endShift,
      required this.startCash,
      required this.expectedCash,
      required this.actualCash,
      required this.difference,
      this.varianceReason,
      required this.isClosed,
      required this.isSynced});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    map['staff_id'] = Variable<String>(staffId);
    map['staff_name'] = Variable<String>(staffName);
    if (!nullToAbsent || outletId != null) {
      map['outlet_id'] = Variable<String>(outletId);
    }
    map['start_shift'] = Variable<DateTime>(startShift);
    if (!nullToAbsent || endShift != null) {
      map['end_shift'] = Variable<DateTime>(endShift);
    }
    map['start_cash'] = Variable<double>(startCash);
    map['expected_cash'] = Variable<double>(expectedCash);
    map['actual_cash'] = Variable<double>(actualCash);
    map['difference'] = Variable<double>(difference);
    if (!nullToAbsent || varianceReason != null) {
      map['variance_reason'] = Variable<String>(varianceReason);
    }
    map['is_closed'] = Variable<bool>(isClosed);
    map['is_synced'] = Variable<bool>(isSynced);
    return map;
  }

  ShiftSessionTableCompanion toCompanion(bool nullToAbsent) {
    return ShiftSessionTableCompanion(
      id: Value(id),
      uuid: Value(uuid),
      staffId: Value(staffId),
      staffName: Value(staffName),
      outletId: outletId == null && nullToAbsent
          ? const Value.absent()
          : Value(outletId),
      startShift: Value(startShift),
      endShift: endShift == null && nullToAbsent
          ? const Value.absent()
          : Value(endShift),
      startCash: Value(startCash),
      expectedCash: Value(expectedCash),
      actualCash: Value(actualCash),
      difference: Value(difference),
      varianceReason: varianceReason == null && nullToAbsent
          ? const Value.absent()
          : Value(varianceReason),
      isClosed: Value(isClosed),
      isSynced: Value(isSynced),
    );
  }

  factory ShiftSessionTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ShiftSessionTableData(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      staffId: serializer.fromJson<String>(json['staffId']),
      staffName: serializer.fromJson<String>(json['staffName']),
      outletId: serializer.fromJson<String?>(json['outletId']),
      startShift: serializer.fromJson<DateTime>(json['startShift']),
      endShift: serializer.fromJson<DateTime?>(json['endShift']),
      startCash: serializer.fromJson<double>(json['startCash']),
      expectedCash: serializer.fromJson<double>(json['expectedCash']),
      actualCash: serializer.fromJson<double>(json['actualCash']),
      difference: serializer.fromJson<double>(json['difference']),
      varianceReason: serializer.fromJson<String?>(json['varianceReason']),
      isClosed: serializer.fromJson<bool>(json['isClosed']),
      isSynced: serializer.fromJson<bool>(json['isSynced']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'staffId': serializer.toJson<String>(staffId),
      'staffName': serializer.toJson<String>(staffName),
      'outletId': serializer.toJson<String?>(outletId),
      'startShift': serializer.toJson<DateTime>(startShift),
      'endShift': serializer.toJson<DateTime?>(endShift),
      'startCash': serializer.toJson<double>(startCash),
      'expectedCash': serializer.toJson<double>(expectedCash),
      'actualCash': serializer.toJson<double>(actualCash),
      'difference': serializer.toJson<double>(difference),
      'varianceReason': serializer.toJson<String?>(varianceReason),
      'isClosed': serializer.toJson<bool>(isClosed),
      'isSynced': serializer.toJson<bool>(isSynced),
    };
  }

  ShiftSessionTableData copyWith(
          {int? id,
          String? uuid,
          String? staffId,
          String? staffName,
          Value<String?> outletId = const Value.absent(),
          DateTime? startShift,
          Value<DateTime?> endShift = const Value.absent(),
          double? startCash,
          double? expectedCash,
          double? actualCash,
          double? difference,
          Value<String?> varianceReason = const Value.absent(),
          bool? isClosed,
          bool? isSynced}) =>
      ShiftSessionTableData(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        staffId: staffId ?? this.staffId,
        staffName: staffName ?? this.staffName,
        outletId: outletId.present ? outletId.value : this.outletId,
        startShift: startShift ?? this.startShift,
        endShift: endShift.present ? endShift.value : this.endShift,
        startCash: startCash ?? this.startCash,
        expectedCash: expectedCash ?? this.expectedCash,
        actualCash: actualCash ?? this.actualCash,
        difference: difference ?? this.difference,
        varianceReason:
            varianceReason.present ? varianceReason.value : this.varianceReason,
        isClosed: isClosed ?? this.isClosed,
        isSynced: isSynced ?? this.isSynced,
      );
  ShiftSessionTableData copyWithCompanion(ShiftSessionTableCompanion data) {
    return ShiftSessionTableData(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      staffId: data.staffId.present ? data.staffId.value : this.staffId,
      staffName: data.staffName.present ? data.staffName.value : this.staffName,
      outletId: data.outletId.present ? data.outletId.value : this.outletId,
      startShift:
          data.startShift.present ? data.startShift.value : this.startShift,
      endShift: data.endShift.present ? data.endShift.value : this.endShift,
      startCash: data.startCash.present ? data.startCash.value : this.startCash,
      expectedCash: data.expectedCash.present
          ? data.expectedCash.value
          : this.expectedCash,
      actualCash:
          data.actualCash.present ? data.actualCash.value : this.actualCash,
      difference:
          data.difference.present ? data.difference.value : this.difference,
      varianceReason: data.varianceReason.present
          ? data.varianceReason.value
          : this.varianceReason,
      isClosed: data.isClosed.present ? data.isClosed.value : this.isClosed,
      isSynced: data.isSynced.present ? data.isSynced.value : this.isSynced,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ShiftSessionTableData(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('staffId: $staffId, ')
          ..write('staffName: $staffName, ')
          ..write('outletId: $outletId, ')
          ..write('startShift: $startShift, ')
          ..write('endShift: $endShift, ')
          ..write('startCash: $startCash, ')
          ..write('expectedCash: $expectedCash, ')
          ..write('actualCash: $actualCash, ')
          ..write('difference: $difference, ')
          ..write('varianceReason: $varianceReason, ')
          ..write('isClosed: $isClosed, ')
          ..write('isSynced: $isSynced')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      uuid,
      staffId,
      staffName,
      outletId,
      startShift,
      endShift,
      startCash,
      expectedCash,
      actualCash,
      difference,
      varianceReason,
      isClosed,
      isSynced);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ShiftSessionTableData &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.staffId == this.staffId &&
          other.staffName == this.staffName &&
          other.outletId == this.outletId &&
          other.startShift == this.startShift &&
          other.endShift == this.endShift &&
          other.startCash == this.startCash &&
          other.expectedCash == this.expectedCash &&
          other.actualCash == this.actualCash &&
          other.difference == this.difference &&
          other.varianceReason == this.varianceReason &&
          other.isClosed == this.isClosed &&
          other.isSynced == this.isSynced);
}

class ShiftSessionTableCompanion
    extends UpdateCompanion<ShiftSessionTableData> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String> staffId;
  final Value<String> staffName;
  final Value<String?> outletId;
  final Value<DateTime> startShift;
  final Value<DateTime?> endShift;
  final Value<double> startCash;
  final Value<double> expectedCash;
  final Value<double> actualCash;
  final Value<double> difference;
  final Value<String?> varianceReason;
  final Value<bool> isClosed;
  final Value<bool> isSynced;
  const ShiftSessionTableCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.staffId = const Value.absent(),
    this.staffName = const Value.absent(),
    this.outletId = const Value.absent(),
    this.startShift = const Value.absent(),
    this.endShift = const Value.absent(),
    this.startCash = const Value.absent(),
    this.expectedCash = const Value.absent(),
    this.actualCash = const Value.absent(),
    this.difference = const Value.absent(),
    this.varianceReason = const Value.absent(),
    this.isClosed = const Value.absent(),
    this.isSynced = const Value.absent(),
  });
  ShiftSessionTableCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    required String staffId,
    required String staffName,
    this.outletId = const Value.absent(),
    required DateTime startShift,
    this.endShift = const Value.absent(),
    required double startCash,
    required double expectedCash,
    required double actualCash,
    required double difference,
    this.varianceReason = const Value.absent(),
    this.isClosed = const Value.absent(),
    this.isSynced = const Value.absent(),
  })  : uuid = Value(uuid),
        staffId = Value(staffId),
        staffName = Value(staffName),
        startShift = Value(startShift),
        startCash = Value(startCash),
        expectedCash = Value(expectedCash),
        actualCash = Value(actualCash),
        difference = Value(difference);
  static Insertable<ShiftSessionTableData> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? staffId,
    Expression<String>? staffName,
    Expression<String>? outletId,
    Expression<DateTime>? startShift,
    Expression<DateTime>? endShift,
    Expression<double>? startCash,
    Expression<double>? expectedCash,
    Expression<double>? actualCash,
    Expression<double>? difference,
    Expression<String>? varianceReason,
    Expression<bool>? isClosed,
    Expression<bool>? isSynced,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (staffId != null) 'staff_id': staffId,
      if (staffName != null) 'staff_name': staffName,
      if (outletId != null) 'outlet_id': outletId,
      if (startShift != null) 'start_shift': startShift,
      if (endShift != null) 'end_shift': endShift,
      if (startCash != null) 'start_cash': startCash,
      if (expectedCash != null) 'expected_cash': expectedCash,
      if (actualCash != null) 'actual_cash': actualCash,
      if (difference != null) 'difference': difference,
      if (varianceReason != null) 'variance_reason': varianceReason,
      if (isClosed != null) 'is_closed': isClosed,
      if (isSynced != null) 'is_synced': isSynced,
    });
  }

  ShiftSessionTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String>? staffId,
      Value<String>? staffName,
      Value<String?>? outletId,
      Value<DateTime>? startShift,
      Value<DateTime?>? endShift,
      Value<double>? startCash,
      Value<double>? expectedCash,
      Value<double>? actualCash,
      Value<double>? difference,
      Value<String?>? varianceReason,
      Value<bool>? isClosed,
      Value<bool>? isSynced}) {
    return ShiftSessionTableCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      staffId: staffId ?? this.staffId,
      staffName: staffName ?? this.staffName,
      outletId: outletId ?? this.outletId,
      startShift: startShift ?? this.startShift,
      endShift: endShift ?? this.endShift,
      startCash: startCash ?? this.startCash,
      expectedCash: expectedCash ?? this.expectedCash,
      actualCash: actualCash ?? this.actualCash,
      difference: difference ?? this.difference,
      varianceReason: varianceReason ?? this.varianceReason,
      isClosed: isClosed ?? this.isClosed,
      isSynced: isSynced ?? this.isSynced,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (staffId.present) {
      map['staff_id'] = Variable<String>(staffId.value);
    }
    if (staffName.present) {
      map['staff_name'] = Variable<String>(staffName.value);
    }
    if (outletId.present) {
      map['outlet_id'] = Variable<String>(outletId.value);
    }
    if (startShift.present) {
      map['start_shift'] = Variable<DateTime>(startShift.value);
    }
    if (endShift.present) {
      map['end_shift'] = Variable<DateTime>(endShift.value);
    }
    if (startCash.present) {
      map['start_cash'] = Variable<double>(startCash.value);
    }
    if (expectedCash.present) {
      map['expected_cash'] = Variable<double>(expectedCash.value);
    }
    if (actualCash.present) {
      map['actual_cash'] = Variable<double>(actualCash.value);
    }
    if (difference.present) {
      map['difference'] = Variable<double>(difference.value);
    }
    if (varianceReason.present) {
      map['variance_reason'] = Variable<String>(varianceReason.value);
    }
    if (isClosed.present) {
      map['is_closed'] = Variable<bool>(isClosed.value);
    }
    if (isSynced.present) {
      map['is_synced'] = Variable<bool>(isSynced.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ShiftSessionTableCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('staffId: $staffId, ')
          ..write('staffName: $staffName, ')
          ..write('outletId: $outletId, ')
          ..write('startShift: $startShift, ')
          ..write('endShift: $endShift, ')
          ..write('startCash: $startCash, ')
          ..write('expectedCash: $expectedCash, ')
          ..write('actualCash: $actualCash, ')
          ..write('difference: $difference, ')
          ..write('varianceReason: $varianceReason, ')
          ..write('isClosed: $isClosed, ')
          ..write('isSynced: $isSynced')
          ..write(')'))
        .toString();
  }
}

class $SyncQueueTable extends SyncQueue
    with TableInfo<$SyncQueueTable, SyncQueueData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SyncQueueTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _actionTypeMeta =
      const VerificationMeta('actionType');
  @override
  late final GeneratedColumn<String> actionType = GeneratedColumn<String>(
      'action_type', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _payloadJsonMeta =
      const VerificationMeta('payloadJson');
  @override
  late final GeneratedColumn<String> payloadJson = GeneratedColumn<String>(
      'payload_json', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _idempotencyKeyMeta =
      const VerificationMeta('idempotencyKey');
  @override
  late final GeneratedColumn<String> idempotencyKey = GeneratedColumn<String>(
      'idempotency_key', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
      'status', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultValue: const Constant('PENDING'));
  static const VerificationMeta _retryCountMeta =
      const VerificationMeta('retryCount');
  @override
  late final GeneratedColumn<int> retryCount = GeneratedColumn<int>(
      'retry_count', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultValue: const Constant(0));
  static const VerificationMeta _nextRetryAtMeta =
      const VerificationMeta('nextRetryAt');
  @override
  late final GeneratedColumn<DateTime> nextRetryAt = GeneratedColumn<DateTime>(
      'next_retry_at', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        actionType,
        payloadJson,
        idempotencyKey,
        createdAt,
        status,
        retryCount,
        nextRetryAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'sync_queue';
  @override
  VerificationContext validateIntegrity(Insertable<SyncQueueData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('action_type')) {
      context.handle(
          _actionTypeMeta,
          actionType.isAcceptableOrUnknown(
              data['action_type']!, _actionTypeMeta));
    } else if (isInserting) {
      context.missing(_actionTypeMeta);
    }
    if (data.containsKey('payload_json')) {
      context.handle(
          _payloadJsonMeta,
          payloadJson.isAcceptableOrUnknown(
              data['payload_json']!, _payloadJsonMeta));
    } else if (isInserting) {
      context.missing(_payloadJsonMeta);
    }
    if (data.containsKey('idempotency_key')) {
      context.handle(
          _idempotencyKeyMeta,
          idempotencyKey.isAcceptableOrUnknown(
              data['idempotency_key']!, _idempotencyKeyMeta));
    } else if (isInserting) {
      context.missing(_idempotencyKeyMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['status']!, _statusMeta));
    }
    if (data.containsKey('retry_count')) {
      context.handle(
          _retryCountMeta,
          retryCount.isAcceptableOrUnknown(
              data['retry_count']!, _retryCountMeta));
    }
    if (data.containsKey('next_retry_at')) {
      context.handle(
          _nextRetryAtMeta,
          nextRetryAt.isAcceptableOrUnknown(
              data['next_retry_at']!, _nextRetryAtMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  SyncQueueData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SyncQueueData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      actionType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}action_type'])!,
      payloadJson: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}payload_json'])!,
      idempotencyKey: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}idempotency_key'])!,
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      status: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}status'])!,
      retryCount: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}retry_count'])!,
      nextRetryAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}next_retry_at']),
    );
  }

  @override
  $SyncQueueTable createAlias(String alias) {
    return $SyncQueueTable(attachedDatabase, alias);
  }
}

class SyncQueueData extends DataClass implements Insertable<SyncQueueData> {
  final int id;
  final String actionType;
  final String payloadJson;
  final String idempotencyKey;
  final DateTime createdAt;
  final String status;
  final int retryCount;
  final DateTime? nextRetryAt;
  const SyncQueueData(
      {required this.id,
      required this.actionType,
      required this.payloadJson,
      required this.idempotencyKey,
      required this.createdAt,
      required this.status,
      required this.retryCount,
      this.nextRetryAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['action_type'] = Variable<String>(actionType);
    map['payload_json'] = Variable<String>(payloadJson);
    map['idempotency_key'] = Variable<String>(idempotencyKey);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['status'] = Variable<String>(status);
    map['retry_count'] = Variable<int>(retryCount);
    if (!nullToAbsent || nextRetryAt != null) {
      map['next_retry_at'] = Variable<DateTime>(nextRetryAt);
    }
    return map;
  }

  SyncQueueCompanion toCompanion(bool nullToAbsent) {
    return SyncQueueCompanion(
      id: Value(id),
      actionType: Value(actionType),
      payloadJson: Value(payloadJson),
      idempotencyKey: Value(idempotencyKey),
      createdAt: Value(createdAt),
      status: Value(status),
      retryCount: Value(retryCount),
      nextRetryAt: nextRetryAt == null && nullToAbsent
          ? const Value.absent()
          : Value(nextRetryAt),
    );
  }

  factory SyncQueueData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SyncQueueData(
      id: serializer.fromJson<int>(json['id']),
      actionType: serializer.fromJson<String>(json['actionType']),
      payloadJson: serializer.fromJson<String>(json['payloadJson']),
      idempotencyKey: serializer.fromJson<String>(json['idempotencyKey']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      status: serializer.fromJson<String>(json['status']),
      retryCount: serializer.fromJson<int>(json['retryCount']),
      nextRetryAt: serializer.fromJson<DateTime?>(json['nextRetryAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'actionType': serializer.toJson<String>(actionType),
      'payloadJson': serializer.toJson<String>(payloadJson),
      'idempotencyKey': serializer.toJson<String>(idempotencyKey),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'status': serializer.toJson<String>(status),
      'retryCount': serializer.toJson<int>(retryCount),
      'nextRetryAt': serializer.toJson<DateTime?>(nextRetryAt),
    };
  }

  SyncQueueData copyWith(
          {int? id,
          String? actionType,
          String? payloadJson,
          String? idempotencyKey,
          DateTime? createdAt,
          String? status,
          int? retryCount,
          Value<DateTime?> nextRetryAt = const Value.absent()}) =>
      SyncQueueData(
        id: id ?? this.id,
        actionType: actionType ?? this.actionType,
        payloadJson: payloadJson ?? this.payloadJson,
        idempotencyKey: idempotencyKey ?? this.idempotencyKey,
        createdAt: createdAt ?? this.createdAt,
        status: status ?? this.status,
        retryCount: retryCount ?? this.retryCount,
        nextRetryAt: nextRetryAt.present ? nextRetryAt.value : this.nextRetryAt,
      );
  SyncQueueData copyWithCompanion(SyncQueueCompanion data) {
    return SyncQueueData(
      id: data.id.present ? data.id.value : this.id,
      actionType:
          data.actionType.present ? data.actionType.value : this.actionType,
      payloadJson:
          data.payloadJson.present ? data.payloadJson.value : this.payloadJson,
      idempotencyKey: data.idempotencyKey.present
          ? data.idempotencyKey.value
          : this.idempotencyKey,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      status: data.status.present ? data.status.value : this.status,
      retryCount:
          data.retryCount.present ? data.retryCount.value : this.retryCount,
      nextRetryAt:
          data.nextRetryAt.present ? data.nextRetryAt.value : this.nextRetryAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('SyncQueueData(')
          ..write('id: $id, ')
          ..write('actionType: $actionType, ')
          ..write('payloadJson: $payloadJson, ')
          ..write('idempotencyKey: $idempotencyKey, ')
          ..write('createdAt: $createdAt, ')
          ..write('status: $status, ')
          ..write('retryCount: $retryCount, ')
          ..write('nextRetryAt: $nextRetryAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, actionType, payloadJson, idempotencyKey,
      createdAt, status, retryCount, nextRetryAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SyncQueueData &&
          other.id == this.id &&
          other.actionType == this.actionType &&
          other.payloadJson == this.payloadJson &&
          other.idempotencyKey == this.idempotencyKey &&
          other.createdAt == this.createdAt &&
          other.status == this.status &&
          other.retryCount == this.retryCount &&
          other.nextRetryAt == this.nextRetryAt);
}

class SyncQueueCompanion extends UpdateCompanion<SyncQueueData> {
  final Value<int> id;
  final Value<String> actionType;
  final Value<String> payloadJson;
  final Value<String> idempotencyKey;
  final Value<DateTime> createdAt;
  final Value<String> status;
  final Value<int> retryCount;
  final Value<DateTime?> nextRetryAt;
  const SyncQueueCompanion({
    this.id = const Value.absent(),
    this.actionType = const Value.absent(),
    this.payloadJson = const Value.absent(),
    this.idempotencyKey = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.status = const Value.absent(),
    this.retryCount = const Value.absent(),
    this.nextRetryAt = const Value.absent(),
  });
  SyncQueueCompanion.insert({
    this.id = const Value.absent(),
    required String actionType,
    required String payloadJson,
    required String idempotencyKey,
    required DateTime createdAt,
    this.status = const Value.absent(),
    this.retryCount = const Value.absent(),
    this.nextRetryAt = const Value.absent(),
  })  : actionType = Value(actionType),
        payloadJson = Value(payloadJson),
        idempotencyKey = Value(idempotencyKey),
        createdAt = Value(createdAt);
  static Insertable<SyncQueueData> custom({
    Expression<int>? id,
    Expression<String>? actionType,
    Expression<String>? payloadJson,
    Expression<String>? idempotencyKey,
    Expression<DateTime>? createdAt,
    Expression<String>? status,
    Expression<int>? retryCount,
    Expression<DateTime>? nextRetryAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (actionType != null) 'action_type': actionType,
      if (payloadJson != null) 'payload_json': payloadJson,
      if (idempotencyKey != null) 'idempotency_key': idempotencyKey,
      if (createdAt != null) 'created_at': createdAt,
      if (status != null) 'status': status,
      if (retryCount != null) 'retry_count': retryCount,
      if (nextRetryAt != null) 'next_retry_at': nextRetryAt,
    });
  }

  SyncQueueCompanion copyWith(
      {Value<int>? id,
      Value<String>? actionType,
      Value<String>? payloadJson,
      Value<String>? idempotencyKey,
      Value<DateTime>? createdAt,
      Value<String>? status,
      Value<int>? retryCount,
      Value<DateTime?>? nextRetryAt}) {
    return SyncQueueCompanion(
      id: id ?? this.id,
      actionType: actionType ?? this.actionType,
      payloadJson: payloadJson ?? this.payloadJson,
      idempotencyKey: idempotencyKey ?? this.idempotencyKey,
      createdAt: createdAt ?? this.createdAt,
      status: status ?? this.status,
      retryCount: retryCount ?? this.retryCount,
      nextRetryAt: nextRetryAt ?? this.nextRetryAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (actionType.present) {
      map['action_type'] = Variable<String>(actionType.value);
    }
    if (payloadJson.present) {
      map['payload_json'] = Variable<String>(payloadJson.value);
    }
    if (idempotencyKey.present) {
      map['idempotency_key'] = Variable<String>(idempotencyKey.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (retryCount.present) {
      map['retry_count'] = Variable<int>(retryCount.value);
    }
    if (nextRetryAt.present) {
      map['next_retry_at'] = Variable<DateTime>(nextRetryAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SyncQueueCompanion(')
          ..write('id: $id, ')
          ..write('actionType: $actionType, ')
          ..write('payloadJson: $payloadJson, ')
          ..write('idempotencyKey: $idempotencyKey, ')
          ..write('createdAt: $createdAt, ')
          ..write('status: $status, ')
          ..write('retryCount: $retryCount, ')
          ..write('nextRetryAt: $nextRetryAt')
          ..write(')'))
        .toString();
  }
}

class $CashTransactionTableTable extends CashTransactionTable
    with TableInfo<$CashTransactionTableTable, CashTransactionTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $CashTransactionTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _shiftUuidMeta =
      const VerificationMeta('shiftUuid');
  @override
  late final GeneratedColumn<String> shiftUuid = GeneratedColumn<String>(
      'shift_uuid', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _typeMeta = const VerificationMeta('type');
  @override
  late final GeneratedColumn<String> type = GeneratedColumn<String>(
      'type', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _amountMeta = const VerificationMeta('amount');
  @override
  late final GeneratedColumn<double> amount = GeneratedColumn<double>(
      'amount', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _reasonMeta = const VerificationMeta('reason');
  @override
  late final GeneratedColumn<String> reason = GeneratedColumn<String>(
      'reason', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _isSyncedMeta =
      const VerificationMeta('isSynced');
  @override
  late final GeneratedColumn<bool> isSynced = GeneratedColumn<bool>(
      'is_synced', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_synced" IN (0, 1))'),
      defaultValue: const Constant(false));
  @override
  List<GeneratedColumn> get $columns =>
      [id, uuid, shiftUuid, type, amount, reason, createdAt, isSynced];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'cash_transaction_table';
  @override
  VerificationContext validateIntegrity(
      Insertable<CashTransactionTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('shift_uuid')) {
      context.handle(_shiftUuidMeta,
          shiftUuid.isAcceptableOrUnknown(data['shift_uuid']!, _shiftUuidMeta));
    }
    if (data.containsKey('type')) {
      context.handle(
          _typeMeta, type.isAcceptableOrUnknown(data['type']!, _typeMeta));
    } else if (isInserting) {
      context.missing(_typeMeta);
    }
    if (data.containsKey('amount')) {
      context.handle(_amountMeta,
          amount.isAcceptableOrUnknown(data['amount']!, _amountMeta));
    } else if (isInserting) {
      context.missing(_amountMeta);
    }
    if (data.containsKey('reason')) {
      context.handle(_reasonMeta,
          reason.isAcceptableOrUnknown(data['reason']!, _reasonMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('is_synced')) {
      context.handle(_isSyncedMeta,
          isSynced.isAcceptableOrUnknown(data['is_synced']!, _isSyncedMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  CashTransactionTableData map(Map<String, dynamic> data,
      {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return CashTransactionTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      shiftUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}shift_uuid']),
      type: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}type'])!,
      amount: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}amount'])!,
      reason: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}reason']),
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      isSynced: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_synced'])!,
    );
  }

  @override
  $CashTransactionTableTable createAlias(String alias) {
    return $CashTransactionTableTable(attachedDatabase, alias);
  }
}

class CashTransactionTableData extends DataClass
    implements Insertable<CashTransactionTableData> {
  final int id;
  final String uuid;
  final String? shiftUuid;
  final String type;
  final double amount;
  final String? reason;
  final DateTime createdAt;
  final bool isSynced;
  const CashTransactionTableData(
      {required this.id,
      required this.uuid,
      this.shiftUuid,
      required this.type,
      required this.amount,
      this.reason,
      required this.createdAt,
      required this.isSynced});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    if (!nullToAbsent || shiftUuid != null) {
      map['shift_uuid'] = Variable<String>(shiftUuid);
    }
    map['type'] = Variable<String>(type);
    map['amount'] = Variable<double>(amount);
    if (!nullToAbsent || reason != null) {
      map['reason'] = Variable<String>(reason);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['is_synced'] = Variable<bool>(isSynced);
    return map;
  }

  CashTransactionTableCompanion toCompanion(bool nullToAbsent) {
    return CashTransactionTableCompanion(
      id: Value(id),
      uuid: Value(uuid),
      shiftUuid: shiftUuid == null && nullToAbsent
          ? const Value.absent()
          : Value(shiftUuid),
      type: Value(type),
      amount: Value(amount),
      reason:
          reason == null && nullToAbsent ? const Value.absent() : Value(reason),
      createdAt: Value(createdAt),
      isSynced: Value(isSynced),
    );
  }

  factory CashTransactionTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return CashTransactionTableData(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      shiftUuid: serializer.fromJson<String?>(json['shiftUuid']),
      type: serializer.fromJson<String>(json['type']),
      amount: serializer.fromJson<double>(json['amount']),
      reason: serializer.fromJson<String?>(json['reason']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      isSynced: serializer.fromJson<bool>(json['isSynced']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'shiftUuid': serializer.toJson<String?>(shiftUuid),
      'type': serializer.toJson<String>(type),
      'amount': serializer.toJson<double>(amount),
      'reason': serializer.toJson<String?>(reason),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'isSynced': serializer.toJson<bool>(isSynced),
    };
  }

  CashTransactionTableData copyWith(
          {int? id,
          String? uuid,
          Value<String?> shiftUuid = const Value.absent(),
          String? type,
          double? amount,
          Value<String?> reason = const Value.absent(),
          DateTime? createdAt,
          bool? isSynced}) =>
      CashTransactionTableData(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        shiftUuid: shiftUuid.present ? shiftUuid.value : this.shiftUuid,
        type: type ?? this.type,
        amount: amount ?? this.amount,
        reason: reason.present ? reason.value : this.reason,
        createdAt: createdAt ?? this.createdAt,
        isSynced: isSynced ?? this.isSynced,
      );
  CashTransactionTableData copyWithCompanion(
      CashTransactionTableCompanion data) {
    return CashTransactionTableData(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      shiftUuid: data.shiftUuid.present ? data.shiftUuid.value : this.shiftUuid,
      type: data.type.present ? data.type.value : this.type,
      amount: data.amount.present ? data.amount.value : this.amount,
      reason: data.reason.present ? data.reason.value : this.reason,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      isSynced: data.isSynced.present ? data.isSynced.value : this.isSynced,
    );
  }

  @override
  String toString() {
    return (StringBuffer('CashTransactionTableData(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('shiftUuid: $shiftUuid, ')
          ..write('type: $type, ')
          ..write('amount: $amount, ')
          ..write('reason: $reason, ')
          ..write('createdAt: $createdAt, ')
          ..write('isSynced: $isSynced')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id, uuid, shiftUuid, type, amount, reason, createdAt, isSynced);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is CashTransactionTableData &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.shiftUuid == this.shiftUuid &&
          other.type == this.type &&
          other.amount == this.amount &&
          other.reason == this.reason &&
          other.createdAt == this.createdAt &&
          other.isSynced == this.isSynced);
}

class CashTransactionTableCompanion
    extends UpdateCompanion<CashTransactionTableData> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String?> shiftUuid;
  final Value<String> type;
  final Value<double> amount;
  final Value<String?> reason;
  final Value<DateTime> createdAt;
  final Value<bool> isSynced;
  const CashTransactionTableCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.shiftUuid = const Value.absent(),
    this.type = const Value.absent(),
    this.amount = const Value.absent(),
    this.reason = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.isSynced = const Value.absent(),
  });
  CashTransactionTableCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    this.shiftUuid = const Value.absent(),
    required String type,
    required double amount,
    this.reason = const Value.absent(),
    required DateTime createdAt,
    this.isSynced = const Value.absent(),
  })  : uuid = Value(uuid),
        type = Value(type),
        amount = Value(amount),
        createdAt = Value(createdAt);
  static Insertable<CashTransactionTableData> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? shiftUuid,
    Expression<String>? type,
    Expression<double>? amount,
    Expression<String>? reason,
    Expression<DateTime>? createdAt,
    Expression<bool>? isSynced,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (shiftUuid != null) 'shift_uuid': shiftUuid,
      if (type != null) 'type': type,
      if (amount != null) 'amount': amount,
      if (reason != null) 'reason': reason,
      if (createdAt != null) 'created_at': createdAt,
      if (isSynced != null) 'is_synced': isSynced,
    });
  }

  CashTransactionTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String?>? shiftUuid,
      Value<String>? type,
      Value<double>? amount,
      Value<String?>? reason,
      Value<DateTime>? createdAt,
      Value<bool>? isSynced}) {
    return CashTransactionTableCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      shiftUuid: shiftUuid ?? this.shiftUuid,
      type: type ?? this.type,
      amount: amount ?? this.amount,
      reason: reason ?? this.reason,
      createdAt: createdAt ?? this.createdAt,
      isSynced: isSynced ?? this.isSynced,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (shiftUuid.present) {
      map['shift_uuid'] = Variable<String>(shiftUuid.value);
    }
    if (type.present) {
      map['type'] = Variable<String>(type.value);
    }
    if (amount.present) {
      map['amount'] = Variable<double>(amount.value);
    }
    if (reason.present) {
      map['reason'] = Variable<String>(reason.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (isSynced.present) {
      map['is_synced'] = Variable<bool>(isSynced.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('CashTransactionTableCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('shiftUuid: $shiftUuid, ')
          ..write('type: $type, ')
          ..write('amount: $amount, ')
          ..write('reason: $reason, ')
          ..write('createdAt: $createdAt, ')
          ..write('isSynced: $isSynced')
          ..write(')'))
        .toString();
  }
}

class $WasteTableTable extends WasteTable
    with TableInfo<$WasteTableTable, WasteTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $WasteTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _itemUuidMeta =
      const VerificationMeta('itemUuid');
  @override
  late final GeneratedColumn<String> itemUuid = GeneratedColumn<String>(
      'item_uuid', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _itemTypeMeta =
      const VerificationMeta('itemType');
  @override
  late final GeneratedColumn<String> itemType = GeneratedColumn<String>(
      'item_type', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _quantityMeta =
      const VerificationMeta('quantity');
  @override
  late final GeneratedColumn<double> quantity = GeneratedColumn<double>(
      'quantity', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _reasonMeta = const VerificationMeta('reason');
  @override
  late final GeneratedColumn<String> reason = GeneratedColumn<String>(
      'reason', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _noteMeta = const VerificationMeta('note');
  @override
  late final GeneratedColumn<String> note = GeneratedColumn<String>(
      'note', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _costLossMeta =
      const VerificationMeta('costLoss');
  @override
  late final GeneratedColumn<double> costLoss = GeneratedColumn<double>(
      'cost_loss', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _staffUuidMeta =
      const VerificationMeta('staffUuid');
  @override
  late final GeneratedColumn<String> staffUuid = GeneratedColumn<String>(
      'staff_uuid', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _warehouseUuidMeta =
      const VerificationMeta('warehouseUuid');
  @override
  late final GeneratedColumn<String> warehouseUuid = GeneratedColumn<String>(
      'warehouse_uuid', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _recordedAtMeta =
      const VerificationMeta('recordedAt');
  @override
  late final GeneratedColumn<DateTime> recordedAt = GeneratedColumn<DateTime>(
      'recorded_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _isSyncedMeta =
      const VerificationMeta('isSynced');
  @override
  late final GeneratedColumn<bool> isSynced = GeneratedColumn<bool>(
      'is_synced', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_synced" IN (0, 1))'),
      defaultValue: const Constant(false));
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        itemUuid,
        itemType,
        quantity,
        reason,
        note,
        costLoss,
        staffUuid,
        warehouseUuid,
        recordedAt,
        isSynced
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'waste_table';
  @override
  VerificationContext validateIntegrity(Insertable<WasteTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('item_uuid')) {
      context.handle(_itemUuidMeta,
          itemUuid.isAcceptableOrUnknown(data['item_uuid']!, _itemUuidMeta));
    } else if (isInserting) {
      context.missing(_itemUuidMeta);
    }
    if (data.containsKey('item_type')) {
      context.handle(_itemTypeMeta,
          itemType.isAcceptableOrUnknown(data['item_type']!, _itemTypeMeta));
    } else if (isInserting) {
      context.missing(_itemTypeMeta);
    }
    if (data.containsKey('quantity')) {
      context.handle(_quantityMeta,
          quantity.isAcceptableOrUnknown(data['quantity']!, _quantityMeta));
    } else if (isInserting) {
      context.missing(_quantityMeta);
    }
    if (data.containsKey('reason')) {
      context.handle(_reasonMeta,
          reason.isAcceptableOrUnknown(data['reason']!, _reasonMeta));
    } else if (isInserting) {
      context.missing(_reasonMeta);
    }
    if (data.containsKey('note')) {
      context.handle(
          _noteMeta, note.isAcceptableOrUnknown(data['note']!, _noteMeta));
    }
    if (data.containsKey('cost_loss')) {
      context.handle(_costLossMeta,
          costLoss.isAcceptableOrUnknown(data['cost_loss']!, _costLossMeta));
    } else if (isInserting) {
      context.missing(_costLossMeta);
    }
    if (data.containsKey('staff_uuid')) {
      context.handle(_staffUuidMeta,
          staffUuid.isAcceptableOrUnknown(data['staff_uuid']!, _staffUuidMeta));
    } else if (isInserting) {
      context.missing(_staffUuidMeta);
    }
    if (data.containsKey('warehouse_uuid')) {
      context.handle(
          _warehouseUuidMeta,
          warehouseUuid.isAcceptableOrUnknown(
              data['warehouse_uuid']!, _warehouseUuidMeta));
    } else if (isInserting) {
      context.missing(_warehouseUuidMeta);
    }
    if (data.containsKey('recorded_at')) {
      context.handle(
          _recordedAtMeta,
          recordedAt.isAcceptableOrUnknown(
              data['recorded_at']!, _recordedAtMeta));
    } else if (isInserting) {
      context.missing(_recordedAtMeta);
    }
    if (data.containsKey('is_synced')) {
      context.handle(_isSyncedMeta,
          isSynced.isAcceptableOrUnknown(data['is_synced']!, _isSyncedMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  WasteTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return WasteTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      itemUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}item_uuid'])!,
      itemType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}item_type'])!,
      quantity: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}quantity'])!,
      reason: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}reason'])!,
      note: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}note']),
      costLoss: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}cost_loss'])!,
      staffUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}staff_uuid'])!,
      warehouseUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}warehouse_uuid'])!,
      recordedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}recorded_at'])!,
      isSynced: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_synced'])!,
    );
  }

  @override
  $WasteTableTable createAlias(String alias) {
    return $WasteTableTable(attachedDatabase, alias);
  }
}

class WasteTableData extends DataClass implements Insertable<WasteTableData> {
  final int id;
  final String uuid;
  final String itemUuid;
  final String itemType;
  final double quantity;
  final String reason;
  final String? note;
  final double costLoss;
  final String staffUuid;
  final String warehouseUuid;
  final DateTime recordedAt;
  final bool isSynced;
  const WasteTableData(
      {required this.id,
      required this.uuid,
      required this.itemUuid,
      required this.itemType,
      required this.quantity,
      required this.reason,
      this.note,
      required this.costLoss,
      required this.staffUuid,
      required this.warehouseUuid,
      required this.recordedAt,
      required this.isSynced});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    map['item_uuid'] = Variable<String>(itemUuid);
    map['item_type'] = Variable<String>(itemType);
    map['quantity'] = Variable<double>(quantity);
    map['reason'] = Variable<String>(reason);
    if (!nullToAbsent || note != null) {
      map['note'] = Variable<String>(note);
    }
    map['cost_loss'] = Variable<double>(costLoss);
    map['staff_uuid'] = Variable<String>(staffUuid);
    map['warehouse_uuid'] = Variable<String>(warehouseUuid);
    map['recorded_at'] = Variable<DateTime>(recordedAt);
    map['is_synced'] = Variable<bool>(isSynced);
    return map;
  }

  WasteTableCompanion toCompanion(bool nullToAbsent) {
    return WasteTableCompanion(
      id: Value(id),
      uuid: Value(uuid),
      itemUuid: Value(itemUuid),
      itemType: Value(itemType),
      quantity: Value(quantity),
      reason: Value(reason),
      note: note == null && nullToAbsent ? const Value.absent() : Value(note),
      costLoss: Value(costLoss),
      staffUuid: Value(staffUuid),
      warehouseUuid: Value(warehouseUuid),
      recordedAt: Value(recordedAt),
      isSynced: Value(isSynced),
    );
  }

  factory WasteTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return WasteTableData(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      itemUuid: serializer.fromJson<String>(json['itemUuid']),
      itemType: serializer.fromJson<String>(json['itemType']),
      quantity: serializer.fromJson<double>(json['quantity']),
      reason: serializer.fromJson<String>(json['reason']),
      note: serializer.fromJson<String?>(json['note']),
      costLoss: serializer.fromJson<double>(json['costLoss']),
      staffUuid: serializer.fromJson<String>(json['staffUuid']),
      warehouseUuid: serializer.fromJson<String>(json['warehouseUuid']),
      recordedAt: serializer.fromJson<DateTime>(json['recordedAt']),
      isSynced: serializer.fromJson<bool>(json['isSynced']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'itemUuid': serializer.toJson<String>(itemUuid),
      'itemType': serializer.toJson<String>(itemType),
      'quantity': serializer.toJson<double>(quantity),
      'reason': serializer.toJson<String>(reason),
      'note': serializer.toJson<String?>(note),
      'costLoss': serializer.toJson<double>(costLoss),
      'staffUuid': serializer.toJson<String>(staffUuid),
      'warehouseUuid': serializer.toJson<String>(warehouseUuid),
      'recordedAt': serializer.toJson<DateTime>(recordedAt),
      'isSynced': serializer.toJson<bool>(isSynced),
    };
  }

  WasteTableData copyWith(
          {int? id,
          String? uuid,
          String? itemUuid,
          String? itemType,
          double? quantity,
          String? reason,
          Value<String?> note = const Value.absent(),
          double? costLoss,
          String? staffUuid,
          String? warehouseUuid,
          DateTime? recordedAt,
          bool? isSynced}) =>
      WasteTableData(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        itemUuid: itemUuid ?? this.itemUuid,
        itemType: itemType ?? this.itemType,
        quantity: quantity ?? this.quantity,
        reason: reason ?? this.reason,
        note: note.present ? note.value : this.note,
        costLoss: costLoss ?? this.costLoss,
        staffUuid: staffUuid ?? this.staffUuid,
        warehouseUuid: warehouseUuid ?? this.warehouseUuid,
        recordedAt: recordedAt ?? this.recordedAt,
        isSynced: isSynced ?? this.isSynced,
      );
  WasteTableData copyWithCompanion(WasteTableCompanion data) {
    return WasteTableData(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      itemUuid: data.itemUuid.present ? data.itemUuid.value : this.itemUuid,
      itemType: data.itemType.present ? data.itemType.value : this.itemType,
      quantity: data.quantity.present ? data.quantity.value : this.quantity,
      reason: data.reason.present ? data.reason.value : this.reason,
      note: data.note.present ? data.note.value : this.note,
      costLoss: data.costLoss.present ? data.costLoss.value : this.costLoss,
      staffUuid: data.staffUuid.present ? data.staffUuid.value : this.staffUuid,
      warehouseUuid: data.warehouseUuid.present
          ? data.warehouseUuid.value
          : this.warehouseUuid,
      recordedAt:
          data.recordedAt.present ? data.recordedAt.value : this.recordedAt,
      isSynced: data.isSynced.present ? data.isSynced.value : this.isSynced,
    );
  }

  @override
  String toString() {
    return (StringBuffer('WasteTableData(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('itemUuid: $itemUuid, ')
          ..write('itemType: $itemType, ')
          ..write('quantity: $quantity, ')
          ..write('reason: $reason, ')
          ..write('note: $note, ')
          ..write('costLoss: $costLoss, ')
          ..write('staffUuid: $staffUuid, ')
          ..write('warehouseUuid: $warehouseUuid, ')
          ..write('recordedAt: $recordedAt, ')
          ..write('isSynced: $isSynced')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, uuid, itemUuid, itemType, quantity,
      reason, note, costLoss, staffUuid, warehouseUuid, recordedAt, isSynced);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is WasteTableData &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.itemUuid == this.itemUuid &&
          other.itemType == this.itemType &&
          other.quantity == this.quantity &&
          other.reason == this.reason &&
          other.note == this.note &&
          other.costLoss == this.costLoss &&
          other.staffUuid == this.staffUuid &&
          other.warehouseUuid == this.warehouseUuid &&
          other.recordedAt == this.recordedAt &&
          other.isSynced == this.isSynced);
}

class WasteTableCompanion extends UpdateCompanion<WasteTableData> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String> itemUuid;
  final Value<String> itemType;
  final Value<double> quantity;
  final Value<String> reason;
  final Value<String?> note;
  final Value<double> costLoss;
  final Value<String> staffUuid;
  final Value<String> warehouseUuid;
  final Value<DateTime> recordedAt;
  final Value<bool> isSynced;
  const WasteTableCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.itemUuid = const Value.absent(),
    this.itemType = const Value.absent(),
    this.quantity = const Value.absent(),
    this.reason = const Value.absent(),
    this.note = const Value.absent(),
    this.costLoss = const Value.absent(),
    this.staffUuid = const Value.absent(),
    this.warehouseUuid = const Value.absent(),
    this.recordedAt = const Value.absent(),
    this.isSynced = const Value.absent(),
  });
  WasteTableCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    required String itemUuid,
    required String itemType,
    required double quantity,
    required String reason,
    this.note = const Value.absent(),
    required double costLoss,
    required String staffUuid,
    required String warehouseUuid,
    required DateTime recordedAt,
    this.isSynced = const Value.absent(),
  })  : uuid = Value(uuid),
        itemUuid = Value(itemUuid),
        itemType = Value(itemType),
        quantity = Value(quantity),
        reason = Value(reason),
        costLoss = Value(costLoss),
        staffUuid = Value(staffUuid),
        warehouseUuid = Value(warehouseUuid),
        recordedAt = Value(recordedAt);
  static Insertable<WasteTableData> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? itemUuid,
    Expression<String>? itemType,
    Expression<double>? quantity,
    Expression<String>? reason,
    Expression<String>? note,
    Expression<double>? costLoss,
    Expression<String>? staffUuid,
    Expression<String>? warehouseUuid,
    Expression<DateTime>? recordedAt,
    Expression<bool>? isSynced,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (itemUuid != null) 'item_uuid': itemUuid,
      if (itemType != null) 'item_type': itemType,
      if (quantity != null) 'quantity': quantity,
      if (reason != null) 'reason': reason,
      if (note != null) 'note': note,
      if (costLoss != null) 'cost_loss': costLoss,
      if (staffUuid != null) 'staff_uuid': staffUuid,
      if (warehouseUuid != null) 'warehouse_uuid': warehouseUuid,
      if (recordedAt != null) 'recorded_at': recordedAt,
      if (isSynced != null) 'is_synced': isSynced,
    });
  }

  WasteTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String>? itemUuid,
      Value<String>? itemType,
      Value<double>? quantity,
      Value<String>? reason,
      Value<String?>? note,
      Value<double>? costLoss,
      Value<String>? staffUuid,
      Value<String>? warehouseUuid,
      Value<DateTime>? recordedAt,
      Value<bool>? isSynced}) {
    return WasteTableCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      itemUuid: itemUuid ?? this.itemUuid,
      itemType: itemType ?? this.itemType,
      quantity: quantity ?? this.quantity,
      reason: reason ?? this.reason,
      note: note ?? this.note,
      costLoss: costLoss ?? this.costLoss,
      staffUuid: staffUuid ?? this.staffUuid,
      warehouseUuid: warehouseUuid ?? this.warehouseUuid,
      recordedAt: recordedAt ?? this.recordedAt,
      isSynced: isSynced ?? this.isSynced,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (itemUuid.present) {
      map['item_uuid'] = Variable<String>(itemUuid.value);
    }
    if (itemType.present) {
      map['item_type'] = Variable<String>(itemType.value);
    }
    if (quantity.present) {
      map['quantity'] = Variable<double>(quantity.value);
    }
    if (reason.present) {
      map['reason'] = Variable<String>(reason.value);
    }
    if (note.present) {
      map['note'] = Variable<String>(note.value);
    }
    if (costLoss.present) {
      map['cost_loss'] = Variable<double>(costLoss.value);
    }
    if (staffUuid.present) {
      map['staff_uuid'] = Variable<String>(staffUuid.value);
    }
    if (warehouseUuid.present) {
      map['warehouse_uuid'] = Variable<String>(warehouseUuid.value);
    }
    if (recordedAt.present) {
      map['recorded_at'] = Variable<DateTime>(recordedAt.value);
    }
    if (isSynced.present) {
      map['is_synced'] = Variable<bool>(isSynced.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('WasteTableCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('itemUuid: $itemUuid, ')
          ..write('itemType: $itemType, ')
          ..write('quantity: $quantity, ')
          ..write('reason: $reason, ')
          ..write('note: $note, ')
          ..write('costLoss: $costLoss, ')
          ..write('staffUuid: $staffUuid, ')
          ..write('warehouseUuid: $warehouseUuid, ')
          ..write('recordedAt: $recordedAt, ')
          ..write('isSynced: $isSynced')
          ..write(')'))
        .toString();
  }
}

class $MarketingCampaignTableTable extends MarketingCampaignTable
    with TableInfo<$MarketingCampaignTableTable, MarketingCampaignTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $MarketingCampaignTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _channelMeta =
      const VerificationMeta('channel');
  @override
  late final GeneratedColumn<String> channel = GeneratedColumn<String>(
      'channel', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _triggerTypeMeta =
      const VerificationMeta('triggerType');
  @override
  late final GeneratedColumn<String> triggerType = GeneratedColumn<String>(
      'trigger_type', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _triggerValueMeta =
      const VerificationMeta('triggerValue');
  @override
  late final GeneratedColumn<String> triggerValue = GeneratedColumn<String>(
      'trigger_value', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _contentMeta =
      const VerificationMeta('content');
  @override
  late final GeneratedColumn<String> content = GeneratedColumn<String>(
      'content', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _isActiveMeta =
      const VerificationMeta('isActive');
  @override
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
      'is_active', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_active" IN (0, 1))'),
      defaultValue: const Constant(true));
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        name,
        channel,
        triggerType,
        triggerValue,
        content,
        isActive,
        createdAt,
        updatedAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'marketing_campaign_table';
  @override
  VerificationContext validateIntegrity(
      Insertable<MarketingCampaignTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('channel')) {
      context.handle(_channelMeta,
          channel.isAcceptableOrUnknown(data['channel']!, _channelMeta));
    } else if (isInserting) {
      context.missing(_channelMeta);
    }
    if (data.containsKey('trigger_type')) {
      context.handle(
          _triggerTypeMeta,
          triggerType.isAcceptableOrUnknown(
              data['trigger_type']!, _triggerTypeMeta));
    } else if (isInserting) {
      context.missing(_triggerTypeMeta);
    }
    if (data.containsKey('trigger_value')) {
      context.handle(
          _triggerValueMeta,
          triggerValue.isAcceptableOrUnknown(
              data['trigger_value']!, _triggerValueMeta));
    }
    if (data.containsKey('content')) {
      context.handle(_contentMeta,
          content.isAcceptableOrUnknown(data['content']!, _contentMeta));
    } else if (isInserting) {
      context.missing(_contentMeta);
    }
    if (data.containsKey('is_active')) {
      context.handle(_isActiveMeta,
          isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  MarketingCampaignTableData map(Map<String, dynamic> data,
      {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return MarketingCampaignTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
      channel: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}channel'])!,
      triggerType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}trigger_type'])!,
      triggerValue: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}trigger_value']),
      content: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}content'])!,
      isActive: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_active'])!,
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at']),
    );
  }

  @override
  $MarketingCampaignTableTable createAlias(String alias) {
    return $MarketingCampaignTableTable(attachedDatabase, alias);
  }
}

class MarketingCampaignTableData extends DataClass
    implements Insertable<MarketingCampaignTableData> {
  final int id;
  final String uuid;
  final String name;
  final String channel;
  final String triggerType;
  final String? triggerValue;
  final String content;
  final bool isActive;
  final DateTime createdAt;
  final DateTime? updatedAt;
  const MarketingCampaignTableData(
      {required this.id,
      required this.uuid,
      required this.name,
      required this.channel,
      required this.triggerType,
      this.triggerValue,
      required this.content,
      required this.isActive,
      required this.createdAt,
      this.updatedAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    map['name'] = Variable<String>(name);
    map['channel'] = Variable<String>(channel);
    map['trigger_type'] = Variable<String>(triggerType);
    if (!nullToAbsent || triggerValue != null) {
      map['trigger_value'] = Variable<String>(triggerValue);
    }
    map['content'] = Variable<String>(content);
    map['is_active'] = Variable<bool>(isActive);
    map['created_at'] = Variable<DateTime>(createdAt);
    if (!nullToAbsent || updatedAt != null) {
      map['updated_at'] = Variable<DateTime>(updatedAt);
    }
    return map;
  }

  MarketingCampaignTableCompanion toCompanion(bool nullToAbsent) {
    return MarketingCampaignTableCompanion(
      id: Value(id),
      uuid: Value(uuid),
      name: Value(name),
      channel: Value(channel),
      triggerType: Value(triggerType),
      triggerValue: triggerValue == null && nullToAbsent
          ? const Value.absent()
          : Value(triggerValue),
      content: Value(content),
      isActive: Value(isActive),
      createdAt: Value(createdAt),
      updatedAt: updatedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(updatedAt),
    );
  }

  factory MarketingCampaignTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return MarketingCampaignTableData(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      name: serializer.fromJson<String>(json['name']),
      channel: serializer.fromJson<String>(json['channel']),
      triggerType: serializer.fromJson<String>(json['triggerType']),
      triggerValue: serializer.fromJson<String?>(json['triggerValue']),
      content: serializer.fromJson<String>(json['content']),
      isActive: serializer.fromJson<bool>(json['isActive']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime?>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'name': serializer.toJson<String>(name),
      'channel': serializer.toJson<String>(channel),
      'triggerType': serializer.toJson<String>(triggerType),
      'triggerValue': serializer.toJson<String?>(triggerValue),
      'content': serializer.toJson<String>(content),
      'isActive': serializer.toJson<bool>(isActive),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime?>(updatedAt),
    };
  }

  MarketingCampaignTableData copyWith(
          {int? id,
          String? uuid,
          String? name,
          String? channel,
          String? triggerType,
          Value<String?> triggerValue = const Value.absent(),
          String? content,
          bool? isActive,
          DateTime? createdAt,
          Value<DateTime?> updatedAt = const Value.absent()}) =>
      MarketingCampaignTableData(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        name: name ?? this.name,
        channel: channel ?? this.channel,
        triggerType: triggerType ?? this.triggerType,
        triggerValue:
            triggerValue.present ? triggerValue.value : this.triggerValue,
        content: content ?? this.content,
        isActive: isActive ?? this.isActive,
        createdAt: createdAt ?? this.createdAt,
        updatedAt: updatedAt.present ? updatedAt.value : this.updatedAt,
      );
  MarketingCampaignTableData copyWithCompanion(
      MarketingCampaignTableCompanion data) {
    return MarketingCampaignTableData(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      name: data.name.present ? data.name.value : this.name,
      channel: data.channel.present ? data.channel.value : this.channel,
      triggerType:
          data.triggerType.present ? data.triggerType.value : this.triggerType,
      triggerValue: data.triggerValue.present
          ? data.triggerValue.value
          : this.triggerValue,
      content: data.content.present ? data.content.value : this.content,
      isActive: data.isActive.present ? data.isActive.value : this.isActive,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('MarketingCampaignTableData(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('channel: $channel, ')
          ..write('triggerType: $triggerType, ')
          ..write('triggerValue: $triggerValue, ')
          ..write('content: $content, ')
          ..write('isActive: $isActive, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, uuid, name, channel, triggerType,
      triggerValue, content, isActive, createdAt, updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is MarketingCampaignTableData &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.name == this.name &&
          other.channel == this.channel &&
          other.triggerType == this.triggerType &&
          other.triggerValue == this.triggerValue &&
          other.content == this.content &&
          other.isActive == this.isActive &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class MarketingCampaignTableCompanion
    extends UpdateCompanion<MarketingCampaignTableData> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String> name;
  final Value<String> channel;
  final Value<String> triggerType;
  final Value<String?> triggerValue;
  final Value<String> content;
  final Value<bool> isActive;
  final Value<DateTime> createdAt;
  final Value<DateTime?> updatedAt;
  const MarketingCampaignTableCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.name = const Value.absent(),
    this.channel = const Value.absent(),
    this.triggerType = const Value.absent(),
    this.triggerValue = const Value.absent(),
    this.content = const Value.absent(),
    this.isActive = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  MarketingCampaignTableCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    required String name,
    required String channel,
    required String triggerType,
    this.triggerValue = const Value.absent(),
    required String content,
    this.isActive = const Value.absent(),
    required DateTime createdAt,
    this.updatedAt = const Value.absent(),
  })  : uuid = Value(uuid),
        name = Value(name),
        channel = Value(channel),
        triggerType = Value(triggerType),
        content = Value(content),
        createdAt = Value(createdAt);
  static Insertable<MarketingCampaignTableData> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? name,
    Expression<String>? channel,
    Expression<String>? triggerType,
    Expression<String>? triggerValue,
    Expression<String>? content,
    Expression<bool>? isActive,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (name != null) 'name': name,
      if (channel != null) 'channel': channel,
      if (triggerType != null) 'trigger_type': triggerType,
      if (triggerValue != null) 'trigger_value': triggerValue,
      if (content != null) 'content': content,
      if (isActive != null) 'is_active': isActive,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  MarketingCampaignTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String>? name,
      Value<String>? channel,
      Value<String>? triggerType,
      Value<String?>? triggerValue,
      Value<String>? content,
      Value<bool>? isActive,
      Value<DateTime>? createdAt,
      Value<DateTime?>? updatedAt}) {
    return MarketingCampaignTableCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      name: name ?? this.name,
      channel: channel ?? this.channel,
      triggerType: triggerType ?? this.triggerType,
      triggerValue: triggerValue ?? this.triggerValue,
      content: content ?? this.content,
      isActive: isActive ?? this.isActive,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (channel.present) {
      map['channel'] = Variable<String>(channel.value);
    }
    if (triggerType.present) {
      map['trigger_type'] = Variable<String>(triggerType.value);
    }
    if (triggerValue.present) {
      map['trigger_value'] = Variable<String>(triggerValue.value);
    }
    if (content.present) {
      map['content'] = Variable<String>(content.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('MarketingCampaignTableCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('channel: $channel, ')
          ..write('triggerType: $triggerType, ')
          ..write('triggerValue: $triggerValue, ')
          ..write('content: $content, ')
          ..write('isActive: $isActive, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class $CampaignRunHistoryTableTable extends CampaignRunHistoryTable
    with TableInfo<$CampaignRunHistoryTableTable, CampaignRunHistoryTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $CampaignRunHistoryTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _campaignUuidMeta =
      const VerificationMeta('campaignUuid');
  @override
  late final GeneratedColumn<String> campaignUuid = GeneratedColumn<String>(
      'campaign_uuid', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _customerUuidMeta =
      const VerificationMeta('customerUuid');
  @override
  late final GeneratedColumn<String> customerUuid = GeneratedColumn<String>(
      'customer_uuid', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
      'status', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _sentAtMeta = const VerificationMeta('sentAt');
  @override
  late final GeneratedColumn<DateTime> sentAt = GeneratedColumn<DateTime>(
      'sent_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _errorMessageMeta =
      const VerificationMeta('errorMessage');
  @override
  late final GeneratedColumn<String> errorMessage = GeneratedColumn<String>(
      'error_message', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns =>
      [id, uuid, campaignUuid, customerUuid, status, sentAt, errorMessage];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'campaign_run_history_table';
  @override
  VerificationContext validateIntegrity(
      Insertable<CampaignRunHistoryTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('campaign_uuid')) {
      context.handle(
          _campaignUuidMeta,
          campaignUuid.isAcceptableOrUnknown(
              data['campaign_uuid']!, _campaignUuidMeta));
    } else if (isInserting) {
      context.missing(_campaignUuidMeta);
    }
    if (data.containsKey('customer_uuid')) {
      context.handle(
          _customerUuidMeta,
          customerUuid.isAcceptableOrUnknown(
              data['customer_uuid']!, _customerUuidMeta));
    } else if (isInserting) {
      context.missing(_customerUuidMeta);
    }
    if (data.containsKey('status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['status']!, _statusMeta));
    } else if (isInserting) {
      context.missing(_statusMeta);
    }
    if (data.containsKey('sent_at')) {
      context.handle(_sentAtMeta,
          sentAt.isAcceptableOrUnknown(data['sent_at']!, _sentAtMeta));
    } else if (isInserting) {
      context.missing(_sentAtMeta);
    }
    if (data.containsKey('error_message')) {
      context.handle(
          _errorMessageMeta,
          errorMessage.isAcceptableOrUnknown(
              data['error_message']!, _errorMessageMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  CampaignRunHistoryTableData map(Map<String, dynamic> data,
      {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return CampaignRunHistoryTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      campaignUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}campaign_uuid'])!,
      customerUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}customer_uuid'])!,
      status: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}status'])!,
      sentAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}sent_at'])!,
      errorMessage: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}error_message']),
    );
  }

  @override
  $CampaignRunHistoryTableTable createAlias(String alias) {
    return $CampaignRunHistoryTableTable(attachedDatabase, alias);
  }
}

class CampaignRunHistoryTableData extends DataClass
    implements Insertable<CampaignRunHistoryTableData> {
  final int id;
  final String uuid;
  final String campaignUuid;
  final String customerUuid;
  final String status;
  final DateTime sentAt;
  final String? errorMessage;
  const CampaignRunHistoryTableData(
      {required this.id,
      required this.uuid,
      required this.campaignUuid,
      required this.customerUuid,
      required this.status,
      required this.sentAt,
      this.errorMessage});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    map['campaign_uuid'] = Variable<String>(campaignUuid);
    map['customer_uuid'] = Variable<String>(customerUuid);
    map['status'] = Variable<String>(status);
    map['sent_at'] = Variable<DateTime>(sentAt);
    if (!nullToAbsent || errorMessage != null) {
      map['error_message'] = Variable<String>(errorMessage);
    }
    return map;
  }

  CampaignRunHistoryTableCompanion toCompanion(bool nullToAbsent) {
    return CampaignRunHistoryTableCompanion(
      id: Value(id),
      uuid: Value(uuid),
      campaignUuid: Value(campaignUuid),
      customerUuid: Value(customerUuid),
      status: Value(status),
      sentAt: Value(sentAt),
      errorMessage: errorMessage == null && nullToAbsent
          ? const Value.absent()
          : Value(errorMessage),
    );
  }

  factory CampaignRunHistoryTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return CampaignRunHistoryTableData(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      campaignUuid: serializer.fromJson<String>(json['campaignUuid']),
      customerUuid: serializer.fromJson<String>(json['customerUuid']),
      status: serializer.fromJson<String>(json['status']),
      sentAt: serializer.fromJson<DateTime>(json['sentAt']),
      errorMessage: serializer.fromJson<String?>(json['errorMessage']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'campaignUuid': serializer.toJson<String>(campaignUuid),
      'customerUuid': serializer.toJson<String>(customerUuid),
      'status': serializer.toJson<String>(status),
      'sentAt': serializer.toJson<DateTime>(sentAt),
      'errorMessage': serializer.toJson<String?>(errorMessage),
    };
  }

  CampaignRunHistoryTableData copyWith(
          {int? id,
          String? uuid,
          String? campaignUuid,
          String? customerUuid,
          String? status,
          DateTime? sentAt,
          Value<String?> errorMessage = const Value.absent()}) =>
      CampaignRunHistoryTableData(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        campaignUuid: campaignUuid ?? this.campaignUuid,
        customerUuid: customerUuid ?? this.customerUuid,
        status: status ?? this.status,
        sentAt: sentAt ?? this.sentAt,
        errorMessage:
            errorMessage.present ? errorMessage.value : this.errorMessage,
      );
  CampaignRunHistoryTableData copyWithCompanion(
      CampaignRunHistoryTableCompanion data) {
    return CampaignRunHistoryTableData(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      campaignUuid: data.campaignUuid.present
          ? data.campaignUuid.value
          : this.campaignUuid,
      customerUuid: data.customerUuid.present
          ? data.customerUuid.value
          : this.customerUuid,
      status: data.status.present ? data.status.value : this.status,
      sentAt: data.sentAt.present ? data.sentAt.value : this.sentAt,
      errorMessage: data.errorMessage.present
          ? data.errorMessage.value
          : this.errorMessage,
    );
  }

  @override
  String toString() {
    return (StringBuffer('CampaignRunHistoryTableData(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('campaignUuid: $campaignUuid, ')
          ..write('customerUuid: $customerUuid, ')
          ..write('status: $status, ')
          ..write('sentAt: $sentAt, ')
          ..write('errorMessage: $errorMessage')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id, uuid, campaignUuid, customerUuid, status, sentAt, errorMessage);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is CampaignRunHistoryTableData &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.campaignUuid == this.campaignUuid &&
          other.customerUuid == this.customerUuid &&
          other.status == this.status &&
          other.sentAt == this.sentAt &&
          other.errorMessage == this.errorMessage);
}

class CampaignRunHistoryTableCompanion
    extends UpdateCompanion<CampaignRunHistoryTableData> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String> campaignUuid;
  final Value<String> customerUuid;
  final Value<String> status;
  final Value<DateTime> sentAt;
  final Value<String?> errorMessage;
  const CampaignRunHistoryTableCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.campaignUuid = const Value.absent(),
    this.customerUuid = const Value.absent(),
    this.status = const Value.absent(),
    this.sentAt = const Value.absent(),
    this.errorMessage = const Value.absent(),
  });
  CampaignRunHistoryTableCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    required String campaignUuid,
    required String customerUuid,
    required String status,
    required DateTime sentAt,
    this.errorMessage = const Value.absent(),
  })  : uuid = Value(uuid),
        campaignUuid = Value(campaignUuid),
        customerUuid = Value(customerUuid),
        status = Value(status),
        sentAt = Value(sentAt);
  static Insertable<CampaignRunHistoryTableData> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? campaignUuid,
    Expression<String>? customerUuid,
    Expression<String>? status,
    Expression<DateTime>? sentAt,
    Expression<String>? errorMessage,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (campaignUuid != null) 'campaign_uuid': campaignUuid,
      if (customerUuid != null) 'customer_uuid': customerUuid,
      if (status != null) 'status': status,
      if (sentAt != null) 'sent_at': sentAt,
      if (errorMessage != null) 'error_message': errorMessage,
    });
  }

  CampaignRunHistoryTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String>? campaignUuid,
      Value<String>? customerUuid,
      Value<String>? status,
      Value<DateTime>? sentAt,
      Value<String?>? errorMessage}) {
    return CampaignRunHistoryTableCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      campaignUuid: campaignUuid ?? this.campaignUuid,
      customerUuid: customerUuid ?? this.customerUuid,
      status: status ?? this.status,
      sentAt: sentAt ?? this.sentAt,
      errorMessage: errorMessage ?? this.errorMessage,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (campaignUuid.present) {
      map['campaign_uuid'] = Variable<String>(campaignUuid.value);
    }
    if (customerUuid.present) {
      map['customer_uuid'] = Variable<String>(customerUuid.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (sentAt.present) {
      map['sent_at'] = Variable<DateTime>(sentAt.value);
    }
    if (errorMessage.present) {
      map['error_message'] = Variable<String>(errorMessage.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('CampaignRunHistoryTableCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('campaignUuid: $campaignUuid, ')
          ..write('customerUuid: $customerUuid, ')
          ..write('status: $status, ')
          ..write('sentAt: $sentAt, ')
          ..write('errorMessage: $errorMessage')
          ..write(')'))
        .toString();
  }
}

class $DeliveryChannelTableTable extends DeliveryChannelTable
    with TableInfo<$DeliveryChannelTableTable, DeliveryChannelTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $DeliveryChannelTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
      'id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _providerMeta =
      const VerificationMeta('provider');
  @override
  late final GeneratedColumn<String> provider = GeneratedColumn<String>(
      'provider', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _isActiveMeta =
      const VerificationMeta('isActive');
  @override
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
      'is_active', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_active" IN (0, 1))'),
      defaultValue: const Constant(true));
  static const VerificationMeta _autoAcceptOrdersMeta =
      const VerificationMeta('autoAcceptOrders');
  @override
  late final GeneratedColumn<bool> autoAcceptOrders = GeneratedColumn<bool>(
      'auto_accept_orders', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("auto_accept_orders" IN (0, 1))'),
      defaultValue: const Constant(true));
  static const VerificationMeta _surchargePercentMeta =
      const VerificationMeta('surchargePercent');
  @override
  late final GeneratedColumn<double> surchargePercent = GeneratedColumn<double>(
      'surcharge_percent', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: false,
      defaultValue: const Constant(0.0));
  static const VerificationMeta _lastSyncedAtMeta =
      const VerificationMeta('lastSyncedAt');
  @override
  late final GeneratedColumn<DateTime> lastSyncedAt = GeneratedColumn<DateTime>(
      'last_synced_at', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        provider,
        isActive,
        autoAcceptOrders,
        surchargePercent,
        lastSyncedAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'delivery_channel_table';
  @override
  VerificationContext validateIntegrity(
      Insertable<DeliveryChannelTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('provider')) {
      context.handle(_providerMeta,
          provider.isAcceptableOrUnknown(data['provider']!, _providerMeta));
    } else if (isInserting) {
      context.missing(_providerMeta);
    }
    if (data.containsKey('is_active')) {
      context.handle(_isActiveMeta,
          isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta));
    }
    if (data.containsKey('auto_accept_orders')) {
      context.handle(
          _autoAcceptOrdersMeta,
          autoAcceptOrders.isAcceptableOrUnknown(
              data['auto_accept_orders']!, _autoAcceptOrdersMeta));
    }
    if (data.containsKey('surcharge_percent')) {
      context.handle(
          _surchargePercentMeta,
          surchargePercent.isAcceptableOrUnknown(
              data['surcharge_percent']!, _surchargePercentMeta));
    }
    if (data.containsKey('last_synced_at')) {
      context.handle(
          _lastSyncedAtMeta,
          lastSyncedAt.isAcceptableOrUnknown(
              data['last_synced_at']!, _lastSyncedAtMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  DeliveryChannelTableData map(Map<String, dynamic> data,
      {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return DeliveryChannelTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}id'])!,
      provider: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}provider'])!,
      isActive: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_active'])!,
      autoAcceptOrders: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}auto_accept_orders'])!,
      surchargePercent: attachedDatabase.typeMapping.read(
          DriftSqlType.double, data['${effectivePrefix}surcharge_percent'])!,
      lastSyncedAt: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}last_synced_at']),
    );
  }

  @override
  $DeliveryChannelTableTable createAlias(String alias) {
    return $DeliveryChannelTableTable(attachedDatabase, alias);
  }
}

class DeliveryChannelTableData extends DataClass
    implements Insertable<DeliveryChannelTableData> {
  final String id;
  final String provider;
  final bool isActive;
  final bool autoAcceptOrders;
  final double surchargePercent;
  final DateTime? lastSyncedAt;
  const DeliveryChannelTableData(
      {required this.id,
      required this.provider,
      required this.isActive,
      required this.autoAcceptOrders,
      required this.surchargePercent,
      this.lastSyncedAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['provider'] = Variable<String>(provider);
    map['is_active'] = Variable<bool>(isActive);
    map['auto_accept_orders'] = Variable<bool>(autoAcceptOrders);
    map['surcharge_percent'] = Variable<double>(surchargePercent);
    if (!nullToAbsent || lastSyncedAt != null) {
      map['last_synced_at'] = Variable<DateTime>(lastSyncedAt);
    }
    return map;
  }

  DeliveryChannelTableCompanion toCompanion(bool nullToAbsent) {
    return DeliveryChannelTableCompanion(
      id: Value(id),
      provider: Value(provider),
      isActive: Value(isActive),
      autoAcceptOrders: Value(autoAcceptOrders),
      surchargePercent: Value(surchargePercent),
      lastSyncedAt: lastSyncedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSyncedAt),
    );
  }

  factory DeliveryChannelTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return DeliveryChannelTableData(
      id: serializer.fromJson<String>(json['id']),
      provider: serializer.fromJson<String>(json['provider']),
      isActive: serializer.fromJson<bool>(json['isActive']),
      autoAcceptOrders: serializer.fromJson<bool>(json['autoAcceptOrders']),
      surchargePercent: serializer.fromJson<double>(json['surchargePercent']),
      lastSyncedAt: serializer.fromJson<DateTime?>(json['lastSyncedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'provider': serializer.toJson<String>(provider),
      'isActive': serializer.toJson<bool>(isActive),
      'autoAcceptOrders': serializer.toJson<bool>(autoAcceptOrders),
      'surchargePercent': serializer.toJson<double>(surchargePercent),
      'lastSyncedAt': serializer.toJson<DateTime?>(lastSyncedAt),
    };
  }

  DeliveryChannelTableData copyWith(
          {String? id,
          String? provider,
          bool? isActive,
          bool? autoAcceptOrders,
          double? surchargePercent,
          Value<DateTime?> lastSyncedAt = const Value.absent()}) =>
      DeliveryChannelTableData(
        id: id ?? this.id,
        provider: provider ?? this.provider,
        isActive: isActive ?? this.isActive,
        autoAcceptOrders: autoAcceptOrders ?? this.autoAcceptOrders,
        surchargePercent: surchargePercent ?? this.surchargePercent,
        lastSyncedAt:
            lastSyncedAt.present ? lastSyncedAt.value : this.lastSyncedAt,
      );
  DeliveryChannelTableData copyWithCompanion(
      DeliveryChannelTableCompanion data) {
    return DeliveryChannelTableData(
      id: data.id.present ? data.id.value : this.id,
      provider: data.provider.present ? data.provider.value : this.provider,
      isActive: data.isActive.present ? data.isActive.value : this.isActive,
      autoAcceptOrders: data.autoAcceptOrders.present
          ? data.autoAcceptOrders.value
          : this.autoAcceptOrders,
      surchargePercent: data.surchargePercent.present
          ? data.surchargePercent.value
          : this.surchargePercent,
      lastSyncedAt: data.lastSyncedAt.present
          ? data.lastSyncedAt.value
          : this.lastSyncedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('DeliveryChannelTableData(')
          ..write('id: $id, ')
          ..write('provider: $provider, ')
          ..write('isActive: $isActive, ')
          ..write('autoAcceptOrders: $autoAcceptOrders, ')
          ..write('surchargePercent: $surchargePercent, ')
          ..write('lastSyncedAt: $lastSyncedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id, provider, isActive, autoAcceptOrders, surchargePercent, lastSyncedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is DeliveryChannelTableData &&
          other.id == this.id &&
          other.provider == this.provider &&
          other.isActive == this.isActive &&
          other.autoAcceptOrders == this.autoAcceptOrders &&
          other.surchargePercent == this.surchargePercent &&
          other.lastSyncedAt == this.lastSyncedAt);
}

class DeliveryChannelTableCompanion
    extends UpdateCompanion<DeliveryChannelTableData> {
  final Value<String> id;
  final Value<String> provider;
  final Value<bool> isActive;
  final Value<bool> autoAcceptOrders;
  final Value<double> surchargePercent;
  final Value<DateTime?> lastSyncedAt;
  final Value<int> rowid;
  const DeliveryChannelTableCompanion({
    this.id = const Value.absent(),
    this.provider = const Value.absent(),
    this.isActive = const Value.absent(),
    this.autoAcceptOrders = const Value.absent(),
    this.surchargePercent = const Value.absent(),
    this.lastSyncedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  DeliveryChannelTableCompanion.insert({
    required String id,
    required String provider,
    this.isActive = const Value.absent(),
    this.autoAcceptOrders = const Value.absent(),
    this.surchargePercent = const Value.absent(),
    this.lastSyncedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  })  : id = Value(id),
        provider = Value(provider);
  static Insertable<DeliveryChannelTableData> custom({
    Expression<String>? id,
    Expression<String>? provider,
    Expression<bool>? isActive,
    Expression<bool>? autoAcceptOrders,
    Expression<double>? surchargePercent,
    Expression<DateTime>? lastSyncedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (provider != null) 'provider': provider,
      if (isActive != null) 'is_active': isActive,
      if (autoAcceptOrders != null) 'auto_accept_orders': autoAcceptOrders,
      if (surchargePercent != null) 'surcharge_percent': surchargePercent,
      if (lastSyncedAt != null) 'last_synced_at': lastSyncedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  DeliveryChannelTableCompanion copyWith(
      {Value<String>? id,
      Value<String>? provider,
      Value<bool>? isActive,
      Value<bool>? autoAcceptOrders,
      Value<double>? surchargePercent,
      Value<DateTime?>? lastSyncedAt,
      Value<int>? rowid}) {
    return DeliveryChannelTableCompanion(
      id: id ?? this.id,
      provider: provider ?? this.provider,
      isActive: isActive ?? this.isActive,
      autoAcceptOrders: autoAcceptOrders ?? this.autoAcceptOrders,
      surchargePercent: surchargePercent ?? this.surchargePercent,
      lastSyncedAt: lastSyncedAt ?? this.lastSyncedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (provider.present) {
      map['provider'] = Variable<String>(provider.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (autoAcceptOrders.present) {
      map['auto_accept_orders'] = Variable<bool>(autoAcceptOrders.value);
    }
    if (surchargePercent.present) {
      map['surcharge_percent'] = Variable<double>(surchargePercent.value);
    }
    if (lastSyncedAt.present) {
      map['last_synced_at'] = Variable<DateTime>(lastSyncedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('DeliveryChannelTableCompanion(')
          ..write('id: $id, ')
          ..write('provider: $provider, ')
          ..write('isActive: $isActive, ')
          ..write('autoAcceptOrders: $autoAcceptOrders, ')
          ..write('surchargePercent: $surchargePercent, ')
          ..write('lastSyncedAt: $lastSyncedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $DeliveryOrderMetadataTableTable extends DeliveryOrderMetadataTable
    with
        TableInfo<$DeliveryOrderMetadataTableTable,
            DeliveryOrderMetadataTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $DeliveryOrderMetadataTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _orderUuidMeta =
      const VerificationMeta('orderUuid');
  @override
  late final GeneratedColumn<String> orderUuid = GeneratedColumn<String>(
      'order_uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES order_table (uuid) ON DELETE CASCADE'));
  static const VerificationMeta _providerMeta =
      const VerificationMeta('provider');
  @override
  late final GeneratedColumn<String> provider = GeneratedColumn<String>(
      'provider', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _externalOrderIdMeta =
      const VerificationMeta('externalOrderId');
  @override
  late final GeneratedColumn<String> externalOrderId = GeneratedColumn<String>(
      'external_order_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _driverNameMeta =
      const VerificationMeta('driverName');
  @override
  late final GeneratedColumn<String> driverName = GeneratedColumn<String>(
      'driver_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _driverPhoneMeta =
      const VerificationMeta('driverPhone');
  @override
  late final GeneratedColumn<String> driverPhone = GeneratedColumn<String>(
      'driver_phone', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _driverPlateMeta =
      const VerificationMeta('driverPlate');
  @override
  late final GeneratedColumn<String> driverPlate = GeneratedColumn<String>(
      'driver_plate', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _pickupTimeMeta =
      const VerificationMeta('pickupTime');
  @override
  late final GeneratedColumn<DateTime> pickupTime = GeneratedColumn<DateTime>(
      'pickup_time', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _deliveryStatusMeta =
      const VerificationMeta('deliveryStatus');
  @override
  late final GeneratedColumn<String> deliveryStatus = GeneratedColumn<String>(
      'delivery_status', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultValue: const Constant('NEW'));
  @override
  List<GeneratedColumn> get $columns => [
        id,
        orderUuid,
        provider,
        externalOrderId,
        driverName,
        driverPhone,
        driverPlate,
        pickupTime,
        deliveryStatus
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'delivery_order_metadata_table';
  @override
  VerificationContext validateIntegrity(
      Insertable<DeliveryOrderMetadataTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('order_uuid')) {
      context.handle(_orderUuidMeta,
          orderUuid.isAcceptableOrUnknown(data['order_uuid']!, _orderUuidMeta));
    } else if (isInserting) {
      context.missing(_orderUuidMeta);
    }
    if (data.containsKey('provider')) {
      context.handle(_providerMeta,
          provider.isAcceptableOrUnknown(data['provider']!, _providerMeta));
    } else if (isInserting) {
      context.missing(_providerMeta);
    }
    if (data.containsKey('external_order_id')) {
      context.handle(
          _externalOrderIdMeta,
          externalOrderId.isAcceptableOrUnknown(
              data['external_order_id']!, _externalOrderIdMeta));
    } else if (isInserting) {
      context.missing(_externalOrderIdMeta);
    }
    if (data.containsKey('driver_name')) {
      context.handle(
          _driverNameMeta,
          driverName.isAcceptableOrUnknown(
              data['driver_name']!, _driverNameMeta));
    }
    if (data.containsKey('driver_phone')) {
      context.handle(
          _driverPhoneMeta,
          driverPhone.isAcceptableOrUnknown(
              data['driver_phone']!, _driverPhoneMeta));
    }
    if (data.containsKey('driver_plate')) {
      context.handle(
          _driverPlateMeta,
          driverPlate.isAcceptableOrUnknown(
              data['driver_plate']!, _driverPlateMeta));
    }
    if (data.containsKey('pickup_time')) {
      context.handle(
          _pickupTimeMeta,
          pickupTime.isAcceptableOrUnknown(
              data['pickup_time']!, _pickupTimeMeta));
    }
    if (data.containsKey('delivery_status')) {
      context.handle(
          _deliveryStatusMeta,
          deliveryStatus.isAcceptableOrUnknown(
              data['delivery_status']!, _deliveryStatusMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
        {provider, externalOrderId},
      ];
  @override
  DeliveryOrderMetadataTableData map(Map<String, dynamic> data,
      {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return DeliveryOrderMetadataTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      orderUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}order_uuid'])!,
      provider: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}provider'])!,
      externalOrderId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}external_order_id'])!,
      driverName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}driver_name']),
      driverPhone: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}driver_phone']),
      driverPlate: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}driver_plate']),
      pickupTime: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}pickup_time']),
      deliveryStatus: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}delivery_status'])!,
    );
  }

  @override
  $DeliveryOrderMetadataTableTable createAlias(String alias) {
    return $DeliveryOrderMetadataTableTable(attachedDatabase, alias);
  }
}

class DeliveryOrderMetadataTableData extends DataClass
    implements Insertable<DeliveryOrderMetadataTableData> {
  final int id;
  final String orderUuid;
  final String provider;
  final String externalOrderId;
  final String? driverName;
  final String? driverPhone;
  final String? driverPlate;
  final DateTime? pickupTime;
  final String deliveryStatus;
  const DeliveryOrderMetadataTableData(
      {required this.id,
      required this.orderUuid,
      required this.provider,
      required this.externalOrderId,
      this.driverName,
      this.driverPhone,
      this.driverPlate,
      this.pickupTime,
      required this.deliveryStatus});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['order_uuid'] = Variable<String>(orderUuid);
    map['provider'] = Variable<String>(provider);
    map['external_order_id'] = Variable<String>(externalOrderId);
    if (!nullToAbsent || driverName != null) {
      map['driver_name'] = Variable<String>(driverName);
    }
    if (!nullToAbsent || driverPhone != null) {
      map['driver_phone'] = Variable<String>(driverPhone);
    }
    if (!nullToAbsent || driverPlate != null) {
      map['driver_plate'] = Variable<String>(driverPlate);
    }
    if (!nullToAbsent || pickupTime != null) {
      map['pickup_time'] = Variable<DateTime>(pickupTime);
    }
    map['delivery_status'] = Variable<String>(deliveryStatus);
    return map;
  }

  DeliveryOrderMetadataTableCompanion toCompanion(bool nullToAbsent) {
    return DeliveryOrderMetadataTableCompanion(
      id: Value(id),
      orderUuid: Value(orderUuid),
      provider: Value(provider),
      externalOrderId: Value(externalOrderId),
      driverName: driverName == null && nullToAbsent
          ? const Value.absent()
          : Value(driverName),
      driverPhone: driverPhone == null && nullToAbsent
          ? const Value.absent()
          : Value(driverPhone),
      driverPlate: driverPlate == null && nullToAbsent
          ? const Value.absent()
          : Value(driverPlate),
      pickupTime: pickupTime == null && nullToAbsent
          ? const Value.absent()
          : Value(pickupTime),
      deliveryStatus: Value(deliveryStatus),
    );
  }

  factory DeliveryOrderMetadataTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return DeliveryOrderMetadataTableData(
      id: serializer.fromJson<int>(json['id']),
      orderUuid: serializer.fromJson<String>(json['orderUuid']),
      provider: serializer.fromJson<String>(json['provider']),
      externalOrderId: serializer.fromJson<String>(json['externalOrderId']),
      driverName: serializer.fromJson<String?>(json['driverName']),
      driverPhone: serializer.fromJson<String?>(json['driverPhone']),
      driverPlate: serializer.fromJson<String?>(json['driverPlate']),
      pickupTime: serializer.fromJson<DateTime?>(json['pickupTime']),
      deliveryStatus: serializer.fromJson<String>(json['deliveryStatus']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'orderUuid': serializer.toJson<String>(orderUuid),
      'provider': serializer.toJson<String>(provider),
      'externalOrderId': serializer.toJson<String>(externalOrderId),
      'driverName': serializer.toJson<String?>(driverName),
      'driverPhone': serializer.toJson<String?>(driverPhone),
      'driverPlate': serializer.toJson<String?>(driverPlate),
      'pickupTime': serializer.toJson<DateTime?>(pickupTime),
      'deliveryStatus': serializer.toJson<String>(deliveryStatus),
    };
  }

  DeliveryOrderMetadataTableData copyWith(
          {int? id,
          String? orderUuid,
          String? provider,
          String? externalOrderId,
          Value<String?> driverName = const Value.absent(),
          Value<String?> driverPhone = const Value.absent(),
          Value<String?> driverPlate = const Value.absent(),
          Value<DateTime?> pickupTime = const Value.absent(),
          String? deliveryStatus}) =>
      DeliveryOrderMetadataTableData(
        id: id ?? this.id,
        orderUuid: orderUuid ?? this.orderUuid,
        provider: provider ?? this.provider,
        externalOrderId: externalOrderId ?? this.externalOrderId,
        driverName: driverName.present ? driverName.value : this.driverName,
        driverPhone: driverPhone.present ? driverPhone.value : this.driverPhone,
        driverPlate: driverPlate.present ? driverPlate.value : this.driverPlate,
        pickupTime: pickupTime.present ? pickupTime.value : this.pickupTime,
        deliveryStatus: deliveryStatus ?? this.deliveryStatus,
      );
  DeliveryOrderMetadataTableData copyWithCompanion(
      DeliveryOrderMetadataTableCompanion data) {
    return DeliveryOrderMetadataTableData(
      id: data.id.present ? data.id.value : this.id,
      orderUuid: data.orderUuid.present ? data.orderUuid.value : this.orderUuid,
      provider: data.provider.present ? data.provider.value : this.provider,
      externalOrderId: data.externalOrderId.present
          ? data.externalOrderId.value
          : this.externalOrderId,
      driverName:
          data.driverName.present ? data.driverName.value : this.driverName,
      driverPhone:
          data.driverPhone.present ? data.driverPhone.value : this.driverPhone,
      driverPlate:
          data.driverPlate.present ? data.driverPlate.value : this.driverPlate,
      pickupTime:
          data.pickupTime.present ? data.pickupTime.value : this.pickupTime,
      deliveryStatus: data.deliveryStatus.present
          ? data.deliveryStatus.value
          : this.deliveryStatus,
    );
  }

  @override
  String toString() {
    return (StringBuffer('DeliveryOrderMetadataTableData(')
          ..write('id: $id, ')
          ..write('orderUuid: $orderUuid, ')
          ..write('provider: $provider, ')
          ..write('externalOrderId: $externalOrderId, ')
          ..write('driverName: $driverName, ')
          ..write('driverPhone: $driverPhone, ')
          ..write('driverPlate: $driverPlate, ')
          ..write('pickupTime: $pickupTime, ')
          ..write('deliveryStatus: $deliveryStatus')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, orderUuid, provider, externalOrderId,
      driverName, driverPhone, driverPlate, pickupTime, deliveryStatus);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is DeliveryOrderMetadataTableData &&
          other.id == this.id &&
          other.orderUuid == this.orderUuid &&
          other.provider == this.provider &&
          other.externalOrderId == this.externalOrderId &&
          other.driverName == this.driverName &&
          other.driverPhone == this.driverPhone &&
          other.driverPlate == this.driverPlate &&
          other.pickupTime == this.pickupTime &&
          other.deliveryStatus == this.deliveryStatus);
}

class DeliveryOrderMetadataTableCompanion
    extends UpdateCompanion<DeliveryOrderMetadataTableData> {
  final Value<int> id;
  final Value<String> orderUuid;
  final Value<String> provider;
  final Value<String> externalOrderId;
  final Value<String?> driverName;
  final Value<String?> driverPhone;
  final Value<String?> driverPlate;
  final Value<DateTime?> pickupTime;
  final Value<String> deliveryStatus;
  const DeliveryOrderMetadataTableCompanion({
    this.id = const Value.absent(),
    this.orderUuid = const Value.absent(),
    this.provider = const Value.absent(),
    this.externalOrderId = const Value.absent(),
    this.driverName = const Value.absent(),
    this.driverPhone = const Value.absent(),
    this.driverPlate = const Value.absent(),
    this.pickupTime = const Value.absent(),
    this.deliveryStatus = const Value.absent(),
  });
  DeliveryOrderMetadataTableCompanion.insert({
    this.id = const Value.absent(),
    required String orderUuid,
    required String provider,
    required String externalOrderId,
    this.driverName = const Value.absent(),
    this.driverPhone = const Value.absent(),
    this.driverPlate = const Value.absent(),
    this.pickupTime = const Value.absent(),
    this.deliveryStatus = const Value.absent(),
  })  : orderUuid = Value(orderUuid),
        provider = Value(provider),
        externalOrderId = Value(externalOrderId);
  static Insertable<DeliveryOrderMetadataTableData> custom({
    Expression<int>? id,
    Expression<String>? orderUuid,
    Expression<String>? provider,
    Expression<String>? externalOrderId,
    Expression<String>? driverName,
    Expression<String>? driverPhone,
    Expression<String>? driverPlate,
    Expression<DateTime>? pickupTime,
    Expression<String>? deliveryStatus,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (orderUuid != null) 'order_uuid': orderUuid,
      if (provider != null) 'provider': provider,
      if (externalOrderId != null) 'external_order_id': externalOrderId,
      if (driverName != null) 'driver_name': driverName,
      if (driverPhone != null) 'driver_phone': driverPhone,
      if (driverPlate != null) 'driver_plate': driverPlate,
      if (pickupTime != null) 'pickup_time': pickupTime,
      if (deliveryStatus != null) 'delivery_status': deliveryStatus,
    });
  }

  DeliveryOrderMetadataTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? orderUuid,
      Value<String>? provider,
      Value<String>? externalOrderId,
      Value<String?>? driverName,
      Value<String?>? driverPhone,
      Value<String?>? driverPlate,
      Value<DateTime?>? pickupTime,
      Value<String>? deliveryStatus}) {
    return DeliveryOrderMetadataTableCompanion(
      id: id ?? this.id,
      orderUuid: orderUuid ?? this.orderUuid,
      provider: provider ?? this.provider,
      externalOrderId: externalOrderId ?? this.externalOrderId,
      driverName: driverName ?? this.driverName,
      driverPhone: driverPhone ?? this.driverPhone,
      driverPlate: driverPlate ?? this.driverPlate,
      pickupTime: pickupTime ?? this.pickupTime,
      deliveryStatus: deliveryStatus ?? this.deliveryStatus,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (orderUuid.present) {
      map['order_uuid'] = Variable<String>(orderUuid.value);
    }
    if (provider.present) {
      map['provider'] = Variable<String>(provider.value);
    }
    if (externalOrderId.present) {
      map['external_order_id'] = Variable<String>(externalOrderId.value);
    }
    if (driverName.present) {
      map['driver_name'] = Variable<String>(driverName.value);
    }
    if (driverPhone.present) {
      map['driver_phone'] = Variable<String>(driverPhone.value);
    }
    if (driverPlate.present) {
      map['driver_plate'] = Variable<String>(driverPlate.value);
    }
    if (pickupTime.present) {
      map['pickup_time'] = Variable<DateTime>(pickupTime.value);
    }
    if (deliveryStatus.present) {
      map['delivery_status'] = Variable<String>(deliveryStatus.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('DeliveryOrderMetadataTableCompanion(')
          ..write('id: $id, ')
          ..write('orderUuid: $orderUuid, ')
          ..write('provider: $provider, ')
          ..write('externalOrderId: $externalOrderId, ')
          ..write('driverName: $driverName, ')
          ..write('driverPhone: $driverPhone, ')
          ..write('driverPlate: $driverPlate, ')
          ..write('pickupTime: $pickupTime, ')
          ..write('deliveryStatus: $deliveryStatus')
          ..write(')'))
        .toString();
  }
}

class $CashDrawerTableTable extends CashDrawerTable
    with TableInfo<$CashDrawerTableTable, CashDrawerTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $CashDrawerTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _shiftUuidMeta =
      const VerificationMeta('shiftUuid');
  @override
  late final GeneratedColumn<String> shiftUuid = GeneratedColumn<String>(
      'shift_uuid', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _employeeUuidMeta =
      const VerificationMeta('employeeUuid');
  @override
  late final GeneratedColumn<String> employeeUuid = GeneratedColumn<String>(
      'employee_uuid', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _employeeNameMeta =
      const VerificationMeta('employeeName');
  @override
  late final GeneratedColumn<String> employeeName = GeneratedColumn<String>(
      'employee_name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _startingBalanceMeta =
      const VerificationMeta('startingBalance');
  @override
  late final GeneratedColumn<double> startingBalance = GeneratedColumn<double>(
      'starting_balance', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _currentBalanceMeta =
      const VerificationMeta('currentBalance');
  @override
  late final GeneratedColumn<double> currentBalance = GeneratedColumn<double>(
      'current_balance', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _expectedBalanceMeta =
      const VerificationMeta('expectedBalance');
  @override
  late final GeneratedColumn<double> expectedBalance = GeneratedColumn<double>(
      'expected_balance', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _stateMeta = const VerificationMeta('state');
  @override
  late final GeneratedColumn<String> state = GeneratedColumn<String>(
      'state', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultValue: const Constant('open'));
  static const VerificationMeta _openedAtMeta =
      const VerificationMeta('openedAt');
  @override
  late final GeneratedColumn<DateTime> openedAt = GeneratedColumn<DateTime>(
      'opened_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _closedAtMeta =
      const VerificationMeta('closedAt');
  @override
  late final GeneratedColumn<DateTime> closedAt = GeneratedColumn<DateTime>(
      'closed_at', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _closingBalanceMeta =
      const VerificationMeta('closingBalance');
  @override
  late final GeneratedColumn<double> closingBalance = GeneratedColumn<double>(
      'closing_balance', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _varianceMeta =
      const VerificationMeta('variance');
  @override
  late final GeneratedColumn<double> variance = GeneratedColumn<double>(
      'variance', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        shiftUuid,
        employeeUuid,
        employeeName,
        startingBalance,
        currentBalance,
        expectedBalance,
        state,
        openedAt,
        closedAt,
        closingBalance,
        variance
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'cash_drawer_table';
  @override
  VerificationContext validateIntegrity(
      Insertable<CashDrawerTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('shift_uuid')) {
      context.handle(_shiftUuidMeta,
          shiftUuid.isAcceptableOrUnknown(data['shift_uuid']!, _shiftUuidMeta));
    } else if (isInserting) {
      context.missing(_shiftUuidMeta);
    }
    if (data.containsKey('employee_uuid')) {
      context.handle(
          _employeeUuidMeta,
          employeeUuid.isAcceptableOrUnknown(
              data['employee_uuid']!, _employeeUuidMeta));
    } else if (isInserting) {
      context.missing(_employeeUuidMeta);
    }
    if (data.containsKey('employee_name')) {
      context.handle(
          _employeeNameMeta,
          employeeName.isAcceptableOrUnknown(
              data['employee_name']!, _employeeNameMeta));
    } else if (isInserting) {
      context.missing(_employeeNameMeta);
    }
    if (data.containsKey('starting_balance')) {
      context.handle(
          _startingBalanceMeta,
          startingBalance.isAcceptableOrUnknown(
              data['starting_balance']!, _startingBalanceMeta));
    } else if (isInserting) {
      context.missing(_startingBalanceMeta);
    }
    if (data.containsKey('current_balance')) {
      context.handle(
          _currentBalanceMeta,
          currentBalance.isAcceptableOrUnknown(
              data['current_balance']!, _currentBalanceMeta));
    } else if (isInserting) {
      context.missing(_currentBalanceMeta);
    }
    if (data.containsKey('expected_balance')) {
      context.handle(
          _expectedBalanceMeta,
          expectedBalance.isAcceptableOrUnknown(
              data['expected_balance']!, _expectedBalanceMeta));
    } else if (isInserting) {
      context.missing(_expectedBalanceMeta);
    }
    if (data.containsKey('state')) {
      context.handle(
          _stateMeta, state.isAcceptableOrUnknown(data['state']!, _stateMeta));
    }
    if (data.containsKey('opened_at')) {
      context.handle(_openedAtMeta,
          openedAt.isAcceptableOrUnknown(data['opened_at']!, _openedAtMeta));
    } else if (isInserting) {
      context.missing(_openedAtMeta);
    }
    if (data.containsKey('closed_at')) {
      context.handle(_closedAtMeta,
          closedAt.isAcceptableOrUnknown(data['closed_at']!, _closedAtMeta));
    }
    if (data.containsKey('closing_balance')) {
      context.handle(
          _closingBalanceMeta,
          closingBalance.isAcceptableOrUnknown(
              data['closing_balance']!, _closingBalanceMeta));
    }
    if (data.containsKey('variance')) {
      context.handle(_varianceMeta,
          variance.isAcceptableOrUnknown(data['variance']!, _varianceMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  CashDrawerTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return CashDrawerTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      shiftUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}shift_uuid'])!,
      employeeUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}employee_uuid'])!,
      employeeName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}employee_name'])!,
      startingBalance: attachedDatabase.typeMapping.read(
          DriftSqlType.double, data['${effectivePrefix}starting_balance'])!,
      currentBalance: attachedDatabase.typeMapping.read(
          DriftSqlType.double, data['${effectivePrefix}current_balance'])!,
      expectedBalance: attachedDatabase.typeMapping.read(
          DriftSqlType.double, data['${effectivePrefix}expected_balance'])!,
      state: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}state'])!,
      openedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}opened_at'])!,
      closedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}closed_at']),
      closingBalance: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}closing_balance']),
      variance: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}variance']),
    );
  }

  @override
  $CashDrawerTableTable createAlias(String alias) {
    return $CashDrawerTableTable(attachedDatabase, alias);
  }
}

class CashDrawerTableData extends DataClass
    implements Insertable<CashDrawerTableData> {
  final int id;
  final String uuid;
  final String shiftUuid;
  final String employeeUuid;
  final String employeeName;
  final double startingBalance;
  final double currentBalance;
  final double expectedBalance;
  final String state;
  final DateTime openedAt;
  final DateTime? closedAt;
  final double? closingBalance;
  final double? variance;
  const CashDrawerTableData(
      {required this.id,
      required this.uuid,
      required this.shiftUuid,
      required this.employeeUuid,
      required this.employeeName,
      required this.startingBalance,
      required this.currentBalance,
      required this.expectedBalance,
      required this.state,
      required this.openedAt,
      this.closedAt,
      this.closingBalance,
      this.variance});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    map['shift_uuid'] = Variable<String>(shiftUuid);
    map['employee_uuid'] = Variable<String>(employeeUuid);
    map['employee_name'] = Variable<String>(employeeName);
    map['starting_balance'] = Variable<double>(startingBalance);
    map['current_balance'] = Variable<double>(currentBalance);
    map['expected_balance'] = Variable<double>(expectedBalance);
    map['state'] = Variable<String>(state);
    map['opened_at'] = Variable<DateTime>(openedAt);
    if (!nullToAbsent || closedAt != null) {
      map['closed_at'] = Variable<DateTime>(closedAt);
    }
    if (!nullToAbsent || closingBalance != null) {
      map['closing_balance'] = Variable<double>(closingBalance);
    }
    if (!nullToAbsent || variance != null) {
      map['variance'] = Variable<double>(variance);
    }
    return map;
  }

  CashDrawerTableCompanion toCompanion(bool nullToAbsent) {
    return CashDrawerTableCompanion(
      id: Value(id),
      uuid: Value(uuid),
      shiftUuid: Value(shiftUuid),
      employeeUuid: Value(employeeUuid),
      employeeName: Value(employeeName),
      startingBalance: Value(startingBalance),
      currentBalance: Value(currentBalance),
      expectedBalance: Value(expectedBalance),
      state: Value(state),
      openedAt: Value(openedAt),
      closedAt: closedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(closedAt),
      closingBalance: closingBalance == null && nullToAbsent
          ? const Value.absent()
          : Value(closingBalance),
      variance: variance == null && nullToAbsent
          ? const Value.absent()
          : Value(variance),
    );
  }

  factory CashDrawerTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return CashDrawerTableData(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      shiftUuid: serializer.fromJson<String>(json['shiftUuid']),
      employeeUuid: serializer.fromJson<String>(json['employeeUuid']),
      employeeName: serializer.fromJson<String>(json['employeeName']),
      startingBalance: serializer.fromJson<double>(json['startingBalance']),
      currentBalance: serializer.fromJson<double>(json['currentBalance']),
      expectedBalance: serializer.fromJson<double>(json['expectedBalance']),
      state: serializer.fromJson<String>(json['state']),
      openedAt: serializer.fromJson<DateTime>(json['openedAt']),
      closedAt: serializer.fromJson<DateTime?>(json['closedAt']),
      closingBalance: serializer.fromJson<double?>(json['closingBalance']),
      variance: serializer.fromJson<double?>(json['variance']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'shiftUuid': serializer.toJson<String>(shiftUuid),
      'employeeUuid': serializer.toJson<String>(employeeUuid),
      'employeeName': serializer.toJson<String>(employeeName),
      'startingBalance': serializer.toJson<double>(startingBalance),
      'currentBalance': serializer.toJson<double>(currentBalance),
      'expectedBalance': serializer.toJson<double>(expectedBalance),
      'state': serializer.toJson<String>(state),
      'openedAt': serializer.toJson<DateTime>(openedAt),
      'closedAt': serializer.toJson<DateTime?>(closedAt),
      'closingBalance': serializer.toJson<double?>(closingBalance),
      'variance': serializer.toJson<double?>(variance),
    };
  }

  CashDrawerTableData copyWith(
          {int? id,
          String? uuid,
          String? shiftUuid,
          String? employeeUuid,
          String? employeeName,
          double? startingBalance,
          double? currentBalance,
          double? expectedBalance,
          String? state,
          DateTime? openedAt,
          Value<DateTime?> closedAt = const Value.absent(),
          Value<double?> closingBalance = const Value.absent(),
          Value<double?> variance = const Value.absent()}) =>
      CashDrawerTableData(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        shiftUuid: shiftUuid ?? this.shiftUuid,
        employeeUuid: employeeUuid ?? this.employeeUuid,
        employeeName: employeeName ?? this.employeeName,
        startingBalance: startingBalance ?? this.startingBalance,
        currentBalance: currentBalance ?? this.currentBalance,
        expectedBalance: expectedBalance ?? this.expectedBalance,
        state: state ?? this.state,
        openedAt: openedAt ?? this.openedAt,
        closedAt: closedAt.present ? closedAt.value : this.closedAt,
        closingBalance:
            closingBalance.present ? closingBalance.value : this.closingBalance,
        variance: variance.present ? variance.value : this.variance,
      );
  CashDrawerTableData copyWithCompanion(CashDrawerTableCompanion data) {
    return CashDrawerTableData(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      shiftUuid: data.shiftUuid.present ? data.shiftUuid.value : this.shiftUuid,
      employeeUuid: data.employeeUuid.present
          ? data.employeeUuid.value
          : this.employeeUuid,
      employeeName: data.employeeName.present
          ? data.employeeName.value
          : this.employeeName,
      startingBalance: data.startingBalance.present
          ? data.startingBalance.value
          : this.startingBalance,
      currentBalance: data.currentBalance.present
          ? data.currentBalance.value
          : this.currentBalance,
      expectedBalance: data.expectedBalance.present
          ? data.expectedBalance.value
          : this.expectedBalance,
      state: data.state.present ? data.state.value : this.state,
      openedAt: data.openedAt.present ? data.openedAt.value : this.openedAt,
      closedAt: data.closedAt.present ? data.closedAt.value : this.closedAt,
      closingBalance: data.closingBalance.present
          ? data.closingBalance.value
          : this.closingBalance,
      variance: data.variance.present ? data.variance.value : this.variance,
    );
  }

  @override
  String toString() {
    return (StringBuffer('CashDrawerTableData(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('shiftUuid: $shiftUuid, ')
          ..write('employeeUuid: $employeeUuid, ')
          ..write('employeeName: $employeeName, ')
          ..write('startingBalance: $startingBalance, ')
          ..write('currentBalance: $currentBalance, ')
          ..write('expectedBalance: $expectedBalance, ')
          ..write('state: $state, ')
          ..write('openedAt: $openedAt, ')
          ..write('closedAt: $closedAt, ')
          ..write('closingBalance: $closingBalance, ')
          ..write('variance: $variance')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      uuid,
      shiftUuid,
      employeeUuid,
      employeeName,
      startingBalance,
      currentBalance,
      expectedBalance,
      state,
      openedAt,
      closedAt,
      closingBalance,
      variance);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is CashDrawerTableData &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.shiftUuid == this.shiftUuid &&
          other.employeeUuid == this.employeeUuid &&
          other.employeeName == this.employeeName &&
          other.startingBalance == this.startingBalance &&
          other.currentBalance == this.currentBalance &&
          other.expectedBalance == this.expectedBalance &&
          other.state == this.state &&
          other.openedAt == this.openedAt &&
          other.closedAt == this.closedAt &&
          other.closingBalance == this.closingBalance &&
          other.variance == this.variance);
}

class CashDrawerTableCompanion extends UpdateCompanion<CashDrawerTableData> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String> shiftUuid;
  final Value<String> employeeUuid;
  final Value<String> employeeName;
  final Value<double> startingBalance;
  final Value<double> currentBalance;
  final Value<double> expectedBalance;
  final Value<String> state;
  final Value<DateTime> openedAt;
  final Value<DateTime?> closedAt;
  final Value<double?> closingBalance;
  final Value<double?> variance;
  const CashDrawerTableCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.shiftUuid = const Value.absent(),
    this.employeeUuid = const Value.absent(),
    this.employeeName = const Value.absent(),
    this.startingBalance = const Value.absent(),
    this.currentBalance = const Value.absent(),
    this.expectedBalance = const Value.absent(),
    this.state = const Value.absent(),
    this.openedAt = const Value.absent(),
    this.closedAt = const Value.absent(),
    this.closingBalance = const Value.absent(),
    this.variance = const Value.absent(),
  });
  CashDrawerTableCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    required String shiftUuid,
    required String employeeUuid,
    required String employeeName,
    required double startingBalance,
    required double currentBalance,
    required double expectedBalance,
    this.state = const Value.absent(),
    required DateTime openedAt,
    this.closedAt = const Value.absent(),
    this.closingBalance = const Value.absent(),
    this.variance = const Value.absent(),
  })  : uuid = Value(uuid),
        shiftUuid = Value(shiftUuid),
        employeeUuid = Value(employeeUuid),
        employeeName = Value(employeeName),
        startingBalance = Value(startingBalance),
        currentBalance = Value(currentBalance),
        expectedBalance = Value(expectedBalance),
        openedAt = Value(openedAt);
  static Insertable<CashDrawerTableData> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? shiftUuid,
    Expression<String>? employeeUuid,
    Expression<String>? employeeName,
    Expression<double>? startingBalance,
    Expression<double>? currentBalance,
    Expression<double>? expectedBalance,
    Expression<String>? state,
    Expression<DateTime>? openedAt,
    Expression<DateTime>? closedAt,
    Expression<double>? closingBalance,
    Expression<double>? variance,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (shiftUuid != null) 'shift_uuid': shiftUuid,
      if (employeeUuid != null) 'employee_uuid': employeeUuid,
      if (employeeName != null) 'employee_name': employeeName,
      if (startingBalance != null) 'starting_balance': startingBalance,
      if (currentBalance != null) 'current_balance': currentBalance,
      if (expectedBalance != null) 'expected_balance': expectedBalance,
      if (state != null) 'state': state,
      if (openedAt != null) 'opened_at': openedAt,
      if (closedAt != null) 'closed_at': closedAt,
      if (closingBalance != null) 'closing_balance': closingBalance,
      if (variance != null) 'variance': variance,
    });
  }

  CashDrawerTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String>? shiftUuid,
      Value<String>? employeeUuid,
      Value<String>? employeeName,
      Value<double>? startingBalance,
      Value<double>? currentBalance,
      Value<double>? expectedBalance,
      Value<String>? state,
      Value<DateTime>? openedAt,
      Value<DateTime?>? closedAt,
      Value<double?>? closingBalance,
      Value<double?>? variance}) {
    return CashDrawerTableCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      shiftUuid: shiftUuid ?? this.shiftUuid,
      employeeUuid: employeeUuid ?? this.employeeUuid,
      employeeName: employeeName ?? this.employeeName,
      startingBalance: startingBalance ?? this.startingBalance,
      currentBalance: currentBalance ?? this.currentBalance,
      expectedBalance: expectedBalance ?? this.expectedBalance,
      state: state ?? this.state,
      openedAt: openedAt ?? this.openedAt,
      closedAt: closedAt ?? this.closedAt,
      closingBalance: closingBalance ?? this.closingBalance,
      variance: variance ?? this.variance,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (shiftUuid.present) {
      map['shift_uuid'] = Variable<String>(shiftUuid.value);
    }
    if (employeeUuid.present) {
      map['employee_uuid'] = Variable<String>(employeeUuid.value);
    }
    if (employeeName.present) {
      map['employee_name'] = Variable<String>(employeeName.value);
    }
    if (startingBalance.present) {
      map['starting_balance'] = Variable<double>(startingBalance.value);
    }
    if (currentBalance.present) {
      map['current_balance'] = Variable<double>(currentBalance.value);
    }
    if (expectedBalance.present) {
      map['expected_balance'] = Variable<double>(expectedBalance.value);
    }
    if (state.present) {
      map['state'] = Variable<String>(state.value);
    }
    if (openedAt.present) {
      map['opened_at'] = Variable<DateTime>(openedAt.value);
    }
    if (closedAt.present) {
      map['closed_at'] = Variable<DateTime>(closedAt.value);
    }
    if (closingBalance.present) {
      map['closing_balance'] = Variable<double>(closingBalance.value);
    }
    if (variance.present) {
      map['variance'] = Variable<double>(variance.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('CashDrawerTableCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('shiftUuid: $shiftUuid, ')
          ..write('employeeUuid: $employeeUuid, ')
          ..write('employeeName: $employeeName, ')
          ..write('startingBalance: $startingBalance, ')
          ..write('currentBalance: $currentBalance, ')
          ..write('expectedBalance: $expectedBalance, ')
          ..write('state: $state, ')
          ..write('openedAt: $openedAt, ')
          ..write('closedAt: $closedAt, ')
          ..write('closingBalance: $closingBalance, ')
          ..write('variance: $variance')
          ..write(')'))
        .toString();
  }
}

class $CashEventTableTable extends CashEventTable
    with TableInfo<$CashEventTableTable, CashEventTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $CashEventTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _drawerUuidMeta =
      const VerificationMeta('drawerUuid');
  @override
  late final GeneratedColumn<String> drawerUuid = GeneratedColumn<String>(
      'drawer_uuid', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _typeMeta = const VerificationMeta('type');
  @override
  late final GeneratedColumn<String> type = GeneratedColumn<String>(
      'type', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _amountMeta = const VerificationMeta('amount');
  @override
  late final GeneratedColumn<double> amount = GeneratedColumn<double>(
      'amount', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _reasonMeta = const VerificationMeta('reason');
  @override
  late final GeneratedColumn<String> reason = GeneratedColumn<String>(
      'reason', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _commentMeta =
      const VerificationMeta('comment');
  @override
  late final GeneratedColumn<String> comment = GeneratedColumn<String>(
      'comment', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _performedByMeta =
      const VerificationMeta('performedBy');
  @override
  late final GeneratedColumn<String> performedBy = GeneratedColumn<String>(
      'performed_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _orderUuidMeta =
      const VerificationMeta('orderUuid');
  @override
  late final GeneratedColumn<String> orderUuid = GeneratedColumn<String>(
      'order_uuid', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _timestampMeta =
      const VerificationMeta('timestamp');
  @override
  late final GeneratedColumn<DateTime> timestamp = GeneratedColumn<DateTime>(
      'timestamp', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        drawerUuid,
        type,
        amount,
        reason,
        comment,
        performedBy,
        orderUuid,
        timestamp
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'cash_event_table';
  @override
  VerificationContext validateIntegrity(Insertable<CashEventTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('drawer_uuid')) {
      context.handle(
          _drawerUuidMeta,
          drawerUuid.isAcceptableOrUnknown(
              data['drawer_uuid']!, _drawerUuidMeta));
    } else if (isInserting) {
      context.missing(_drawerUuidMeta);
    }
    if (data.containsKey('type')) {
      context.handle(
          _typeMeta, type.isAcceptableOrUnknown(data['type']!, _typeMeta));
    } else if (isInserting) {
      context.missing(_typeMeta);
    }
    if (data.containsKey('amount')) {
      context.handle(_amountMeta,
          amount.isAcceptableOrUnknown(data['amount']!, _amountMeta));
    } else if (isInserting) {
      context.missing(_amountMeta);
    }
    if (data.containsKey('reason')) {
      context.handle(_reasonMeta,
          reason.isAcceptableOrUnknown(data['reason']!, _reasonMeta));
    } else if (isInserting) {
      context.missing(_reasonMeta);
    }
    if (data.containsKey('comment')) {
      context.handle(_commentMeta,
          comment.isAcceptableOrUnknown(data['comment']!, _commentMeta));
    }
    if (data.containsKey('performed_by')) {
      context.handle(
          _performedByMeta,
          performedBy.isAcceptableOrUnknown(
              data['performed_by']!, _performedByMeta));
    }
    if (data.containsKey('order_uuid')) {
      context.handle(_orderUuidMeta,
          orderUuid.isAcceptableOrUnknown(data['order_uuid']!, _orderUuidMeta));
    }
    if (data.containsKey('timestamp')) {
      context.handle(_timestampMeta,
          timestamp.isAcceptableOrUnknown(data['timestamp']!, _timestampMeta));
    } else if (isInserting) {
      context.missing(_timestampMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  CashEventTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return CashEventTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      drawerUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}drawer_uuid'])!,
      type: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}type'])!,
      amount: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}amount'])!,
      reason: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}reason'])!,
      comment: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}comment']),
      performedBy: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}performed_by']),
      orderUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}order_uuid']),
      timestamp: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}timestamp'])!,
    );
  }

  @override
  $CashEventTableTable createAlias(String alias) {
    return $CashEventTableTable(attachedDatabase, alias);
  }
}

class CashEventTableData extends DataClass
    implements Insertable<CashEventTableData> {
  final int id;
  final String uuid;
  final String drawerUuid;
  final String type;
  final double amount;
  final String reason;
  final String? comment;
  final String? performedBy;
  final String? orderUuid;
  final DateTime timestamp;
  const CashEventTableData(
      {required this.id,
      required this.uuid,
      required this.drawerUuid,
      required this.type,
      required this.amount,
      required this.reason,
      this.comment,
      this.performedBy,
      this.orderUuid,
      required this.timestamp});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    map['drawer_uuid'] = Variable<String>(drawerUuid);
    map['type'] = Variable<String>(type);
    map['amount'] = Variable<double>(amount);
    map['reason'] = Variable<String>(reason);
    if (!nullToAbsent || comment != null) {
      map['comment'] = Variable<String>(comment);
    }
    if (!nullToAbsent || performedBy != null) {
      map['performed_by'] = Variable<String>(performedBy);
    }
    if (!nullToAbsent || orderUuid != null) {
      map['order_uuid'] = Variable<String>(orderUuid);
    }
    map['timestamp'] = Variable<DateTime>(timestamp);
    return map;
  }

  CashEventTableCompanion toCompanion(bool nullToAbsent) {
    return CashEventTableCompanion(
      id: Value(id),
      uuid: Value(uuid),
      drawerUuid: Value(drawerUuid),
      type: Value(type),
      amount: Value(amount),
      reason: Value(reason),
      comment: comment == null && nullToAbsent
          ? const Value.absent()
          : Value(comment),
      performedBy: performedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(performedBy),
      orderUuid: orderUuid == null && nullToAbsent
          ? const Value.absent()
          : Value(orderUuid),
      timestamp: Value(timestamp),
    );
  }

  factory CashEventTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return CashEventTableData(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      drawerUuid: serializer.fromJson<String>(json['drawerUuid']),
      type: serializer.fromJson<String>(json['type']),
      amount: serializer.fromJson<double>(json['amount']),
      reason: serializer.fromJson<String>(json['reason']),
      comment: serializer.fromJson<String?>(json['comment']),
      performedBy: serializer.fromJson<String?>(json['performedBy']),
      orderUuid: serializer.fromJson<String?>(json['orderUuid']),
      timestamp: serializer.fromJson<DateTime>(json['timestamp']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'drawerUuid': serializer.toJson<String>(drawerUuid),
      'type': serializer.toJson<String>(type),
      'amount': serializer.toJson<double>(amount),
      'reason': serializer.toJson<String>(reason),
      'comment': serializer.toJson<String?>(comment),
      'performedBy': serializer.toJson<String?>(performedBy),
      'orderUuid': serializer.toJson<String?>(orderUuid),
      'timestamp': serializer.toJson<DateTime>(timestamp),
    };
  }

  CashEventTableData copyWith(
          {int? id,
          String? uuid,
          String? drawerUuid,
          String? type,
          double? amount,
          String? reason,
          Value<String?> comment = const Value.absent(),
          Value<String?> performedBy = const Value.absent(),
          Value<String?> orderUuid = const Value.absent(),
          DateTime? timestamp}) =>
      CashEventTableData(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        drawerUuid: drawerUuid ?? this.drawerUuid,
        type: type ?? this.type,
        amount: amount ?? this.amount,
        reason: reason ?? this.reason,
        comment: comment.present ? comment.value : this.comment,
        performedBy: performedBy.present ? performedBy.value : this.performedBy,
        orderUuid: orderUuid.present ? orderUuid.value : this.orderUuid,
        timestamp: timestamp ?? this.timestamp,
      );
  CashEventTableData copyWithCompanion(CashEventTableCompanion data) {
    return CashEventTableData(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      drawerUuid:
          data.drawerUuid.present ? data.drawerUuid.value : this.drawerUuid,
      type: data.type.present ? data.type.value : this.type,
      amount: data.amount.present ? data.amount.value : this.amount,
      reason: data.reason.present ? data.reason.value : this.reason,
      comment: data.comment.present ? data.comment.value : this.comment,
      performedBy:
          data.performedBy.present ? data.performedBy.value : this.performedBy,
      orderUuid: data.orderUuid.present ? data.orderUuid.value : this.orderUuid,
      timestamp: data.timestamp.present ? data.timestamp.value : this.timestamp,
    );
  }

  @override
  String toString() {
    return (StringBuffer('CashEventTableData(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('drawerUuid: $drawerUuid, ')
          ..write('type: $type, ')
          ..write('amount: $amount, ')
          ..write('reason: $reason, ')
          ..write('comment: $comment, ')
          ..write('performedBy: $performedBy, ')
          ..write('orderUuid: $orderUuid, ')
          ..write('timestamp: $timestamp')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, uuid, drawerUuid, type, amount, reason,
      comment, performedBy, orderUuid, timestamp);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is CashEventTableData &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.drawerUuid == this.drawerUuid &&
          other.type == this.type &&
          other.amount == this.amount &&
          other.reason == this.reason &&
          other.comment == this.comment &&
          other.performedBy == this.performedBy &&
          other.orderUuid == this.orderUuid &&
          other.timestamp == this.timestamp);
}

class CashEventTableCompanion extends UpdateCompanion<CashEventTableData> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String> drawerUuid;
  final Value<String> type;
  final Value<double> amount;
  final Value<String> reason;
  final Value<String?> comment;
  final Value<String?> performedBy;
  final Value<String?> orderUuid;
  final Value<DateTime> timestamp;
  const CashEventTableCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.drawerUuid = const Value.absent(),
    this.type = const Value.absent(),
    this.amount = const Value.absent(),
    this.reason = const Value.absent(),
    this.comment = const Value.absent(),
    this.performedBy = const Value.absent(),
    this.orderUuid = const Value.absent(),
    this.timestamp = const Value.absent(),
  });
  CashEventTableCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    required String drawerUuid,
    required String type,
    required double amount,
    required String reason,
    this.comment = const Value.absent(),
    this.performedBy = const Value.absent(),
    this.orderUuid = const Value.absent(),
    required DateTime timestamp,
  })  : uuid = Value(uuid),
        drawerUuid = Value(drawerUuid),
        type = Value(type),
        amount = Value(amount),
        reason = Value(reason),
        timestamp = Value(timestamp);
  static Insertable<CashEventTableData> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? drawerUuid,
    Expression<String>? type,
    Expression<double>? amount,
    Expression<String>? reason,
    Expression<String>? comment,
    Expression<String>? performedBy,
    Expression<String>? orderUuid,
    Expression<DateTime>? timestamp,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (drawerUuid != null) 'drawer_uuid': drawerUuid,
      if (type != null) 'type': type,
      if (amount != null) 'amount': amount,
      if (reason != null) 'reason': reason,
      if (comment != null) 'comment': comment,
      if (performedBy != null) 'performed_by': performedBy,
      if (orderUuid != null) 'order_uuid': orderUuid,
      if (timestamp != null) 'timestamp': timestamp,
    });
  }

  CashEventTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String>? drawerUuid,
      Value<String>? type,
      Value<double>? amount,
      Value<String>? reason,
      Value<String?>? comment,
      Value<String?>? performedBy,
      Value<String?>? orderUuid,
      Value<DateTime>? timestamp}) {
    return CashEventTableCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      drawerUuid: drawerUuid ?? this.drawerUuid,
      type: type ?? this.type,
      amount: amount ?? this.amount,
      reason: reason ?? this.reason,
      comment: comment ?? this.comment,
      performedBy: performedBy ?? this.performedBy,
      orderUuid: orderUuid ?? this.orderUuid,
      timestamp: timestamp ?? this.timestamp,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (drawerUuid.present) {
      map['drawer_uuid'] = Variable<String>(drawerUuid.value);
    }
    if (type.present) {
      map['type'] = Variable<String>(type.value);
    }
    if (amount.present) {
      map['amount'] = Variable<double>(amount.value);
    }
    if (reason.present) {
      map['reason'] = Variable<String>(reason.value);
    }
    if (comment.present) {
      map['comment'] = Variable<String>(comment.value);
    }
    if (performedBy.present) {
      map['performed_by'] = Variable<String>(performedBy.value);
    }
    if (orderUuid.present) {
      map['order_uuid'] = Variable<String>(orderUuid.value);
    }
    if (timestamp.present) {
      map['timestamp'] = Variable<DateTime>(timestamp.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('CashEventTableCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('drawerUuid: $drawerUuid, ')
          ..write('type: $type, ')
          ..write('amount: $amount, ')
          ..write('reason: $reason, ')
          ..write('comment: $comment, ')
          ..write('performedBy: $performedBy, ')
          ..write('orderUuid: $orderUuid, ')
          ..write('timestamp: $timestamp')
          ..write(')'))
        .toString();
  }
}

class $CustomerNoteTableTable extends CustomerNoteTable
    with TableInfo<$CustomerNoteTableTable, CustomerNoteTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $CustomerNoteTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _customerUuidMeta =
      const VerificationMeta('customerUuid');
  @override
  late final GeneratedColumn<String> customerUuid = GeneratedColumn<String>(
      'customer_uuid', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _contentMeta =
      const VerificationMeta('content');
  @override
  late final GeneratedColumn<String> content = GeneratedColumn<String>(
      'content', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _createdByMeta =
      const VerificationMeta('createdBy');
  @override
  late final GeneratedColumn<String> createdBy = GeneratedColumn<String>(
      'created_by', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _isCriticalMeta =
      const VerificationMeta('isCritical');
  @override
  late final GeneratedColumn<bool> isCritical = GeneratedColumn<bool>(
      'is_critical', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_critical" IN (0, 1))'),
      defaultValue: const Constant(false));
  @override
  List<GeneratedColumn> get $columns =>
      [id, uuid, customerUuid, content, createdBy, createdAt, isCritical];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'customer_note_table';
  @override
  VerificationContext validateIntegrity(
      Insertable<CustomerNoteTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('customer_uuid')) {
      context.handle(
          _customerUuidMeta,
          customerUuid.isAcceptableOrUnknown(
              data['customer_uuid']!, _customerUuidMeta));
    } else if (isInserting) {
      context.missing(_customerUuidMeta);
    }
    if (data.containsKey('content')) {
      context.handle(_contentMeta,
          content.isAcceptableOrUnknown(data['content']!, _contentMeta));
    } else if (isInserting) {
      context.missing(_contentMeta);
    }
    if (data.containsKey('created_by')) {
      context.handle(_createdByMeta,
          createdBy.isAcceptableOrUnknown(data['created_by']!, _createdByMeta));
    } else if (isInserting) {
      context.missing(_createdByMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('is_critical')) {
      context.handle(
          _isCriticalMeta,
          isCritical.isAcceptableOrUnknown(
              data['is_critical']!, _isCriticalMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  CustomerNoteTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return CustomerNoteTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      customerUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}customer_uuid'])!,
      content: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}content'])!,
      createdBy: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}created_by'])!,
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      isCritical: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_critical'])!,
    );
  }

  @override
  $CustomerNoteTableTable createAlias(String alias) {
    return $CustomerNoteTableTable(attachedDatabase, alias);
  }
}

class CustomerNoteTableData extends DataClass
    implements Insertable<CustomerNoteTableData> {
  final int id;
  final String uuid;
  final String customerUuid;
  final String content;
  final String createdBy;
  final DateTime createdAt;
  final bool isCritical;
  const CustomerNoteTableData(
      {required this.id,
      required this.uuid,
      required this.customerUuid,
      required this.content,
      required this.createdBy,
      required this.createdAt,
      required this.isCritical});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    map['customer_uuid'] = Variable<String>(customerUuid);
    map['content'] = Variable<String>(content);
    map['created_by'] = Variable<String>(createdBy);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['is_critical'] = Variable<bool>(isCritical);
    return map;
  }

  CustomerNoteTableCompanion toCompanion(bool nullToAbsent) {
    return CustomerNoteTableCompanion(
      id: Value(id),
      uuid: Value(uuid),
      customerUuid: Value(customerUuid),
      content: Value(content),
      createdBy: Value(createdBy),
      createdAt: Value(createdAt),
      isCritical: Value(isCritical),
    );
  }

  factory CustomerNoteTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return CustomerNoteTableData(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      customerUuid: serializer.fromJson<String>(json['customerUuid']),
      content: serializer.fromJson<String>(json['content']),
      createdBy: serializer.fromJson<String>(json['createdBy']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      isCritical: serializer.fromJson<bool>(json['isCritical']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'customerUuid': serializer.toJson<String>(customerUuid),
      'content': serializer.toJson<String>(content),
      'createdBy': serializer.toJson<String>(createdBy),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'isCritical': serializer.toJson<bool>(isCritical),
    };
  }

  CustomerNoteTableData copyWith(
          {int? id,
          String? uuid,
          String? customerUuid,
          String? content,
          String? createdBy,
          DateTime? createdAt,
          bool? isCritical}) =>
      CustomerNoteTableData(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        customerUuid: customerUuid ?? this.customerUuid,
        content: content ?? this.content,
        createdBy: createdBy ?? this.createdBy,
        createdAt: createdAt ?? this.createdAt,
        isCritical: isCritical ?? this.isCritical,
      );
  CustomerNoteTableData copyWithCompanion(CustomerNoteTableCompanion data) {
    return CustomerNoteTableData(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      customerUuid: data.customerUuid.present
          ? data.customerUuid.value
          : this.customerUuid,
      content: data.content.present ? data.content.value : this.content,
      createdBy: data.createdBy.present ? data.createdBy.value : this.createdBy,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      isCritical:
          data.isCritical.present ? data.isCritical.value : this.isCritical,
    );
  }

  @override
  String toString() {
    return (StringBuffer('CustomerNoteTableData(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('customerUuid: $customerUuid, ')
          ..write('content: $content, ')
          ..write('createdBy: $createdBy, ')
          ..write('createdAt: $createdAt, ')
          ..write('isCritical: $isCritical')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id, uuid, customerUuid, content, createdBy, createdAt, isCritical);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is CustomerNoteTableData &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.customerUuid == this.customerUuid &&
          other.content == this.content &&
          other.createdBy == this.createdBy &&
          other.createdAt == this.createdAt &&
          other.isCritical == this.isCritical);
}

class CustomerNoteTableCompanion
    extends UpdateCompanion<CustomerNoteTableData> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String> customerUuid;
  final Value<String> content;
  final Value<String> createdBy;
  final Value<DateTime> createdAt;
  final Value<bool> isCritical;
  const CustomerNoteTableCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.customerUuid = const Value.absent(),
    this.content = const Value.absent(),
    this.createdBy = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.isCritical = const Value.absent(),
  });
  CustomerNoteTableCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    required String customerUuid,
    required String content,
    required String createdBy,
    required DateTime createdAt,
    this.isCritical = const Value.absent(),
  })  : uuid = Value(uuid),
        customerUuid = Value(customerUuid),
        content = Value(content),
        createdBy = Value(createdBy),
        createdAt = Value(createdAt);
  static Insertable<CustomerNoteTableData> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? customerUuid,
    Expression<String>? content,
    Expression<String>? createdBy,
    Expression<DateTime>? createdAt,
    Expression<bool>? isCritical,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (customerUuid != null) 'customer_uuid': customerUuid,
      if (content != null) 'content': content,
      if (createdBy != null) 'created_by': createdBy,
      if (createdAt != null) 'created_at': createdAt,
      if (isCritical != null) 'is_critical': isCritical,
    });
  }

  CustomerNoteTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String>? customerUuid,
      Value<String>? content,
      Value<String>? createdBy,
      Value<DateTime>? createdAt,
      Value<bool>? isCritical}) {
    return CustomerNoteTableCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      customerUuid: customerUuid ?? this.customerUuid,
      content: content ?? this.content,
      createdBy: createdBy ?? this.createdBy,
      createdAt: createdAt ?? this.createdAt,
      isCritical: isCritical ?? this.isCritical,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (customerUuid.present) {
      map['customer_uuid'] = Variable<String>(customerUuid.value);
    }
    if (content.present) {
      map['content'] = Variable<String>(content.value);
    }
    if (createdBy.present) {
      map['created_by'] = Variable<String>(createdBy.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (isCritical.present) {
      map['is_critical'] = Variable<bool>(isCritical.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('CustomerNoteTableCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('customerUuid: $customerUuid, ')
          ..write('content: $content, ')
          ..write('createdBy: $createdBy, ')
          ..write('createdAt: $createdAt, ')
          ..write('isCritical: $isCritical')
          ..write(')'))
        .toString();
  }
}

class $CustomerTagTableTable extends CustomerTagTable
    with TableInfo<$CustomerTagTableTable, CustomerTagTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $CustomerTagTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _customerUuidMeta =
      const VerificationMeta('customerUuid');
  @override
  late final GeneratedColumn<String> customerUuid = GeneratedColumn<String>(
      'customer_uuid', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _tagMeta = const VerificationMeta('tag');
  @override
  late final GeneratedColumn<String> tag = GeneratedColumn<String>(
      'tag', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [id, customerUuid, tag];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'customer_tag_table';
  @override
  VerificationContext validateIntegrity(
      Insertable<CustomerTagTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('customer_uuid')) {
      context.handle(
          _customerUuidMeta,
          customerUuid.isAcceptableOrUnknown(
              data['customer_uuid']!, _customerUuidMeta));
    } else if (isInserting) {
      context.missing(_customerUuidMeta);
    }
    if (data.containsKey('tag')) {
      context.handle(
          _tagMeta, tag.isAcceptableOrUnknown(data['tag']!, _tagMeta));
    } else if (isInserting) {
      context.missing(_tagMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
        {customerUuid, tag},
      ];
  @override
  CustomerTagTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return CustomerTagTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      customerUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}customer_uuid'])!,
      tag: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tag'])!,
    );
  }

  @override
  $CustomerTagTableTable createAlias(String alias) {
    return $CustomerTagTableTable(attachedDatabase, alias);
  }
}

class CustomerTagTableData extends DataClass
    implements Insertable<CustomerTagTableData> {
  final int id;
  final String customerUuid;
  final String tag;
  const CustomerTagTableData(
      {required this.id, required this.customerUuid, required this.tag});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['customer_uuid'] = Variable<String>(customerUuid);
    map['tag'] = Variable<String>(tag);
    return map;
  }

  CustomerTagTableCompanion toCompanion(bool nullToAbsent) {
    return CustomerTagTableCompanion(
      id: Value(id),
      customerUuid: Value(customerUuid),
      tag: Value(tag),
    );
  }

  factory CustomerTagTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return CustomerTagTableData(
      id: serializer.fromJson<int>(json['id']),
      customerUuid: serializer.fromJson<String>(json['customerUuid']),
      tag: serializer.fromJson<String>(json['tag']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'customerUuid': serializer.toJson<String>(customerUuid),
      'tag': serializer.toJson<String>(tag),
    };
  }

  CustomerTagTableData copyWith({int? id, String? customerUuid, String? tag}) =>
      CustomerTagTableData(
        id: id ?? this.id,
        customerUuid: customerUuid ?? this.customerUuid,
        tag: tag ?? this.tag,
      );
  CustomerTagTableData copyWithCompanion(CustomerTagTableCompanion data) {
    return CustomerTagTableData(
      id: data.id.present ? data.id.value : this.id,
      customerUuid: data.customerUuid.present
          ? data.customerUuid.value
          : this.customerUuid,
      tag: data.tag.present ? data.tag.value : this.tag,
    );
  }

  @override
  String toString() {
    return (StringBuffer('CustomerTagTableData(')
          ..write('id: $id, ')
          ..write('customerUuid: $customerUuid, ')
          ..write('tag: $tag')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, customerUuid, tag);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is CustomerTagTableData &&
          other.id == this.id &&
          other.customerUuid == this.customerUuid &&
          other.tag == this.tag);
}

class CustomerTagTableCompanion extends UpdateCompanion<CustomerTagTableData> {
  final Value<int> id;
  final Value<String> customerUuid;
  final Value<String> tag;
  const CustomerTagTableCompanion({
    this.id = const Value.absent(),
    this.customerUuid = const Value.absent(),
    this.tag = const Value.absent(),
  });
  CustomerTagTableCompanion.insert({
    this.id = const Value.absent(),
    required String customerUuid,
    required String tag,
  })  : customerUuid = Value(customerUuid),
        tag = Value(tag);
  static Insertable<CustomerTagTableData> custom({
    Expression<int>? id,
    Expression<String>? customerUuid,
    Expression<String>? tag,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (customerUuid != null) 'customer_uuid': customerUuid,
      if (tag != null) 'tag': tag,
    });
  }

  CustomerTagTableCompanion copyWith(
      {Value<int>? id, Value<String>? customerUuid, Value<String>? tag}) {
    return CustomerTagTableCompanion(
      id: id ?? this.id,
      customerUuid: customerUuid ?? this.customerUuid,
      tag: tag ?? this.tag,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (customerUuid.present) {
      map['customer_uuid'] = Variable<String>(customerUuid.value);
    }
    if (tag.present) {
      map['tag'] = Variable<String>(tag.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('CustomerTagTableCompanion(')
          ..write('id: $id, ')
          ..write('customerUuid: $customerUuid, ')
          ..write('tag: $tag')
          ..write(')'))
        .toString();
  }
}

class $PaymentTransactionTableTable extends PaymentTransactionTable
    with TableInfo<$PaymentTransactionTableTable, PaymentTransactionTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $PaymentTransactionTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _orderUuidMeta =
      const VerificationMeta('orderUuid');
  @override
  late final GeneratedColumn<String> orderUuid = GeneratedColumn<String>(
      'order_uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES order_table (uuid) ON DELETE CASCADE'));
  static const VerificationMeta _methodMeta = const VerificationMeta('method');
  @override
  late final GeneratedColumn<String> method = GeneratedColumn<String>(
      'method', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _amountMeta = const VerificationMeta('amount');
  @override
  late final GeneratedColumn<double> amount = GeneratedColumn<double>(
      'amount', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _tenderedMeta =
      const VerificationMeta('tendered');
  @override
  late final GeneratedColumn<double> tendered = GeneratedColumn<double>(
      'tendered', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _changeMeta = const VerificationMeta('change');
  @override
  late final GeneratedColumn<double> change = GeneratedColumn<double>(
      'change', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
      'status', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultValue: const Constant('PAID'));
  static const VerificationMeta _referenceIdMeta =
      const VerificationMeta('referenceId');
  @override
  late final GeneratedColumn<String> referenceId = GeneratedColumn<String>(
      'reference_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _noteMeta = const VerificationMeta('note');
  @override
  late final GeneratedColumn<String> note = GeneratedColumn<String>(
      'note', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _createdByMeta =
      const VerificationMeta('createdBy');
  @override
  late final GeneratedColumn<String> createdBy = GeneratedColumn<String>(
      'created_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isSyncedMeta =
      const VerificationMeta('isSynced');
  @override
  late final GeneratedColumn<bool> isSynced = GeneratedColumn<bool>(
      'is_synced', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_synced" IN (0, 1))'),
      defaultValue: const Constant(false));
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        orderUuid,
        method,
        amount,
        tendered,
        change,
        status,
        referenceId,
        note,
        createdAt,
        createdBy,
        isSynced
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'payment_transaction_table';
  @override
  VerificationContext validateIntegrity(
      Insertable<PaymentTransactionTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('order_uuid')) {
      context.handle(_orderUuidMeta,
          orderUuid.isAcceptableOrUnknown(data['order_uuid']!, _orderUuidMeta));
    } else if (isInserting) {
      context.missing(_orderUuidMeta);
    }
    if (data.containsKey('method')) {
      context.handle(_methodMeta,
          method.isAcceptableOrUnknown(data['method']!, _methodMeta));
    } else if (isInserting) {
      context.missing(_methodMeta);
    }
    if (data.containsKey('amount')) {
      context.handle(_amountMeta,
          amount.isAcceptableOrUnknown(data['amount']!, _amountMeta));
    } else if (isInserting) {
      context.missing(_amountMeta);
    }
    if (data.containsKey('tendered')) {
      context.handle(_tenderedMeta,
          tendered.isAcceptableOrUnknown(data['tendered']!, _tenderedMeta));
    }
    if (data.containsKey('change')) {
      context.handle(_changeMeta,
          change.isAcceptableOrUnknown(data['change']!, _changeMeta));
    }
    if (data.containsKey('status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['status']!, _statusMeta));
    }
    if (data.containsKey('reference_id')) {
      context.handle(
          _referenceIdMeta,
          referenceId.isAcceptableOrUnknown(
              data['reference_id']!, _referenceIdMeta));
    }
    if (data.containsKey('note')) {
      context.handle(
          _noteMeta, note.isAcceptableOrUnknown(data['note']!, _noteMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('created_by')) {
      context.handle(_createdByMeta,
          createdBy.isAcceptableOrUnknown(data['created_by']!, _createdByMeta));
    }
    if (data.containsKey('is_synced')) {
      context.handle(_isSyncedMeta,
          isSynced.isAcceptableOrUnknown(data['is_synced']!, _isSyncedMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  PaymentTransactionTableData map(Map<String, dynamic> data,
      {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return PaymentTransactionTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      orderUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}order_uuid'])!,
      method: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}method'])!,
      amount: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}amount'])!,
      tendered: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}tendered']),
      change: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}change']),
      status: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}status'])!,
      referenceId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}reference_id']),
      note: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}note']),
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      createdBy: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}created_by']),
      isSynced: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_synced'])!,
    );
  }

  @override
  $PaymentTransactionTableTable createAlias(String alias) {
    return $PaymentTransactionTableTable(attachedDatabase, alias);
  }
}

class PaymentTransactionTableData extends DataClass
    implements Insertable<PaymentTransactionTableData> {
  final int id;
  final String uuid;
  final String orderUuid;
  final String method;
  final double amount;
  final double? tendered;
  final double? change;
  final String status;
  final String? referenceId;
  final String? note;
  final DateTime createdAt;
  final String? createdBy;
  final bool isSynced;
  const PaymentTransactionTableData(
      {required this.id,
      required this.uuid,
      required this.orderUuid,
      required this.method,
      required this.amount,
      this.tendered,
      this.change,
      required this.status,
      this.referenceId,
      this.note,
      required this.createdAt,
      this.createdBy,
      required this.isSynced});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    map['order_uuid'] = Variable<String>(orderUuid);
    map['method'] = Variable<String>(method);
    map['amount'] = Variable<double>(amount);
    if (!nullToAbsent || tendered != null) {
      map['tendered'] = Variable<double>(tendered);
    }
    if (!nullToAbsent || change != null) {
      map['change'] = Variable<double>(change);
    }
    map['status'] = Variable<String>(status);
    if (!nullToAbsent || referenceId != null) {
      map['reference_id'] = Variable<String>(referenceId);
    }
    if (!nullToAbsent || note != null) {
      map['note'] = Variable<String>(note);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    if (!nullToAbsent || createdBy != null) {
      map['created_by'] = Variable<String>(createdBy);
    }
    map['is_synced'] = Variable<bool>(isSynced);
    return map;
  }

  PaymentTransactionTableCompanion toCompanion(bool nullToAbsent) {
    return PaymentTransactionTableCompanion(
      id: Value(id),
      uuid: Value(uuid),
      orderUuid: Value(orderUuid),
      method: Value(method),
      amount: Value(amount),
      tendered: tendered == null && nullToAbsent
          ? const Value.absent()
          : Value(tendered),
      change:
          change == null && nullToAbsent ? const Value.absent() : Value(change),
      status: Value(status),
      referenceId: referenceId == null && nullToAbsent
          ? const Value.absent()
          : Value(referenceId),
      note: note == null && nullToAbsent ? const Value.absent() : Value(note),
      createdAt: Value(createdAt),
      createdBy: createdBy == null && nullToAbsent
          ? const Value.absent()
          : Value(createdBy),
      isSynced: Value(isSynced),
    );
  }

  factory PaymentTransactionTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return PaymentTransactionTableData(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      orderUuid: serializer.fromJson<String>(json['orderUuid']),
      method: serializer.fromJson<String>(json['method']),
      amount: serializer.fromJson<double>(json['amount']),
      tendered: serializer.fromJson<double?>(json['tendered']),
      change: serializer.fromJson<double?>(json['change']),
      status: serializer.fromJson<String>(json['status']),
      referenceId: serializer.fromJson<String?>(json['referenceId']),
      note: serializer.fromJson<String?>(json['note']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      createdBy: serializer.fromJson<String?>(json['createdBy']),
      isSynced: serializer.fromJson<bool>(json['isSynced']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'orderUuid': serializer.toJson<String>(orderUuid),
      'method': serializer.toJson<String>(method),
      'amount': serializer.toJson<double>(amount),
      'tendered': serializer.toJson<double?>(tendered),
      'change': serializer.toJson<double?>(change),
      'status': serializer.toJson<String>(status),
      'referenceId': serializer.toJson<String?>(referenceId),
      'note': serializer.toJson<String?>(note),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'createdBy': serializer.toJson<String?>(createdBy),
      'isSynced': serializer.toJson<bool>(isSynced),
    };
  }

  PaymentTransactionTableData copyWith(
          {int? id,
          String? uuid,
          String? orderUuid,
          String? method,
          double? amount,
          Value<double?> tendered = const Value.absent(),
          Value<double?> change = const Value.absent(),
          String? status,
          Value<String?> referenceId = const Value.absent(),
          Value<String?> note = const Value.absent(),
          DateTime? createdAt,
          Value<String?> createdBy = const Value.absent(),
          bool? isSynced}) =>
      PaymentTransactionTableData(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        orderUuid: orderUuid ?? this.orderUuid,
        method: method ?? this.method,
        amount: amount ?? this.amount,
        tendered: tendered.present ? tendered.value : this.tendered,
        change: change.present ? change.value : this.change,
        status: status ?? this.status,
        referenceId: referenceId.present ? referenceId.value : this.referenceId,
        note: note.present ? note.value : this.note,
        createdAt: createdAt ?? this.createdAt,
        createdBy: createdBy.present ? createdBy.value : this.createdBy,
        isSynced: isSynced ?? this.isSynced,
      );
  PaymentTransactionTableData copyWithCompanion(
      PaymentTransactionTableCompanion data) {
    return PaymentTransactionTableData(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      orderUuid: data.orderUuid.present ? data.orderUuid.value : this.orderUuid,
      method: data.method.present ? data.method.value : this.method,
      amount: data.amount.present ? data.amount.value : this.amount,
      tendered: data.tendered.present ? data.tendered.value : this.tendered,
      change: data.change.present ? data.change.value : this.change,
      status: data.status.present ? data.status.value : this.status,
      referenceId:
          data.referenceId.present ? data.referenceId.value : this.referenceId,
      note: data.note.present ? data.note.value : this.note,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      createdBy: data.createdBy.present ? data.createdBy.value : this.createdBy,
      isSynced: data.isSynced.present ? data.isSynced.value : this.isSynced,
    );
  }

  @override
  String toString() {
    return (StringBuffer('PaymentTransactionTableData(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('orderUuid: $orderUuid, ')
          ..write('method: $method, ')
          ..write('amount: $amount, ')
          ..write('tendered: $tendered, ')
          ..write('change: $change, ')
          ..write('status: $status, ')
          ..write('referenceId: $referenceId, ')
          ..write('note: $note, ')
          ..write('createdAt: $createdAt, ')
          ..write('createdBy: $createdBy, ')
          ..write('isSynced: $isSynced')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, uuid, orderUuid, method, amount, tendered,
      change, status, referenceId, note, createdAt, createdBy, isSynced);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is PaymentTransactionTableData &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.orderUuid == this.orderUuid &&
          other.method == this.method &&
          other.amount == this.amount &&
          other.tendered == this.tendered &&
          other.change == this.change &&
          other.status == this.status &&
          other.referenceId == this.referenceId &&
          other.note == this.note &&
          other.createdAt == this.createdAt &&
          other.createdBy == this.createdBy &&
          other.isSynced == this.isSynced);
}

class PaymentTransactionTableCompanion
    extends UpdateCompanion<PaymentTransactionTableData> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String> orderUuid;
  final Value<String> method;
  final Value<double> amount;
  final Value<double?> tendered;
  final Value<double?> change;
  final Value<String> status;
  final Value<String?> referenceId;
  final Value<String?> note;
  final Value<DateTime> createdAt;
  final Value<String?> createdBy;
  final Value<bool> isSynced;
  const PaymentTransactionTableCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.orderUuid = const Value.absent(),
    this.method = const Value.absent(),
    this.amount = const Value.absent(),
    this.tendered = const Value.absent(),
    this.change = const Value.absent(),
    this.status = const Value.absent(),
    this.referenceId = const Value.absent(),
    this.note = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.createdBy = const Value.absent(),
    this.isSynced = const Value.absent(),
  });
  PaymentTransactionTableCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    required String orderUuid,
    required String method,
    required double amount,
    this.tendered = const Value.absent(),
    this.change = const Value.absent(),
    this.status = const Value.absent(),
    this.referenceId = const Value.absent(),
    this.note = const Value.absent(),
    required DateTime createdAt,
    this.createdBy = const Value.absent(),
    this.isSynced = const Value.absent(),
  })  : uuid = Value(uuid),
        orderUuid = Value(orderUuid),
        method = Value(method),
        amount = Value(amount),
        createdAt = Value(createdAt);
  static Insertable<PaymentTransactionTableData> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? orderUuid,
    Expression<String>? method,
    Expression<double>? amount,
    Expression<double>? tendered,
    Expression<double>? change,
    Expression<String>? status,
    Expression<String>? referenceId,
    Expression<String>? note,
    Expression<DateTime>? createdAt,
    Expression<String>? createdBy,
    Expression<bool>? isSynced,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (orderUuid != null) 'order_uuid': orderUuid,
      if (method != null) 'method': method,
      if (amount != null) 'amount': amount,
      if (tendered != null) 'tendered': tendered,
      if (change != null) 'change': change,
      if (status != null) 'status': status,
      if (referenceId != null) 'reference_id': referenceId,
      if (note != null) 'note': note,
      if (createdAt != null) 'created_at': createdAt,
      if (createdBy != null) 'created_by': createdBy,
      if (isSynced != null) 'is_synced': isSynced,
    });
  }

  PaymentTransactionTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String>? orderUuid,
      Value<String>? method,
      Value<double>? amount,
      Value<double?>? tendered,
      Value<double?>? change,
      Value<String>? status,
      Value<String?>? referenceId,
      Value<String?>? note,
      Value<DateTime>? createdAt,
      Value<String?>? createdBy,
      Value<bool>? isSynced}) {
    return PaymentTransactionTableCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      orderUuid: orderUuid ?? this.orderUuid,
      method: method ?? this.method,
      amount: amount ?? this.amount,
      tendered: tendered ?? this.tendered,
      change: change ?? this.change,
      status: status ?? this.status,
      referenceId: referenceId ?? this.referenceId,
      note: note ?? this.note,
      createdAt: createdAt ?? this.createdAt,
      createdBy: createdBy ?? this.createdBy,
      isSynced: isSynced ?? this.isSynced,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (orderUuid.present) {
      map['order_uuid'] = Variable<String>(orderUuid.value);
    }
    if (method.present) {
      map['method'] = Variable<String>(method.value);
    }
    if (amount.present) {
      map['amount'] = Variable<double>(amount.value);
    }
    if (tendered.present) {
      map['tendered'] = Variable<double>(tendered.value);
    }
    if (change.present) {
      map['change'] = Variable<double>(change.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (referenceId.present) {
      map['reference_id'] = Variable<String>(referenceId.value);
    }
    if (note.present) {
      map['note'] = Variable<String>(note.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (createdBy.present) {
      map['created_by'] = Variable<String>(createdBy.value);
    }
    if (isSynced.present) {
      map['is_synced'] = Variable<bool>(isSynced.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('PaymentTransactionTableCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('orderUuid: $orderUuid, ')
          ..write('method: $method, ')
          ..write('amount: $amount, ')
          ..write('tendered: $tendered, ')
          ..write('change: $change, ')
          ..write('status: $status, ')
          ..write('referenceId: $referenceId, ')
          ..write('note: $note, ')
          ..write('createdAt: $createdAt, ')
          ..write('createdBy: $createdBy, ')
          ..write('isSynced: $isSynced')
          ..write(')'))
        .toString();
  }
}

class $StockCountTableTable extends StockCountTable
    with TableInfo<$StockCountTableTable, StockCountTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $StockCountTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _warehouseUuidMeta =
      const VerificationMeta('warehouseUuid');
  @override
  late final GeneratedColumn<String> warehouseUuid = GeneratedColumn<String>(
      'warehouse_uuid', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
      'status', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultValue: const Constant('IN_PROGRESS'));
  static const VerificationMeta _startedAtMeta =
      const VerificationMeta('startedAt');
  @override
  late final GeneratedColumn<DateTime> startedAt = GeneratedColumn<DateTime>(
      'started_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _completedAtMeta =
      const VerificationMeta('completedAt');
  @override
  late final GeneratedColumn<DateTime> completedAt = GeneratedColumn<DateTime>(
      'completed_at', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _conductedByMeta =
      const VerificationMeta('conductedBy');
  @override
  late final GeneratedColumn<String> conductedBy = GeneratedColumn<String>(
      'conducted_by', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns =>
      [id, uuid, warehouseUuid, status, startedAt, completedAt, conductedBy];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'stock_count_table';
  @override
  VerificationContext validateIntegrity(
      Insertable<StockCountTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('warehouse_uuid')) {
      context.handle(
          _warehouseUuidMeta,
          warehouseUuid.isAcceptableOrUnknown(
              data['warehouse_uuid']!, _warehouseUuidMeta));
    } else if (isInserting) {
      context.missing(_warehouseUuidMeta);
    }
    if (data.containsKey('status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['status']!, _statusMeta));
    }
    if (data.containsKey('started_at')) {
      context.handle(_startedAtMeta,
          startedAt.isAcceptableOrUnknown(data['started_at']!, _startedAtMeta));
    } else if (isInserting) {
      context.missing(_startedAtMeta);
    }
    if (data.containsKey('completed_at')) {
      context.handle(
          _completedAtMeta,
          completedAt.isAcceptableOrUnknown(
              data['completed_at']!, _completedAtMeta));
    }
    if (data.containsKey('conducted_by')) {
      context.handle(
          _conductedByMeta,
          conductedBy.isAcceptableOrUnknown(
              data['conducted_by']!, _conductedByMeta));
    } else if (isInserting) {
      context.missing(_conductedByMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  StockCountTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return StockCountTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      warehouseUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}warehouse_uuid'])!,
      status: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}status'])!,
      startedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}started_at'])!,
      completedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}completed_at']),
      conductedBy: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}conducted_by'])!,
    );
  }

  @override
  $StockCountTableTable createAlias(String alias) {
    return $StockCountTableTable(attachedDatabase, alias);
  }
}

class StockCountTableData extends DataClass
    implements Insertable<StockCountTableData> {
  final int id;
  final String uuid;
  final String warehouseUuid;
  final String status;
  final DateTime startedAt;
  final DateTime? completedAt;
  final String conductedBy;
  const StockCountTableData(
      {required this.id,
      required this.uuid,
      required this.warehouseUuid,
      required this.status,
      required this.startedAt,
      this.completedAt,
      required this.conductedBy});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    map['warehouse_uuid'] = Variable<String>(warehouseUuid);
    map['status'] = Variable<String>(status);
    map['started_at'] = Variable<DateTime>(startedAt);
    if (!nullToAbsent || completedAt != null) {
      map['completed_at'] = Variable<DateTime>(completedAt);
    }
    map['conducted_by'] = Variable<String>(conductedBy);
    return map;
  }

  StockCountTableCompanion toCompanion(bool nullToAbsent) {
    return StockCountTableCompanion(
      id: Value(id),
      uuid: Value(uuid),
      warehouseUuid: Value(warehouseUuid),
      status: Value(status),
      startedAt: Value(startedAt),
      completedAt: completedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(completedAt),
      conductedBy: Value(conductedBy),
    );
  }

  factory StockCountTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return StockCountTableData(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      warehouseUuid: serializer.fromJson<String>(json['warehouseUuid']),
      status: serializer.fromJson<String>(json['status']),
      startedAt: serializer.fromJson<DateTime>(json['startedAt']),
      completedAt: serializer.fromJson<DateTime?>(json['completedAt']),
      conductedBy: serializer.fromJson<String>(json['conductedBy']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'warehouseUuid': serializer.toJson<String>(warehouseUuid),
      'status': serializer.toJson<String>(status),
      'startedAt': serializer.toJson<DateTime>(startedAt),
      'completedAt': serializer.toJson<DateTime?>(completedAt),
      'conductedBy': serializer.toJson<String>(conductedBy),
    };
  }

  StockCountTableData copyWith(
          {int? id,
          String? uuid,
          String? warehouseUuid,
          String? status,
          DateTime? startedAt,
          Value<DateTime?> completedAt = const Value.absent(),
          String? conductedBy}) =>
      StockCountTableData(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        warehouseUuid: warehouseUuid ?? this.warehouseUuid,
        status: status ?? this.status,
        startedAt: startedAt ?? this.startedAt,
        completedAt: completedAt.present ? completedAt.value : this.completedAt,
        conductedBy: conductedBy ?? this.conductedBy,
      );
  StockCountTableData copyWithCompanion(StockCountTableCompanion data) {
    return StockCountTableData(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      warehouseUuid: data.warehouseUuid.present
          ? data.warehouseUuid.value
          : this.warehouseUuid,
      status: data.status.present ? data.status.value : this.status,
      startedAt: data.startedAt.present ? data.startedAt.value : this.startedAt,
      completedAt:
          data.completedAt.present ? data.completedAt.value : this.completedAt,
      conductedBy:
          data.conductedBy.present ? data.conductedBy.value : this.conductedBy,
    );
  }

  @override
  String toString() {
    return (StringBuffer('StockCountTableData(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('warehouseUuid: $warehouseUuid, ')
          ..write('status: $status, ')
          ..write('startedAt: $startedAt, ')
          ..write('completedAt: $completedAt, ')
          ..write('conductedBy: $conductedBy')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id, uuid, warehouseUuid, status, startedAt, completedAt, conductedBy);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is StockCountTableData &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.warehouseUuid == this.warehouseUuid &&
          other.status == this.status &&
          other.startedAt == this.startedAt &&
          other.completedAt == this.completedAt &&
          other.conductedBy == this.conductedBy);
}

class StockCountTableCompanion extends UpdateCompanion<StockCountTableData> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String> warehouseUuid;
  final Value<String> status;
  final Value<DateTime> startedAt;
  final Value<DateTime?> completedAt;
  final Value<String> conductedBy;
  const StockCountTableCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.warehouseUuid = const Value.absent(),
    this.status = const Value.absent(),
    this.startedAt = const Value.absent(),
    this.completedAt = const Value.absent(),
    this.conductedBy = const Value.absent(),
  });
  StockCountTableCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    required String warehouseUuid,
    this.status = const Value.absent(),
    required DateTime startedAt,
    this.completedAt = const Value.absent(),
    required String conductedBy,
  })  : uuid = Value(uuid),
        warehouseUuid = Value(warehouseUuid),
        startedAt = Value(startedAt),
        conductedBy = Value(conductedBy);
  static Insertable<StockCountTableData> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? warehouseUuid,
    Expression<String>? status,
    Expression<DateTime>? startedAt,
    Expression<DateTime>? completedAt,
    Expression<String>? conductedBy,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (warehouseUuid != null) 'warehouse_uuid': warehouseUuid,
      if (status != null) 'status': status,
      if (startedAt != null) 'started_at': startedAt,
      if (completedAt != null) 'completed_at': completedAt,
      if (conductedBy != null) 'conducted_by': conductedBy,
    });
  }

  StockCountTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String>? warehouseUuid,
      Value<String>? status,
      Value<DateTime>? startedAt,
      Value<DateTime?>? completedAt,
      Value<String>? conductedBy}) {
    return StockCountTableCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      warehouseUuid: warehouseUuid ?? this.warehouseUuid,
      status: status ?? this.status,
      startedAt: startedAt ?? this.startedAt,
      completedAt: completedAt ?? this.completedAt,
      conductedBy: conductedBy ?? this.conductedBy,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (warehouseUuid.present) {
      map['warehouse_uuid'] = Variable<String>(warehouseUuid.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (startedAt.present) {
      map['started_at'] = Variable<DateTime>(startedAt.value);
    }
    if (completedAt.present) {
      map['completed_at'] = Variable<DateTime>(completedAt.value);
    }
    if (conductedBy.present) {
      map['conducted_by'] = Variable<String>(conductedBy.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('StockCountTableCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('warehouseUuid: $warehouseUuid, ')
          ..write('status: $status, ')
          ..write('startedAt: $startedAt, ')
          ..write('completedAt: $completedAt, ')
          ..write('conductedBy: $conductedBy')
          ..write(')'))
        .toString();
  }
}

class $StockCountItemTableTable extends StockCountItemTable
    with TableInfo<$StockCountItemTableTable, StockCountItemTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $StockCountItemTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _countUuidMeta =
      const VerificationMeta('countUuid');
  @override
  late final GeneratedColumn<String> countUuid = GeneratedColumn<String>(
      'count_uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES stock_count_table (uuid) ON DELETE CASCADE'));
  static const VerificationMeta _productUuidMeta =
      const VerificationMeta('productUuid');
  @override
  late final GeneratedColumn<String> productUuid = GeneratedColumn<String>(
      'product_uuid', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _expectedQtyMeta =
      const VerificationMeta('expectedQty');
  @override
  late final GeneratedColumn<double> expectedQty = GeneratedColumn<double>(
      'expected_qty', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _countedQtyMeta =
      const VerificationMeta('countedQty');
  @override
  late final GeneratedColumn<double> countedQty = GeneratedColumn<double>(
      'counted_qty', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _varianceMeta =
      const VerificationMeta('variance');
  @override
  late final GeneratedColumn<double> variance = GeneratedColumn<double>(
      'variance', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns =>
      [id, countUuid, productUuid, expectedQty, countedQty, variance];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'stock_count_item_table';
  @override
  VerificationContext validateIntegrity(
      Insertable<StockCountItemTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('count_uuid')) {
      context.handle(_countUuidMeta,
          countUuid.isAcceptableOrUnknown(data['count_uuid']!, _countUuidMeta));
    } else if (isInserting) {
      context.missing(_countUuidMeta);
    }
    if (data.containsKey('product_uuid')) {
      context.handle(
          _productUuidMeta,
          productUuid.isAcceptableOrUnknown(
              data['product_uuid']!, _productUuidMeta));
    } else if (isInserting) {
      context.missing(_productUuidMeta);
    }
    if (data.containsKey('expected_qty')) {
      context.handle(
          _expectedQtyMeta,
          expectedQty.isAcceptableOrUnknown(
              data['expected_qty']!, _expectedQtyMeta));
    } else if (isInserting) {
      context.missing(_expectedQtyMeta);
    }
    if (data.containsKey('counted_qty')) {
      context.handle(
          _countedQtyMeta,
          countedQty.isAcceptableOrUnknown(
              data['counted_qty']!, _countedQtyMeta));
    } else if (isInserting) {
      context.missing(_countedQtyMeta);
    }
    if (data.containsKey('variance')) {
      context.handle(_varianceMeta,
          variance.isAcceptableOrUnknown(data['variance']!, _varianceMeta));
    } else if (isInserting) {
      context.missing(_varianceMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  StockCountItemTableData map(Map<String, dynamic> data,
      {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return StockCountItemTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      countUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}count_uuid'])!,
      productUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}product_uuid'])!,
      expectedQty: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}expected_qty'])!,
      countedQty: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}counted_qty'])!,
      variance: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}variance'])!,
    );
  }

  @override
  $StockCountItemTableTable createAlias(String alias) {
    return $StockCountItemTableTable(attachedDatabase, alias);
  }
}

class StockCountItemTableData extends DataClass
    implements Insertable<StockCountItemTableData> {
  final int id;
  final String countUuid;
  final String productUuid;
  final double expectedQty;
  final double countedQty;
  final double variance;
  const StockCountItemTableData(
      {required this.id,
      required this.countUuid,
      required this.productUuid,
      required this.expectedQty,
      required this.countedQty,
      required this.variance});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['count_uuid'] = Variable<String>(countUuid);
    map['product_uuid'] = Variable<String>(productUuid);
    map['expected_qty'] = Variable<double>(expectedQty);
    map['counted_qty'] = Variable<double>(countedQty);
    map['variance'] = Variable<double>(variance);
    return map;
  }

  StockCountItemTableCompanion toCompanion(bool nullToAbsent) {
    return StockCountItemTableCompanion(
      id: Value(id),
      countUuid: Value(countUuid),
      productUuid: Value(productUuid),
      expectedQty: Value(expectedQty),
      countedQty: Value(countedQty),
      variance: Value(variance),
    );
  }

  factory StockCountItemTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return StockCountItemTableData(
      id: serializer.fromJson<int>(json['id']),
      countUuid: serializer.fromJson<String>(json['countUuid']),
      productUuid: serializer.fromJson<String>(json['productUuid']),
      expectedQty: serializer.fromJson<double>(json['expectedQty']),
      countedQty: serializer.fromJson<double>(json['countedQty']),
      variance: serializer.fromJson<double>(json['variance']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'countUuid': serializer.toJson<String>(countUuid),
      'productUuid': serializer.toJson<String>(productUuid),
      'expectedQty': serializer.toJson<double>(expectedQty),
      'countedQty': serializer.toJson<double>(countedQty),
      'variance': serializer.toJson<double>(variance),
    };
  }

  StockCountItemTableData copyWith(
          {int? id,
          String? countUuid,
          String? productUuid,
          double? expectedQty,
          double? countedQty,
          double? variance}) =>
      StockCountItemTableData(
        id: id ?? this.id,
        countUuid: countUuid ?? this.countUuid,
        productUuid: productUuid ?? this.productUuid,
        expectedQty: expectedQty ?? this.expectedQty,
        countedQty: countedQty ?? this.countedQty,
        variance: variance ?? this.variance,
      );
  StockCountItemTableData copyWithCompanion(StockCountItemTableCompanion data) {
    return StockCountItemTableData(
      id: data.id.present ? data.id.value : this.id,
      countUuid: data.countUuid.present ? data.countUuid.value : this.countUuid,
      productUuid:
          data.productUuid.present ? data.productUuid.value : this.productUuid,
      expectedQty:
          data.expectedQty.present ? data.expectedQty.value : this.expectedQty,
      countedQty:
          data.countedQty.present ? data.countedQty.value : this.countedQty,
      variance: data.variance.present ? data.variance.value : this.variance,
    );
  }

  @override
  String toString() {
    return (StringBuffer('StockCountItemTableData(')
          ..write('id: $id, ')
          ..write('countUuid: $countUuid, ')
          ..write('productUuid: $productUuid, ')
          ..write('expectedQty: $expectedQty, ')
          ..write('countedQty: $countedQty, ')
          ..write('variance: $variance')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id, countUuid, productUuid, expectedQty, countedQty, variance);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is StockCountItemTableData &&
          other.id == this.id &&
          other.countUuid == this.countUuid &&
          other.productUuid == this.productUuid &&
          other.expectedQty == this.expectedQty &&
          other.countedQty == this.countedQty &&
          other.variance == this.variance);
}

class StockCountItemTableCompanion
    extends UpdateCompanion<StockCountItemTableData> {
  final Value<int> id;
  final Value<String> countUuid;
  final Value<String> productUuid;
  final Value<double> expectedQty;
  final Value<double> countedQty;
  final Value<double> variance;
  const StockCountItemTableCompanion({
    this.id = const Value.absent(),
    this.countUuid = const Value.absent(),
    this.productUuid = const Value.absent(),
    this.expectedQty = const Value.absent(),
    this.countedQty = const Value.absent(),
    this.variance = const Value.absent(),
  });
  StockCountItemTableCompanion.insert({
    this.id = const Value.absent(),
    required String countUuid,
    required String productUuid,
    required double expectedQty,
    required double countedQty,
    required double variance,
  })  : countUuid = Value(countUuid),
        productUuid = Value(productUuid),
        expectedQty = Value(expectedQty),
        countedQty = Value(countedQty),
        variance = Value(variance);
  static Insertable<StockCountItemTableData> custom({
    Expression<int>? id,
    Expression<String>? countUuid,
    Expression<String>? productUuid,
    Expression<double>? expectedQty,
    Expression<double>? countedQty,
    Expression<double>? variance,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (countUuid != null) 'count_uuid': countUuid,
      if (productUuid != null) 'product_uuid': productUuid,
      if (expectedQty != null) 'expected_qty': expectedQty,
      if (countedQty != null) 'counted_qty': countedQty,
      if (variance != null) 'variance': variance,
    });
  }

  StockCountItemTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? countUuid,
      Value<String>? productUuid,
      Value<double>? expectedQty,
      Value<double>? countedQty,
      Value<double>? variance}) {
    return StockCountItemTableCompanion(
      id: id ?? this.id,
      countUuid: countUuid ?? this.countUuid,
      productUuid: productUuid ?? this.productUuid,
      expectedQty: expectedQty ?? this.expectedQty,
      countedQty: countedQty ?? this.countedQty,
      variance: variance ?? this.variance,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (countUuid.present) {
      map['count_uuid'] = Variable<String>(countUuid.value);
    }
    if (productUuid.present) {
      map['product_uuid'] = Variable<String>(productUuid.value);
    }
    if (expectedQty.present) {
      map['expected_qty'] = Variable<double>(expectedQty.value);
    }
    if (countedQty.present) {
      map['counted_qty'] = Variable<double>(countedQty.value);
    }
    if (variance.present) {
      map['variance'] = Variable<double>(variance.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('StockCountItemTableCompanion(')
          ..write('id: $id, ')
          ..write('countUuid: $countUuid, ')
          ..write('productUuid: $productUuid, ')
          ..write('expectedQty: $expectedQty, ')
          ..write('countedQty: $countedQty, ')
          ..write('variance: $variance')
          ..write(')'))
        .toString();
  }
}

class $WarehouseTableTable extends WarehouseTable
    with TableInfo<$WarehouseTableTable, WarehouseTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $WarehouseTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
      'code', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _typeMeta = const VerificationMeta('type');
  @override
  late final GeneratedColumn<String> type = GeneratedColumn<String>(
      'type', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultValue: const Constant('WAREHOUSE'));
  static const VerificationMeta _addressMeta =
      const VerificationMeta('address');
  @override
  late final GeneratedColumn<String> address = GeneratedColumn<String>(
      'address', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _contactPhoneMeta =
      const VerificationMeta('contactPhone');
  @override
  late final GeneratedColumn<String> contactPhone = GeneratedColumn<String>(
      'contact_phone', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isPrimaryMeta =
      const VerificationMeta('isPrimary');
  @override
  late final GeneratedColumn<bool> isPrimary = GeneratedColumn<bool>(
      'is_primary', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_primary" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _isActiveMeta =
      const VerificationMeta('isActive');
  @override
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
      'is_active', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_active" IN (0, 1))'),
      defaultValue: const Constant(true));
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        name,
        code,
        type,
        address,
        contactPhone,
        isPrimary,
        isActive,
        createdAt,
        updatedAt,
        isDeleted
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'warehouse_table';
  @override
  VerificationContext validateIntegrity(Insertable<WarehouseTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('type')) {
      context.handle(
          _typeMeta, type.isAcceptableOrUnknown(data['type']!, _typeMeta));
    }
    if (data.containsKey('address')) {
      context.handle(_addressMeta,
          address.isAcceptableOrUnknown(data['address']!, _addressMeta));
    }
    if (data.containsKey('contact_phone')) {
      context.handle(
          _contactPhoneMeta,
          contactPhone.isAcceptableOrUnknown(
              data['contact_phone']!, _contactPhoneMeta));
    }
    if (data.containsKey('is_primary')) {
      context.handle(_isPrimaryMeta,
          isPrimary.isAcceptableOrUnknown(data['is_primary']!, _isPrimaryMeta));
    }
    if (data.containsKey('is_active')) {
      context.handle(_isActiveMeta,
          isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  WarehouseTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return WarehouseTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      type: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}type'])!,
      address: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}address']),
      contactPhone: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}contact_phone']),
      isPrimary: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_primary'])!,
      isActive: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_active'])!,
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted'])!,
    );
  }

  @override
  $WarehouseTableTable createAlias(String alias) {
    return $WarehouseTableTable(attachedDatabase, alias);
  }
}

class WarehouseTableData extends DataClass
    implements Insertable<WarehouseTableData> {
  final int id;
  final String uuid;
  final String name;
  final String code;
  final String type;
  final String? address;
  final String? contactPhone;
  final bool isPrimary;
  final bool isActive;
  final DateTime createdAt;
  final DateTime updatedAt;
  final bool isDeleted;
  const WarehouseTableData(
      {required this.id,
      required this.uuid,
      required this.name,
      required this.code,
      required this.type,
      this.address,
      this.contactPhone,
      required this.isPrimary,
      required this.isActive,
      required this.createdAt,
      required this.updatedAt,
      required this.isDeleted});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    map['name'] = Variable<String>(name);
    map['code'] = Variable<String>(code);
    map['type'] = Variable<String>(type);
    if (!nullToAbsent || address != null) {
      map['address'] = Variable<String>(address);
    }
    if (!nullToAbsent || contactPhone != null) {
      map['contact_phone'] = Variable<String>(contactPhone);
    }
    map['is_primary'] = Variable<bool>(isPrimary);
    map['is_active'] = Variable<bool>(isActive);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    map['is_deleted'] = Variable<bool>(isDeleted);
    return map;
  }

  WarehouseTableCompanion toCompanion(bool nullToAbsent) {
    return WarehouseTableCompanion(
      id: Value(id),
      uuid: Value(uuid),
      name: Value(name),
      code: Value(code),
      type: Value(type),
      address: address == null && nullToAbsent
          ? const Value.absent()
          : Value(address),
      contactPhone: contactPhone == null && nullToAbsent
          ? const Value.absent()
          : Value(contactPhone),
      isPrimary: Value(isPrimary),
      isActive: Value(isActive),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
      isDeleted: Value(isDeleted),
    );
  }

  factory WarehouseTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return WarehouseTableData(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      name: serializer.fromJson<String>(json['name']),
      code: serializer.fromJson<String>(json['code']),
      type: serializer.fromJson<String>(json['type']),
      address: serializer.fromJson<String?>(json['address']),
      contactPhone: serializer.fromJson<String?>(json['contactPhone']),
      isPrimary: serializer.fromJson<bool>(json['isPrimary']),
      isActive: serializer.fromJson<bool>(json['isActive']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'name': serializer.toJson<String>(name),
      'code': serializer.toJson<String>(code),
      'type': serializer.toJson<String>(type),
      'address': serializer.toJson<String?>(address),
      'contactPhone': serializer.toJson<String?>(contactPhone),
      'isPrimary': serializer.toJson<bool>(isPrimary),
      'isActive': serializer.toJson<bool>(isActive),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
      'isDeleted': serializer.toJson<bool>(isDeleted),
    };
  }

  WarehouseTableData copyWith(
          {int? id,
          String? uuid,
          String? name,
          String? code,
          String? type,
          Value<String?> address = const Value.absent(),
          Value<String?> contactPhone = const Value.absent(),
          bool? isPrimary,
          bool? isActive,
          DateTime? createdAt,
          DateTime? updatedAt,
          bool? isDeleted}) =>
      WarehouseTableData(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        name: name ?? this.name,
        code: code ?? this.code,
        type: type ?? this.type,
        address: address.present ? address.value : this.address,
        contactPhone:
            contactPhone.present ? contactPhone.value : this.contactPhone,
        isPrimary: isPrimary ?? this.isPrimary,
        isActive: isActive ?? this.isActive,
        createdAt: createdAt ?? this.createdAt,
        updatedAt: updatedAt ?? this.updatedAt,
        isDeleted: isDeleted ?? this.isDeleted,
      );
  WarehouseTableData copyWithCompanion(WarehouseTableCompanion data) {
    return WarehouseTableData(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      name: data.name.present ? data.name.value : this.name,
      code: data.code.present ? data.code.value : this.code,
      type: data.type.present ? data.type.value : this.type,
      address: data.address.present ? data.address.value : this.address,
      contactPhone: data.contactPhone.present
          ? data.contactPhone.value
          : this.contactPhone,
      isPrimary: data.isPrimary.present ? data.isPrimary.value : this.isPrimary,
      isActive: data.isActive.present ? data.isActive.value : this.isActive,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      isDeleted: data.isDeleted.present ? data.isDeleted.value : this.isDeleted,
    );
  }

  @override
  String toString() {
    return (StringBuffer('WarehouseTableData(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('code: $code, ')
          ..write('type: $type, ')
          ..write('address: $address, ')
          ..write('contactPhone: $contactPhone, ')
          ..write('isPrimary: $isPrimary, ')
          ..write('isActive: $isActive, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('isDeleted: $isDeleted')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, uuid, name, code, type, address,
      contactPhone, isPrimary, isActive, createdAt, updatedAt, isDeleted);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is WarehouseTableData &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.name == this.name &&
          other.code == this.code &&
          other.type == this.type &&
          other.address == this.address &&
          other.contactPhone == this.contactPhone &&
          other.isPrimary == this.isPrimary &&
          other.isActive == this.isActive &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt &&
          other.isDeleted == this.isDeleted);
}

class WarehouseTableCompanion extends UpdateCompanion<WarehouseTableData> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String> name;
  final Value<String> code;
  final Value<String> type;
  final Value<String?> address;
  final Value<String?> contactPhone;
  final Value<bool> isPrimary;
  final Value<bool> isActive;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<bool> isDeleted;
  const WarehouseTableCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.name = const Value.absent(),
    this.code = const Value.absent(),
    this.type = const Value.absent(),
    this.address = const Value.absent(),
    this.contactPhone = const Value.absent(),
    this.isPrimary = const Value.absent(),
    this.isActive = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.isDeleted = const Value.absent(),
  });
  WarehouseTableCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    required String name,
    required String code,
    this.type = const Value.absent(),
    this.address = const Value.absent(),
    this.contactPhone = const Value.absent(),
    this.isPrimary = const Value.absent(),
    this.isActive = const Value.absent(),
    required DateTime createdAt,
    required DateTime updatedAt,
    this.isDeleted = const Value.absent(),
  })  : uuid = Value(uuid),
        name = Value(name),
        code = Value(code),
        createdAt = Value(createdAt),
        updatedAt = Value(updatedAt);
  static Insertable<WarehouseTableData> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? name,
    Expression<String>? code,
    Expression<String>? type,
    Expression<String>? address,
    Expression<String>? contactPhone,
    Expression<bool>? isPrimary,
    Expression<bool>? isActive,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<bool>? isDeleted,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (name != null) 'name': name,
      if (code != null) 'code': code,
      if (type != null) 'type': type,
      if (address != null) 'address': address,
      if (contactPhone != null) 'contact_phone': contactPhone,
      if (isPrimary != null) 'is_primary': isPrimary,
      if (isActive != null) 'is_active': isActive,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (isDeleted != null) 'is_deleted': isDeleted,
    });
  }

  WarehouseTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String>? name,
      Value<String>? code,
      Value<String>? type,
      Value<String?>? address,
      Value<String?>? contactPhone,
      Value<bool>? isPrimary,
      Value<bool>? isActive,
      Value<DateTime>? createdAt,
      Value<DateTime>? updatedAt,
      Value<bool>? isDeleted}) {
    return WarehouseTableCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      name: name ?? this.name,
      code: code ?? this.code,
      type: type ?? this.type,
      address: address ?? this.address,
      contactPhone: contactPhone ?? this.contactPhone,
      isPrimary: isPrimary ?? this.isPrimary,
      isActive: isActive ?? this.isActive,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      isDeleted: isDeleted ?? this.isDeleted,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (type.present) {
      map['type'] = Variable<String>(type.value);
    }
    if (address.present) {
      map['address'] = Variable<String>(address.value);
    }
    if (contactPhone.present) {
      map['contact_phone'] = Variable<String>(contactPhone.value);
    }
    if (isPrimary.present) {
      map['is_primary'] = Variable<bool>(isPrimary.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('WarehouseTableCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('code: $code, ')
          ..write('type: $type, ')
          ..write('address: $address, ')
          ..write('contactPhone: $contactPhone, ')
          ..write('isPrimary: $isPrimary, ')
          ..write('isActive: $isActive, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('isDeleted: $isDeleted')
          ..write(')'))
        .toString();
  }
}

class $StockLevelTableTable extends StockLevelTable
    with TableInfo<$StockLevelTableTable, StockLevelTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $StockLevelTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _productUuidMeta =
      const VerificationMeta('productUuid');
  @override
  late final GeneratedColumn<String> productUuid = GeneratedColumn<String>(
      'product_uuid', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _warehouseUuidMeta =
      const VerificationMeta('warehouseUuid');
  @override
  late final GeneratedColumn<String> warehouseUuid = GeneratedColumn<String>(
      'warehouse_uuid', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _quantityMeta =
      const VerificationMeta('quantity');
  @override
  late final GeneratedColumn<double> quantity = GeneratedColumn<double>(
      'quantity', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: false,
      defaultValue: const Constant(0));
  static const VerificationMeta _reservedQuantityMeta =
      const VerificationMeta('reservedQuantity');
  @override
  late final GeneratedColumn<double> reservedQuantity = GeneratedColumn<double>(
      'reserved_quantity', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: false,
      defaultValue: const Constant(0));
  static const VerificationMeta _availableQuantityMeta =
      const VerificationMeta('availableQuantity');
  @override
  late final GeneratedColumn<double> availableQuantity =
      GeneratedColumn<double>('available_quantity', aliasedName, false,
          type: DriftSqlType.double,
          requiredDuringInsert: false,
          defaultValue: const Constant(0));
  static const VerificationMeta _reorderPointMeta =
      const VerificationMeta('reorderPoint');
  @override
  late final GeneratedColumn<double> reorderPoint = GeneratedColumn<double>(
      'reorder_point', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _reorderQuantityMeta =
      const VerificationMeta('reorderQuantity');
  @override
  late final GeneratedColumn<double> reorderQuantity = GeneratedColumn<double>(
      'reorder_quantity', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _maxStockLevelMeta =
      const VerificationMeta('maxStockLevel');
  @override
  late final GeneratedColumn<double> maxStockLevel = GeneratedColumn<double>(
      'max_stock_level', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _averageCostMeta =
      const VerificationMeta('averageCost');
  @override
  late final GeneratedColumn<double> averageCost = GeneratedColumn<double>(
      'average_cost', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: false,
      defaultValue: const Constant(0));
  static const VerificationMeta _averageDailySalesMeta =
      const VerificationMeta('averageDailySales');
  @override
  late final GeneratedColumn<double> averageDailySales =
      GeneratedColumn<double>('average_daily_sales', aliasedName, false,
          type: DriftSqlType.double,
          requiredDuringInsert: false,
          defaultValue: const Constant(0));
  static const VerificationMeta _daysOfStockMeta =
      const VerificationMeta('daysOfStock');
  @override
  late final GeneratedColumn<int> daysOfStock = GeneratedColumn<int>(
      'days_of_stock', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _lastCountedAtMeta =
      const VerificationMeta('lastCountedAt');
  @override
  late final GeneratedColumn<DateTime> lastCountedAt =
      GeneratedColumn<DateTime>('last_counted_at', aliasedName, true,
          type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _lastMovementAtMeta =
      const VerificationMeta('lastMovementAt');
  @override
  late final GeneratedColumn<DateTime> lastMovementAt =
      GeneratedColumn<DateTime>('last_movement_at', aliasedName, true,
          type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        productUuid,
        warehouseUuid,
        quantity,
        reservedQuantity,
        availableQuantity,
        reorderPoint,
        reorderQuantity,
        maxStockLevel,
        averageCost,
        averageDailySales,
        daysOfStock,
        lastCountedAt,
        lastMovementAt,
        updatedAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'stock_level_table';
  @override
  VerificationContext validateIntegrity(
      Insertable<StockLevelTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('product_uuid')) {
      context.handle(
          _productUuidMeta,
          productUuid.isAcceptableOrUnknown(
              data['product_uuid']!, _productUuidMeta));
    } else if (isInserting) {
      context.missing(_productUuidMeta);
    }
    if (data.containsKey('warehouse_uuid')) {
      context.handle(
          _warehouseUuidMeta,
          warehouseUuid.isAcceptableOrUnknown(
              data['warehouse_uuid']!, _warehouseUuidMeta));
    } else if (isInserting) {
      context.missing(_warehouseUuidMeta);
    }
    if (data.containsKey('quantity')) {
      context.handle(_quantityMeta,
          quantity.isAcceptableOrUnknown(data['quantity']!, _quantityMeta));
    }
    if (data.containsKey('reserved_quantity')) {
      context.handle(
          _reservedQuantityMeta,
          reservedQuantity.isAcceptableOrUnknown(
              data['reserved_quantity']!, _reservedQuantityMeta));
    }
    if (data.containsKey('available_quantity')) {
      context.handle(
          _availableQuantityMeta,
          availableQuantity.isAcceptableOrUnknown(
              data['available_quantity']!, _availableQuantityMeta));
    }
    if (data.containsKey('reorder_point')) {
      context.handle(
          _reorderPointMeta,
          reorderPoint.isAcceptableOrUnknown(
              data['reorder_point']!, _reorderPointMeta));
    }
    if (data.containsKey('reorder_quantity')) {
      context.handle(
          _reorderQuantityMeta,
          reorderQuantity.isAcceptableOrUnknown(
              data['reorder_quantity']!, _reorderQuantityMeta));
    }
    if (data.containsKey('max_stock_level')) {
      context.handle(
          _maxStockLevelMeta,
          maxStockLevel.isAcceptableOrUnknown(
              data['max_stock_level']!, _maxStockLevelMeta));
    }
    if (data.containsKey('average_cost')) {
      context.handle(
          _averageCostMeta,
          averageCost.isAcceptableOrUnknown(
              data['average_cost']!, _averageCostMeta));
    }
    if (data.containsKey('average_daily_sales')) {
      context.handle(
          _averageDailySalesMeta,
          averageDailySales.isAcceptableOrUnknown(
              data['average_daily_sales']!, _averageDailySalesMeta));
    }
    if (data.containsKey('days_of_stock')) {
      context.handle(
          _daysOfStockMeta,
          daysOfStock.isAcceptableOrUnknown(
              data['days_of_stock']!, _daysOfStockMeta));
    }
    if (data.containsKey('last_counted_at')) {
      context.handle(
          _lastCountedAtMeta,
          lastCountedAt.isAcceptableOrUnknown(
              data['last_counted_at']!, _lastCountedAtMeta));
    }
    if (data.containsKey('last_movement_at')) {
      context.handle(
          _lastMovementAtMeta,
          lastMovementAt.isAcceptableOrUnknown(
              data['last_movement_at']!, _lastMovementAtMeta));
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
        {productUuid, warehouseUuid},
      ];
  @override
  StockLevelTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return StockLevelTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      productUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}product_uuid'])!,
      warehouseUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}warehouse_uuid'])!,
      quantity: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}quantity'])!,
      reservedQuantity: attachedDatabase.typeMapping.read(
          DriftSqlType.double, data['${effectivePrefix}reserved_quantity'])!,
      availableQuantity: attachedDatabase.typeMapping.read(
          DriftSqlType.double, data['${effectivePrefix}available_quantity'])!,
      reorderPoint: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}reorder_point']),
      reorderQuantity: attachedDatabase.typeMapping.read(
          DriftSqlType.double, data['${effectivePrefix}reorder_quantity']),
      maxStockLevel: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}max_stock_level']),
      averageCost: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}average_cost'])!,
      averageDailySales: attachedDatabase.typeMapping.read(
          DriftSqlType.double, data['${effectivePrefix}average_daily_sales'])!,
      daysOfStock: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}days_of_stock']),
      lastCountedAt: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}last_counted_at']),
      lastMovementAt: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}last_movement_at']),
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $StockLevelTableTable createAlias(String alias) {
    return $StockLevelTableTable(attachedDatabase, alias);
  }
}

class StockLevelTableData extends DataClass
    implements Insertable<StockLevelTableData> {
  final int id;
  final String productUuid;
  final String warehouseUuid;
  final double quantity;
  final double reservedQuantity;
  final double availableQuantity;
  final double? reorderPoint;
  final double? reorderQuantity;
  final double? maxStockLevel;
  final double averageCost;
  final double averageDailySales;
  final int? daysOfStock;
  final DateTime? lastCountedAt;
  final DateTime? lastMovementAt;
  final DateTime updatedAt;
  const StockLevelTableData(
      {required this.id,
      required this.productUuid,
      required this.warehouseUuid,
      required this.quantity,
      required this.reservedQuantity,
      required this.availableQuantity,
      this.reorderPoint,
      this.reorderQuantity,
      this.maxStockLevel,
      required this.averageCost,
      required this.averageDailySales,
      this.daysOfStock,
      this.lastCountedAt,
      this.lastMovementAt,
      required this.updatedAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['product_uuid'] = Variable<String>(productUuid);
    map['warehouse_uuid'] = Variable<String>(warehouseUuid);
    map['quantity'] = Variable<double>(quantity);
    map['reserved_quantity'] = Variable<double>(reservedQuantity);
    map['available_quantity'] = Variable<double>(availableQuantity);
    if (!nullToAbsent || reorderPoint != null) {
      map['reorder_point'] = Variable<double>(reorderPoint);
    }
    if (!nullToAbsent || reorderQuantity != null) {
      map['reorder_quantity'] = Variable<double>(reorderQuantity);
    }
    if (!nullToAbsent || maxStockLevel != null) {
      map['max_stock_level'] = Variable<double>(maxStockLevel);
    }
    map['average_cost'] = Variable<double>(averageCost);
    map['average_daily_sales'] = Variable<double>(averageDailySales);
    if (!nullToAbsent || daysOfStock != null) {
      map['days_of_stock'] = Variable<int>(daysOfStock);
    }
    if (!nullToAbsent || lastCountedAt != null) {
      map['last_counted_at'] = Variable<DateTime>(lastCountedAt);
    }
    if (!nullToAbsent || lastMovementAt != null) {
      map['last_movement_at'] = Variable<DateTime>(lastMovementAt);
    }
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  StockLevelTableCompanion toCompanion(bool nullToAbsent) {
    return StockLevelTableCompanion(
      id: Value(id),
      productUuid: Value(productUuid),
      warehouseUuid: Value(warehouseUuid),
      quantity: Value(quantity),
      reservedQuantity: Value(reservedQuantity),
      availableQuantity: Value(availableQuantity),
      reorderPoint: reorderPoint == null && nullToAbsent
          ? const Value.absent()
          : Value(reorderPoint),
      reorderQuantity: reorderQuantity == null && nullToAbsent
          ? const Value.absent()
          : Value(reorderQuantity),
      maxStockLevel: maxStockLevel == null && nullToAbsent
          ? const Value.absent()
          : Value(maxStockLevel),
      averageCost: Value(averageCost),
      averageDailySales: Value(averageDailySales),
      daysOfStock: daysOfStock == null && nullToAbsent
          ? const Value.absent()
          : Value(daysOfStock),
      lastCountedAt: lastCountedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(lastCountedAt),
      lastMovementAt: lastMovementAt == null && nullToAbsent
          ? const Value.absent()
          : Value(lastMovementAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory StockLevelTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return StockLevelTableData(
      id: serializer.fromJson<int>(json['id']),
      productUuid: serializer.fromJson<String>(json['productUuid']),
      warehouseUuid: serializer.fromJson<String>(json['warehouseUuid']),
      quantity: serializer.fromJson<double>(json['quantity']),
      reservedQuantity: serializer.fromJson<double>(json['reservedQuantity']),
      availableQuantity: serializer.fromJson<double>(json['availableQuantity']),
      reorderPoint: serializer.fromJson<double?>(json['reorderPoint']),
      reorderQuantity: serializer.fromJson<double?>(json['reorderQuantity']),
      maxStockLevel: serializer.fromJson<double?>(json['maxStockLevel']),
      averageCost: serializer.fromJson<double>(json['averageCost']),
      averageDailySales: serializer.fromJson<double>(json['averageDailySales']),
      daysOfStock: serializer.fromJson<int?>(json['daysOfStock']),
      lastCountedAt: serializer.fromJson<DateTime?>(json['lastCountedAt']),
      lastMovementAt: serializer.fromJson<DateTime?>(json['lastMovementAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'productUuid': serializer.toJson<String>(productUuid),
      'warehouseUuid': serializer.toJson<String>(warehouseUuid),
      'quantity': serializer.toJson<double>(quantity),
      'reservedQuantity': serializer.toJson<double>(reservedQuantity),
      'availableQuantity': serializer.toJson<double>(availableQuantity),
      'reorderPoint': serializer.toJson<double?>(reorderPoint),
      'reorderQuantity': serializer.toJson<double?>(reorderQuantity),
      'maxStockLevel': serializer.toJson<double?>(maxStockLevel),
      'averageCost': serializer.toJson<double>(averageCost),
      'averageDailySales': serializer.toJson<double>(averageDailySales),
      'daysOfStock': serializer.toJson<int?>(daysOfStock),
      'lastCountedAt': serializer.toJson<DateTime?>(lastCountedAt),
      'lastMovementAt': serializer.toJson<DateTime?>(lastMovementAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  StockLevelTableData copyWith(
          {int? id,
          String? productUuid,
          String? warehouseUuid,
          double? quantity,
          double? reservedQuantity,
          double? availableQuantity,
          Value<double?> reorderPoint = const Value.absent(),
          Value<double?> reorderQuantity = const Value.absent(),
          Value<double?> maxStockLevel = const Value.absent(),
          double? averageCost,
          double? averageDailySales,
          Value<int?> daysOfStock = const Value.absent(),
          Value<DateTime?> lastCountedAt = const Value.absent(),
          Value<DateTime?> lastMovementAt = const Value.absent(),
          DateTime? updatedAt}) =>
      StockLevelTableData(
        id: id ?? this.id,
        productUuid: productUuid ?? this.productUuid,
        warehouseUuid: warehouseUuid ?? this.warehouseUuid,
        quantity: quantity ?? this.quantity,
        reservedQuantity: reservedQuantity ?? this.reservedQuantity,
        availableQuantity: availableQuantity ?? this.availableQuantity,
        reorderPoint:
            reorderPoint.present ? reorderPoint.value : this.reorderPoint,
        reorderQuantity: reorderQuantity.present
            ? reorderQuantity.value
            : this.reorderQuantity,
        maxStockLevel:
            maxStockLevel.present ? maxStockLevel.value : this.maxStockLevel,
        averageCost: averageCost ?? this.averageCost,
        averageDailySales: averageDailySales ?? this.averageDailySales,
        daysOfStock: daysOfStock.present ? daysOfStock.value : this.daysOfStock,
        lastCountedAt:
            lastCountedAt.present ? lastCountedAt.value : this.lastCountedAt,
        lastMovementAt:
            lastMovementAt.present ? lastMovementAt.value : this.lastMovementAt,
        updatedAt: updatedAt ?? this.updatedAt,
      );
  StockLevelTableData copyWithCompanion(StockLevelTableCompanion data) {
    return StockLevelTableData(
      id: data.id.present ? data.id.value : this.id,
      productUuid:
          data.productUuid.present ? data.productUuid.value : this.productUuid,
      warehouseUuid: data.warehouseUuid.present
          ? data.warehouseUuid.value
          : this.warehouseUuid,
      quantity: data.quantity.present ? data.quantity.value : this.quantity,
      reservedQuantity: data.reservedQuantity.present
          ? data.reservedQuantity.value
          : this.reservedQuantity,
      availableQuantity: data.availableQuantity.present
          ? data.availableQuantity.value
          : this.availableQuantity,
      reorderPoint: data.reorderPoint.present
          ? data.reorderPoint.value
          : this.reorderPoint,
      reorderQuantity: data.reorderQuantity.present
          ? data.reorderQuantity.value
          : this.reorderQuantity,
      maxStockLevel: data.maxStockLevel.present
          ? data.maxStockLevel.value
          : this.maxStockLevel,
      averageCost:
          data.averageCost.present ? data.averageCost.value : this.averageCost,
      averageDailySales: data.averageDailySales.present
          ? data.averageDailySales.value
          : this.averageDailySales,
      daysOfStock:
          data.daysOfStock.present ? data.daysOfStock.value : this.daysOfStock,
      lastCountedAt: data.lastCountedAt.present
          ? data.lastCountedAt.value
          : this.lastCountedAt,
      lastMovementAt: data.lastMovementAt.present
          ? data.lastMovementAt.value
          : this.lastMovementAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('StockLevelTableData(')
          ..write('id: $id, ')
          ..write('productUuid: $productUuid, ')
          ..write('warehouseUuid: $warehouseUuid, ')
          ..write('quantity: $quantity, ')
          ..write('reservedQuantity: $reservedQuantity, ')
          ..write('availableQuantity: $availableQuantity, ')
          ..write('reorderPoint: $reorderPoint, ')
          ..write('reorderQuantity: $reorderQuantity, ')
          ..write('maxStockLevel: $maxStockLevel, ')
          ..write('averageCost: $averageCost, ')
          ..write('averageDailySales: $averageDailySales, ')
          ..write('daysOfStock: $daysOfStock, ')
          ..write('lastCountedAt: $lastCountedAt, ')
          ..write('lastMovementAt: $lastMovementAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      productUuid,
      warehouseUuid,
      quantity,
      reservedQuantity,
      availableQuantity,
      reorderPoint,
      reorderQuantity,
      maxStockLevel,
      averageCost,
      averageDailySales,
      daysOfStock,
      lastCountedAt,
      lastMovementAt,
      updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is StockLevelTableData &&
          other.id == this.id &&
          other.productUuid == this.productUuid &&
          other.warehouseUuid == this.warehouseUuid &&
          other.quantity == this.quantity &&
          other.reservedQuantity == this.reservedQuantity &&
          other.availableQuantity == this.availableQuantity &&
          other.reorderPoint == this.reorderPoint &&
          other.reorderQuantity == this.reorderQuantity &&
          other.maxStockLevel == this.maxStockLevel &&
          other.averageCost == this.averageCost &&
          other.averageDailySales == this.averageDailySales &&
          other.daysOfStock == this.daysOfStock &&
          other.lastCountedAt == this.lastCountedAt &&
          other.lastMovementAt == this.lastMovementAt &&
          other.updatedAt == this.updatedAt);
}

class StockLevelTableCompanion extends UpdateCompanion<StockLevelTableData> {
  final Value<int> id;
  final Value<String> productUuid;
  final Value<String> warehouseUuid;
  final Value<double> quantity;
  final Value<double> reservedQuantity;
  final Value<double> availableQuantity;
  final Value<double?> reorderPoint;
  final Value<double?> reorderQuantity;
  final Value<double?> maxStockLevel;
  final Value<double> averageCost;
  final Value<double> averageDailySales;
  final Value<int?> daysOfStock;
  final Value<DateTime?> lastCountedAt;
  final Value<DateTime?> lastMovementAt;
  final Value<DateTime> updatedAt;
  const StockLevelTableCompanion({
    this.id = const Value.absent(),
    this.productUuid = const Value.absent(),
    this.warehouseUuid = const Value.absent(),
    this.quantity = const Value.absent(),
    this.reservedQuantity = const Value.absent(),
    this.availableQuantity = const Value.absent(),
    this.reorderPoint = const Value.absent(),
    this.reorderQuantity = const Value.absent(),
    this.maxStockLevel = const Value.absent(),
    this.averageCost = const Value.absent(),
    this.averageDailySales = const Value.absent(),
    this.daysOfStock = const Value.absent(),
    this.lastCountedAt = const Value.absent(),
    this.lastMovementAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  StockLevelTableCompanion.insert({
    this.id = const Value.absent(),
    required String productUuid,
    required String warehouseUuid,
    this.quantity = const Value.absent(),
    this.reservedQuantity = const Value.absent(),
    this.availableQuantity = const Value.absent(),
    this.reorderPoint = const Value.absent(),
    this.reorderQuantity = const Value.absent(),
    this.maxStockLevel = const Value.absent(),
    this.averageCost = const Value.absent(),
    this.averageDailySales = const Value.absent(),
    this.daysOfStock = const Value.absent(),
    this.lastCountedAt = const Value.absent(),
    this.lastMovementAt = const Value.absent(),
    required DateTime updatedAt,
  })  : productUuid = Value(productUuid),
        warehouseUuid = Value(warehouseUuid),
        updatedAt = Value(updatedAt);
  static Insertable<StockLevelTableData> custom({
    Expression<int>? id,
    Expression<String>? productUuid,
    Expression<String>? warehouseUuid,
    Expression<double>? quantity,
    Expression<double>? reservedQuantity,
    Expression<double>? availableQuantity,
    Expression<double>? reorderPoint,
    Expression<double>? reorderQuantity,
    Expression<double>? maxStockLevel,
    Expression<double>? averageCost,
    Expression<double>? averageDailySales,
    Expression<int>? daysOfStock,
    Expression<DateTime>? lastCountedAt,
    Expression<DateTime>? lastMovementAt,
    Expression<DateTime>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (productUuid != null) 'product_uuid': productUuid,
      if (warehouseUuid != null) 'warehouse_uuid': warehouseUuid,
      if (quantity != null) 'quantity': quantity,
      if (reservedQuantity != null) 'reserved_quantity': reservedQuantity,
      if (availableQuantity != null) 'available_quantity': availableQuantity,
      if (reorderPoint != null) 'reorder_point': reorderPoint,
      if (reorderQuantity != null) 'reorder_quantity': reorderQuantity,
      if (maxStockLevel != null) 'max_stock_level': maxStockLevel,
      if (averageCost != null) 'average_cost': averageCost,
      if (averageDailySales != null) 'average_daily_sales': averageDailySales,
      if (daysOfStock != null) 'days_of_stock': daysOfStock,
      if (lastCountedAt != null) 'last_counted_at': lastCountedAt,
      if (lastMovementAt != null) 'last_movement_at': lastMovementAt,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  StockLevelTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? productUuid,
      Value<String>? warehouseUuid,
      Value<double>? quantity,
      Value<double>? reservedQuantity,
      Value<double>? availableQuantity,
      Value<double?>? reorderPoint,
      Value<double?>? reorderQuantity,
      Value<double?>? maxStockLevel,
      Value<double>? averageCost,
      Value<double>? averageDailySales,
      Value<int?>? daysOfStock,
      Value<DateTime?>? lastCountedAt,
      Value<DateTime?>? lastMovementAt,
      Value<DateTime>? updatedAt}) {
    return StockLevelTableCompanion(
      id: id ?? this.id,
      productUuid: productUuid ?? this.productUuid,
      warehouseUuid: warehouseUuid ?? this.warehouseUuid,
      quantity: quantity ?? this.quantity,
      reservedQuantity: reservedQuantity ?? this.reservedQuantity,
      availableQuantity: availableQuantity ?? this.availableQuantity,
      reorderPoint: reorderPoint ?? this.reorderPoint,
      reorderQuantity: reorderQuantity ?? this.reorderQuantity,
      maxStockLevel: maxStockLevel ?? this.maxStockLevel,
      averageCost: averageCost ?? this.averageCost,
      averageDailySales: averageDailySales ?? this.averageDailySales,
      daysOfStock: daysOfStock ?? this.daysOfStock,
      lastCountedAt: lastCountedAt ?? this.lastCountedAt,
      lastMovementAt: lastMovementAt ?? this.lastMovementAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (productUuid.present) {
      map['product_uuid'] = Variable<String>(productUuid.value);
    }
    if (warehouseUuid.present) {
      map['warehouse_uuid'] = Variable<String>(warehouseUuid.value);
    }
    if (quantity.present) {
      map['quantity'] = Variable<double>(quantity.value);
    }
    if (reservedQuantity.present) {
      map['reserved_quantity'] = Variable<double>(reservedQuantity.value);
    }
    if (availableQuantity.present) {
      map['available_quantity'] = Variable<double>(availableQuantity.value);
    }
    if (reorderPoint.present) {
      map['reorder_point'] = Variable<double>(reorderPoint.value);
    }
    if (reorderQuantity.present) {
      map['reorder_quantity'] = Variable<double>(reorderQuantity.value);
    }
    if (maxStockLevel.present) {
      map['max_stock_level'] = Variable<double>(maxStockLevel.value);
    }
    if (averageCost.present) {
      map['average_cost'] = Variable<double>(averageCost.value);
    }
    if (averageDailySales.present) {
      map['average_daily_sales'] = Variable<double>(averageDailySales.value);
    }
    if (daysOfStock.present) {
      map['days_of_stock'] = Variable<int>(daysOfStock.value);
    }
    if (lastCountedAt.present) {
      map['last_counted_at'] = Variable<DateTime>(lastCountedAt.value);
    }
    if (lastMovementAt.present) {
      map['last_movement_at'] = Variable<DateTime>(lastMovementAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('StockLevelTableCompanion(')
          ..write('id: $id, ')
          ..write('productUuid: $productUuid, ')
          ..write('warehouseUuid: $warehouseUuid, ')
          ..write('quantity: $quantity, ')
          ..write('reservedQuantity: $reservedQuantity, ')
          ..write('availableQuantity: $availableQuantity, ')
          ..write('reorderPoint: $reorderPoint, ')
          ..write('reorderQuantity: $reorderQuantity, ')
          ..write('maxStockLevel: $maxStockLevel, ')
          ..write('averageCost: $averageCost, ')
          ..write('averageDailySales: $averageDailySales, ')
          ..write('daysOfStock: $daysOfStock, ')
          ..write('lastCountedAt: $lastCountedAt, ')
          ..write('lastMovementAt: $lastMovementAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class $BatchTableTable extends BatchTable
    with TableInfo<$BatchTableTable, BatchTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $BatchTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _productUuidMeta =
      const VerificationMeta('productUuid');
  @override
  late final GeneratedColumn<String> productUuid = GeneratedColumn<String>(
      'product_uuid', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _warehouseUuidMeta =
      const VerificationMeta('warehouseUuid');
  @override
  late final GeneratedColumn<String> warehouseUuid = GeneratedColumn<String>(
      'warehouse_uuid', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _batchNumberMeta =
      const VerificationMeta('batchNumber');
  @override
  late final GeneratedColumn<String> batchNumber = GeneratedColumn<String>(
      'batch_number', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _supplierUuidMeta =
      const VerificationMeta('supplierUuid');
  @override
  late final GeneratedColumn<String> supplierUuid = GeneratedColumn<String>(
      'supplier_uuid', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _poUuidMeta = const VerificationMeta('poUuid');
  @override
  late final GeneratedColumn<String> poUuid = GeneratedColumn<String>(
      'po_uuid', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _initialQuantityMeta =
      const VerificationMeta('initialQuantity');
  @override
  late final GeneratedColumn<double> initialQuantity = GeneratedColumn<double>(
      'initial_quantity', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _currentQuantityMeta =
      const VerificationMeta('currentQuantity');
  @override
  late final GeneratedColumn<double> currentQuantity = GeneratedColumn<double>(
      'current_quantity', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _unitCostMeta =
      const VerificationMeta('unitCost');
  @override
  late final GeneratedColumn<double> unitCost = GeneratedColumn<double>(
      'unit_cost', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _manufacturedAtMeta =
      const VerificationMeta('manufacturedAt');
  @override
  late final GeneratedColumn<DateTime> manufacturedAt =
      GeneratedColumn<DateTime>('manufactured_at', aliasedName, true,
          type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _expiryDateMeta =
      const VerificationMeta('expiryDate');
  @override
  late final GeneratedColumn<DateTime> expiryDate = GeneratedColumn<DateTime>(
      'expiry_date', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _receivedAtMeta =
      const VerificationMeta('receivedAt');
  @override
  late final GeneratedColumn<DateTime> receivedAt = GeneratedColumn<DateTime>(
      'received_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
      'status', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultValue: const Constant('ACTIVE'));
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
      'notes', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        productUuid,
        warehouseUuid,
        batchNumber,
        supplierUuid,
        poUuid,
        initialQuantity,
        currentQuantity,
        unitCost,
        manufacturedAt,
        expiryDate,
        receivedAt,
        status,
        notes,
        updatedAt,
        isDeleted
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'batch_table';
  @override
  VerificationContext validateIntegrity(Insertable<BatchTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('product_uuid')) {
      context.handle(
          _productUuidMeta,
          productUuid.isAcceptableOrUnknown(
              data['product_uuid']!, _productUuidMeta));
    } else if (isInserting) {
      context.missing(_productUuidMeta);
    }
    if (data.containsKey('warehouse_uuid')) {
      context.handle(
          _warehouseUuidMeta,
          warehouseUuid.isAcceptableOrUnknown(
              data['warehouse_uuid']!, _warehouseUuidMeta));
    } else if (isInserting) {
      context.missing(_warehouseUuidMeta);
    }
    if (data.containsKey('batch_number')) {
      context.handle(
          _batchNumberMeta,
          batchNumber.isAcceptableOrUnknown(
              data['batch_number']!, _batchNumberMeta));
    } else if (isInserting) {
      context.missing(_batchNumberMeta);
    }
    if (data.containsKey('supplier_uuid')) {
      context.handle(
          _supplierUuidMeta,
          supplierUuid.isAcceptableOrUnknown(
              data['supplier_uuid']!, _supplierUuidMeta));
    }
    if (data.containsKey('po_uuid')) {
      context.handle(_poUuidMeta,
          poUuid.isAcceptableOrUnknown(data['po_uuid']!, _poUuidMeta));
    }
    if (data.containsKey('initial_quantity')) {
      context.handle(
          _initialQuantityMeta,
          initialQuantity.isAcceptableOrUnknown(
              data['initial_quantity']!, _initialQuantityMeta));
    } else if (isInserting) {
      context.missing(_initialQuantityMeta);
    }
    if (data.containsKey('current_quantity')) {
      context.handle(
          _currentQuantityMeta,
          currentQuantity.isAcceptableOrUnknown(
              data['current_quantity']!, _currentQuantityMeta));
    } else if (isInserting) {
      context.missing(_currentQuantityMeta);
    }
    if (data.containsKey('unit_cost')) {
      context.handle(_unitCostMeta,
          unitCost.isAcceptableOrUnknown(data['unit_cost']!, _unitCostMeta));
    } else if (isInserting) {
      context.missing(_unitCostMeta);
    }
    if (data.containsKey('manufactured_at')) {
      context.handle(
          _manufacturedAtMeta,
          manufacturedAt.isAcceptableOrUnknown(
              data['manufactured_at']!, _manufacturedAtMeta));
    }
    if (data.containsKey('expiry_date')) {
      context.handle(
          _expiryDateMeta,
          expiryDate.isAcceptableOrUnknown(
              data['expiry_date']!, _expiryDateMeta));
    }
    if (data.containsKey('received_at')) {
      context.handle(
          _receivedAtMeta,
          receivedAt.isAcceptableOrUnknown(
              data['received_at']!, _receivedAtMeta));
    } else if (isInserting) {
      context.missing(_receivedAtMeta);
    }
    if (data.containsKey('status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['status']!, _statusMeta));
    }
    if (data.containsKey('notes')) {
      context.handle(
          _notesMeta, notes.isAcceptableOrUnknown(data['notes']!, _notesMeta));
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
        {productUuid, warehouseUuid, batchNumber},
      ];
  @override
  BatchTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return BatchTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      productUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}product_uuid'])!,
      warehouseUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}warehouse_uuid'])!,
      batchNumber: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}batch_number'])!,
      supplierUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}supplier_uuid']),
      poUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}po_uuid']),
      initialQuantity: attachedDatabase.typeMapping.read(
          DriftSqlType.double, data['${effectivePrefix}initial_quantity'])!,
      currentQuantity: attachedDatabase.typeMapping.read(
          DriftSqlType.double, data['${effectivePrefix}current_quantity'])!,
      unitCost: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}unit_cost'])!,
      manufacturedAt: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}manufactured_at']),
      expiryDate: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}expiry_date']),
      receivedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}received_at'])!,
      status: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}status'])!,
      notes: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}notes']),
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted'])!,
    );
  }

  @override
  $BatchTableTable createAlias(String alias) {
    return $BatchTableTable(attachedDatabase, alias);
  }
}

class BatchTableData extends DataClass implements Insertable<BatchTableData> {
  final int id;
  final String uuid;
  final String productUuid;
  final String warehouseUuid;
  final String batchNumber;
  final String? supplierUuid;
  final String? poUuid;
  final double initialQuantity;
  final double currentQuantity;
  final double unitCost;
  final DateTime? manufacturedAt;
  final DateTime? expiryDate;
  final DateTime receivedAt;
  final String status;
  final String? notes;
  final DateTime updatedAt;
  final bool isDeleted;
  const BatchTableData(
      {required this.id,
      required this.uuid,
      required this.productUuid,
      required this.warehouseUuid,
      required this.batchNumber,
      this.supplierUuid,
      this.poUuid,
      required this.initialQuantity,
      required this.currentQuantity,
      required this.unitCost,
      this.manufacturedAt,
      this.expiryDate,
      required this.receivedAt,
      required this.status,
      this.notes,
      required this.updatedAt,
      required this.isDeleted});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    map['product_uuid'] = Variable<String>(productUuid);
    map['warehouse_uuid'] = Variable<String>(warehouseUuid);
    map['batch_number'] = Variable<String>(batchNumber);
    if (!nullToAbsent || supplierUuid != null) {
      map['supplier_uuid'] = Variable<String>(supplierUuid);
    }
    if (!nullToAbsent || poUuid != null) {
      map['po_uuid'] = Variable<String>(poUuid);
    }
    map['initial_quantity'] = Variable<double>(initialQuantity);
    map['current_quantity'] = Variable<double>(currentQuantity);
    map['unit_cost'] = Variable<double>(unitCost);
    if (!nullToAbsent || manufacturedAt != null) {
      map['manufactured_at'] = Variable<DateTime>(manufacturedAt);
    }
    if (!nullToAbsent || expiryDate != null) {
      map['expiry_date'] = Variable<DateTime>(expiryDate);
    }
    map['received_at'] = Variable<DateTime>(receivedAt);
    map['status'] = Variable<String>(status);
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    map['updated_at'] = Variable<DateTime>(updatedAt);
    map['is_deleted'] = Variable<bool>(isDeleted);
    return map;
  }

  BatchTableCompanion toCompanion(bool nullToAbsent) {
    return BatchTableCompanion(
      id: Value(id),
      uuid: Value(uuid),
      productUuid: Value(productUuid),
      warehouseUuid: Value(warehouseUuid),
      batchNumber: Value(batchNumber),
      supplierUuid: supplierUuid == null && nullToAbsent
          ? const Value.absent()
          : Value(supplierUuid),
      poUuid:
          poUuid == null && nullToAbsent ? const Value.absent() : Value(poUuid),
      initialQuantity: Value(initialQuantity),
      currentQuantity: Value(currentQuantity),
      unitCost: Value(unitCost),
      manufacturedAt: manufacturedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(manufacturedAt),
      expiryDate: expiryDate == null && nullToAbsent
          ? const Value.absent()
          : Value(expiryDate),
      receivedAt: Value(receivedAt),
      status: Value(status),
      notes:
          notes == null && nullToAbsent ? const Value.absent() : Value(notes),
      updatedAt: Value(updatedAt),
      isDeleted: Value(isDeleted),
    );
  }

  factory BatchTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return BatchTableData(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      productUuid: serializer.fromJson<String>(json['productUuid']),
      warehouseUuid: serializer.fromJson<String>(json['warehouseUuid']),
      batchNumber: serializer.fromJson<String>(json['batchNumber']),
      supplierUuid: serializer.fromJson<String?>(json['supplierUuid']),
      poUuid: serializer.fromJson<String?>(json['poUuid']),
      initialQuantity: serializer.fromJson<double>(json['initialQuantity']),
      currentQuantity: serializer.fromJson<double>(json['currentQuantity']),
      unitCost: serializer.fromJson<double>(json['unitCost']),
      manufacturedAt: serializer.fromJson<DateTime?>(json['manufacturedAt']),
      expiryDate: serializer.fromJson<DateTime?>(json['expiryDate']),
      receivedAt: serializer.fromJson<DateTime>(json['receivedAt']),
      status: serializer.fromJson<String>(json['status']),
      notes: serializer.fromJson<String?>(json['notes']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'productUuid': serializer.toJson<String>(productUuid),
      'warehouseUuid': serializer.toJson<String>(warehouseUuid),
      'batchNumber': serializer.toJson<String>(batchNumber),
      'supplierUuid': serializer.toJson<String?>(supplierUuid),
      'poUuid': serializer.toJson<String?>(poUuid),
      'initialQuantity': serializer.toJson<double>(initialQuantity),
      'currentQuantity': serializer.toJson<double>(currentQuantity),
      'unitCost': serializer.toJson<double>(unitCost),
      'manufacturedAt': serializer.toJson<DateTime?>(manufacturedAt),
      'expiryDate': serializer.toJson<DateTime?>(expiryDate),
      'receivedAt': serializer.toJson<DateTime>(receivedAt),
      'status': serializer.toJson<String>(status),
      'notes': serializer.toJson<String?>(notes),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
      'isDeleted': serializer.toJson<bool>(isDeleted),
    };
  }

  BatchTableData copyWith(
          {int? id,
          String? uuid,
          String? productUuid,
          String? warehouseUuid,
          String? batchNumber,
          Value<String?> supplierUuid = const Value.absent(),
          Value<String?> poUuid = const Value.absent(),
          double? initialQuantity,
          double? currentQuantity,
          double? unitCost,
          Value<DateTime?> manufacturedAt = const Value.absent(),
          Value<DateTime?> expiryDate = const Value.absent(),
          DateTime? receivedAt,
          String? status,
          Value<String?> notes = const Value.absent(),
          DateTime? updatedAt,
          bool? isDeleted}) =>
      BatchTableData(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        productUuid: productUuid ?? this.productUuid,
        warehouseUuid: warehouseUuid ?? this.warehouseUuid,
        batchNumber: batchNumber ?? this.batchNumber,
        supplierUuid:
            supplierUuid.present ? supplierUuid.value : this.supplierUuid,
        poUuid: poUuid.present ? poUuid.value : this.poUuid,
        initialQuantity: initialQuantity ?? this.initialQuantity,
        currentQuantity: currentQuantity ?? this.currentQuantity,
        unitCost: unitCost ?? this.unitCost,
        manufacturedAt:
            manufacturedAt.present ? manufacturedAt.value : this.manufacturedAt,
        expiryDate: expiryDate.present ? expiryDate.value : this.expiryDate,
        receivedAt: receivedAt ?? this.receivedAt,
        status: status ?? this.status,
        notes: notes.present ? notes.value : this.notes,
        updatedAt: updatedAt ?? this.updatedAt,
        isDeleted: isDeleted ?? this.isDeleted,
      );
  BatchTableData copyWithCompanion(BatchTableCompanion data) {
    return BatchTableData(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      productUuid:
          data.productUuid.present ? data.productUuid.value : this.productUuid,
      warehouseUuid: data.warehouseUuid.present
          ? data.warehouseUuid.value
          : this.warehouseUuid,
      batchNumber:
          data.batchNumber.present ? data.batchNumber.value : this.batchNumber,
      supplierUuid: data.supplierUuid.present
          ? data.supplierUuid.value
          : this.supplierUuid,
      poUuid: data.poUuid.present ? data.poUuid.value : this.poUuid,
      initialQuantity: data.initialQuantity.present
          ? data.initialQuantity.value
          : this.initialQuantity,
      currentQuantity: data.currentQuantity.present
          ? data.currentQuantity.value
          : this.currentQuantity,
      unitCost: data.unitCost.present ? data.unitCost.value : this.unitCost,
      manufacturedAt: data.manufacturedAt.present
          ? data.manufacturedAt.value
          : this.manufacturedAt,
      expiryDate:
          data.expiryDate.present ? data.expiryDate.value : this.expiryDate,
      receivedAt:
          data.receivedAt.present ? data.receivedAt.value : this.receivedAt,
      status: data.status.present ? data.status.value : this.status,
      notes: data.notes.present ? data.notes.value : this.notes,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      isDeleted: data.isDeleted.present ? data.isDeleted.value : this.isDeleted,
    );
  }

  @override
  String toString() {
    return (StringBuffer('BatchTableData(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('productUuid: $productUuid, ')
          ..write('warehouseUuid: $warehouseUuid, ')
          ..write('batchNumber: $batchNumber, ')
          ..write('supplierUuid: $supplierUuid, ')
          ..write('poUuid: $poUuid, ')
          ..write('initialQuantity: $initialQuantity, ')
          ..write('currentQuantity: $currentQuantity, ')
          ..write('unitCost: $unitCost, ')
          ..write('manufacturedAt: $manufacturedAt, ')
          ..write('expiryDate: $expiryDate, ')
          ..write('receivedAt: $receivedAt, ')
          ..write('status: $status, ')
          ..write('notes: $notes, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('isDeleted: $isDeleted')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      uuid,
      productUuid,
      warehouseUuid,
      batchNumber,
      supplierUuid,
      poUuid,
      initialQuantity,
      currentQuantity,
      unitCost,
      manufacturedAt,
      expiryDate,
      receivedAt,
      status,
      notes,
      updatedAt,
      isDeleted);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is BatchTableData &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.productUuid == this.productUuid &&
          other.warehouseUuid == this.warehouseUuid &&
          other.batchNumber == this.batchNumber &&
          other.supplierUuid == this.supplierUuid &&
          other.poUuid == this.poUuid &&
          other.initialQuantity == this.initialQuantity &&
          other.currentQuantity == this.currentQuantity &&
          other.unitCost == this.unitCost &&
          other.manufacturedAt == this.manufacturedAt &&
          other.expiryDate == this.expiryDate &&
          other.receivedAt == this.receivedAt &&
          other.status == this.status &&
          other.notes == this.notes &&
          other.updatedAt == this.updatedAt &&
          other.isDeleted == this.isDeleted);
}

class BatchTableCompanion extends UpdateCompanion<BatchTableData> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String> productUuid;
  final Value<String> warehouseUuid;
  final Value<String> batchNumber;
  final Value<String?> supplierUuid;
  final Value<String?> poUuid;
  final Value<double> initialQuantity;
  final Value<double> currentQuantity;
  final Value<double> unitCost;
  final Value<DateTime?> manufacturedAt;
  final Value<DateTime?> expiryDate;
  final Value<DateTime> receivedAt;
  final Value<String> status;
  final Value<String?> notes;
  final Value<DateTime> updatedAt;
  final Value<bool> isDeleted;
  const BatchTableCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.productUuid = const Value.absent(),
    this.warehouseUuid = const Value.absent(),
    this.batchNumber = const Value.absent(),
    this.supplierUuid = const Value.absent(),
    this.poUuid = const Value.absent(),
    this.initialQuantity = const Value.absent(),
    this.currentQuantity = const Value.absent(),
    this.unitCost = const Value.absent(),
    this.manufacturedAt = const Value.absent(),
    this.expiryDate = const Value.absent(),
    this.receivedAt = const Value.absent(),
    this.status = const Value.absent(),
    this.notes = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.isDeleted = const Value.absent(),
  });
  BatchTableCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    required String productUuid,
    required String warehouseUuid,
    required String batchNumber,
    this.supplierUuid = const Value.absent(),
    this.poUuid = const Value.absent(),
    required double initialQuantity,
    required double currentQuantity,
    required double unitCost,
    this.manufacturedAt = const Value.absent(),
    this.expiryDate = const Value.absent(),
    required DateTime receivedAt,
    this.status = const Value.absent(),
    this.notes = const Value.absent(),
    required DateTime updatedAt,
    this.isDeleted = const Value.absent(),
  })  : uuid = Value(uuid),
        productUuid = Value(productUuid),
        warehouseUuid = Value(warehouseUuid),
        batchNumber = Value(batchNumber),
        initialQuantity = Value(initialQuantity),
        currentQuantity = Value(currentQuantity),
        unitCost = Value(unitCost),
        receivedAt = Value(receivedAt),
        updatedAt = Value(updatedAt);
  static Insertable<BatchTableData> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? productUuid,
    Expression<String>? warehouseUuid,
    Expression<String>? batchNumber,
    Expression<String>? supplierUuid,
    Expression<String>? poUuid,
    Expression<double>? initialQuantity,
    Expression<double>? currentQuantity,
    Expression<double>? unitCost,
    Expression<DateTime>? manufacturedAt,
    Expression<DateTime>? expiryDate,
    Expression<DateTime>? receivedAt,
    Expression<String>? status,
    Expression<String>? notes,
    Expression<DateTime>? updatedAt,
    Expression<bool>? isDeleted,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (productUuid != null) 'product_uuid': productUuid,
      if (warehouseUuid != null) 'warehouse_uuid': warehouseUuid,
      if (batchNumber != null) 'batch_number': batchNumber,
      if (supplierUuid != null) 'supplier_uuid': supplierUuid,
      if (poUuid != null) 'po_uuid': poUuid,
      if (initialQuantity != null) 'initial_quantity': initialQuantity,
      if (currentQuantity != null) 'current_quantity': currentQuantity,
      if (unitCost != null) 'unit_cost': unitCost,
      if (manufacturedAt != null) 'manufactured_at': manufacturedAt,
      if (expiryDate != null) 'expiry_date': expiryDate,
      if (receivedAt != null) 'received_at': receivedAt,
      if (status != null) 'status': status,
      if (notes != null) 'notes': notes,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (isDeleted != null) 'is_deleted': isDeleted,
    });
  }

  BatchTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String>? productUuid,
      Value<String>? warehouseUuid,
      Value<String>? batchNumber,
      Value<String?>? supplierUuid,
      Value<String?>? poUuid,
      Value<double>? initialQuantity,
      Value<double>? currentQuantity,
      Value<double>? unitCost,
      Value<DateTime?>? manufacturedAt,
      Value<DateTime?>? expiryDate,
      Value<DateTime>? receivedAt,
      Value<String>? status,
      Value<String?>? notes,
      Value<DateTime>? updatedAt,
      Value<bool>? isDeleted}) {
    return BatchTableCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      productUuid: productUuid ?? this.productUuid,
      warehouseUuid: warehouseUuid ?? this.warehouseUuid,
      batchNumber: batchNumber ?? this.batchNumber,
      supplierUuid: supplierUuid ?? this.supplierUuid,
      poUuid: poUuid ?? this.poUuid,
      initialQuantity: initialQuantity ?? this.initialQuantity,
      currentQuantity: currentQuantity ?? this.currentQuantity,
      unitCost: unitCost ?? this.unitCost,
      manufacturedAt: manufacturedAt ?? this.manufacturedAt,
      expiryDate: expiryDate ?? this.expiryDate,
      receivedAt: receivedAt ?? this.receivedAt,
      status: status ?? this.status,
      notes: notes ?? this.notes,
      updatedAt: updatedAt ?? this.updatedAt,
      isDeleted: isDeleted ?? this.isDeleted,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (productUuid.present) {
      map['product_uuid'] = Variable<String>(productUuid.value);
    }
    if (warehouseUuid.present) {
      map['warehouse_uuid'] = Variable<String>(warehouseUuid.value);
    }
    if (batchNumber.present) {
      map['batch_number'] = Variable<String>(batchNumber.value);
    }
    if (supplierUuid.present) {
      map['supplier_uuid'] = Variable<String>(supplierUuid.value);
    }
    if (poUuid.present) {
      map['po_uuid'] = Variable<String>(poUuid.value);
    }
    if (initialQuantity.present) {
      map['initial_quantity'] = Variable<double>(initialQuantity.value);
    }
    if (currentQuantity.present) {
      map['current_quantity'] = Variable<double>(currentQuantity.value);
    }
    if (unitCost.present) {
      map['unit_cost'] = Variable<double>(unitCost.value);
    }
    if (manufacturedAt.present) {
      map['manufactured_at'] = Variable<DateTime>(manufacturedAt.value);
    }
    if (expiryDate.present) {
      map['expiry_date'] = Variable<DateTime>(expiryDate.value);
    }
    if (receivedAt.present) {
      map['received_at'] = Variable<DateTime>(receivedAt.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('BatchTableCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('productUuid: $productUuid, ')
          ..write('warehouseUuid: $warehouseUuid, ')
          ..write('batchNumber: $batchNumber, ')
          ..write('supplierUuid: $supplierUuid, ')
          ..write('poUuid: $poUuid, ')
          ..write('initialQuantity: $initialQuantity, ')
          ..write('currentQuantity: $currentQuantity, ')
          ..write('unitCost: $unitCost, ')
          ..write('manufacturedAt: $manufacturedAt, ')
          ..write('expiryDate: $expiryDate, ')
          ..write('receivedAt: $receivedAt, ')
          ..write('status: $status, ')
          ..write('notes: $notes, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('isDeleted: $isDeleted')
          ..write(')'))
        .toString();
  }
}

class $StockAlertTableTable extends StockAlertTable
    with TableInfo<$StockAlertTableTable, StockAlertTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $StockAlertTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _productUuidMeta =
      const VerificationMeta('productUuid');
  @override
  late final GeneratedColumn<String> productUuid = GeneratedColumn<String>(
      'product_uuid', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _productNameMeta =
      const VerificationMeta('productName');
  @override
  late final GeneratedColumn<String> productName = GeneratedColumn<String>(
      'product_name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _warehouseUuidMeta =
      const VerificationMeta('warehouseUuid');
  @override
  late final GeneratedColumn<String> warehouseUuid = GeneratedColumn<String>(
      'warehouse_uuid', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _alertTypeMeta =
      const VerificationMeta('alertType');
  @override
  late final GeneratedColumn<String> alertType = GeneratedColumn<String>(
      'alert_type', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _severityMeta =
      const VerificationMeta('severity');
  @override
  late final GeneratedColumn<String> severity = GeneratedColumn<String>(
      'severity', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultValue: const Constant('WARNING'));
  static const VerificationMeta _currentValueMeta =
      const VerificationMeta('currentValue');
  @override
  late final GeneratedColumn<double> currentValue = GeneratedColumn<double>(
      'current_value', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _thresholdValueMeta =
      const VerificationMeta('thresholdValue');
  @override
  late final GeneratedColumn<double> thresholdValue = GeneratedColumn<double>(
      'threshold_value', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _daysBeforeExpiryMeta =
      const VerificationMeta('daysBeforeExpiry');
  @override
  late final GeneratedColumn<int> daysBeforeExpiry = GeneratedColumn<int>(
      'days_before_expiry', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _messageMeta =
      const VerificationMeta('message');
  @override
  late final GeneratedColumn<String> message = GeneratedColumn<String>(
      'message', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _isAcknowledgedMeta =
      const VerificationMeta('isAcknowledged');
  @override
  late final GeneratedColumn<bool> isAcknowledged = GeneratedColumn<bool>(
      'is_acknowledged', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("is_acknowledged" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _acknowledgedByMeta =
      const VerificationMeta('acknowledgedBy');
  @override
  late final GeneratedColumn<String> acknowledgedBy = GeneratedColumn<String>(
      'acknowledged_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _acknowledgedAtMeta =
      const VerificationMeta('acknowledgedAt');
  @override
  late final GeneratedColumn<DateTime> acknowledgedAt =
      GeneratedColumn<DateTime>('acknowledged_at', aliasedName, true,
          type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _actionTakenMeta =
      const VerificationMeta('actionTaken');
  @override
  late final GeneratedColumn<String> actionTaken = GeneratedColumn<String>(
      'action_taken', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isResolvedMeta =
      const VerificationMeta('isResolved');
  @override
  late final GeneratedColumn<bool> isResolved = GeneratedColumn<bool>(
      'is_resolved', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_resolved" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _resolvedAtMeta =
      const VerificationMeta('resolvedAt');
  @override
  late final GeneratedColumn<DateTime> resolvedAt = GeneratedColumn<DateTime>(
      'resolved_at', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        productUuid,
        productName,
        warehouseUuid,
        alertType,
        severity,
        currentValue,
        thresholdValue,
        daysBeforeExpiry,
        message,
        isAcknowledged,
        acknowledgedBy,
        acknowledgedAt,
        actionTaken,
        isResolved,
        resolvedAt,
        createdAt,
        updatedAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'stock_alert_table';
  @override
  VerificationContext validateIntegrity(
      Insertable<StockAlertTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('product_uuid')) {
      context.handle(
          _productUuidMeta,
          productUuid.isAcceptableOrUnknown(
              data['product_uuid']!, _productUuidMeta));
    } else if (isInserting) {
      context.missing(_productUuidMeta);
    }
    if (data.containsKey('product_name')) {
      context.handle(
          _productNameMeta,
          productName.isAcceptableOrUnknown(
              data['product_name']!, _productNameMeta));
    } else if (isInserting) {
      context.missing(_productNameMeta);
    }
    if (data.containsKey('warehouse_uuid')) {
      context.handle(
          _warehouseUuidMeta,
          warehouseUuid.isAcceptableOrUnknown(
              data['warehouse_uuid']!, _warehouseUuidMeta));
    }
    if (data.containsKey('alert_type')) {
      context.handle(_alertTypeMeta,
          alertType.isAcceptableOrUnknown(data['alert_type']!, _alertTypeMeta));
    } else if (isInserting) {
      context.missing(_alertTypeMeta);
    }
    if (data.containsKey('severity')) {
      context.handle(_severityMeta,
          severity.isAcceptableOrUnknown(data['severity']!, _severityMeta));
    }
    if (data.containsKey('current_value')) {
      context.handle(
          _currentValueMeta,
          currentValue.isAcceptableOrUnknown(
              data['current_value']!, _currentValueMeta));
    }
    if (data.containsKey('threshold_value')) {
      context.handle(
          _thresholdValueMeta,
          thresholdValue.isAcceptableOrUnknown(
              data['threshold_value']!, _thresholdValueMeta));
    }
    if (data.containsKey('days_before_expiry')) {
      context.handle(
          _daysBeforeExpiryMeta,
          daysBeforeExpiry.isAcceptableOrUnknown(
              data['days_before_expiry']!, _daysBeforeExpiryMeta));
    }
    if (data.containsKey('message')) {
      context.handle(_messageMeta,
          message.isAcceptableOrUnknown(data['message']!, _messageMeta));
    } else if (isInserting) {
      context.missing(_messageMeta);
    }
    if (data.containsKey('is_acknowledged')) {
      context.handle(
          _isAcknowledgedMeta,
          isAcknowledged.isAcceptableOrUnknown(
              data['is_acknowledged']!, _isAcknowledgedMeta));
    }
    if (data.containsKey('acknowledged_by')) {
      context.handle(
          _acknowledgedByMeta,
          acknowledgedBy.isAcceptableOrUnknown(
              data['acknowledged_by']!, _acknowledgedByMeta));
    }
    if (data.containsKey('acknowledged_at')) {
      context.handle(
          _acknowledgedAtMeta,
          acknowledgedAt.isAcceptableOrUnknown(
              data['acknowledged_at']!, _acknowledgedAtMeta));
    }
    if (data.containsKey('action_taken')) {
      context.handle(
          _actionTakenMeta,
          actionTaken.isAcceptableOrUnknown(
              data['action_taken']!, _actionTakenMeta));
    }
    if (data.containsKey('is_resolved')) {
      context.handle(
          _isResolvedMeta,
          isResolved.isAcceptableOrUnknown(
              data['is_resolved']!, _isResolvedMeta));
    }
    if (data.containsKey('resolved_at')) {
      context.handle(
          _resolvedAtMeta,
          resolvedAt.isAcceptableOrUnknown(
              data['resolved_at']!, _resolvedAtMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  StockAlertTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return StockAlertTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      productUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}product_uuid'])!,
      productName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}product_name'])!,
      warehouseUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}warehouse_uuid']),
      alertType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}alert_type'])!,
      severity: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}severity'])!,
      currentValue: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}current_value']),
      thresholdValue: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}threshold_value']),
      daysBeforeExpiry: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}days_before_expiry']),
      message: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}message'])!,
      isAcknowledged: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_acknowledged'])!,
      acknowledgedBy: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}acknowledged_by']),
      acknowledgedAt: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}acknowledged_at']),
      actionTaken: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}action_taken']),
      isResolved: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_resolved'])!,
      resolvedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}resolved_at']),
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $StockAlertTableTable createAlias(String alias) {
    return $StockAlertTableTable(attachedDatabase, alias);
  }
}

class StockAlertTableData extends DataClass
    implements Insertable<StockAlertTableData> {
  final int id;
  final String uuid;
  final String productUuid;
  final String productName;
  final String? warehouseUuid;
  final String alertType;
  final String severity;
  final double? currentValue;
  final double? thresholdValue;
  final int? daysBeforeExpiry;
  final String message;
  final bool isAcknowledged;
  final String? acknowledgedBy;
  final DateTime? acknowledgedAt;
  final String? actionTaken;
  final bool isResolved;
  final DateTime? resolvedAt;
  final DateTime createdAt;
  final DateTime updatedAt;
  const StockAlertTableData(
      {required this.id,
      required this.uuid,
      required this.productUuid,
      required this.productName,
      this.warehouseUuid,
      required this.alertType,
      required this.severity,
      this.currentValue,
      this.thresholdValue,
      this.daysBeforeExpiry,
      required this.message,
      required this.isAcknowledged,
      this.acknowledgedBy,
      this.acknowledgedAt,
      this.actionTaken,
      required this.isResolved,
      this.resolvedAt,
      required this.createdAt,
      required this.updatedAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    map['product_uuid'] = Variable<String>(productUuid);
    map['product_name'] = Variable<String>(productName);
    if (!nullToAbsent || warehouseUuid != null) {
      map['warehouse_uuid'] = Variable<String>(warehouseUuid);
    }
    map['alert_type'] = Variable<String>(alertType);
    map['severity'] = Variable<String>(severity);
    if (!nullToAbsent || currentValue != null) {
      map['current_value'] = Variable<double>(currentValue);
    }
    if (!nullToAbsent || thresholdValue != null) {
      map['threshold_value'] = Variable<double>(thresholdValue);
    }
    if (!nullToAbsent || daysBeforeExpiry != null) {
      map['days_before_expiry'] = Variable<int>(daysBeforeExpiry);
    }
    map['message'] = Variable<String>(message);
    map['is_acknowledged'] = Variable<bool>(isAcknowledged);
    if (!nullToAbsent || acknowledgedBy != null) {
      map['acknowledged_by'] = Variable<String>(acknowledgedBy);
    }
    if (!nullToAbsent || acknowledgedAt != null) {
      map['acknowledged_at'] = Variable<DateTime>(acknowledgedAt);
    }
    if (!nullToAbsent || actionTaken != null) {
      map['action_taken'] = Variable<String>(actionTaken);
    }
    map['is_resolved'] = Variable<bool>(isResolved);
    if (!nullToAbsent || resolvedAt != null) {
      map['resolved_at'] = Variable<DateTime>(resolvedAt);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  StockAlertTableCompanion toCompanion(bool nullToAbsent) {
    return StockAlertTableCompanion(
      id: Value(id),
      uuid: Value(uuid),
      productUuid: Value(productUuid),
      productName: Value(productName),
      warehouseUuid: warehouseUuid == null && nullToAbsent
          ? const Value.absent()
          : Value(warehouseUuid),
      alertType: Value(alertType),
      severity: Value(severity),
      currentValue: currentValue == null && nullToAbsent
          ? const Value.absent()
          : Value(currentValue),
      thresholdValue: thresholdValue == null && nullToAbsent
          ? const Value.absent()
          : Value(thresholdValue),
      daysBeforeExpiry: daysBeforeExpiry == null && nullToAbsent
          ? const Value.absent()
          : Value(daysBeforeExpiry),
      message: Value(message),
      isAcknowledged: Value(isAcknowledged),
      acknowledgedBy: acknowledgedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(acknowledgedBy),
      acknowledgedAt: acknowledgedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(acknowledgedAt),
      actionTaken: actionTaken == null && nullToAbsent
          ? const Value.absent()
          : Value(actionTaken),
      isResolved: Value(isResolved),
      resolvedAt: resolvedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(resolvedAt),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory StockAlertTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return StockAlertTableData(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      productUuid: serializer.fromJson<String>(json['productUuid']),
      productName: serializer.fromJson<String>(json['productName']),
      warehouseUuid: serializer.fromJson<String?>(json['warehouseUuid']),
      alertType: serializer.fromJson<String>(json['alertType']),
      severity: serializer.fromJson<String>(json['severity']),
      currentValue: serializer.fromJson<double?>(json['currentValue']),
      thresholdValue: serializer.fromJson<double?>(json['thresholdValue']),
      daysBeforeExpiry: serializer.fromJson<int?>(json['daysBeforeExpiry']),
      message: serializer.fromJson<String>(json['message']),
      isAcknowledged: serializer.fromJson<bool>(json['isAcknowledged']),
      acknowledgedBy: serializer.fromJson<String?>(json['acknowledgedBy']),
      acknowledgedAt: serializer.fromJson<DateTime?>(json['acknowledgedAt']),
      actionTaken: serializer.fromJson<String?>(json['actionTaken']),
      isResolved: serializer.fromJson<bool>(json['isResolved']),
      resolvedAt: serializer.fromJson<DateTime?>(json['resolvedAt']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'productUuid': serializer.toJson<String>(productUuid),
      'productName': serializer.toJson<String>(productName),
      'warehouseUuid': serializer.toJson<String?>(warehouseUuid),
      'alertType': serializer.toJson<String>(alertType),
      'severity': serializer.toJson<String>(severity),
      'currentValue': serializer.toJson<double?>(currentValue),
      'thresholdValue': serializer.toJson<double?>(thresholdValue),
      'daysBeforeExpiry': serializer.toJson<int?>(daysBeforeExpiry),
      'message': serializer.toJson<String>(message),
      'isAcknowledged': serializer.toJson<bool>(isAcknowledged),
      'acknowledgedBy': serializer.toJson<String?>(acknowledgedBy),
      'acknowledgedAt': serializer.toJson<DateTime?>(acknowledgedAt),
      'actionTaken': serializer.toJson<String?>(actionTaken),
      'isResolved': serializer.toJson<bool>(isResolved),
      'resolvedAt': serializer.toJson<DateTime?>(resolvedAt),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  StockAlertTableData copyWith(
          {int? id,
          String? uuid,
          String? productUuid,
          String? productName,
          Value<String?> warehouseUuid = const Value.absent(),
          String? alertType,
          String? severity,
          Value<double?> currentValue = const Value.absent(),
          Value<double?> thresholdValue = const Value.absent(),
          Value<int?> daysBeforeExpiry = const Value.absent(),
          String? message,
          bool? isAcknowledged,
          Value<String?> acknowledgedBy = const Value.absent(),
          Value<DateTime?> acknowledgedAt = const Value.absent(),
          Value<String?> actionTaken = const Value.absent(),
          bool? isResolved,
          Value<DateTime?> resolvedAt = const Value.absent(),
          DateTime? createdAt,
          DateTime? updatedAt}) =>
      StockAlertTableData(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        productUuid: productUuid ?? this.productUuid,
        productName: productName ?? this.productName,
        warehouseUuid:
            warehouseUuid.present ? warehouseUuid.value : this.warehouseUuid,
        alertType: alertType ?? this.alertType,
        severity: severity ?? this.severity,
        currentValue:
            currentValue.present ? currentValue.value : this.currentValue,
        thresholdValue:
            thresholdValue.present ? thresholdValue.value : this.thresholdValue,
        daysBeforeExpiry: daysBeforeExpiry.present
            ? daysBeforeExpiry.value
            : this.daysBeforeExpiry,
        message: message ?? this.message,
        isAcknowledged: isAcknowledged ?? this.isAcknowledged,
        acknowledgedBy:
            acknowledgedBy.present ? acknowledgedBy.value : this.acknowledgedBy,
        acknowledgedAt:
            acknowledgedAt.present ? acknowledgedAt.value : this.acknowledgedAt,
        actionTaken: actionTaken.present ? actionTaken.value : this.actionTaken,
        isResolved: isResolved ?? this.isResolved,
        resolvedAt: resolvedAt.present ? resolvedAt.value : this.resolvedAt,
        createdAt: createdAt ?? this.createdAt,
        updatedAt: updatedAt ?? this.updatedAt,
      );
  StockAlertTableData copyWithCompanion(StockAlertTableCompanion data) {
    return StockAlertTableData(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      productUuid:
          data.productUuid.present ? data.productUuid.value : this.productUuid,
      productName:
          data.productName.present ? data.productName.value : this.productName,
      warehouseUuid: data.warehouseUuid.present
          ? data.warehouseUuid.value
          : this.warehouseUuid,
      alertType: data.alertType.present ? data.alertType.value : this.alertType,
      severity: data.severity.present ? data.severity.value : this.severity,
      currentValue: data.currentValue.present
          ? data.currentValue.value
          : this.currentValue,
      thresholdValue: data.thresholdValue.present
          ? data.thresholdValue.value
          : this.thresholdValue,
      daysBeforeExpiry: data.daysBeforeExpiry.present
          ? data.daysBeforeExpiry.value
          : this.daysBeforeExpiry,
      message: data.message.present ? data.message.value : this.message,
      isAcknowledged: data.isAcknowledged.present
          ? data.isAcknowledged.value
          : this.isAcknowledged,
      acknowledgedBy: data.acknowledgedBy.present
          ? data.acknowledgedBy.value
          : this.acknowledgedBy,
      acknowledgedAt: data.acknowledgedAt.present
          ? data.acknowledgedAt.value
          : this.acknowledgedAt,
      actionTaken:
          data.actionTaken.present ? data.actionTaken.value : this.actionTaken,
      isResolved:
          data.isResolved.present ? data.isResolved.value : this.isResolved,
      resolvedAt:
          data.resolvedAt.present ? data.resolvedAt.value : this.resolvedAt,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('StockAlertTableData(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('productUuid: $productUuid, ')
          ..write('productName: $productName, ')
          ..write('warehouseUuid: $warehouseUuid, ')
          ..write('alertType: $alertType, ')
          ..write('severity: $severity, ')
          ..write('currentValue: $currentValue, ')
          ..write('thresholdValue: $thresholdValue, ')
          ..write('daysBeforeExpiry: $daysBeforeExpiry, ')
          ..write('message: $message, ')
          ..write('isAcknowledged: $isAcknowledged, ')
          ..write('acknowledgedBy: $acknowledgedBy, ')
          ..write('acknowledgedAt: $acknowledgedAt, ')
          ..write('actionTaken: $actionTaken, ')
          ..write('isResolved: $isResolved, ')
          ..write('resolvedAt: $resolvedAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      uuid,
      productUuid,
      productName,
      warehouseUuid,
      alertType,
      severity,
      currentValue,
      thresholdValue,
      daysBeforeExpiry,
      message,
      isAcknowledged,
      acknowledgedBy,
      acknowledgedAt,
      actionTaken,
      isResolved,
      resolvedAt,
      createdAt,
      updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is StockAlertTableData &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.productUuid == this.productUuid &&
          other.productName == this.productName &&
          other.warehouseUuid == this.warehouseUuid &&
          other.alertType == this.alertType &&
          other.severity == this.severity &&
          other.currentValue == this.currentValue &&
          other.thresholdValue == this.thresholdValue &&
          other.daysBeforeExpiry == this.daysBeforeExpiry &&
          other.message == this.message &&
          other.isAcknowledged == this.isAcknowledged &&
          other.acknowledgedBy == this.acknowledgedBy &&
          other.acknowledgedAt == this.acknowledgedAt &&
          other.actionTaken == this.actionTaken &&
          other.isResolved == this.isResolved &&
          other.resolvedAt == this.resolvedAt &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class StockAlertTableCompanion extends UpdateCompanion<StockAlertTableData> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String> productUuid;
  final Value<String> productName;
  final Value<String?> warehouseUuid;
  final Value<String> alertType;
  final Value<String> severity;
  final Value<double?> currentValue;
  final Value<double?> thresholdValue;
  final Value<int?> daysBeforeExpiry;
  final Value<String> message;
  final Value<bool> isAcknowledged;
  final Value<String?> acknowledgedBy;
  final Value<DateTime?> acknowledgedAt;
  final Value<String?> actionTaken;
  final Value<bool> isResolved;
  final Value<DateTime?> resolvedAt;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  const StockAlertTableCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.productUuid = const Value.absent(),
    this.productName = const Value.absent(),
    this.warehouseUuid = const Value.absent(),
    this.alertType = const Value.absent(),
    this.severity = const Value.absent(),
    this.currentValue = const Value.absent(),
    this.thresholdValue = const Value.absent(),
    this.daysBeforeExpiry = const Value.absent(),
    this.message = const Value.absent(),
    this.isAcknowledged = const Value.absent(),
    this.acknowledgedBy = const Value.absent(),
    this.acknowledgedAt = const Value.absent(),
    this.actionTaken = const Value.absent(),
    this.isResolved = const Value.absent(),
    this.resolvedAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  StockAlertTableCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    required String productUuid,
    required String productName,
    this.warehouseUuid = const Value.absent(),
    required String alertType,
    this.severity = const Value.absent(),
    this.currentValue = const Value.absent(),
    this.thresholdValue = const Value.absent(),
    this.daysBeforeExpiry = const Value.absent(),
    required String message,
    this.isAcknowledged = const Value.absent(),
    this.acknowledgedBy = const Value.absent(),
    this.acknowledgedAt = const Value.absent(),
    this.actionTaken = const Value.absent(),
    this.isResolved = const Value.absent(),
    this.resolvedAt = const Value.absent(),
    required DateTime createdAt,
    required DateTime updatedAt,
  })  : uuid = Value(uuid),
        productUuid = Value(productUuid),
        productName = Value(productName),
        alertType = Value(alertType),
        message = Value(message),
        createdAt = Value(createdAt),
        updatedAt = Value(updatedAt);
  static Insertable<StockAlertTableData> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? productUuid,
    Expression<String>? productName,
    Expression<String>? warehouseUuid,
    Expression<String>? alertType,
    Expression<String>? severity,
    Expression<double>? currentValue,
    Expression<double>? thresholdValue,
    Expression<int>? daysBeforeExpiry,
    Expression<String>? message,
    Expression<bool>? isAcknowledged,
    Expression<String>? acknowledgedBy,
    Expression<DateTime>? acknowledgedAt,
    Expression<String>? actionTaken,
    Expression<bool>? isResolved,
    Expression<DateTime>? resolvedAt,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (productUuid != null) 'product_uuid': productUuid,
      if (productName != null) 'product_name': productName,
      if (warehouseUuid != null) 'warehouse_uuid': warehouseUuid,
      if (alertType != null) 'alert_type': alertType,
      if (severity != null) 'severity': severity,
      if (currentValue != null) 'current_value': currentValue,
      if (thresholdValue != null) 'threshold_value': thresholdValue,
      if (daysBeforeExpiry != null) 'days_before_expiry': daysBeforeExpiry,
      if (message != null) 'message': message,
      if (isAcknowledged != null) 'is_acknowledged': isAcknowledged,
      if (acknowledgedBy != null) 'acknowledged_by': acknowledgedBy,
      if (acknowledgedAt != null) 'acknowledged_at': acknowledgedAt,
      if (actionTaken != null) 'action_taken': actionTaken,
      if (isResolved != null) 'is_resolved': isResolved,
      if (resolvedAt != null) 'resolved_at': resolvedAt,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  StockAlertTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String>? productUuid,
      Value<String>? productName,
      Value<String?>? warehouseUuid,
      Value<String>? alertType,
      Value<String>? severity,
      Value<double?>? currentValue,
      Value<double?>? thresholdValue,
      Value<int?>? daysBeforeExpiry,
      Value<String>? message,
      Value<bool>? isAcknowledged,
      Value<String?>? acknowledgedBy,
      Value<DateTime?>? acknowledgedAt,
      Value<String?>? actionTaken,
      Value<bool>? isResolved,
      Value<DateTime?>? resolvedAt,
      Value<DateTime>? createdAt,
      Value<DateTime>? updatedAt}) {
    return StockAlertTableCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      productUuid: productUuid ?? this.productUuid,
      productName: productName ?? this.productName,
      warehouseUuid: warehouseUuid ?? this.warehouseUuid,
      alertType: alertType ?? this.alertType,
      severity: severity ?? this.severity,
      currentValue: currentValue ?? this.currentValue,
      thresholdValue: thresholdValue ?? this.thresholdValue,
      daysBeforeExpiry: daysBeforeExpiry ?? this.daysBeforeExpiry,
      message: message ?? this.message,
      isAcknowledged: isAcknowledged ?? this.isAcknowledged,
      acknowledgedBy: acknowledgedBy ?? this.acknowledgedBy,
      acknowledgedAt: acknowledgedAt ?? this.acknowledgedAt,
      actionTaken: actionTaken ?? this.actionTaken,
      isResolved: isResolved ?? this.isResolved,
      resolvedAt: resolvedAt ?? this.resolvedAt,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (productUuid.present) {
      map['product_uuid'] = Variable<String>(productUuid.value);
    }
    if (productName.present) {
      map['product_name'] = Variable<String>(productName.value);
    }
    if (warehouseUuid.present) {
      map['warehouse_uuid'] = Variable<String>(warehouseUuid.value);
    }
    if (alertType.present) {
      map['alert_type'] = Variable<String>(alertType.value);
    }
    if (severity.present) {
      map['severity'] = Variable<String>(severity.value);
    }
    if (currentValue.present) {
      map['current_value'] = Variable<double>(currentValue.value);
    }
    if (thresholdValue.present) {
      map['threshold_value'] = Variable<double>(thresholdValue.value);
    }
    if (daysBeforeExpiry.present) {
      map['days_before_expiry'] = Variable<int>(daysBeforeExpiry.value);
    }
    if (message.present) {
      map['message'] = Variable<String>(message.value);
    }
    if (isAcknowledged.present) {
      map['is_acknowledged'] = Variable<bool>(isAcknowledged.value);
    }
    if (acknowledgedBy.present) {
      map['acknowledged_by'] = Variable<String>(acknowledgedBy.value);
    }
    if (acknowledgedAt.present) {
      map['acknowledged_at'] = Variable<DateTime>(acknowledgedAt.value);
    }
    if (actionTaken.present) {
      map['action_taken'] = Variable<String>(actionTaken.value);
    }
    if (isResolved.present) {
      map['is_resolved'] = Variable<bool>(isResolved.value);
    }
    if (resolvedAt.present) {
      map['resolved_at'] = Variable<DateTime>(resolvedAt.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('StockAlertTableCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('productUuid: $productUuid, ')
          ..write('productName: $productName, ')
          ..write('warehouseUuid: $warehouseUuid, ')
          ..write('alertType: $alertType, ')
          ..write('severity: $severity, ')
          ..write('currentValue: $currentValue, ')
          ..write('thresholdValue: $thresholdValue, ')
          ..write('daysBeforeExpiry: $daysBeforeExpiry, ')
          ..write('message: $message, ')
          ..write('isAcknowledged: $isAcknowledged, ')
          ..write('acknowledgedBy: $acknowledgedBy, ')
          ..write('acknowledgedAt: $acknowledgedAt, ')
          ..write('actionTaken: $actionTaken, ')
          ..write('isResolved: $isResolved, ')
          ..write('resolvedAt: $resolvedAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class $StockTransferTableTable extends StockTransferTable
    with TableInfo<$StockTransferTableTable, StockTransferTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $StockTransferTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _transferNumberMeta =
      const VerificationMeta('transferNumber');
  @override
  late final GeneratedColumn<String> transferNumber = GeneratedColumn<String>(
      'transfer_number', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _sourceWarehouseUuidMeta =
      const VerificationMeta('sourceWarehouseUuid');
  @override
  late final GeneratedColumn<String> sourceWarehouseUuid =
      GeneratedColumn<String>('source_warehouse_uuid', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _sourceWarehouseNameMeta =
      const VerificationMeta('sourceWarehouseName');
  @override
  late final GeneratedColumn<String> sourceWarehouseName =
      GeneratedColumn<String>('source_warehouse_name', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _targetWarehouseUuidMeta =
      const VerificationMeta('targetWarehouseUuid');
  @override
  late final GeneratedColumn<String> targetWarehouseUuid =
      GeneratedColumn<String>('target_warehouse_uuid', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _targetWarehouseNameMeta =
      const VerificationMeta('targetWarehouseName');
  @override
  late final GeneratedColumn<String> targetWarehouseName =
      GeneratedColumn<String>('target_warehouse_name', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
      'status', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultValue: const Constant('DRAFT'));
  static const VerificationMeta _createdByMeta =
      const VerificationMeta('createdBy');
  @override
  late final GeneratedColumn<String> createdBy = GeneratedColumn<String>(
      'created_by', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _createdByNameMeta =
      const VerificationMeta('createdByName');
  @override
  late final GeneratedColumn<String> createdByName = GeneratedColumn<String>(
      'created_by_name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _approvedByMeta =
      const VerificationMeta('approvedBy');
  @override
  late final GeneratedColumn<String> approvedBy = GeneratedColumn<String>(
      'approved_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _approvedAtMeta =
      const VerificationMeta('approvedAt');
  @override
  late final GeneratedColumn<DateTime> approvedAt = GeneratedColumn<DateTime>(
      'approved_at', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
      'notes', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _totalValueMeta =
      const VerificationMeta('totalValue');
  @override
  late final GeneratedColumn<double> totalValue = GeneratedColumn<double>(
      'total_value', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: false,
      defaultValue: const Constant(0));
  static const VerificationMeta _totalItemsMeta =
      const VerificationMeta('totalItems');
  @override
  late final GeneratedColumn<int> totalItems = GeneratedColumn<int>(
      'total_items', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultValue: const Constant(0));
  static const VerificationMeta _expectedDeliveryAtMeta =
      const VerificationMeta('expectedDeliveryAt');
  @override
  late final GeneratedColumn<DateTime> expectedDeliveryAt =
      GeneratedColumn<DateTime>('expected_delivery_at', aliasedName, true,
          type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _shippedAtMeta =
      const VerificationMeta('shippedAt');
  @override
  late final GeneratedColumn<DateTime> shippedAt = GeneratedColumn<DateTime>(
      'shipped_at', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _receivedAtMeta =
      const VerificationMeta('receivedAt');
  @override
  late final GeneratedColumn<DateTime> receivedAt = GeneratedColumn<DateTime>(
      'received_at', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        transferNumber,
        sourceWarehouseUuid,
        sourceWarehouseName,
        targetWarehouseUuid,
        targetWarehouseName,
        status,
        createdBy,
        createdByName,
        approvedBy,
        approvedAt,
        notes,
        totalValue,
        totalItems,
        expectedDeliveryAt,
        shippedAt,
        receivedAt,
        createdAt,
        updatedAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'stock_transfer_table';
  @override
  VerificationContext validateIntegrity(
      Insertable<StockTransferTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('transfer_number')) {
      context.handle(
          _transferNumberMeta,
          transferNumber.isAcceptableOrUnknown(
              data['transfer_number']!, _transferNumberMeta));
    } else if (isInserting) {
      context.missing(_transferNumberMeta);
    }
    if (data.containsKey('source_warehouse_uuid')) {
      context.handle(
          _sourceWarehouseUuidMeta,
          sourceWarehouseUuid.isAcceptableOrUnknown(
              data['source_warehouse_uuid']!, _sourceWarehouseUuidMeta));
    } else if (isInserting) {
      context.missing(_sourceWarehouseUuidMeta);
    }
    if (data.containsKey('source_warehouse_name')) {
      context.handle(
          _sourceWarehouseNameMeta,
          sourceWarehouseName.isAcceptableOrUnknown(
              data['source_warehouse_name']!, _sourceWarehouseNameMeta));
    } else if (isInserting) {
      context.missing(_sourceWarehouseNameMeta);
    }
    if (data.containsKey('target_warehouse_uuid')) {
      context.handle(
          _targetWarehouseUuidMeta,
          targetWarehouseUuid.isAcceptableOrUnknown(
              data['target_warehouse_uuid']!, _targetWarehouseUuidMeta));
    } else if (isInserting) {
      context.missing(_targetWarehouseUuidMeta);
    }
    if (data.containsKey('target_warehouse_name')) {
      context.handle(
          _targetWarehouseNameMeta,
          targetWarehouseName.isAcceptableOrUnknown(
              data['target_warehouse_name']!, _targetWarehouseNameMeta));
    } else if (isInserting) {
      context.missing(_targetWarehouseNameMeta);
    }
    if (data.containsKey('status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['status']!, _statusMeta));
    }
    if (data.containsKey('created_by')) {
      context.handle(_createdByMeta,
          createdBy.isAcceptableOrUnknown(data['created_by']!, _createdByMeta));
    } else if (isInserting) {
      context.missing(_createdByMeta);
    }
    if (data.containsKey('created_by_name')) {
      context.handle(
          _createdByNameMeta,
          createdByName.isAcceptableOrUnknown(
              data['created_by_name']!, _createdByNameMeta));
    } else if (isInserting) {
      context.missing(_createdByNameMeta);
    }
    if (data.containsKey('approved_by')) {
      context.handle(
          _approvedByMeta,
          approvedBy.isAcceptableOrUnknown(
              data['approved_by']!, _approvedByMeta));
    }
    if (data.containsKey('approved_at')) {
      context.handle(
          _approvedAtMeta,
          approvedAt.isAcceptableOrUnknown(
              data['approved_at']!, _approvedAtMeta));
    }
    if (data.containsKey('notes')) {
      context.handle(
          _notesMeta, notes.isAcceptableOrUnknown(data['notes']!, _notesMeta));
    }
    if (data.containsKey('total_value')) {
      context.handle(
          _totalValueMeta,
          totalValue.isAcceptableOrUnknown(
              data['total_value']!, _totalValueMeta));
    }
    if (data.containsKey('total_items')) {
      context.handle(
          _totalItemsMeta,
          totalItems.isAcceptableOrUnknown(
              data['total_items']!, _totalItemsMeta));
    }
    if (data.containsKey('expected_delivery_at')) {
      context.handle(
          _expectedDeliveryAtMeta,
          expectedDeliveryAt.isAcceptableOrUnknown(
              data['expected_delivery_at']!, _expectedDeliveryAtMeta));
    }
    if (data.containsKey('shipped_at')) {
      context.handle(_shippedAtMeta,
          shippedAt.isAcceptableOrUnknown(data['shipped_at']!, _shippedAtMeta));
    }
    if (data.containsKey('received_at')) {
      context.handle(
          _receivedAtMeta,
          receivedAt.isAcceptableOrUnknown(
              data['received_at']!, _receivedAtMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  StockTransferTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return StockTransferTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      transferNumber: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}transfer_number'])!,
      sourceWarehouseUuid: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}source_warehouse_uuid'])!,
      sourceWarehouseName: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}source_warehouse_name'])!,
      targetWarehouseUuid: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}target_warehouse_uuid'])!,
      targetWarehouseName: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}target_warehouse_name'])!,
      status: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}status'])!,
      createdBy: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}created_by'])!,
      createdByName: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}created_by_name'])!,
      approvedBy: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}approved_by']),
      approvedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}approved_at']),
      notes: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}notes']),
      totalValue: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}total_value'])!,
      totalItems: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}total_items'])!,
      expectedDeliveryAt: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime,
          data['${effectivePrefix}expected_delivery_at']),
      shippedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}shipped_at']),
      receivedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}received_at']),
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $StockTransferTableTable createAlias(String alias) {
    return $StockTransferTableTable(attachedDatabase, alias);
  }
}

class StockTransferTableData extends DataClass
    implements Insertable<StockTransferTableData> {
  final int id;
  final String uuid;
  final String transferNumber;
  final String sourceWarehouseUuid;
  final String sourceWarehouseName;
  final String targetWarehouseUuid;
  final String targetWarehouseName;
  final String status;
  final String createdBy;
  final String createdByName;
  final String? approvedBy;
  final DateTime? approvedAt;
  final String? notes;
  final double totalValue;
  final int totalItems;
  final DateTime? expectedDeliveryAt;
  final DateTime? shippedAt;
  final DateTime? receivedAt;
  final DateTime createdAt;
  final DateTime updatedAt;
  const StockTransferTableData(
      {required this.id,
      required this.uuid,
      required this.transferNumber,
      required this.sourceWarehouseUuid,
      required this.sourceWarehouseName,
      required this.targetWarehouseUuid,
      required this.targetWarehouseName,
      required this.status,
      required this.createdBy,
      required this.createdByName,
      this.approvedBy,
      this.approvedAt,
      this.notes,
      required this.totalValue,
      required this.totalItems,
      this.expectedDeliveryAt,
      this.shippedAt,
      this.receivedAt,
      required this.createdAt,
      required this.updatedAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    map['transfer_number'] = Variable<String>(transferNumber);
    map['source_warehouse_uuid'] = Variable<String>(sourceWarehouseUuid);
    map['source_warehouse_name'] = Variable<String>(sourceWarehouseName);
    map['target_warehouse_uuid'] = Variable<String>(targetWarehouseUuid);
    map['target_warehouse_name'] = Variable<String>(targetWarehouseName);
    map['status'] = Variable<String>(status);
    map['created_by'] = Variable<String>(createdBy);
    map['created_by_name'] = Variable<String>(createdByName);
    if (!nullToAbsent || approvedBy != null) {
      map['approved_by'] = Variable<String>(approvedBy);
    }
    if (!nullToAbsent || approvedAt != null) {
      map['approved_at'] = Variable<DateTime>(approvedAt);
    }
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    map['total_value'] = Variable<double>(totalValue);
    map['total_items'] = Variable<int>(totalItems);
    if (!nullToAbsent || expectedDeliveryAt != null) {
      map['expected_delivery_at'] = Variable<DateTime>(expectedDeliveryAt);
    }
    if (!nullToAbsent || shippedAt != null) {
      map['shipped_at'] = Variable<DateTime>(shippedAt);
    }
    if (!nullToAbsent || receivedAt != null) {
      map['received_at'] = Variable<DateTime>(receivedAt);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  StockTransferTableCompanion toCompanion(bool nullToAbsent) {
    return StockTransferTableCompanion(
      id: Value(id),
      uuid: Value(uuid),
      transferNumber: Value(transferNumber),
      sourceWarehouseUuid: Value(sourceWarehouseUuid),
      sourceWarehouseName: Value(sourceWarehouseName),
      targetWarehouseUuid: Value(targetWarehouseUuid),
      targetWarehouseName: Value(targetWarehouseName),
      status: Value(status),
      createdBy: Value(createdBy),
      createdByName: Value(createdByName),
      approvedBy: approvedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(approvedBy),
      approvedAt: approvedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(approvedAt),
      notes:
          notes == null && nullToAbsent ? const Value.absent() : Value(notes),
      totalValue: Value(totalValue),
      totalItems: Value(totalItems),
      expectedDeliveryAt: expectedDeliveryAt == null && nullToAbsent
          ? const Value.absent()
          : Value(expectedDeliveryAt),
      shippedAt: shippedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(shippedAt),
      receivedAt: receivedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(receivedAt),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory StockTransferTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return StockTransferTableData(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      transferNumber: serializer.fromJson<String>(json['transferNumber']),
      sourceWarehouseUuid:
          serializer.fromJson<String>(json['sourceWarehouseUuid']),
      sourceWarehouseName:
          serializer.fromJson<String>(json['sourceWarehouseName']),
      targetWarehouseUuid:
          serializer.fromJson<String>(json['targetWarehouseUuid']),
      targetWarehouseName:
          serializer.fromJson<String>(json['targetWarehouseName']),
      status: serializer.fromJson<String>(json['status']),
      createdBy: serializer.fromJson<String>(json['createdBy']),
      createdByName: serializer.fromJson<String>(json['createdByName']),
      approvedBy: serializer.fromJson<String?>(json['approvedBy']),
      approvedAt: serializer.fromJson<DateTime?>(json['approvedAt']),
      notes: serializer.fromJson<String?>(json['notes']),
      totalValue: serializer.fromJson<double>(json['totalValue']),
      totalItems: serializer.fromJson<int>(json['totalItems']),
      expectedDeliveryAt:
          serializer.fromJson<DateTime?>(json['expectedDeliveryAt']),
      shippedAt: serializer.fromJson<DateTime?>(json['shippedAt']),
      receivedAt: serializer.fromJson<DateTime?>(json['receivedAt']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'transferNumber': serializer.toJson<String>(transferNumber),
      'sourceWarehouseUuid': serializer.toJson<String>(sourceWarehouseUuid),
      'sourceWarehouseName': serializer.toJson<String>(sourceWarehouseName),
      'targetWarehouseUuid': serializer.toJson<String>(targetWarehouseUuid),
      'targetWarehouseName': serializer.toJson<String>(targetWarehouseName),
      'status': serializer.toJson<String>(status),
      'createdBy': serializer.toJson<String>(createdBy),
      'createdByName': serializer.toJson<String>(createdByName),
      'approvedBy': serializer.toJson<String?>(approvedBy),
      'approvedAt': serializer.toJson<DateTime?>(approvedAt),
      'notes': serializer.toJson<String?>(notes),
      'totalValue': serializer.toJson<double>(totalValue),
      'totalItems': serializer.toJson<int>(totalItems),
      'expectedDeliveryAt': serializer.toJson<DateTime?>(expectedDeliveryAt),
      'shippedAt': serializer.toJson<DateTime?>(shippedAt),
      'receivedAt': serializer.toJson<DateTime?>(receivedAt),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  StockTransferTableData copyWith(
          {int? id,
          String? uuid,
          String? transferNumber,
          String? sourceWarehouseUuid,
          String? sourceWarehouseName,
          String? targetWarehouseUuid,
          String? targetWarehouseName,
          String? status,
          String? createdBy,
          String? createdByName,
          Value<String?> approvedBy = const Value.absent(),
          Value<DateTime?> approvedAt = const Value.absent(),
          Value<String?> notes = const Value.absent(),
          double? totalValue,
          int? totalItems,
          Value<DateTime?> expectedDeliveryAt = const Value.absent(),
          Value<DateTime?> shippedAt = const Value.absent(),
          Value<DateTime?> receivedAt = const Value.absent(),
          DateTime? createdAt,
          DateTime? updatedAt}) =>
      StockTransferTableData(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        transferNumber: transferNumber ?? this.transferNumber,
        sourceWarehouseUuid: sourceWarehouseUuid ?? this.sourceWarehouseUuid,
        sourceWarehouseName: sourceWarehouseName ?? this.sourceWarehouseName,
        targetWarehouseUuid: targetWarehouseUuid ?? this.targetWarehouseUuid,
        targetWarehouseName: targetWarehouseName ?? this.targetWarehouseName,
        status: status ?? this.status,
        createdBy: createdBy ?? this.createdBy,
        createdByName: createdByName ?? this.createdByName,
        approvedBy: approvedBy.present ? approvedBy.value : this.approvedBy,
        approvedAt: approvedAt.present ? approvedAt.value : this.approvedAt,
        notes: notes.present ? notes.value : this.notes,
        totalValue: totalValue ?? this.totalValue,
        totalItems: totalItems ?? this.totalItems,
        expectedDeliveryAt: expectedDeliveryAt.present
            ? expectedDeliveryAt.value
            : this.expectedDeliveryAt,
        shippedAt: shippedAt.present ? shippedAt.value : this.shippedAt,
        receivedAt: receivedAt.present ? receivedAt.value : this.receivedAt,
        createdAt: createdAt ?? this.createdAt,
        updatedAt: updatedAt ?? this.updatedAt,
      );
  StockTransferTableData copyWithCompanion(StockTransferTableCompanion data) {
    return StockTransferTableData(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      transferNumber: data.transferNumber.present
          ? data.transferNumber.value
          : this.transferNumber,
      sourceWarehouseUuid: data.sourceWarehouseUuid.present
          ? data.sourceWarehouseUuid.value
          : this.sourceWarehouseUuid,
      sourceWarehouseName: data.sourceWarehouseName.present
          ? data.sourceWarehouseName.value
          : this.sourceWarehouseName,
      targetWarehouseUuid: data.targetWarehouseUuid.present
          ? data.targetWarehouseUuid.value
          : this.targetWarehouseUuid,
      targetWarehouseName: data.targetWarehouseName.present
          ? data.targetWarehouseName.value
          : this.targetWarehouseName,
      status: data.status.present ? data.status.value : this.status,
      createdBy: data.createdBy.present ? data.createdBy.value : this.createdBy,
      createdByName: data.createdByName.present
          ? data.createdByName.value
          : this.createdByName,
      approvedBy:
          data.approvedBy.present ? data.approvedBy.value : this.approvedBy,
      approvedAt:
          data.approvedAt.present ? data.approvedAt.value : this.approvedAt,
      notes: data.notes.present ? data.notes.value : this.notes,
      totalValue:
          data.totalValue.present ? data.totalValue.value : this.totalValue,
      totalItems:
          data.totalItems.present ? data.totalItems.value : this.totalItems,
      expectedDeliveryAt: data.expectedDeliveryAt.present
          ? data.expectedDeliveryAt.value
          : this.expectedDeliveryAt,
      shippedAt: data.shippedAt.present ? data.shippedAt.value : this.shippedAt,
      receivedAt:
          data.receivedAt.present ? data.receivedAt.value : this.receivedAt,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('StockTransferTableData(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('transferNumber: $transferNumber, ')
          ..write('sourceWarehouseUuid: $sourceWarehouseUuid, ')
          ..write('sourceWarehouseName: $sourceWarehouseName, ')
          ..write('targetWarehouseUuid: $targetWarehouseUuid, ')
          ..write('targetWarehouseName: $targetWarehouseName, ')
          ..write('status: $status, ')
          ..write('createdBy: $createdBy, ')
          ..write('createdByName: $createdByName, ')
          ..write('approvedBy: $approvedBy, ')
          ..write('approvedAt: $approvedAt, ')
          ..write('notes: $notes, ')
          ..write('totalValue: $totalValue, ')
          ..write('totalItems: $totalItems, ')
          ..write('expectedDeliveryAt: $expectedDeliveryAt, ')
          ..write('shippedAt: $shippedAt, ')
          ..write('receivedAt: $receivedAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      uuid,
      transferNumber,
      sourceWarehouseUuid,
      sourceWarehouseName,
      targetWarehouseUuid,
      targetWarehouseName,
      status,
      createdBy,
      createdByName,
      approvedBy,
      approvedAt,
      notes,
      totalValue,
      totalItems,
      expectedDeliveryAt,
      shippedAt,
      receivedAt,
      createdAt,
      updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is StockTransferTableData &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.transferNumber == this.transferNumber &&
          other.sourceWarehouseUuid == this.sourceWarehouseUuid &&
          other.sourceWarehouseName == this.sourceWarehouseName &&
          other.targetWarehouseUuid == this.targetWarehouseUuid &&
          other.targetWarehouseName == this.targetWarehouseName &&
          other.status == this.status &&
          other.createdBy == this.createdBy &&
          other.createdByName == this.createdByName &&
          other.approvedBy == this.approvedBy &&
          other.approvedAt == this.approvedAt &&
          other.notes == this.notes &&
          other.totalValue == this.totalValue &&
          other.totalItems == this.totalItems &&
          other.expectedDeliveryAt == this.expectedDeliveryAt &&
          other.shippedAt == this.shippedAt &&
          other.receivedAt == this.receivedAt &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class StockTransferTableCompanion
    extends UpdateCompanion<StockTransferTableData> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String> transferNumber;
  final Value<String> sourceWarehouseUuid;
  final Value<String> sourceWarehouseName;
  final Value<String> targetWarehouseUuid;
  final Value<String> targetWarehouseName;
  final Value<String> status;
  final Value<String> createdBy;
  final Value<String> createdByName;
  final Value<String?> approvedBy;
  final Value<DateTime?> approvedAt;
  final Value<String?> notes;
  final Value<double> totalValue;
  final Value<int> totalItems;
  final Value<DateTime?> expectedDeliveryAt;
  final Value<DateTime?> shippedAt;
  final Value<DateTime?> receivedAt;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  const StockTransferTableCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.transferNumber = const Value.absent(),
    this.sourceWarehouseUuid = const Value.absent(),
    this.sourceWarehouseName = const Value.absent(),
    this.targetWarehouseUuid = const Value.absent(),
    this.targetWarehouseName = const Value.absent(),
    this.status = const Value.absent(),
    this.createdBy = const Value.absent(),
    this.createdByName = const Value.absent(),
    this.approvedBy = const Value.absent(),
    this.approvedAt = const Value.absent(),
    this.notes = const Value.absent(),
    this.totalValue = const Value.absent(),
    this.totalItems = const Value.absent(),
    this.expectedDeliveryAt = const Value.absent(),
    this.shippedAt = const Value.absent(),
    this.receivedAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  StockTransferTableCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    required String transferNumber,
    required String sourceWarehouseUuid,
    required String sourceWarehouseName,
    required String targetWarehouseUuid,
    required String targetWarehouseName,
    this.status = const Value.absent(),
    required String createdBy,
    required String createdByName,
    this.approvedBy = const Value.absent(),
    this.approvedAt = const Value.absent(),
    this.notes = const Value.absent(),
    this.totalValue = const Value.absent(),
    this.totalItems = const Value.absent(),
    this.expectedDeliveryAt = const Value.absent(),
    this.shippedAt = const Value.absent(),
    this.receivedAt = const Value.absent(),
    required DateTime createdAt,
    required DateTime updatedAt,
  })  : uuid = Value(uuid),
        transferNumber = Value(transferNumber),
        sourceWarehouseUuid = Value(sourceWarehouseUuid),
        sourceWarehouseName = Value(sourceWarehouseName),
        targetWarehouseUuid = Value(targetWarehouseUuid),
        targetWarehouseName = Value(targetWarehouseName),
        createdBy = Value(createdBy),
        createdByName = Value(createdByName),
        createdAt = Value(createdAt),
        updatedAt = Value(updatedAt);
  static Insertable<StockTransferTableData> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? transferNumber,
    Expression<String>? sourceWarehouseUuid,
    Expression<String>? sourceWarehouseName,
    Expression<String>? targetWarehouseUuid,
    Expression<String>? targetWarehouseName,
    Expression<String>? status,
    Expression<String>? createdBy,
    Expression<String>? createdByName,
    Expression<String>? approvedBy,
    Expression<DateTime>? approvedAt,
    Expression<String>? notes,
    Expression<double>? totalValue,
    Expression<int>? totalItems,
    Expression<DateTime>? expectedDeliveryAt,
    Expression<DateTime>? shippedAt,
    Expression<DateTime>? receivedAt,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (transferNumber != null) 'transfer_number': transferNumber,
      if (sourceWarehouseUuid != null)
        'source_warehouse_uuid': sourceWarehouseUuid,
      if (sourceWarehouseName != null)
        'source_warehouse_name': sourceWarehouseName,
      if (targetWarehouseUuid != null)
        'target_warehouse_uuid': targetWarehouseUuid,
      if (targetWarehouseName != null)
        'target_warehouse_name': targetWarehouseName,
      if (status != null) 'status': status,
      if (createdBy != null) 'created_by': createdBy,
      if (createdByName != null) 'created_by_name': createdByName,
      if (approvedBy != null) 'approved_by': approvedBy,
      if (approvedAt != null) 'approved_at': approvedAt,
      if (notes != null) 'notes': notes,
      if (totalValue != null) 'total_value': totalValue,
      if (totalItems != null) 'total_items': totalItems,
      if (expectedDeliveryAt != null)
        'expected_delivery_at': expectedDeliveryAt,
      if (shippedAt != null) 'shipped_at': shippedAt,
      if (receivedAt != null) 'received_at': receivedAt,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  StockTransferTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String>? transferNumber,
      Value<String>? sourceWarehouseUuid,
      Value<String>? sourceWarehouseName,
      Value<String>? targetWarehouseUuid,
      Value<String>? targetWarehouseName,
      Value<String>? status,
      Value<String>? createdBy,
      Value<String>? createdByName,
      Value<String?>? approvedBy,
      Value<DateTime?>? approvedAt,
      Value<String?>? notes,
      Value<double>? totalValue,
      Value<int>? totalItems,
      Value<DateTime?>? expectedDeliveryAt,
      Value<DateTime?>? shippedAt,
      Value<DateTime?>? receivedAt,
      Value<DateTime>? createdAt,
      Value<DateTime>? updatedAt}) {
    return StockTransferTableCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      transferNumber: transferNumber ?? this.transferNumber,
      sourceWarehouseUuid: sourceWarehouseUuid ?? this.sourceWarehouseUuid,
      sourceWarehouseName: sourceWarehouseName ?? this.sourceWarehouseName,
      targetWarehouseUuid: targetWarehouseUuid ?? this.targetWarehouseUuid,
      targetWarehouseName: targetWarehouseName ?? this.targetWarehouseName,
      status: status ?? this.status,
      createdBy: createdBy ?? this.createdBy,
      createdByName: createdByName ?? this.createdByName,
      approvedBy: approvedBy ?? this.approvedBy,
      approvedAt: approvedAt ?? this.approvedAt,
      notes: notes ?? this.notes,
      totalValue: totalValue ?? this.totalValue,
      totalItems: totalItems ?? this.totalItems,
      expectedDeliveryAt: expectedDeliveryAt ?? this.expectedDeliveryAt,
      shippedAt: shippedAt ?? this.shippedAt,
      receivedAt: receivedAt ?? this.receivedAt,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (transferNumber.present) {
      map['transfer_number'] = Variable<String>(transferNumber.value);
    }
    if (sourceWarehouseUuid.present) {
      map['source_warehouse_uuid'] =
          Variable<String>(sourceWarehouseUuid.value);
    }
    if (sourceWarehouseName.present) {
      map['source_warehouse_name'] =
          Variable<String>(sourceWarehouseName.value);
    }
    if (targetWarehouseUuid.present) {
      map['target_warehouse_uuid'] =
          Variable<String>(targetWarehouseUuid.value);
    }
    if (targetWarehouseName.present) {
      map['target_warehouse_name'] =
          Variable<String>(targetWarehouseName.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (createdBy.present) {
      map['created_by'] = Variable<String>(createdBy.value);
    }
    if (createdByName.present) {
      map['created_by_name'] = Variable<String>(createdByName.value);
    }
    if (approvedBy.present) {
      map['approved_by'] = Variable<String>(approvedBy.value);
    }
    if (approvedAt.present) {
      map['approved_at'] = Variable<DateTime>(approvedAt.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (totalValue.present) {
      map['total_value'] = Variable<double>(totalValue.value);
    }
    if (totalItems.present) {
      map['total_items'] = Variable<int>(totalItems.value);
    }
    if (expectedDeliveryAt.present) {
      map['expected_delivery_at'] =
          Variable<DateTime>(expectedDeliveryAt.value);
    }
    if (shippedAt.present) {
      map['shipped_at'] = Variable<DateTime>(shippedAt.value);
    }
    if (receivedAt.present) {
      map['received_at'] = Variable<DateTime>(receivedAt.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('StockTransferTableCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('transferNumber: $transferNumber, ')
          ..write('sourceWarehouseUuid: $sourceWarehouseUuid, ')
          ..write('sourceWarehouseName: $sourceWarehouseName, ')
          ..write('targetWarehouseUuid: $targetWarehouseUuid, ')
          ..write('targetWarehouseName: $targetWarehouseName, ')
          ..write('status: $status, ')
          ..write('createdBy: $createdBy, ')
          ..write('createdByName: $createdByName, ')
          ..write('approvedBy: $approvedBy, ')
          ..write('approvedAt: $approvedAt, ')
          ..write('notes: $notes, ')
          ..write('totalValue: $totalValue, ')
          ..write('totalItems: $totalItems, ')
          ..write('expectedDeliveryAt: $expectedDeliveryAt, ')
          ..write('shippedAt: $shippedAt, ')
          ..write('receivedAt: $receivedAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class $StockTransferItemTableTable extends StockTransferItemTable
    with TableInfo<$StockTransferItemTableTable, StockTransferItemTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $StockTransferItemTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _transferUuidMeta =
      const VerificationMeta('transferUuid');
  @override
  late final GeneratedColumn<String> transferUuid = GeneratedColumn<String>(
      'transfer_uuid', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _productUuidMeta =
      const VerificationMeta('productUuid');
  @override
  late final GeneratedColumn<String> productUuid = GeneratedColumn<String>(
      'product_uuid', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _productNameMeta =
      const VerificationMeta('productName');
  @override
  late final GeneratedColumn<String> productName = GeneratedColumn<String>(
      'product_name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _batchUuidMeta =
      const VerificationMeta('batchUuid');
  @override
  late final GeneratedColumn<String> batchUuid = GeneratedColumn<String>(
      'batch_uuid', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _quantityRequestedMeta =
      const VerificationMeta('quantityRequested');
  @override
  late final GeneratedColumn<double> quantityRequested =
      GeneratedColumn<double>('quantity_requested', aliasedName, false,
          type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _quantityShippedMeta =
      const VerificationMeta('quantityShipped');
  @override
  late final GeneratedColumn<double> quantityShipped = GeneratedColumn<double>(
      'quantity_shipped', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: false,
      defaultValue: const Constant(0));
  static const VerificationMeta _quantityReceivedMeta =
      const VerificationMeta('quantityReceived');
  @override
  late final GeneratedColumn<double> quantityReceived = GeneratedColumn<double>(
      'quantity_received', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: false,
      defaultValue: const Constant(0));
  static const VerificationMeta _unitCostMeta =
      const VerificationMeta('unitCost');
  @override
  late final GeneratedColumn<double> unitCost = GeneratedColumn<double>(
      'unit_cost', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
      'notes', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        transferUuid,
        productUuid,
        productName,
        batchUuid,
        quantityRequested,
        quantityShipped,
        quantityReceived,
        unitCost,
        notes
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'stock_transfer_item_table';
  @override
  VerificationContext validateIntegrity(
      Insertable<StockTransferItemTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('transfer_uuid')) {
      context.handle(
          _transferUuidMeta,
          transferUuid.isAcceptableOrUnknown(
              data['transfer_uuid']!, _transferUuidMeta));
    } else if (isInserting) {
      context.missing(_transferUuidMeta);
    }
    if (data.containsKey('product_uuid')) {
      context.handle(
          _productUuidMeta,
          productUuid.isAcceptableOrUnknown(
              data['product_uuid']!, _productUuidMeta));
    } else if (isInserting) {
      context.missing(_productUuidMeta);
    }
    if (data.containsKey('product_name')) {
      context.handle(
          _productNameMeta,
          productName.isAcceptableOrUnknown(
              data['product_name']!, _productNameMeta));
    } else if (isInserting) {
      context.missing(_productNameMeta);
    }
    if (data.containsKey('batch_uuid')) {
      context.handle(_batchUuidMeta,
          batchUuid.isAcceptableOrUnknown(data['batch_uuid']!, _batchUuidMeta));
    }
    if (data.containsKey('quantity_requested')) {
      context.handle(
          _quantityRequestedMeta,
          quantityRequested.isAcceptableOrUnknown(
              data['quantity_requested']!, _quantityRequestedMeta));
    } else if (isInserting) {
      context.missing(_quantityRequestedMeta);
    }
    if (data.containsKey('quantity_shipped')) {
      context.handle(
          _quantityShippedMeta,
          quantityShipped.isAcceptableOrUnknown(
              data['quantity_shipped']!, _quantityShippedMeta));
    }
    if (data.containsKey('quantity_received')) {
      context.handle(
          _quantityReceivedMeta,
          quantityReceived.isAcceptableOrUnknown(
              data['quantity_received']!, _quantityReceivedMeta));
    }
    if (data.containsKey('unit_cost')) {
      context.handle(_unitCostMeta,
          unitCost.isAcceptableOrUnknown(data['unit_cost']!, _unitCostMeta));
    } else if (isInserting) {
      context.missing(_unitCostMeta);
    }
    if (data.containsKey('notes')) {
      context.handle(
          _notesMeta, notes.isAcceptableOrUnknown(data['notes']!, _notesMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
        {transferUuid, productUuid, batchUuid},
      ];
  @override
  StockTransferItemTableData map(Map<String, dynamic> data,
      {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return StockTransferItemTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      transferUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}transfer_uuid'])!,
      productUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}product_uuid'])!,
      productName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}product_name'])!,
      batchUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}batch_uuid']),
      quantityRequested: attachedDatabase.typeMapping.read(
          DriftSqlType.double, data['${effectivePrefix}quantity_requested'])!,
      quantityShipped: attachedDatabase.typeMapping.read(
          DriftSqlType.double, data['${effectivePrefix}quantity_shipped'])!,
      quantityReceived: attachedDatabase.typeMapping.read(
          DriftSqlType.double, data['${effectivePrefix}quantity_received'])!,
      unitCost: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}unit_cost'])!,
      notes: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}notes']),
    );
  }

  @override
  $StockTransferItemTableTable createAlias(String alias) {
    return $StockTransferItemTableTable(attachedDatabase, alias);
  }
}

class StockTransferItemTableData extends DataClass
    implements Insertable<StockTransferItemTableData> {
  final int id;
  final String transferUuid;
  final String productUuid;
  final String productName;
  final String? batchUuid;
  final double quantityRequested;
  final double quantityShipped;
  final double quantityReceived;
  final double unitCost;
  final String? notes;
  const StockTransferItemTableData(
      {required this.id,
      required this.transferUuid,
      required this.productUuid,
      required this.productName,
      this.batchUuid,
      required this.quantityRequested,
      required this.quantityShipped,
      required this.quantityReceived,
      required this.unitCost,
      this.notes});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['transfer_uuid'] = Variable<String>(transferUuid);
    map['product_uuid'] = Variable<String>(productUuid);
    map['product_name'] = Variable<String>(productName);
    if (!nullToAbsent || batchUuid != null) {
      map['batch_uuid'] = Variable<String>(batchUuid);
    }
    map['quantity_requested'] = Variable<double>(quantityRequested);
    map['quantity_shipped'] = Variable<double>(quantityShipped);
    map['quantity_received'] = Variable<double>(quantityReceived);
    map['unit_cost'] = Variable<double>(unitCost);
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    return map;
  }

  StockTransferItemTableCompanion toCompanion(bool nullToAbsent) {
    return StockTransferItemTableCompanion(
      id: Value(id),
      transferUuid: Value(transferUuid),
      productUuid: Value(productUuid),
      productName: Value(productName),
      batchUuid: batchUuid == null && nullToAbsent
          ? const Value.absent()
          : Value(batchUuid),
      quantityRequested: Value(quantityRequested),
      quantityShipped: Value(quantityShipped),
      quantityReceived: Value(quantityReceived),
      unitCost: Value(unitCost),
      notes:
          notes == null && nullToAbsent ? const Value.absent() : Value(notes),
    );
  }

  factory StockTransferItemTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return StockTransferItemTableData(
      id: serializer.fromJson<int>(json['id']),
      transferUuid: serializer.fromJson<String>(json['transferUuid']),
      productUuid: serializer.fromJson<String>(json['productUuid']),
      productName: serializer.fromJson<String>(json['productName']),
      batchUuid: serializer.fromJson<String?>(json['batchUuid']),
      quantityRequested: serializer.fromJson<double>(json['quantityRequested']),
      quantityShipped: serializer.fromJson<double>(json['quantityShipped']),
      quantityReceived: serializer.fromJson<double>(json['quantityReceived']),
      unitCost: serializer.fromJson<double>(json['unitCost']),
      notes: serializer.fromJson<String?>(json['notes']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'transferUuid': serializer.toJson<String>(transferUuid),
      'productUuid': serializer.toJson<String>(productUuid),
      'productName': serializer.toJson<String>(productName),
      'batchUuid': serializer.toJson<String?>(batchUuid),
      'quantityRequested': serializer.toJson<double>(quantityRequested),
      'quantityShipped': serializer.toJson<double>(quantityShipped),
      'quantityReceived': serializer.toJson<double>(quantityReceived),
      'unitCost': serializer.toJson<double>(unitCost),
      'notes': serializer.toJson<String?>(notes),
    };
  }

  StockTransferItemTableData copyWith(
          {int? id,
          String? transferUuid,
          String? productUuid,
          String? productName,
          Value<String?> batchUuid = const Value.absent(),
          double? quantityRequested,
          double? quantityShipped,
          double? quantityReceived,
          double? unitCost,
          Value<String?> notes = const Value.absent()}) =>
      StockTransferItemTableData(
        id: id ?? this.id,
        transferUuid: transferUuid ?? this.transferUuid,
        productUuid: productUuid ?? this.productUuid,
        productName: productName ?? this.productName,
        batchUuid: batchUuid.present ? batchUuid.value : this.batchUuid,
        quantityRequested: quantityRequested ?? this.quantityRequested,
        quantityShipped: quantityShipped ?? this.quantityShipped,
        quantityReceived: quantityReceived ?? this.quantityReceived,
        unitCost: unitCost ?? this.unitCost,
        notes: notes.present ? notes.value : this.notes,
      );
  StockTransferItemTableData copyWithCompanion(
      StockTransferItemTableCompanion data) {
    return StockTransferItemTableData(
      id: data.id.present ? data.id.value : this.id,
      transferUuid: data.transferUuid.present
          ? data.transferUuid.value
          : this.transferUuid,
      productUuid:
          data.productUuid.present ? data.productUuid.value : this.productUuid,
      productName:
          data.productName.present ? data.productName.value : this.productName,
      batchUuid: data.batchUuid.present ? data.batchUuid.value : this.batchUuid,
      quantityRequested: data.quantityRequested.present
          ? data.quantityRequested.value
          : this.quantityRequested,
      quantityShipped: data.quantityShipped.present
          ? data.quantityShipped.value
          : this.quantityShipped,
      quantityReceived: data.quantityReceived.present
          ? data.quantityReceived.value
          : this.quantityReceived,
      unitCost: data.unitCost.present ? data.unitCost.value : this.unitCost,
      notes: data.notes.present ? data.notes.value : this.notes,
    );
  }

  @override
  String toString() {
    return (StringBuffer('StockTransferItemTableData(')
          ..write('id: $id, ')
          ..write('transferUuid: $transferUuid, ')
          ..write('productUuid: $productUuid, ')
          ..write('productName: $productName, ')
          ..write('batchUuid: $batchUuid, ')
          ..write('quantityRequested: $quantityRequested, ')
          ..write('quantityShipped: $quantityShipped, ')
          ..write('quantityReceived: $quantityReceived, ')
          ..write('unitCost: $unitCost, ')
          ..write('notes: $notes')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      transferUuid,
      productUuid,
      productName,
      batchUuid,
      quantityRequested,
      quantityShipped,
      quantityReceived,
      unitCost,
      notes);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is StockTransferItemTableData &&
          other.id == this.id &&
          other.transferUuid == this.transferUuid &&
          other.productUuid == this.productUuid &&
          other.productName == this.productName &&
          other.batchUuid == this.batchUuid &&
          other.quantityRequested == this.quantityRequested &&
          other.quantityShipped == this.quantityShipped &&
          other.quantityReceived == this.quantityReceived &&
          other.unitCost == this.unitCost &&
          other.notes == this.notes);
}

class StockTransferItemTableCompanion
    extends UpdateCompanion<StockTransferItemTableData> {
  final Value<int> id;
  final Value<String> transferUuid;
  final Value<String> productUuid;
  final Value<String> productName;
  final Value<String?> batchUuid;
  final Value<double> quantityRequested;
  final Value<double> quantityShipped;
  final Value<double> quantityReceived;
  final Value<double> unitCost;
  final Value<String?> notes;
  const StockTransferItemTableCompanion({
    this.id = const Value.absent(),
    this.transferUuid = const Value.absent(),
    this.productUuid = const Value.absent(),
    this.productName = const Value.absent(),
    this.batchUuid = const Value.absent(),
    this.quantityRequested = const Value.absent(),
    this.quantityShipped = const Value.absent(),
    this.quantityReceived = const Value.absent(),
    this.unitCost = const Value.absent(),
    this.notes = const Value.absent(),
  });
  StockTransferItemTableCompanion.insert({
    this.id = const Value.absent(),
    required String transferUuid,
    required String productUuid,
    required String productName,
    this.batchUuid = const Value.absent(),
    required double quantityRequested,
    this.quantityShipped = const Value.absent(),
    this.quantityReceived = const Value.absent(),
    required double unitCost,
    this.notes = const Value.absent(),
  })  : transferUuid = Value(transferUuid),
        productUuid = Value(productUuid),
        productName = Value(productName),
        quantityRequested = Value(quantityRequested),
        unitCost = Value(unitCost);
  static Insertable<StockTransferItemTableData> custom({
    Expression<int>? id,
    Expression<String>? transferUuid,
    Expression<String>? productUuid,
    Expression<String>? productName,
    Expression<String>? batchUuid,
    Expression<double>? quantityRequested,
    Expression<double>? quantityShipped,
    Expression<double>? quantityReceived,
    Expression<double>? unitCost,
    Expression<String>? notes,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (transferUuid != null) 'transfer_uuid': transferUuid,
      if (productUuid != null) 'product_uuid': productUuid,
      if (productName != null) 'product_name': productName,
      if (batchUuid != null) 'batch_uuid': batchUuid,
      if (quantityRequested != null) 'quantity_requested': quantityRequested,
      if (quantityShipped != null) 'quantity_shipped': quantityShipped,
      if (quantityReceived != null) 'quantity_received': quantityReceived,
      if (unitCost != null) 'unit_cost': unitCost,
      if (notes != null) 'notes': notes,
    });
  }

  StockTransferItemTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? transferUuid,
      Value<String>? productUuid,
      Value<String>? productName,
      Value<String?>? batchUuid,
      Value<double>? quantityRequested,
      Value<double>? quantityShipped,
      Value<double>? quantityReceived,
      Value<double>? unitCost,
      Value<String?>? notes}) {
    return StockTransferItemTableCompanion(
      id: id ?? this.id,
      transferUuid: transferUuid ?? this.transferUuid,
      productUuid: productUuid ?? this.productUuid,
      productName: productName ?? this.productName,
      batchUuid: batchUuid ?? this.batchUuid,
      quantityRequested: quantityRequested ?? this.quantityRequested,
      quantityShipped: quantityShipped ?? this.quantityShipped,
      quantityReceived: quantityReceived ?? this.quantityReceived,
      unitCost: unitCost ?? this.unitCost,
      notes: notes ?? this.notes,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (transferUuid.present) {
      map['transfer_uuid'] = Variable<String>(transferUuid.value);
    }
    if (productUuid.present) {
      map['product_uuid'] = Variable<String>(productUuid.value);
    }
    if (productName.present) {
      map['product_name'] = Variable<String>(productName.value);
    }
    if (batchUuid.present) {
      map['batch_uuid'] = Variable<String>(batchUuid.value);
    }
    if (quantityRequested.present) {
      map['quantity_requested'] = Variable<double>(quantityRequested.value);
    }
    if (quantityShipped.present) {
      map['quantity_shipped'] = Variable<double>(quantityShipped.value);
    }
    if (quantityReceived.present) {
      map['quantity_received'] = Variable<double>(quantityReceived.value);
    }
    if (unitCost.present) {
      map['unit_cost'] = Variable<double>(unitCost.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('StockTransferItemTableCompanion(')
          ..write('id: $id, ')
          ..write('transferUuid: $transferUuid, ')
          ..write('productUuid: $productUuid, ')
          ..write('productName: $productName, ')
          ..write('batchUuid: $batchUuid, ')
          ..write('quantityRequested: $quantityRequested, ')
          ..write('quantityShipped: $quantityShipped, ')
          ..write('quantityReceived: $quantityReceived, ')
          ..write('unitCost: $unitCost, ')
          ..write('notes: $notes')
          ..write(')'))
        .toString();
  }
}

class $StockAlertConfigTableTable extends StockAlertConfigTable
    with TableInfo<$StockAlertConfigTableTable, StockAlertConfigTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $StockAlertConfigTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _productUuidMeta =
      const VerificationMeta('productUuid');
  @override
  late final GeneratedColumn<String> productUuid = GeneratedColumn<String>(
      'product_uuid', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _warehouseUuidMeta =
      const VerificationMeta('warehouseUuid');
  @override
  late final GeneratedColumn<String> warehouseUuid = GeneratedColumn<String>(
      'warehouse_uuid', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _lowStockThresholdMeta =
      const VerificationMeta('lowStockThreshold');
  @override
  late final GeneratedColumn<double> lowStockThreshold =
      GeneratedColumn<double>('low_stock_threshold', aliasedName, true,
          type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _criticalStockThresholdMeta =
      const VerificationMeta('criticalStockThreshold');
  @override
  late final GeneratedColumn<double> criticalStockThreshold =
      GeneratedColumn<double>('critical_stock_threshold', aliasedName, true,
          type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _overstockThresholdMeta =
      const VerificationMeta('overstockThreshold');
  @override
  late final GeneratedColumn<double> overstockThreshold =
      GeneratedColumn<double>('overstock_threshold', aliasedName, true,
          type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _expiryWarningDaysMeta =
      const VerificationMeta('expiryWarningDays');
  @override
  late final GeneratedColumn<int> expiryWarningDays = GeneratedColumn<int>(
      'expiry_warning_days', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultValue: const Constant(7));
  static const VerificationMeta _lowStockEmailEnabledMeta =
      const VerificationMeta('lowStockEmailEnabled');
  @override
  late final GeneratedColumn<bool> lowStockEmailEnabled = GeneratedColumn<bool>(
      'low_stock_email_enabled', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("low_stock_email_enabled" IN (0, 1))'),
      defaultValue: const Constant(true));
  static const VerificationMeta _outOfStockEmailEnabledMeta =
      const VerificationMeta('outOfStockEmailEnabled');
  @override
  late final GeneratedColumn<bool> outOfStockEmailEnabled =
      GeneratedColumn<bool>('out_of_stock_email_enabled', aliasedName, false,
          type: DriftSqlType.bool,
          requiredDuringInsert: false,
          defaultConstraints: GeneratedColumn.constraintIsAlways(
              'CHECK ("out_of_stock_email_enabled" IN (0, 1))'),
          defaultValue: const Constant(true));
  static const VerificationMeta _expiryEmailEnabledMeta =
      const VerificationMeta('expiryEmailEnabled');
  @override
  late final GeneratedColumn<bool> expiryEmailEnabled = GeneratedColumn<bool>(
      'expiry_email_enabled', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("expiry_email_enabled" IN (0, 1))'),
      defaultValue: const Constant(true));
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        productUuid,
        warehouseUuid,
        lowStockThreshold,
        criticalStockThreshold,
        overstockThreshold,
        expiryWarningDays,
        lowStockEmailEnabled,
        outOfStockEmailEnabled,
        expiryEmailEnabled,
        updatedAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'stock_alert_config_table';
  @override
  VerificationContext validateIntegrity(
      Insertable<StockAlertConfigTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('product_uuid')) {
      context.handle(
          _productUuidMeta,
          productUuid.isAcceptableOrUnknown(
              data['product_uuid']!, _productUuidMeta));
    } else if (isInserting) {
      context.missing(_productUuidMeta);
    }
    if (data.containsKey('warehouse_uuid')) {
      context.handle(
          _warehouseUuidMeta,
          warehouseUuid.isAcceptableOrUnknown(
              data['warehouse_uuid']!, _warehouseUuidMeta));
    }
    if (data.containsKey('low_stock_threshold')) {
      context.handle(
          _lowStockThresholdMeta,
          lowStockThreshold.isAcceptableOrUnknown(
              data['low_stock_threshold']!, _lowStockThresholdMeta));
    }
    if (data.containsKey('critical_stock_threshold')) {
      context.handle(
          _criticalStockThresholdMeta,
          criticalStockThreshold.isAcceptableOrUnknown(
              data['critical_stock_threshold']!, _criticalStockThresholdMeta));
    }
    if (data.containsKey('overstock_threshold')) {
      context.handle(
          _overstockThresholdMeta,
          overstockThreshold.isAcceptableOrUnknown(
              data['overstock_threshold']!, _overstockThresholdMeta));
    }
    if (data.containsKey('expiry_warning_days')) {
      context.handle(
          _expiryWarningDaysMeta,
          expiryWarningDays.isAcceptableOrUnknown(
              data['expiry_warning_days']!, _expiryWarningDaysMeta));
    }
    if (data.containsKey('low_stock_email_enabled')) {
      context.handle(
          _lowStockEmailEnabledMeta,
          lowStockEmailEnabled.isAcceptableOrUnknown(
              data['low_stock_email_enabled']!, _lowStockEmailEnabledMeta));
    }
    if (data.containsKey('out_of_stock_email_enabled')) {
      context.handle(
          _outOfStockEmailEnabledMeta,
          outOfStockEmailEnabled.isAcceptableOrUnknown(
              data['out_of_stock_email_enabled']!,
              _outOfStockEmailEnabledMeta));
    }
    if (data.containsKey('expiry_email_enabled')) {
      context.handle(
          _expiryEmailEnabledMeta,
          expiryEmailEnabled.isAcceptableOrUnknown(
              data['expiry_email_enabled']!, _expiryEmailEnabledMeta));
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
        {productUuid, warehouseUuid},
      ];
  @override
  StockAlertConfigTableData map(Map<String, dynamic> data,
      {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return StockAlertConfigTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      productUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}product_uuid'])!,
      warehouseUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}warehouse_uuid']),
      lowStockThreshold: attachedDatabase.typeMapping.read(
          DriftSqlType.double, data['${effectivePrefix}low_stock_threshold']),
      criticalStockThreshold: attachedDatabase.typeMapping.read(
          DriftSqlType.double,
          data['${effectivePrefix}critical_stock_threshold']),
      overstockThreshold: attachedDatabase.typeMapping.read(
          DriftSqlType.double, data['${effectivePrefix}overstock_threshold']),
      expiryWarningDays: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}expiry_warning_days'])!,
      lowStockEmailEnabled: attachedDatabase.typeMapping.read(DriftSqlType.bool,
          data['${effectivePrefix}low_stock_email_enabled'])!,
      outOfStockEmailEnabled: attachedDatabase.typeMapping.read(
          DriftSqlType.bool,
          data['${effectivePrefix}out_of_stock_email_enabled'])!,
      expiryEmailEnabled: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}expiry_email_enabled'])!,
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $StockAlertConfigTableTable createAlias(String alias) {
    return $StockAlertConfigTableTable(attachedDatabase, alias);
  }
}

class StockAlertConfigTableData extends DataClass
    implements Insertable<StockAlertConfigTableData> {
  final int id;
  final String uuid;
  final String productUuid;
  final String? warehouseUuid;
  final double? lowStockThreshold;
  final double? criticalStockThreshold;
  final double? overstockThreshold;
  final int expiryWarningDays;
  final bool lowStockEmailEnabled;
  final bool outOfStockEmailEnabled;
  final bool expiryEmailEnabled;
  final DateTime updatedAt;
  const StockAlertConfigTableData(
      {required this.id,
      required this.uuid,
      required this.productUuid,
      this.warehouseUuid,
      this.lowStockThreshold,
      this.criticalStockThreshold,
      this.overstockThreshold,
      required this.expiryWarningDays,
      required this.lowStockEmailEnabled,
      required this.outOfStockEmailEnabled,
      required this.expiryEmailEnabled,
      required this.updatedAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    map['product_uuid'] = Variable<String>(productUuid);
    if (!nullToAbsent || warehouseUuid != null) {
      map['warehouse_uuid'] = Variable<String>(warehouseUuid);
    }
    if (!nullToAbsent || lowStockThreshold != null) {
      map['low_stock_threshold'] = Variable<double>(lowStockThreshold);
    }
    if (!nullToAbsent || criticalStockThreshold != null) {
      map['critical_stock_threshold'] =
          Variable<double>(criticalStockThreshold);
    }
    if (!nullToAbsent || overstockThreshold != null) {
      map['overstock_threshold'] = Variable<double>(overstockThreshold);
    }
    map['expiry_warning_days'] = Variable<int>(expiryWarningDays);
    map['low_stock_email_enabled'] = Variable<bool>(lowStockEmailEnabled);
    map['out_of_stock_email_enabled'] = Variable<bool>(outOfStockEmailEnabled);
    map['expiry_email_enabled'] = Variable<bool>(expiryEmailEnabled);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  StockAlertConfigTableCompanion toCompanion(bool nullToAbsent) {
    return StockAlertConfigTableCompanion(
      id: Value(id),
      uuid: Value(uuid),
      productUuid: Value(productUuid),
      warehouseUuid: warehouseUuid == null && nullToAbsent
          ? const Value.absent()
          : Value(warehouseUuid),
      lowStockThreshold: lowStockThreshold == null && nullToAbsent
          ? const Value.absent()
          : Value(lowStockThreshold),
      criticalStockThreshold: criticalStockThreshold == null && nullToAbsent
          ? const Value.absent()
          : Value(criticalStockThreshold),
      overstockThreshold: overstockThreshold == null && nullToAbsent
          ? const Value.absent()
          : Value(overstockThreshold),
      expiryWarningDays: Value(expiryWarningDays),
      lowStockEmailEnabled: Value(lowStockEmailEnabled),
      outOfStockEmailEnabled: Value(outOfStockEmailEnabled),
      expiryEmailEnabled: Value(expiryEmailEnabled),
      updatedAt: Value(updatedAt),
    );
  }

  factory StockAlertConfigTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return StockAlertConfigTableData(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      productUuid: serializer.fromJson<String>(json['productUuid']),
      warehouseUuid: serializer.fromJson<String?>(json['warehouseUuid']),
      lowStockThreshold:
          serializer.fromJson<double?>(json['lowStockThreshold']),
      criticalStockThreshold:
          serializer.fromJson<double?>(json['criticalStockThreshold']),
      overstockThreshold:
          serializer.fromJson<double?>(json['overstockThreshold']),
      expiryWarningDays: serializer.fromJson<int>(json['expiryWarningDays']),
      lowStockEmailEnabled:
          serializer.fromJson<bool>(json['lowStockEmailEnabled']),
      outOfStockEmailEnabled:
          serializer.fromJson<bool>(json['outOfStockEmailEnabled']),
      expiryEmailEnabled: serializer.fromJson<bool>(json['expiryEmailEnabled']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'productUuid': serializer.toJson<String>(productUuid),
      'warehouseUuid': serializer.toJson<String?>(warehouseUuid),
      'lowStockThreshold': serializer.toJson<double?>(lowStockThreshold),
      'criticalStockThreshold':
          serializer.toJson<double?>(criticalStockThreshold),
      'overstockThreshold': serializer.toJson<double?>(overstockThreshold),
      'expiryWarningDays': serializer.toJson<int>(expiryWarningDays),
      'lowStockEmailEnabled': serializer.toJson<bool>(lowStockEmailEnabled),
      'outOfStockEmailEnabled': serializer.toJson<bool>(outOfStockEmailEnabled),
      'expiryEmailEnabled': serializer.toJson<bool>(expiryEmailEnabled),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  StockAlertConfigTableData copyWith(
          {int? id,
          String? uuid,
          String? productUuid,
          Value<String?> warehouseUuid = const Value.absent(),
          Value<double?> lowStockThreshold = const Value.absent(),
          Value<double?> criticalStockThreshold = const Value.absent(),
          Value<double?> overstockThreshold = const Value.absent(),
          int? expiryWarningDays,
          bool? lowStockEmailEnabled,
          bool? outOfStockEmailEnabled,
          bool? expiryEmailEnabled,
          DateTime? updatedAt}) =>
      StockAlertConfigTableData(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        productUuid: productUuid ?? this.productUuid,
        warehouseUuid:
            warehouseUuid.present ? warehouseUuid.value : this.warehouseUuid,
        lowStockThreshold: lowStockThreshold.present
            ? lowStockThreshold.value
            : this.lowStockThreshold,
        criticalStockThreshold: criticalStockThreshold.present
            ? criticalStockThreshold.value
            : this.criticalStockThreshold,
        overstockThreshold: overstockThreshold.present
            ? overstockThreshold.value
            : this.overstockThreshold,
        expiryWarningDays: expiryWarningDays ?? this.expiryWarningDays,
        lowStockEmailEnabled: lowStockEmailEnabled ?? this.lowStockEmailEnabled,
        outOfStockEmailEnabled:
            outOfStockEmailEnabled ?? this.outOfStockEmailEnabled,
        expiryEmailEnabled: expiryEmailEnabled ?? this.expiryEmailEnabled,
        updatedAt: updatedAt ?? this.updatedAt,
      );
  StockAlertConfigTableData copyWithCompanion(
      StockAlertConfigTableCompanion data) {
    return StockAlertConfigTableData(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      productUuid:
          data.productUuid.present ? data.productUuid.value : this.productUuid,
      warehouseUuid: data.warehouseUuid.present
          ? data.warehouseUuid.value
          : this.warehouseUuid,
      lowStockThreshold: data.lowStockThreshold.present
          ? data.lowStockThreshold.value
          : this.lowStockThreshold,
      criticalStockThreshold: data.criticalStockThreshold.present
          ? data.criticalStockThreshold.value
          : this.criticalStockThreshold,
      overstockThreshold: data.overstockThreshold.present
          ? data.overstockThreshold.value
          : this.overstockThreshold,
      expiryWarningDays: data.expiryWarningDays.present
          ? data.expiryWarningDays.value
          : this.expiryWarningDays,
      lowStockEmailEnabled: data.lowStockEmailEnabled.present
          ? data.lowStockEmailEnabled.value
          : this.lowStockEmailEnabled,
      outOfStockEmailEnabled: data.outOfStockEmailEnabled.present
          ? data.outOfStockEmailEnabled.value
          : this.outOfStockEmailEnabled,
      expiryEmailEnabled: data.expiryEmailEnabled.present
          ? data.expiryEmailEnabled.value
          : this.expiryEmailEnabled,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('StockAlertConfigTableData(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('productUuid: $productUuid, ')
          ..write('warehouseUuid: $warehouseUuid, ')
          ..write('lowStockThreshold: $lowStockThreshold, ')
          ..write('criticalStockThreshold: $criticalStockThreshold, ')
          ..write('overstockThreshold: $overstockThreshold, ')
          ..write('expiryWarningDays: $expiryWarningDays, ')
          ..write('lowStockEmailEnabled: $lowStockEmailEnabled, ')
          ..write('outOfStockEmailEnabled: $outOfStockEmailEnabled, ')
          ..write('expiryEmailEnabled: $expiryEmailEnabled, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      uuid,
      productUuid,
      warehouseUuid,
      lowStockThreshold,
      criticalStockThreshold,
      overstockThreshold,
      expiryWarningDays,
      lowStockEmailEnabled,
      outOfStockEmailEnabled,
      expiryEmailEnabled,
      updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is StockAlertConfigTableData &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.productUuid == this.productUuid &&
          other.warehouseUuid == this.warehouseUuid &&
          other.lowStockThreshold == this.lowStockThreshold &&
          other.criticalStockThreshold == this.criticalStockThreshold &&
          other.overstockThreshold == this.overstockThreshold &&
          other.expiryWarningDays == this.expiryWarningDays &&
          other.lowStockEmailEnabled == this.lowStockEmailEnabled &&
          other.outOfStockEmailEnabled == this.outOfStockEmailEnabled &&
          other.expiryEmailEnabled == this.expiryEmailEnabled &&
          other.updatedAt == this.updatedAt);
}

class StockAlertConfigTableCompanion
    extends UpdateCompanion<StockAlertConfigTableData> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String> productUuid;
  final Value<String?> warehouseUuid;
  final Value<double?> lowStockThreshold;
  final Value<double?> criticalStockThreshold;
  final Value<double?> overstockThreshold;
  final Value<int> expiryWarningDays;
  final Value<bool> lowStockEmailEnabled;
  final Value<bool> outOfStockEmailEnabled;
  final Value<bool> expiryEmailEnabled;
  final Value<DateTime> updatedAt;
  const StockAlertConfigTableCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.productUuid = const Value.absent(),
    this.warehouseUuid = const Value.absent(),
    this.lowStockThreshold = const Value.absent(),
    this.criticalStockThreshold = const Value.absent(),
    this.overstockThreshold = const Value.absent(),
    this.expiryWarningDays = const Value.absent(),
    this.lowStockEmailEnabled = const Value.absent(),
    this.outOfStockEmailEnabled = const Value.absent(),
    this.expiryEmailEnabled = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  StockAlertConfigTableCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    required String productUuid,
    this.warehouseUuid = const Value.absent(),
    this.lowStockThreshold = const Value.absent(),
    this.criticalStockThreshold = const Value.absent(),
    this.overstockThreshold = const Value.absent(),
    this.expiryWarningDays = const Value.absent(),
    this.lowStockEmailEnabled = const Value.absent(),
    this.outOfStockEmailEnabled = const Value.absent(),
    this.expiryEmailEnabled = const Value.absent(),
    required DateTime updatedAt,
  })  : uuid = Value(uuid),
        productUuid = Value(productUuid),
        updatedAt = Value(updatedAt);
  static Insertable<StockAlertConfigTableData> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? productUuid,
    Expression<String>? warehouseUuid,
    Expression<double>? lowStockThreshold,
    Expression<double>? criticalStockThreshold,
    Expression<double>? overstockThreshold,
    Expression<int>? expiryWarningDays,
    Expression<bool>? lowStockEmailEnabled,
    Expression<bool>? outOfStockEmailEnabled,
    Expression<bool>? expiryEmailEnabled,
    Expression<DateTime>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (productUuid != null) 'product_uuid': productUuid,
      if (warehouseUuid != null) 'warehouse_uuid': warehouseUuid,
      if (lowStockThreshold != null) 'low_stock_threshold': lowStockThreshold,
      if (criticalStockThreshold != null)
        'critical_stock_threshold': criticalStockThreshold,
      if (overstockThreshold != null) 'overstock_threshold': overstockThreshold,
      if (expiryWarningDays != null) 'expiry_warning_days': expiryWarningDays,
      if (lowStockEmailEnabled != null)
        'low_stock_email_enabled': lowStockEmailEnabled,
      if (outOfStockEmailEnabled != null)
        'out_of_stock_email_enabled': outOfStockEmailEnabled,
      if (expiryEmailEnabled != null)
        'expiry_email_enabled': expiryEmailEnabled,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  StockAlertConfigTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String>? productUuid,
      Value<String?>? warehouseUuid,
      Value<double?>? lowStockThreshold,
      Value<double?>? criticalStockThreshold,
      Value<double?>? overstockThreshold,
      Value<int>? expiryWarningDays,
      Value<bool>? lowStockEmailEnabled,
      Value<bool>? outOfStockEmailEnabled,
      Value<bool>? expiryEmailEnabled,
      Value<DateTime>? updatedAt}) {
    return StockAlertConfigTableCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      productUuid: productUuid ?? this.productUuid,
      warehouseUuid: warehouseUuid ?? this.warehouseUuid,
      lowStockThreshold: lowStockThreshold ?? this.lowStockThreshold,
      criticalStockThreshold:
          criticalStockThreshold ?? this.criticalStockThreshold,
      overstockThreshold: overstockThreshold ?? this.overstockThreshold,
      expiryWarningDays: expiryWarningDays ?? this.expiryWarningDays,
      lowStockEmailEnabled: lowStockEmailEnabled ?? this.lowStockEmailEnabled,
      outOfStockEmailEnabled:
          outOfStockEmailEnabled ?? this.outOfStockEmailEnabled,
      expiryEmailEnabled: expiryEmailEnabled ?? this.expiryEmailEnabled,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (productUuid.present) {
      map['product_uuid'] = Variable<String>(productUuid.value);
    }
    if (warehouseUuid.present) {
      map['warehouse_uuid'] = Variable<String>(warehouseUuid.value);
    }
    if (lowStockThreshold.present) {
      map['low_stock_threshold'] = Variable<double>(lowStockThreshold.value);
    }
    if (criticalStockThreshold.present) {
      map['critical_stock_threshold'] =
          Variable<double>(criticalStockThreshold.value);
    }
    if (overstockThreshold.present) {
      map['overstock_threshold'] = Variable<double>(overstockThreshold.value);
    }
    if (expiryWarningDays.present) {
      map['expiry_warning_days'] = Variable<int>(expiryWarningDays.value);
    }
    if (lowStockEmailEnabled.present) {
      map['low_stock_email_enabled'] =
          Variable<bool>(lowStockEmailEnabled.value);
    }
    if (outOfStockEmailEnabled.present) {
      map['out_of_stock_email_enabled'] =
          Variable<bool>(outOfStockEmailEnabled.value);
    }
    if (expiryEmailEnabled.present) {
      map['expiry_email_enabled'] = Variable<bool>(expiryEmailEnabled.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('StockAlertConfigTableCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('productUuid: $productUuid, ')
          ..write('warehouseUuid: $warehouseUuid, ')
          ..write('lowStockThreshold: $lowStockThreshold, ')
          ..write('criticalStockThreshold: $criticalStockThreshold, ')
          ..write('overstockThreshold: $overstockThreshold, ')
          ..write('expiryWarningDays: $expiryWarningDays, ')
          ..write('lowStockEmailEnabled: $lowStockEmailEnabled, ')
          ..write('outOfStockEmailEnabled: $outOfStockEmailEnabled, ')
          ..write('expiryEmailEnabled: $expiryEmailEnabled, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class $StockMovementTableTable extends StockMovementTable
    with TableInfo<$StockMovementTableTable, StockMovementTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $StockMovementTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _productUuidMeta =
      const VerificationMeta('productUuid');
  @override
  late final GeneratedColumn<String> productUuid = GeneratedColumn<String>(
      'product_uuid', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _productNameMeta =
      const VerificationMeta('productName');
  @override
  late final GeneratedColumn<String> productName = GeneratedColumn<String>(
      'product_name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _warehouseUuidMeta =
      const VerificationMeta('warehouseUuid');
  @override
  late final GeneratedColumn<String> warehouseUuid = GeneratedColumn<String>(
      'warehouse_uuid', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _batchUuidMeta =
      const VerificationMeta('batchUuid');
  @override
  late final GeneratedColumn<String> batchUuid = GeneratedColumn<String>(
      'batch_uuid', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _movementTypeMeta =
      const VerificationMeta('movementType');
  @override
  late final GeneratedColumn<String> movementType = GeneratedColumn<String>(
      'movement_type', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _quantityChangeMeta =
      const VerificationMeta('quantityChange');
  @override
  late final GeneratedColumn<double> quantityChange = GeneratedColumn<double>(
      'quantity_change', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _unitCostMeta =
      const VerificationMeta('unitCost');
  @override
  late final GeneratedColumn<double> unitCost = GeneratedColumn<double>(
      'unit_cost', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _totalCostMeta =
      const VerificationMeta('totalCost');
  @override
  late final GeneratedColumn<double> totalCost = GeneratedColumn<double>(
      'total_cost', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _referenceTypeMeta =
      const VerificationMeta('referenceType');
  @override
  late final GeneratedColumn<String> referenceType = GeneratedColumn<String>(
      'reference_type', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _referenceUuidMeta =
      const VerificationMeta('referenceUuid');
  @override
  late final GeneratedColumn<String> referenceUuid = GeneratedColumn<String>(
      'reference_uuid', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _referenceNumberMeta =
      const VerificationMeta('referenceNumber');
  @override
  late final GeneratedColumn<String> referenceNumber = GeneratedColumn<String>(
      'reference_number', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _reasonCodeMeta =
      const VerificationMeta('reasonCode');
  @override
  late final GeneratedColumn<String> reasonCode = GeneratedColumn<String>(
      'reason_code', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
      'notes', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _performedByMeta =
      const VerificationMeta('performedBy');
  @override
  late final GeneratedColumn<String> performedBy = GeneratedColumn<String>(
      'performed_by', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _performedByNameMeta =
      const VerificationMeta('performedByName');
  @override
  late final GeneratedColumn<String> performedByName = GeneratedColumn<String>(
      'performed_by_name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _balanceBeforeMeta =
      const VerificationMeta('balanceBefore');
  @override
  late final GeneratedColumn<double> balanceBefore = GeneratedColumn<double>(
      'balance_before', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _balanceAfterMeta =
      const VerificationMeta('balanceAfter');
  @override
  late final GeneratedColumn<double> balanceAfter = GeneratedColumn<double>(
      'balance_after', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _timestampMeta =
      const VerificationMeta('timestamp');
  @override
  late final GeneratedColumn<DateTime> timestamp = GeneratedColumn<DateTime>(
      'timestamp', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        productUuid,
        productName,
        warehouseUuid,
        batchUuid,
        movementType,
        quantityChange,
        unitCost,
        totalCost,
        referenceType,
        referenceUuid,
        referenceNumber,
        reasonCode,
        notes,
        performedBy,
        performedByName,
        balanceBefore,
        balanceAfter,
        timestamp
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'stock_movement_table';
  @override
  VerificationContext validateIntegrity(
      Insertable<StockMovementTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('product_uuid')) {
      context.handle(
          _productUuidMeta,
          productUuid.isAcceptableOrUnknown(
              data['product_uuid']!, _productUuidMeta));
    } else if (isInserting) {
      context.missing(_productUuidMeta);
    }
    if (data.containsKey('product_name')) {
      context.handle(
          _productNameMeta,
          productName.isAcceptableOrUnknown(
              data['product_name']!, _productNameMeta));
    } else if (isInserting) {
      context.missing(_productNameMeta);
    }
    if (data.containsKey('warehouse_uuid')) {
      context.handle(
          _warehouseUuidMeta,
          warehouseUuid.isAcceptableOrUnknown(
              data['warehouse_uuid']!, _warehouseUuidMeta));
    } else if (isInserting) {
      context.missing(_warehouseUuidMeta);
    }
    if (data.containsKey('batch_uuid')) {
      context.handle(_batchUuidMeta,
          batchUuid.isAcceptableOrUnknown(data['batch_uuid']!, _batchUuidMeta));
    }
    if (data.containsKey('movement_type')) {
      context.handle(
          _movementTypeMeta,
          movementType.isAcceptableOrUnknown(
              data['movement_type']!, _movementTypeMeta));
    } else if (isInserting) {
      context.missing(_movementTypeMeta);
    }
    if (data.containsKey('quantity_change')) {
      context.handle(
          _quantityChangeMeta,
          quantityChange.isAcceptableOrUnknown(
              data['quantity_change']!, _quantityChangeMeta));
    } else if (isInserting) {
      context.missing(_quantityChangeMeta);
    }
    if (data.containsKey('unit_cost')) {
      context.handle(_unitCostMeta,
          unitCost.isAcceptableOrUnknown(data['unit_cost']!, _unitCostMeta));
    }
    if (data.containsKey('total_cost')) {
      context.handle(_totalCostMeta,
          totalCost.isAcceptableOrUnknown(data['total_cost']!, _totalCostMeta));
    }
    if (data.containsKey('reference_type')) {
      context.handle(
          _referenceTypeMeta,
          referenceType.isAcceptableOrUnknown(
              data['reference_type']!, _referenceTypeMeta));
    }
    if (data.containsKey('reference_uuid')) {
      context.handle(
          _referenceUuidMeta,
          referenceUuid.isAcceptableOrUnknown(
              data['reference_uuid']!, _referenceUuidMeta));
    }
    if (data.containsKey('reference_number')) {
      context.handle(
          _referenceNumberMeta,
          referenceNumber.isAcceptableOrUnknown(
              data['reference_number']!, _referenceNumberMeta));
    }
    if (data.containsKey('reason_code')) {
      context.handle(
          _reasonCodeMeta,
          reasonCode.isAcceptableOrUnknown(
              data['reason_code']!, _reasonCodeMeta));
    }
    if (data.containsKey('notes')) {
      context.handle(
          _notesMeta, notes.isAcceptableOrUnknown(data['notes']!, _notesMeta));
    }
    if (data.containsKey('performed_by')) {
      context.handle(
          _performedByMeta,
          performedBy.isAcceptableOrUnknown(
              data['performed_by']!, _performedByMeta));
    } else if (isInserting) {
      context.missing(_performedByMeta);
    }
    if (data.containsKey('performed_by_name')) {
      context.handle(
          _performedByNameMeta,
          performedByName.isAcceptableOrUnknown(
              data['performed_by_name']!, _performedByNameMeta));
    } else if (isInserting) {
      context.missing(_performedByNameMeta);
    }
    if (data.containsKey('balance_before')) {
      context.handle(
          _balanceBeforeMeta,
          balanceBefore.isAcceptableOrUnknown(
              data['balance_before']!, _balanceBeforeMeta));
    } else if (isInserting) {
      context.missing(_balanceBeforeMeta);
    }
    if (data.containsKey('balance_after')) {
      context.handle(
          _balanceAfterMeta,
          balanceAfter.isAcceptableOrUnknown(
              data['balance_after']!, _balanceAfterMeta));
    } else if (isInserting) {
      context.missing(_balanceAfterMeta);
    }
    if (data.containsKey('timestamp')) {
      context.handle(_timestampMeta,
          timestamp.isAcceptableOrUnknown(data['timestamp']!, _timestampMeta));
    } else if (isInserting) {
      context.missing(_timestampMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  StockMovementTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return StockMovementTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      productUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}product_uuid'])!,
      productName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}product_name'])!,
      warehouseUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}warehouse_uuid'])!,
      batchUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}batch_uuid']),
      movementType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}movement_type'])!,
      quantityChange: attachedDatabase.typeMapping.read(
          DriftSqlType.double, data['${effectivePrefix}quantity_change'])!,
      unitCost: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}unit_cost']),
      totalCost: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}total_cost']),
      referenceType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}reference_type']),
      referenceUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}reference_uuid']),
      referenceNumber: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}reference_number']),
      reasonCode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}reason_code']),
      notes: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}notes']),
      performedBy: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}performed_by'])!,
      performedByName: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}performed_by_name'])!,
      balanceBefore: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}balance_before'])!,
      balanceAfter: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}balance_after'])!,
      timestamp: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}timestamp'])!,
    );
  }

  @override
  $StockMovementTableTable createAlias(String alias) {
    return $StockMovementTableTable(attachedDatabase, alias);
  }
}

class StockMovementTableData extends DataClass
    implements Insertable<StockMovementTableData> {
  final int id;
  final String uuid;
  final String productUuid;
  final String productName;
  final String warehouseUuid;
  final String? batchUuid;
  final String movementType;
  final double quantityChange;
  final double? unitCost;
  final double? totalCost;
  final String? referenceType;
  final String? referenceUuid;
  final String? referenceNumber;
  final String? reasonCode;
  final String? notes;
  final String performedBy;
  final String performedByName;
  final double balanceBefore;
  final double balanceAfter;
  final DateTime timestamp;
  const StockMovementTableData(
      {required this.id,
      required this.uuid,
      required this.productUuid,
      required this.productName,
      required this.warehouseUuid,
      this.batchUuid,
      required this.movementType,
      required this.quantityChange,
      this.unitCost,
      this.totalCost,
      this.referenceType,
      this.referenceUuid,
      this.referenceNumber,
      this.reasonCode,
      this.notes,
      required this.performedBy,
      required this.performedByName,
      required this.balanceBefore,
      required this.balanceAfter,
      required this.timestamp});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    map['product_uuid'] = Variable<String>(productUuid);
    map['product_name'] = Variable<String>(productName);
    map['warehouse_uuid'] = Variable<String>(warehouseUuid);
    if (!nullToAbsent || batchUuid != null) {
      map['batch_uuid'] = Variable<String>(batchUuid);
    }
    map['movement_type'] = Variable<String>(movementType);
    map['quantity_change'] = Variable<double>(quantityChange);
    if (!nullToAbsent || unitCost != null) {
      map['unit_cost'] = Variable<double>(unitCost);
    }
    if (!nullToAbsent || totalCost != null) {
      map['total_cost'] = Variable<double>(totalCost);
    }
    if (!nullToAbsent || referenceType != null) {
      map['reference_type'] = Variable<String>(referenceType);
    }
    if (!nullToAbsent || referenceUuid != null) {
      map['reference_uuid'] = Variable<String>(referenceUuid);
    }
    if (!nullToAbsent || referenceNumber != null) {
      map['reference_number'] = Variable<String>(referenceNumber);
    }
    if (!nullToAbsent || reasonCode != null) {
      map['reason_code'] = Variable<String>(reasonCode);
    }
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    map['performed_by'] = Variable<String>(performedBy);
    map['performed_by_name'] = Variable<String>(performedByName);
    map['balance_before'] = Variable<double>(balanceBefore);
    map['balance_after'] = Variable<double>(balanceAfter);
    map['timestamp'] = Variable<DateTime>(timestamp);
    return map;
  }

  StockMovementTableCompanion toCompanion(bool nullToAbsent) {
    return StockMovementTableCompanion(
      id: Value(id),
      uuid: Value(uuid),
      productUuid: Value(productUuid),
      productName: Value(productName),
      warehouseUuid: Value(warehouseUuid),
      batchUuid: batchUuid == null && nullToAbsent
          ? const Value.absent()
          : Value(batchUuid),
      movementType: Value(movementType),
      quantityChange: Value(quantityChange),
      unitCost: unitCost == null && nullToAbsent
          ? const Value.absent()
          : Value(unitCost),
      totalCost: totalCost == null && nullToAbsent
          ? const Value.absent()
          : Value(totalCost),
      referenceType: referenceType == null && nullToAbsent
          ? const Value.absent()
          : Value(referenceType),
      referenceUuid: referenceUuid == null && nullToAbsent
          ? const Value.absent()
          : Value(referenceUuid),
      referenceNumber: referenceNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(referenceNumber),
      reasonCode: reasonCode == null && nullToAbsent
          ? const Value.absent()
          : Value(reasonCode),
      notes:
          notes == null && nullToAbsent ? const Value.absent() : Value(notes),
      performedBy: Value(performedBy),
      performedByName: Value(performedByName),
      balanceBefore: Value(balanceBefore),
      balanceAfter: Value(balanceAfter),
      timestamp: Value(timestamp),
    );
  }

  factory StockMovementTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return StockMovementTableData(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      productUuid: serializer.fromJson<String>(json['productUuid']),
      productName: serializer.fromJson<String>(json['productName']),
      warehouseUuid: serializer.fromJson<String>(json['warehouseUuid']),
      batchUuid: serializer.fromJson<String?>(json['batchUuid']),
      movementType: serializer.fromJson<String>(json['movementType']),
      quantityChange: serializer.fromJson<double>(json['quantityChange']),
      unitCost: serializer.fromJson<double?>(json['unitCost']),
      totalCost: serializer.fromJson<double?>(json['totalCost']),
      referenceType: serializer.fromJson<String?>(json['referenceType']),
      referenceUuid: serializer.fromJson<String?>(json['referenceUuid']),
      referenceNumber: serializer.fromJson<String?>(json['referenceNumber']),
      reasonCode: serializer.fromJson<String?>(json['reasonCode']),
      notes: serializer.fromJson<String?>(json['notes']),
      performedBy: serializer.fromJson<String>(json['performedBy']),
      performedByName: serializer.fromJson<String>(json['performedByName']),
      balanceBefore: serializer.fromJson<double>(json['balanceBefore']),
      balanceAfter: serializer.fromJson<double>(json['balanceAfter']),
      timestamp: serializer.fromJson<DateTime>(json['timestamp']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'productUuid': serializer.toJson<String>(productUuid),
      'productName': serializer.toJson<String>(productName),
      'warehouseUuid': serializer.toJson<String>(warehouseUuid),
      'batchUuid': serializer.toJson<String?>(batchUuid),
      'movementType': serializer.toJson<String>(movementType),
      'quantityChange': serializer.toJson<double>(quantityChange),
      'unitCost': serializer.toJson<double?>(unitCost),
      'totalCost': serializer.toJson<double?>(totalCost),
      'referenceType': serializer.toJson<String?>(referenceType),
      'referenceUuid': serializer.toJson<String?>(referenceUuid),
      'referenceNumber': serializer.toJson<String?>(referenceNumber),
      'reasonCode': serializer.toJson<String?>(reasonCode),
      'notes': serializer.toJson<String?>(notes),
      'performedBy': serializer.toJson<String>(performedBy),
      'performedByName': serializer.toJson<String>(performedByName),
      'balanceBefore': serializer.toJson<double>(balanceBefore),
      'balanceAfter': serializer.toJson<double>(balanceAfter),
      'timestamp': serializer.toJson<DateTime>(timestamp),
    };
  }

  StockMovementTableData copyWith(
          {int? id,
          String? uuid,
          String? productUuid,
          String? productName,
          String? warehouseUuid,
          Value<String?> batchUuid = const Value.absent(),
          String? movementType,
          double? quantityChange,
          Value<double?> unitCost = const Value.absent(),
          Value<double?> totalCost = const Value.absent(),
          Value<String?> referenceType = const Value.absent(),
          Value<String?> referenceUuid = const Value.absent(),
          Value<String?> referenceNumber = const Value.absent(),
          Value<String?> reasonCode = const Value.absent(),
          Value<String?> notes = const Value.absent(),
          String? performedBy,
          String? performedByName,
          double? balanceBefore,
          double? balanceAfter,
          DateTime? timestamp}) =>
      StockMovementTableData(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        productUuid: productUuid ?? this.productUuid,
        productName: productName ?? this.productName,
        warehouseUuid: warehouseUuid ?? this.warehouseUuid,
        batchUuid: batchUuid.present ? batchUuid.value : this.batchUuid,
        movementType: movementType ?? this.movementType,
        quantityChange: quantityChange ?? this.quantityChange,
        unitCost: unitCost.present ? unitCost.value : this.unitCost,
        totalCost: totalCost.present ? totalCost.value : this.totalCost,
        referenceType:
            referenceType.present ? referenceType.value : this.referenceType,
        referenceUuid:
            referenceUuid.present ? referenceUuid.value : this.referenceUuid,
        referenceNumber: referenceNumber.present
            ? referenceNumber.value
            : this.referenceNumber,
        reasonCode: reasonCode.present ? reasonCode.value : this.reasonCode,
        notes: notes.present ? notes.value : this.notes,
        performedBy: performedBy ?? this.performedBy,
        performedByName: performedByName ?? this.performedByName,
        balanceBefore: balanceBefore ?? this.balanceBefore,
        balanceAfter: balanceAfter ?? this.balanceAfter,
        timestamp: timestamp ?? this.timestamp,
      );
  StockMovementTableData copyWithCompanion(StockMovementTableCompanion data) {
    return StockMovementTableData(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      productUuid:
          data.productUuid.present ? data.productUuid.value : this.productUuid,
      productName:
          data.productName.present ? data.productName.value : this.productName,
      warehouseUuid: data.warehouseUuid.present
          ? data.warehouseUuid.value
          : this.warehouseUuid,
      batchUuid: data.batchUuid.present ? data.batchUuid.value : this.batchUuid,
      movementType: data.movementType.present
          ? data.movementType.value
          : this.movementType,
      quantityChange: data.quantityChange.present
          ? data.quantityChange.value
          : this.quantityChange,
      unitCost: data.unitCost.present ? data.unitCost.value : this.unitCost,
      totalCost: data.totalCost.present ? data.totalCost.value : this.totalCost,
      referenceType: data.referenceType.present
          ? data.referenceType.value
          : this.referenceType,
      referenceUuid: data.referenceUuid.present
          ? data.referenceUuid.value
          : this.referenceUuid,
      referenceNumber: data.referenceNumber.present
          ? data.referenceNumber.value
          : this.referenceNumber,
      reasonCode:
          data.reasonCode.present ? data.reasonCode.value : this.reasonCode,
      notes: data.notes.present ? data.notes.value : this.notes,
      performedBy:
          data.performedBy.present ? data.performedBy.value : this.performedBy,
      performedByName: data.performedByName.present
          ? data.performedByName.value
          : this.performedByName,
      balanceBefore: data.balanceBefore.present
          ? data.balanceBefore.value
          : this.balanceBefore,
      balanceAfter: data.balanceAfter.present
          ? data.balanceAfter.value
          : this.balanceAfter,
      timestamp: data.timestamp.present ? data.timestamp.value : this.timestamp,
    );
  }

  @override
  String toString() {
    return (StringBuffer('StockMovementTableData(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('productUuid: $productUuid, ')
          ..write('productName: $productName, ')
          ..write('warehouseUuid: $warehouseUuid, ')
          ..write('batchUuid: $batchUuid, ')
          ..write('movementType: $movementType, ')
          ..write('quantityChange: $quantityChange, ')
          ..write('unitCost: $unitCost, ')
          ..write('totalCost: $totalCost, ')
          ..write('referenceType: $referenceType, ')
          ..write('referenceUuid: $referenceUuid, ')
          ..write('referenceNumber: $referenceNumber, ')
          ..write('reasonCode: $reasonCode, ')
          ..write('notes: $notes, ')
          ..write('performedBy: $performedBy, ')
          ..write('performedByName: $performedByName, ')
          ..write('balanceBefore: $balanceBefore, ')
          ..write('balanceAfter: $balanceAfter, ')
          ..write('timestamp: $timestamp')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      uuid,
      productUuid,
      productName,
      warehouseUuid,
      batchUuid,
      movementType,
      quantityChange,
      unitCost,
      totalCost,
      referenceType,
      referenceUuid,
      referenceNumber,
      reasonCode,
      notes,
      performedBy,
      performedByName,
      balanceBefore,
      balanceAfter,
      timestamp);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is StockMovementTableData &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.productUuid == this.productUuid &&
          other.productName == this.productName &&
          other.warehouseUuid == this.warehouseUuid &&
          other.batchUuid == this.batchUuid &&
          other.movementType == this.movementType &&
          other.quantityChange == this.quantityChange &&
          other.unitCost == this.unitCost &&
          other.totalCost == this.totalCost &&
          other.referenceType == this.referenceType &&
          other.referenceUuid == this.referenceUuid &&
          other.referenceNumber == this.referenceNumber &&
          other.reasonCode == this.reasonCode &&
          other.notes == this.notes &&
          other.performedBy == this.performedBy &&
          other.performedByName == this.performedByName &&
          other.balanceBefore == this.balanceBefore &&
          other.balanceAfter == this.balanceAfter &&
          other.timestamp == this.timestamp);
}

class StockMovementTableCompanion
    extends UpdateCompanion<StockMovementTableData> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String> productUuid;
  final Value<String> productName;
  final Value<String> warehouseUuid;
  final Value<String?> batchUuid;
  final Value<String> movementType;
  final Value<double> quantityChange;
  final Value<double?> unitCost;
  final Value<double?> totalCost;
  final Value<String?> referenceType;
  final Value<String?> referenceUuid;
  final Value<String?> referenceNumber;
  final Value<String?> reasonCode;
  final Value<String?> notes;
  final Value<String> performedBy;
  final Value<String> performedByName;
  final Value<double> balanceBefore;
  final Value<double> balanceAfter;
  final Value<DateTime> timestamp;
  const StockMovementTableCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.productUuid = const Value.absent(),
    this.productName = const Value.absent(),
    this.warehouseUuid = const Value.absent(),
    this.batchUuid = const Value.absent(),
    this.movementType = const Value.absent(),
    this.quantityChange = const Value.absent(),
    this.unitCost = const Value.absent(),
    this.totalCost = const Value.absent(),
    this.referenceType = const Value.absent(),
    this.referenceUuid = const Value.absent(),
    this.referenceNumber = const Value.absent(),
    this.reasonCode = const Value.absent(),
    this.notes = const Value.absent(),
    this.performedBy = const Value.absent(),
    this.performedByName = const Value.absent(),
    this.balanceBefore = const Value.absent(),
    this.balanceAfter = const Value.absent(),
    this.timestamp = const Value.absent(),
  });
  StockMovementTableCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    required String productUuid,
    required String productName,
    required String warehouseUuid,
    this.batchUuid = const Value.absent(),
    required String movementType,
    required double quantityChange,
    this.unitCost = const Value.absent(),
    this.totalCost = const Value.absent(),
    this.referenceType = const Value.absent(),
    this.referenceUuid = const Value.absent(),
    this.referenceNumber = const Value.absent(),
    this.reasonCode = const Value.absent(),
    this.notes = const Value.absent(),
    required String performedBy,
    required String performedByName,
    required double balanceBefore,
    required double balanceAfter,
    required DateTime timestamp,
  })  : uuid = Value(uuid),
        productUuid = Value(productUuid),
        productName = Value(productName),
        warehouseUuid = Value(warehouseUuid),
        movementType = Value(movementType),
        quantityChange = Value(quantityChange),
        performedBy = Value(performedBy),
        performedByName = Value(performedByName),
        balanceBefore = Value(balanceBefore),
        balanceAfter = Value(balanceAfter),
        timestamp = Value(timestamp);
  static Insertable<StockMovementTableData> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? productUuid,
    Expression<String>? productName,
    Expression<String>? warehouseUuid,
    Expression<String>? batchUuid,
    Expression<String>? movementType,
    Expression<double>? quantityChange,
    Expression<double>? unitCost,
    Expression<double>? totalCost,
    Expression<String>? referenceType,
    Expression<String>? referenceUuid,
    Expression<String>? referenceNumber,
    Expression<String>? reasonCode,
    Expression<String>? notes,
    Expression<String>? performedBy,
    Expression<String>? performedByName,
    Expression<double>? balanceBefore,
    Expression<double>? balanceAfter,
    Expression<DateTime>? timestamp,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (productUuid != null) 'product_uuid': productUuid,
      if (productName != null) 'product_name': productName,
      if (warehouseUuid != null) 'warehouse_uuid': warehouseUuid,
      if (batchUuid != null) 'batch_uuid': batchUuid,
      if (movementType != null) 'movement_type': movementType,
      if (quantityChange != null) 'quantity_change': quantityChange,
      if (unitCost != null) 'unit_cost': unitCost,
      if (totalCost != null) 'total_cost': totalCost,
      if (referenceType != null) 'reference_type': referenceType,
      if (referenceUuid != null) 'reference_uuid': referenceUuid,
      if (referenceNumber != null) 'reference_number': referenceNumber,
      if (reasonCode != null) 'reason_code': reasonCode,
      if (notes != null) 'notes': notes,
      if (performedBy != null) 'performed_by': performedBy,
      if (performedByName != null) 'performed_by_name': performedByName,
      if (balanceBefore != null) 'balance_before': balanceBefore,
      if (balanceAfter != null) 'balance_after': balanceAfter,
      if (timestamp != null) 'timestamp': timestamp,
    });
  }

  StockMovementTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String>? productUuid,
      Value<String>? productName,
      Value<String>? warehouseUuid,
      Value<String?>? batchUuid,
      Value<String>? movementType,
      Value<double>? quantityChange,
      Value<double?>? unitCost,
      Value<double?>? totalCost,
      Value<String?>? referenceType,
      Value<String?>? referenceUuid,
      Value<String?>? referenceNumber,
      Value<String?>? reasonCode,
      Value<String?>? notes,
      Value<String>? performedBy,
      Value<String>? performedByName,
      Value<double>? balanceBefore,
      Value<double>? balanceAfter,
      Value<DateTime>? timestamp}) {
    return StockMovementTableCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      productUuid: productUuid ?? this.productUuid,
      productName: productName ?? this.productName,
      warehouseUuid: warehouseUuid ?? this.warehouseUuid,
      batchUuid: batchUuid ?? this.batchUuid,
      movementType: movementType ?? this.movementType,
      quantityChange: quantityChange ?? this.quantityChange,
      unitCost: unitCost ?? this.unitCost,
      totalCost: totalCost ?? this.totalCost,
      referenceType: referenceType ?? this.referenceType,
      referenceUuid: referenceUuid ?? this.referenceUuid,
      referenceNumber: referenceNumber ?? this.referenceNumber,
      reasonCode: reasonCode ?? this.reasonCode,
      notes: notes ?? this.notes,
      performedBy: performedBy ?? this.performedBy,
      performedByName: performedByName ?? this.performedByName,
      balanceBefore: balanceBefore ?? this.balanceBefore,
      balanceAfter: balanceAfter ?? this.balanceAfter,
      timestamp: timestamp ?? this.timestamp,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (productUuid.present) {
      map['product_uuid'] = Variable<String>(productUuid.value);
    }
    if (productName.present) {
      map['product_name'] = Variable<String>(productName.value);
    }
    if (warehouseUuid.present) {
      map['warehouse_uuid'] = Variable<String>(warehouseUuid.value);
    }
    if (batchUuid.present) {
      map['batch_uuid'] = Variable<String>(batchUuid.value);
    }
    if (movementType.present) {
      map['movement_type'] = Variable<String>(movementType.value);
    }
    if (quantityChange.present) {
      map['quantity_change'] = Variable<double>(quantityChange.value);
    }
    if (unitCost.present) {
      map['unit_cost'] = Variable<double>(unitCost.value);
    }
    if (totalCost.present) {
      map['total_cost'] = Variable<double>(totalCost.value);
    }
    if (referenceType.present) {
      map['reference_type'] = Variable<String>(referenceType.value);
    }
    if (referenceUuid.present) {
      map['reference_uuid'] = Variable<String>(referenceUuid.value);
    }
    if (referenceNumber.present) {
      map['reference_number'] = Variable<String>(referenceNumber.value);
    }
    if (reasonCode.present) {
      map['reason_code'] = Variable<String>(reasonCode.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (performedBy.present) {
      map['performed_by'] = Variable<String>(performedBy.value);
    }
    if (performedByName.present) {
      map['performed_by_name'] = Variable<String>(performedByName.value);
    }
    if (balanceBefore.present) {
      map['balance_before'] = Variable<double>(balanceBefore.value);
    }
    if (balanceAfter.present) {
      map['balance_after'] = Variable<double>(balanceAfter.value);
    }
    if (timestamp.present) {
      map['timestamp'] = Variable<DateTime>(timestamp.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('StockMovementTableCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('productUuid: $productUuid, ')
          ..write('productName: $productName, ')
          ..write('warehouseUuid: $warehouseUuid, ')
          ..write('batchUuid: $batchUuid, ')
          ..write('movementType: $movementType, ')
          ..write('quantityChange: $quantityChange, ')
          ..write('unitCost: $unitCost, ')
          ..write('totalCost: $totalCost, ')
          ..write('referenceType: $referenceType, ')
          ..write('referenceUuid: $referenceUuid, ')
          ..write('referenceNumber: $referenceNumber, ')
          ..write('reasonCode: $reasonCode, ')
          ..write('notes: $notes, ')
          ..write('performedBy: $performedBy, ')
          ..write('performedByName: $performedByName, ')
          ..write('balanceBefore: $balanceBefore, ')
          ..write('balanceAfter: $balanceAfter, ')
          ..write('timestamp: $timestamp')
          ..write(')'))
        .toString();
  }
}

class $TimeEntryTableTable extends TimeEntryTable
    with TableInfo<$TimeEntryTableTable, TimeEntryTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $TimeEntryTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _employeeUuidMeta =
      const VerificationMeta('employeeUuid');
  @override
  late final GeneratedColumn<String> employeeUuid = GeneratedColumn<String>(
      'employee_uuid', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _clockInMeta =
      const VerificationMeta('clockIn');
  @override
  late final GeneratedColumn<DateTime> clockIn = GeneratedColumn<DateTime>(
      'clock_in', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _clockOutMeta =
      const VerificationMeta('clockOut');
  @override
  late final GeneratedColumn<DateTime> clockOut = GeneratedColumn<DateTime>(
      'clock_out', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _breakStartMeta =
      const VerificationMeta('breakStart');
  @override
  late final GeneratedColumn<DateTime> breakStart = GeneratedColumn<DateTime>(
      'break_start', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _breakEndMeta =
      const VerificationMeta('breakEnd');
  @override
  late final GeneratedColumn<DateTime> breakEnd = GeneratedColumn<DateTime>(
      'break_end', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _regularHoursMeta =
      const VerificationMeta('regularHours');
  @override
  late final GeneratedColumn<double> regularHours = GeneratedColumn<double>(
      'regular_hours', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: false,
      defaultValue: const Constant(0));
  static const VerificationMeta _overtimeHoursMeta =
      const VerificationMeta('overtimeHours');
  @override
  late final GeneratedColumn<double> overtimeHours = GeneratedColumn<double>(
      'overtime_hours', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: false,
      defaultValue: const Constant(0));
  static const VerificationMeta _breakMinutesMeta =
      const VerificationMeta('breakMinutes');
  @override
  late final GeneratedColumn<double> breakMinutes = GeneratedColumn<double>(
      'break_minutes', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: false,
      defaultValue: const Constant(0));
  static const VerificationMeta _cashTipsMeta =
      const VerificationMeta('cashTips');
  @override
  late final GeneratedColumn<double> cashTips = GeneratedColumn<double>(
      'cash_tips', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: false,
      defaultValue: const Constant(0));
  static const VerificationMeta _cardTipsMeta =
      const VerificationMeta('cardTips');
  @override
  late final GeneratedColumn<double> cardTips = GeneratedColumn<double>(
      'card_tips', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: false,
      defaultValue: const Constant(0));
  static const VerificationMeta _shiftUuidMeta =
      const VerificationMeta('shiftUuid');
  @override
  late final GeneratedColumn<String> shiftUuid = GeneratedColumn<String>(
      'shift_uuid', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
      'notes', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isApprovedMeta =
      const VerificationMeta('isApproved');
  @override
  late final GeneratedColumn<bool> isApproved = GeneratedColumn<bool>(
      'is_approved', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_approved" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _approvedByMeta =
      const VerificationMeta('approvedBy');
  @override
  late final GeneratedColumn<String> approvedBy = GeneratedColumn<String>(
      'approved_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        employeeUuid,
        clockIn,
        clockOut,
        breakStart,
        breakEnd,
        regularHours,
        overtimeHours,
        breakMinutes,
        cashTips,
        cardTips,
        shiftUuid,
        notes,
        isApproved,
        approvedBy,
        createdAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'time_entry_table';
  @override
  VerificationContext validateIntegrity(Insertable<TimeEntryTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('employee_uuid')) {
      context.handle(
          _employeeUuidMeta,
          employeeUuid.isAcceptableOrUnknown(
              data['employee_uuid']!, _employeeUuidMeta));
    } else if (isInserting) {
      context.missing(_employeeUuidMeta);
    }
    if (data.containsKey('clock_in')) {
      context.handle(_clockInMeta,
          clockIn.isAcceptableOrUnknown(data['clock_in']!, _clockInMeta));
    } else if (isInserting) {
      context.missing(_clockInMeta);
    }
    if (data.containsKey('clock_out')) {
      context.handle(_clockOutMeta,
          clockOut.isAcceptableOrUnknown(data['clock_out']!, _clockOutMeta));
    }
    if (data.containsKey('break_start')) {
      context.handle(
          _breakStartMeta,
          breakStart.isAcceptableOrUnknown(
              data['break_start']!, _breakStartMeta));
    }
    if (data.containsKey('break_end')) {
      context.handle(_breakEndMeta,
          breakEnd.isAcceptableOrUnknown(data['break_end']!, _breakEndMeta));
    }
    if (data.containsKey('regular_hours')) {
      context.handle(
          _regularHoursMeta,
          regularHours.isAcceptableOrUnknown(
              data['regular_hours']!, _regularHoursMeta));
    }
    if (data.containsKey('overtime_hours')) {
      context.handle(
          _overtimeHoursMeta,
          overtimeHours.isAcceptableOrUnknown(
              data['overtime_hours']!, _overtimeHoursMeta));
    }
    if (data.containsKey('break_minutes')) {
      context.handle(
          _breakMinutesMeta,
          breakMinutes.isAcceptableOrUnknown(
              data['break_minutes']!, _breakMinutesMeta));
    }
    if (data.containsKey('cash_tips')) {
      context.handle(_cashTipsMeta,
          cashTips.isAcceptableOrUnknown(data['cash_tips']!, _cashTipsMeta));
    }
    if (data.containsKey('card_tips')) {
      context.handle(_cardTipsMeta,
          cardTips.isAcceptableOrUnknown(data['card_tips']!, _cardTipsMeta));
    }
    if (data.containsKey('shift_uuid')) {
      context.handle(_shiftUuidMeta,
          shiftUuid.isAcceptableOrUnknown(data['shift_uuid']!, _shiftUuidMeta));
    }
    if (data.containsKey('notes')) {
      context.handle(
          _notesMeta, notes.isAcceptableOrUnknown(data['notes']!, _notesMeta));
    }
    if (data.containsKey('is_approved')) {
      context.handle(
          _isApprovedMeta,
          isApproved.isAcceptableOrUnknown(
              data['is_approved']!, _isApprovedMeta));
    }
    if (data.containsKey('approved_by')) {
      context.handle(
          _approvedByMeta,
          approvedBy.isAcceptableOrUnknown(
              data['approved_by']!, _approvedByMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  TimeEntryTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return TimeEntryTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      employeeUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}employee_uuid'])!,
      clockIn: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}clock_in'])!,
      clockOut: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}clock_out']),
      breakStart: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}break_start']),
      breakEnd: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}break_end']),
      regularHours: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}regular_hours'])!,
      overtimeHours: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}overtime_hours'])!,
      breakMinutes: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}break_minutes'])!,
      cashTips: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}cash_tips'])!,
      cardTips: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}card_tips'])!,
      shiftUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}shift_uuid']),
      notes: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}notes']),
      isApproved: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_approved'])!,
      approvedBy: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}approved_by']),
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
    );
  }

  @override
  $TimeEntryTableTable createAlias(String alias) {
    return $TimeEntryTableTable(attachedDatabase, alias);
  }
}

class TimeEntryTableData extends DataClass
    implements Insertable<TimeEntryTableData> {
  final int id;
  final String uuid;
  final String employeeUuid;
  final DateTime clockIn;
  final DateTime? clockOut;
  final DateTime? breakStart;
  final DateTime? breakEnd;
  final double regularHours;
  final double overtimeHours;
  final double breakMinutes;
  final double cashTips;
  final double cardTips;
  final String? shiftUuid;
  final String? notes;
  final bool isApproved;
  final String? approvedBy;
  final DateTime createdAt;
  const TimeEntryTableData(
      {required this.id,
      required this.uuid,
      required this.employeeUuid,
      required this.clockIn,
      this.clockOut,
      this.breakStart,
      this.breakEnd,
      required this.regularHours,
      required this.overtimeHours,
      required this.breakMinutes,
      required this.cashTips,
      required this.cardTips,
      this.shiftUuid,
      this.notes,
      required this.isApproved,
      this.approvedBy,
      required this.createdAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    map['employee_uuid'] = Variable<String>(employeeUuid);
    map['clock_in'] = Variable<DateTime>(clockIn);
    if (!nullToAbsent || clockOut != null) {
      map['clock_out'] = Variable<DateTime>(clockOut);
    }
    if (!nullToAbsent || breakStart != null) {
      map['break_start'] = Variable<DateTime>(breakStart);
    }
    if (!nullToAbsent || breakEnd != null) {
      map['break_end'] = Variable<DateTime>(breakEnd);
    }
    map['regular_hours'] = Variable<double>(regularHours);
    map['overtime_hours'] = Variable<double>(overtimeHours);
    map['break_minutes'] = Variable<double>(breakMinutes);
    map['cash_tips'] = Variable<double>(cashTips);
    map['card_tips'] = Variable<double>(cardTips);
    if (!nullToAbsent || shiftUuid != null) {
      map['shift_uuid'] = Variable<String>(shiftUuid);
    }
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    map['is_approved'] = Variable<bool>(isApproved);
    if (!nullToAbsent || approvedBy != null) {
      map['approved_by'] = Variable<String>(approvedBy);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    return map;
  }

  TimeEntryTableCompanion toCompanion(bool nullToAbsent) {
    return TimeEntryTableCompanion(
      id: Value(id),
      uuid: Value(uuid),
      employeeUuid: Value(employeeUuid),
      clockIn: Value(clockIn),
      clockOut: clockOut == null && nullToAbsent
          ? const Value.absent()
          : Value(clockOut),
      breakStart: breakStart == null && nullToAbsent
          ? const Value.absent()
          : Value(breakStart),
      breakEnd: breakEnd == null && nullToAbsent
          ? const Value.absent()
          : Value(breakEnd),
      regularHours: Value(regularHours),
      overtimeHours: Value(overtimeHours),
      breakMinutes: Value(breakMinutes),
      cashTips: Value(cashTips),
      cardTips: Value(cardTips),
      shiftUuid: shiftUuid == null && nullToAbsent
          ? const Value.absent()
          : Value(shiftUuid),
      notes:
          notes == null && nullToAbsent ? const Value.absent() : Value(notes),
      isApproved: Value(isApproved),
      approvedBy: approvedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(approvedBy),
      createdAt: Value(createdAt),
    );
  }

  factory TimeEntryTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return TimeEntryTableData(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      employeeUuid: serializer.fromJson<String>(json['employeeUuid']),
      clockIn: serializer.fromJson<DateTime>(json['clockIn']),
      clockOut: serializer.fromJson<DateTime?>(json['clockOut']),
      breakStart: serializer.fromJson<DateTime?>(json['breakStart']),
      breakEnd: serializer.fromJson<DateTime?>(json['breakEnd']),
      regularHours: serializer.fromJson<double>(json['regularHours']),
      overtimeHours: serializer.fromJson<double>(json['overtimeHours']),
      breakMinutes: serializer.fromJson<double>(json['breakMinutes']),
      cashTips: serializer.fromJson<double>(json['cashTips']),
      cardTips: serializer.fromJson<double>(json['cardTips']),
      shiftUuid: serializer.fromJson<String?>(json['shiftUuid']),
      notes: serializer.fromJson<String?>(json['notes']),
      isApproved: serializer.fromJson<bool>(json['isApproved']),
      approvedBy: serializer.fromJson<String?>(json['approvedBy']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'employeeUuid': serializer.toJson<String>(employeeUuid),
      'clockIn': serializer.toJson<DateTime>(clockIn),
      'clockOut': serializer.toJson<DateTime?>(clockOut),
      'breakStart': serializer.toJson<DateTime?>(breakStart),
      'breakEnd': serializer.toJson<DateTime?>(breakEnd),
      'regularHours': serializer.toJson<double>(regularHours),
      'overtimeHours': serializer.toJson<double>(overtimeHours),
      'breakMinutes': serializer.toJson<double>(breakMinutes),
      'cashTips': serializer.toJson<double>(cashTips),
      'cardTips': serializer.toJson<double>(cardTips),
      'shiftUuid': serializer.toJson<String?>(shiftUuid),
      'notes': serializer.toJson<String?>(notes),
      'isApproved': serializer.toJson<bool>(isApproved),
      'approvedBy': serializer.toJson<String?>(approvedBy),
      'createdAt': serializer.toJson<DateTime>(createdAt),
    };
  }

  TimeEntryTableData copyWith(
          {int? id,
          String? uuid,
          String? employeeUuid,
          DateTime? clockIn,
          Value<DateTime?> clockOut = const Value.absent(),
          Value<DateTime?> breakStart = const Value.absent(),
          Value<DateTime?> breakEnd = const Value.absent(),
          double? regularHours,
          double? overtimeHours,
          double? breakMinutes,
          double? cashTips,
          double? cardTips,
          Value<String?> shiftUuid = const Value.absent(),
          Value<String?> notes = const Value.absent(),
          bool? isApproved,
          Value<String?> approvedBy = const Value.absent(),
          DateTime? createdAt}) =>
      TimeEntryTableData(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        employeeUuid: employeeUuid ?? this.employeeUuid,
        clockIn: clockIn ?? this.clockIn,
        clockOut: clockOut.present ? clockOut.value : this.clockOut,
        breakStart: breakStart.present ? breakStart.value : this.breakStart,
        breakEnd: breakEnd.present ? breakEnd.value : this.breakEnd,
        regularHours: regularHours ?? this.regularHours,
        overtimeHours: overtimeHours ?? this.overtimeHours,
        breakMinutes: breakMinutes ?? this.breakMinutes,
        cashTips: cashTips ?? this.cashTips,
        cardTips: cardTips ?? this.cardTips,
        shiftUuid: shiftUuid.present ? shiftUuid.value : this.shiftUuid,
        notes: notes.present ? notes.value : this.notes,
        isApproved: isApproved ?? this.isApproved,
        approvedBy: approvedBy.present ? approvedBy.value : this.approvedBy,
        createdAt: createdAt ?? this.createdAt,
      );
  TimeEntryTableData copyWithCompanion(TimeEntryTableCompanion data) {
    return TimeEntryTableData(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      employeeUuid: data.employeeUuid.present
          ? data.employeeUuid.value
          : this.employeeUuid,
      clockIn: data.clockIn.present ? data.clockIn.value : this.clockIn,
      clockOut: data.clockOut.present ? data.clockOut.value : this.clockOut,
      breakStart:
          data.breakStart.present ? data.breakStart.value : this.breakStart,
      breakEnd: data.breakEnd.present ? data.breakEnd.value : this.breakEnd,
      regularHours: data.regularHours.present
          ? data.regularHours.value
          : this.regularHours,
      overtimeHours: data.overtimeHours.present
          ? data.overtimeHours.value
          : this.overtimeHours,
      breakMinutes: data.breakMinutes.present
          ? data.breakMinutes.value
          : this.breakMinutes,
      cashTips: data.cashTips.present ? data.cashTips.value : this.cashTips,
      cardTips: data.cardTips.present ? data.cardTips.value : this.cardTips,
      shiftUuid: data.shiftUuid.present ? data.shiftUuid.value : this.shiftUuid,
      notes: data.notes.present ? data.notes.value : this.notes,
      isApproved:
          data.isApproved.present ? data.isApproved.value : this.isApproved,
      approvedBy:
          data.approvedBy.present ? data.approvedBy.value : this.approvedBy,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('TimeEntryTableData(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('employeeUuid: $employeeUuid, ')
          ..write('clockIn: $clockIn, ')
          ..write('clockOut: $clockOut, ')
          ..write('breakStart: $breakStart, ')
          ..write('breakEnd: $breakEnd, ')
          ..write('regularHours: $regularHours, ')
          ..write('overtimeHours: $overtimeHours, ')
          ..write('breakMinutes: $breakMinutes, ')
          ..write('cashTips: $cashTips, ')
          ..write('cardTips: $cardTips, ')
          ..write('shiftUuid: $shiftUuid, ')
          ..write('notes: $notes, ')
          ..write('isApproved: $isApproved, ')
          ..write('approvedBy: $approvedBy, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      uuid,
      employeeUuid,
      clockIn,
      clockOut,
      breakStart,
      breakEnd,
      regularHours,
      overtimeHours,
      breakMinutes,
      cashTips,
      cardTips,
      shiftUuid,
      notes,
      isApproved,
      approvedBy,
      createdAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is TimeEntryTableData &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.employeeUuid == this.employeeUuid &&
          other.clockIn == this.clockIn &&
          other.clockOut == this.clockOut &&
          other.breakStart == this.breakStart &&
          other.breakEnd == this.breakEnd &&
          other.regularHours == this.regularHours &&
          other.overtimeHours == this.overtimeHours &&
          other.breakMinutes == this.breakMinutes &&
          other.cashTips == this.cashTips &&
          other.cardTips == this.cardTips &&
          other.shiftUuid == this.shiftUuid &&
          other.notes == this.notes &&
          other.isApproved == this.isApproved &&
          other.approvedBy == this.approvedBy &&
          other.createdAt == this.createdAt);
}

class TimeEntryTableCompanion extends UpdateCompanion<TimeEntryTableData> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String> employeeUuid;
  final Value<DateTime> clockIn;
  final Value<DateTime?> clockOut;
  final Value<DateTime?> breakStart;
  final Value<DateTime?> breakEnd;
  final Value<double> regularHours;
  final Value<double> overtimeHours;
  final Value<double> breakMinutes;
  final Value<double> cashTips;
  final Value<double> cardTips;
  final Value<String?> shiftUuid;
  final Value<String?> notes;
  final Value<bool> isApproved;
  final Value<String?> approvedBy;
  final Value<DateTime> createdAt;
  const TimeEntryTableCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.employeeUuid = const Value.absent(),
    this.clockIn = const Value.absent(),
    this.clockOut = const Value.absent(),
    this.breakStart = const Value.absent(),
    this.breakEnd = const Value.absent(),
    this.regularHours = const Value.absent(),
    this.overtimeHours = const Value.absent(),
    this.breakMinutes = const Value.absent(),
    this.cashTips = const Value.absent(),
    this.cardTips = const Value.absent(),
    this.shiftUuid = const Value.absent(),
    this.notes = const Value.absent(),
    this.isApproved = const Value.absent(),
    this.approvedBy = const Value.absent(),
    this.createdAt = const Value.absent(),
  });
  TimeEntryTableCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    required String employeeUuid,
    required DateTime clockIn,
    this.clockOut = const Value.absent(),
    this.breakStart = const Value.absent(),
    this.breakEnd = const Value.absent(),
    this.regularHours = const Value.absent(),
    this.overtimeHours = const Value.absent(),
    this.breakMinutes = const Value.absent(),
    this.cashTips = const Value.absent(),
    this.cardTips = const Value.absent(),
    this.shiftUuid = const Value.absent(),
    this.notes = const Value.absent(),
    this.isApproved = const Value.absent(),
    this.approvedBy = const Value.absent(),
    required DateTime createdAt,
  })  : uuid = Value(uuid),
        employeeUuid = Value(employeeUuid),
        clockIn = Value(clockIn),
        createdAt = Value(createdAt);
  static Insertable<TimeEntryTableData> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? employeeUuid,
    Expression<DateTime>? clockIn,
    Expression<DateTime>? clockOut,
    Expression<DateTime>? breakStart,
    Expression<DateTime>? breakEnd,
    Expression<double>? regularHours,
    Expression<double>? overtimeHours,
    Expression<double>? breakMinutes,
    Expression<double>? cashTips,
    Expression<double>? cardTips,
    Expression<String>? shiftUuid,
    Expression<String>? notes,
    Expression<bool>? isApproved,
    Expression<String>? approvedBy,
    Expression<DateTime>? createdAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (employeeUuid != null) 'employee_uuid': employeeUuid,
      if (clockIn != null) 'clock_in': clockIn,
      if (clockOut != null) 'clock_out': clockOut,
      if (breakStart != null) 'break_start': breakStart,
      if (breakEnd != null) 'break_end': breakEnd,
      if (regularHours != null) 'regular_hours': regularHours,
      if (overtimeHours != null) 'overtime_hours': overtimeHours,
      if (breakMinutes != null) 'break_minutes': breakMinutes,
      if (cashTips != null) 'cash_tips': cashTips,
      if (cardTips != null) 'card_tips': cardTips,
      if (shiftUuid != null) 'shift_uuid': shiftUuid,
      if (notes != null) 'notes': notes,
      if (isApproved != null) 'is_approved': isApproved,
      if (approvedBy != null) 'approved_by': approvedBy,
      if (createdAt != null) 'created_at': createdAt,
    });
  }

  TimeEntryTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String>? employeeUuid,
      Value<DateTime>? clockIn,
      Value<DateTime?>? clockOut,
      Value<DateTime?>? breakStart,
      Value<DateTime?>? breakEnd,
      Value<double>? regularHours,
      Value<double>? overtimeHours,
      Value<double>? breakMinutes,
      Value<double>? cashTips,
      Value<double>? cardTips,
      Value<String?>? shiftUuid,
      Value<String?>? notes,
      Value<bool>? isApproved,
      Value<String?>? approvedBy,
      Value<DateTime>? createdAt}) {
    return TimeEntryTableCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      employeeUuid: employeeUuid ?? this.employeeUuid,
      clockIn: clockIn ?? this.clockIn,
      clockOut: clockOut ?? this.clockOut,
      breakStart: breakStart ?? this.breakStart,
      breakEnd: breakEnd ?? this.breakEnd,
      regularHours: regularHours ?? this.regularHours,
      overtimeHours: overtimeHours ?? this.overtimeHours,
      breakMinutes: breakMinutes ?? this.breakMinutes,
      cashTips: cashTips ?? this.cashTips,
      cardTips: cardTips ?? this.cardTips,
      shiftUuid: shiftUuid ?? this.shiftUuid,
      notes: notes ?? this.notes,
      isApproved: isApproved ?? this.isApproved,
      approvedBy: approvedBy ?? this.approvedBy,
      createdAt: createdAt ?? this.createdAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (employeeUuid.present) {
      map['employee_uuid'] = Variable<String>(employeeUuid.value);
    }
    if (clockIn.present) {
      map['clock_in'] = Variable<DateTime>(clockIn.value);
    }
    if (clockOut.present) {
      map['clock_out'] = Variable<DateTime>(clockOut.value);
    }
    if (breakStart.present) {
      map['break_start'] = Variable<DateTime>(breakStart.value);
    }
    if (breakEnd.present) {
      map['break_end'] = Variable<DateTime>(breakEnd.value);
    }
    if (regularHours.present) {
      map['regular_hours'] = Variable<double>(regularHours.value);
    }
    if (overtimeHours.present) {
      map['overtime_hours'] = Variable<double>(overtimeHours.value);
    }
    if (breakMinutes.present) {
      map['break_minutes'] = Variable<double>(breakMinutes.value);
    }
    if (cashTips.present) {
      map['cash_tips'] = Variable<double>(cashTips.value);
    }
    if (cardTips.present) {
      map['card_tips'] = Variable<double>(cardTips.value);
    }
    if (shiftUuid.present) {
      map['shift_uuid'] = Variable<String>(shiftUuid.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (isApproved.present) {
      map['is_approved'] = Variable<bool>(isApproved.value);
    }
    if (approvedBy.present) {
      map['approved_by'] = Variable<String>(approvedBy.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('TimeEntryTableCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('employeeUuid: $employeeUuid, ')
          ..write('clockIn: $clockIn, ')
          ..write('clockOut: $clockOut, ')
          ..write('breakStart: $breakStart, ')
          ..write('breakEnd: $breakEnd, ')
          ..write('regularHours: $regularHours, ')
          ..write('overtimeHours: $overtimeHours, ')
          ..write('breakMinutes: $breakMinutes, ')
          ..write('cashTips: $cashTips, ')
          ..write('cardTips: $cardTips, ')
          ..write('shiftUuid: $shiftUuid, ')
          ..write('notes: $notes, ')
          ..write('isApproved: $isApproved, ')
          ..write('approvedBy: $approvedBy, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }
}

class $ScheduledShiftTableTable extends ScheduledShiftTable
    with TableInfo<$ScheduledShiftTableTable, ScheduledShiftTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ScheduledShiftTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _employeeUuidMeta =
      const VerificationMeta('employeeUuid');
  @override
  late final GeneratedColumn<String> employeeUuid = GeneratedColumn<String>(
      'employee_uuid', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _dateMeta = const VerificationMeta('date');
  @override
  late final GeneratedColumn<DateTime> date = GeneratedColumn<DateTime>(
      'date', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _startTimeMeta =
      const VerificationMeta('startTime');
  @override
  late final GeneratedColumn<DateTime> startTime = GeneratedColumn<DateTime>(
      'start_time', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _endTimeMeta =
      const VerificationMeta('endTime');
  @override
  late final GeneratedColumn<DateTime> endTime = GeneratedColumn<DateTime>(
      'end_time', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _positionMeta =
      const VerificationMeta('position');
  @override
  late final GeneratedColumn<String> position = GeneratedColumn<String>(
      'position', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
      'notes', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isPublishedMeta =
      const VerificationMeta('isPublished');
  @override
  late final GeneratedColumn<bool> isPublished = GeneratedColumn<bool>(
      'is_published', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("is_published" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _isAcknowledgedMeta =
      const VerificationMeta('isAcknowledged');
  @override
  late final GeneratedColumn<bool> isAcknowledged = GeneratedColumn<bool>(
      'is_acknowledged', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("is_acknowledged" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _swapRequestedWithMeta =
      const VerificationMeta('swapRequestedWith');
  @override
  late final GeneratedColumn<String> swapRequestedWith =
      GeneratedColumn<String>('swap_requested_with', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isSwapPendingMeta =
      const VerificationMeta('isSwapPending');
  @override
  late final GeneratedColumn<bool> isSwapPending = GeneratedColumn<bool>(
      'is_swap_pending', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("is_swap_pending" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        employeeUuid,
        date,
        startTime,
        endTime,
        position,
        notes,
        isPublished,
        isAcknowledged,
        swapRequestedWith,
        isSwapPending,
        createdAt,
        updatedAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'scheduled_shift_table';
  @override
  VerificationContext validateIntegrity(
      Insertable<ScheduledShiftTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('employee_uuid')) {
      context.handle(
          _employeeUuidMeta,
          employeeUuid.isAcceptableOrUnknown(
              data['employee_uuid']!, _employeeUuidMeta));
    } else if (isInserting) {
      context.missing(_employeeUuidMeta);
    }
    if (data.containsKey('date')) {
      context.handle(
          _dateMeta, date.isAcceptableOrUnknown(data['date']!, _dateMeta));
    } else if (isInserting) {
      context.missing(_dateMeta);
    }
    if (data.containsKey('start_time')) {
      context.handle(_startTimeMeta,
          startTime.isAcceptableOrUnknown(data['start_time']!, _startTimeMeta));
    } else if (isInserting) {
      context.missing(_startTimeMeta);
    }
    if (data.containsKey('end_time')) {
      context.handle(_endTimeMeta,
          endTime.isAcceptableOrUnknown(data['end_time']!, _endTimeMeta));
    } else if (isInserting) {
      context.missing(_endTimeMeta);
    }
    if (data.containsKey('position')) {
      context.handle(_positionMeta,
          position.isAcceptableOrUnknown(data['position']!, _positionMeta));
    }
    if (data.containsKey('notes')) {
      context.handle(
          _notesMeta, notes.isAcceptableOrUnknown(data['notes']!, _notesMeta));
    }
    if (data.containsKey('is_published')) {
      context.handle(
          _isPublishedMeta,
          isPublished.isAcceptableOrUnknown(
              data['is_published']!, _isPublishedMeta));
    }
    if (data.containsKey('is_acknowledged')) {
      context.handle(
          _isAcknowledgedMeta,
          isAcknowledged.isAcceptableOrUnknown(
              data['is_acknowledged']!, _isAcknowledgedMeta));
    }
    if (data.containsKey('swap_requested_with')) {
      context.handle(
          _swapRequestedWithMeta,
          swapRequestedWith.isAcceptableOrUnknown(
              data['swap_requested_with']!, _swapRequestedWithMeta));
    }
    if (data.containsKey('is_swap_pending')) {
      context.handle(
          _isSwapPendingMeta,
          isSwapPending.isAcceptableOrUnknown(
              data['is_swap_pending']!, _isSwapPendingMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  ScheduledShiftTableData map(Map<String, dynamic> data,
      {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ScheduledShiftTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      employeeUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}employee_uuid'])!,
      date: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}date'])!,
      startTime: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}start_time'])!,
      endTime: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}end_time'])!,
      position: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}position']),
      notes: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}notes']),
      isPublished: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_published'])!,
      isAcknowledged: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_acknowledged'])!,
      swapRequestedWith: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}swap_requested_with']),
      isSwapPending: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_swap_pending'])!,
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $ScheduledShiftTableTable createAlias(String alias) {
    return $ScheduledShiftTableTable(attachedDatabase, alias);
  }
}

class ScheduledShiftTableData extends DataClass
    implements Insertable<ScheduledShiftTableData> {
  final int id;
  final String uuid;
  final String employeeUuid;
  final DateTime date;
  final DateTime startTime;
  final DateTime endTime;
  final String? position;
  final String? notes;
  final bool isPublished;
  final bool isAcknowledged;
  final String? swapRequestedWith;
  final bool isSwapPending;
  final DateTime createdAt;
  final DateTime updatedAt;
  const ScheduledShiftTableData(
      {required this.id,
      required this.uuid,
      required this.employeeUuid,
      required this.date,
      required this.startTime,
      required this.endTime,
      this.position,
      this.notes,
      required this.isPublished,
      required this.isAcknowledged,
      this.swapRequestedWith,
      required this.isSwapPending,
      required this.createdAt,
      required this.updatedAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    map['employee_uuid'] = Variable<String>(employeeUuid);
    map['date'] = Variable<DateTime>(date);
    map['start_time'] = Variable<DateTime>(startTime);
    map['end_time'] = Variable<DateTime>(endTime);
    if (!nullToAbsent || position != null) {
      map['position'] = Variable<String>(position);
    }
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    map['is_published'] = Variable<bool>(isPublished);
    map['is_acknowledged'] = Variable<bool>(isAcknowledged);
    if (!nullToAbsent || swapRequestedWith != null) {
      map['swap_requested_with'] = Variable<String>(swapRequestedWith);
    }
    map['is_swap_pending'] = Variable<bool>(isSwapPending);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  ScheduledShiftTableCompanion toCompanion(bool nullToAbsent) {
    return ScheduledShiftTableCompanion(
      id: Value(id),
      uuid: Value(uuid),
      employeeUuid: Value(employeeUuid),
      date: Value(date),
      startTime: Value(startTime),
      endTime: Value(endTime),
      position: position == null && nullToAbsent
          ? const Value.absent()
          : Value(position),
      notes:
          notes == null && nullToAbsent ? const Value.absent() : Value(notes),
      isPublished: Value(isPublished),
      isAcknowledged: Value(isAcknowledged),
      swapRequestedWith: swapRequestedWith == null && nullToAbsent
          ? const Value.absent()
          : Value(swapRequestedWith),
      isSwapPending: Value(isSwapPending),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory ScheduledShiftTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ScheduledShiftTableData(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      employeeUuid: serializer.fromJson<String>(json['employeeUuid']),
      date: serializer.fromJson<DateTime>(json['date']),
      startTime: serializer.fromJson<DateTime>(json['startTime']),
      endTime: serializer.fromJson<DateTime>(json['endTime']),
      position: serializer.fromJson<String?>(json['position']),
      notes: serializer.fromJson<String?>(json['notes']),
      isPublished: serializer.fromJson<bool>(json['isPublished']),
      isAcknowledged: serializer.fromJson<bool>(json['isAcknowledged']),
      swapRequestedWith:
          serializer.fromJson<String?>(json['swapRequestedWith']),
      isSwapPending: serializer.fromJson<bool>(json['isSwapPending']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'employeeUuid': serializer.toJson<String>(employeeUuid),
      'date': serializer.toJson<DateTime>(date),
      'startTime': serializer.toJson<DateTime>(startTime),
      'endTime': serializer.toJson<DateTime>(endTime),
      'position': serializer.toJson<String?>(position),
      'notes': serializer.toJson<String?>(notes),
      'isPublished': serializer.toJson<bool>(isPublished),
      'isAcknowledged': serializer.toJson<bool>(isAcknowledged),
      'swapRequestedWith': serializer.toJson<String?>(swapRequestedWith),
      'isSwapPending': serializer.toJson<bool>(isSwapPending),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  ScheduledShiftTableData copyWith(
          {int? id,
          String? uuid,
          String? employeeUuid,
          DateTime? date,
          DateTime? startTime,
          DateTime? endTime,
          Value<String?> position = const Value.absent(),
          Value<String?> notes = const Value.absent(),
          bool? isPublished,
          bool? isAcknowledged,
          Value<String?> swapRequestedWith = const Value.absent(),
          bool? isSwapPending,
          DateTime? createdAt,
          DateTime? updatedAt}) =>
      ScheduledShiftTableData(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        employeeUuid: employeeUuid ?? this.employeeUuid,
        date: date ?? this.date,
        startTime: startTime ?? this.startTime,
        endTime: endTime ?? this.endTime,
        position: position.present ? position.value : this.position,
        notes: notes.present ? notes.value : this.notes,
        isPublished: isPublished ?? this.isPublished,
        isAcknowledged: isAcknowledged ?? this.isAcknowledged,
        swapRequestedWith: swapRequestedWith.present
            ? swapRequestedWith.value
            : this.swapRequestedWith,
        isSwapPending: isSwapPending ?? this.isSwapPending,
        createdAt: createdAt ?? this.createdAt,
        updatedAt: updatedAt ?? this.updatedAt,
      );
  ScheduledShiftTableData copyWithCompanion(ScheduledShiftTableCompanion data) {
    return ScheduledShiftTableData(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      employeeUuid: data.employeeUuid.present
          ? data.employeeUuid.value
          : this.employeeUuid,
      date: data.date.present ? data.date.value : this.date,
      startTime: data.startTime.present ? data.startTime.value : this.startTime,
      endTime: data.endTime.present ? data.endTime.value : this.endTime,
      position: data.position.present ? data.position.value : this.position,
      notes: data.notes.present ? data.notes.value : this.notes,
      isPublished:
          data.isPublished.present ? data.isPublished.value : this.isPublished,
      isAcknowledged: data.isAcknowledged.present
          ? data.isAcknowledged.value
          : this.isAcknowledged,
      swapRequestedWith: data.swapRequestedWith.present
          ? data.swapRequestedWith.value
          : this.swapRequestedWith,
      isSwapPending: data.isSwapPending.present
          ? data.isSwapPending.value
          : this.isSwapPending,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ScheduledShiftTableData(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('employeeUuid: $employeeUuid, ')
          ..write('date: $date, ')
          ..write('startTime: $startTime, ')
          ..write('endTime: $endTime, ')
          ..write('position: $position, ')
          ..write('notes: $notes, ')
          ..write('isPublished: $isPublished, ')
          ..write('isAcknowledged: $isAcknowledged, ')
          ..write('swapRequestedWith: $swapRequestedWith, ')
          ..write('isSwapPending: $isSwapPending, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      uuid,
      employeeUuid,
      date,
      startTime,
      endTime,
      position,
      notes,
      isPublished,
      isAcknowledged,
      swapRequestedWith,
      isSwapPending,
      createdAt,
      updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ScheduledShiftTableData &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.employeeUuid == this.employeeUuid &&
          other.date == this.date &&
          other.startTime == this.startTime &&
          other.endTime == this.endTime &&
          other.position == this.position &&
          other.notes == this.notes &&
          other.isPublished == this.isPublished &&
          other.isAcknowledged == this.isAcknowledged &&
          other.swapRequestedWith == this.swapRequestedWith &&
          other.isSwapPending == this.isSwapPending &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class ScheduledShiftTableCompanion
    extends UpdateCompanion<ScheduledShiftTableData> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String> employeeUuid;
  final Value<DateTime> date;
  final Value<DateTime> startTime;
  final Value<DateTime> endTime;
  final Value<String?> position;
  final Value<String?> notes;
  final Value<bool> isPublished;
  final Value<bool> isAcknowledged;
  final Value<String?> swapRequestedWith;
  final Value<bool> isSwapPending;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  const ScheduledShiftTableCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.employeeUuid = const Value.absent(),
    this.date = const Value.absent(),
    this.startTime = const Value.absent(),
    this.endTime = const Value.absent(),
    this.position = const Value.absent(),
    this.notes = const Value.absent(),
    this.isPublished = const Value.absent(),
    this.isAcknowledged = const Value.absent(),
    this.swapRequestedWith = const Value.absent(),
    this.isSwapPending = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  ScheduledShiftTableCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    required String employeeUuid,
    required DateTime date,
    required DateTime startTime,
    required DateTime endTime,
    this.position = const Value.absent(),
    this.notes = const Value.absent(),
    this.isPublished = const Value.absent(),
    this.isAcknowledged = const Value.absent(),
    this.swapRequestedWith = const Value.absent(),
    this.isSwapPending = const Value.absent(),
    required DateTime createdAt,
    required DateTime updatedAt,
  })  : uuid = Value(uuid),
        employeeUuid = Value(employeeUuid),
        date = Value(date),
        startTime = Value(startTime),
        endTime = Value(endTime),
        createdAt = Value(createdAt),
        updatedAt = Value(updatedAt);
  static Insertable<ScheduledShiftTableData> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? employeeUuid,
    Expression<DateTime>? date,
    Expression<DateTime>? startTime,
    Expression<DateTime>? endTime,
    Expression<String>? position,
    Expression<String>? notes,
    Expression<bool>? isPublished,
    Expression<bool>? isAcknowledged,
    Expression<String>? swapRequestedWith,
    Expression<bool>? isSwapPending,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (employeeUuid != null) 'employee_uuid': employeeUuid,
      if (date != null) 'date': date,
      if (startTime != null) 'start_time': startTime,
      if (endTime != null) 'end_time': endTime,
      if (position != null) 'position': position,
      if (notes != null) 'notes': notes,
      if (isPublished != null) 'is_published': isPublished,
      if (isAcknowledged != null) 'is_acknowledged': isAcknowledged,
      if (swapRequestedWith != null) 'swap_requested_with': swapRequestedWith,
      if (isSwapPending != null) 'is_swap_pending': isSwapPending,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  ScheduledShiftTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String>? employeeUuid,
      Value<DateTime>? date,
      Value<DateTime>? startTime,
      Value<DateTime>? endTime,
      Value<String?>? position,
      Value<String?>? notes,
      Value<bool>? isPublished,
      Value<bool>? isAcknowledged,
      Value<String?>? swapRequestedWith,
      Value<bool>? isSwapPending,
      Value<DateTime>? createdAt,
      Value<DateTime>? updatedAt}) {
    return ScheduledShiftTableCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      employeeUuid: employeeUuid ?? this.employeeUuid,
      date: date ?? this.date,
      startTime: startTime ?? this.startTime,
      endTime: endTime ?? this.endTime,
      position: position ?? this.position,
      notes: notes ?? this.notes,
      isPublished: isPublished ?? this.isPublished,
      isAcknowledged: isAcknowledged ?? this.isAcknowledged,
      swapRequestedWith: swapRequestedWith ?? this.swapRequestedWith,
      isSwapPending: isSwapPending ?? this.isSwapPending,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (employeeUuid.present) {
      map['employee_uuid'] = Variable<String>(employeeUuid.value);
    }
    if (date.present) {
      map['date'] = Variable<DateTime>(date.value);
    }
    if (startTime.present) {
      map['start_time'] = Variable<DateTime>(startTime.value);
    }
    if (endTime.present) {
      map['end_time'] = Variable<DateTime>(endTime.value);
    }
    if (position.present) {
      map['position'] = Variable<String>(position.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (isPublished.present) {
      map['is_published'] = Variable<bool>(isPublished.value);
    }
    if (isAcknowledged.present) {
      map['is_acknowledged'] = Variable<bool>(isAcknowledged.value);
    }
    if (swapRequestedWith.present) {
      map['swap_requested_with'] = Variable<String>(swapRequestedWith.value);
    }
    if (isSwapPending.present) {
      map['is_swap_pending'] = Variable<bool>(isSwapPending.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ScheduledShiftTableCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('employeeUuid: $employeeUuid, ')
          ..write('date: $date, ')
          ..write('startTime: $startTime, ')
          ..write('endTime: $endTime, ')
          ..write('position: $position, ')
          ..write('notes: $notes, ')
          ..write('isPublished: $isPublished, ')
          ..write('isAcknowledged: $isAcknowledged, ')
          ..write('swapRequestedWith: $swapRequestedWith, ')
          ..write('isSwapPending: $isSwapPending, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class $EmployeeExtendedTableTable extends EmployeeExtendedTable
    with TableInfo<$EmployeeExtendedTableTable, EmployeeExtendedTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $EmployeeExtendedTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _employeeUuidMeta =
      const VerificationMeta('employeeUuid');
  @override
  late final GeneratedColumn<String> employeeUuid = GeneratedColumn<String>(
      'employee_uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _hourlyRateMeta =
      const VerificationMeta('hourlyRate');
  @override
  late final GeneratedColumn<double> hourlyRate = GeneratedColumn<double>(
      'hourly_rate', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: false,
      defaultValue: const Constant(0));
  static const VerificationMeta _salaryMeta = const VerificationMeta('salary');
  @override
  late final GeneratedColumn<double> salary = GeneratedColumn<double>(
      'salary', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: false,
      defaultValue: const Constant(0));
  static const VerificationMeta _payTypeMeta =
      const VerificationMeta('payType');
  @override
  late final GeneratedColumn<String> payType = GeneratedColumn<String>(
      'pay_type', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultValue: const Constant('hourly'));
  static const VerificationMeta _employmentStatusMeta =
      const VerificationMeta('employmentStatus');
  @override
  late final GeneratedColumn<String> employmentStatus = GeneratedColumn<String>(
      'employment_status', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultValue: const Constant('active'));
  static const VerificationMeta _phoneMeta = const VerificationMeta('phone');
  @override
  late final GeneratedColumn<String> phone = GeneratedColumn<String>(
      'phone', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _emailMeta = const VerificationMeta('email');
  @override
  late final GeneratedColumn<String> email = GeneratedColumn<String>(
      'email', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _avatarUrlMeta =
      const VerificationMeta('avatarUrl');
  @override
  late final GeneratedColumn<String> avatarUrl = GeneratedColumn<String>(
      'avatar_url', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _hireDateMeta =
      const VerificationMeta('hireDate');
  @override
  late final GeneratedColumn<DateTime> hireDate = GeneratedColumn<DateTime>(
      'hire_date', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _terminationDateMeta =
      const VerificationMeta('terminationDate');
  @override
  late final GeneratedColumn<DateTime> terminationDate =
      GeneratedColumn<DateTime>('termination_date', aliasedName, true,
          type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _permissionsJsonMeta =
      const VerificationMeta('permissionsJson');
  @override
  late final GeneratedColumn<String> permissionsJson = GeneratedColumn<String>(
      'permissions_json', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultValue: const Constant('[]'));
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        employeeUuid,
        hourlyRate,
        salary,
        payType,
        employmentStatus,
        phone,
        email,
        avatarUrl,
        hireDate,
        terminationDate,
        permissionsJson,
        updatedAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'employee_extended_table';
  @override
  VerificationContext validateIntegrity(
      Insertable<EmployeeExtendedTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('employee_uuid')) {
      context.handle(
          _employeeUuidMeta,
          employeeUuid.isAcceptableOrUnknown(
              data['employee_uuid']!, _employeeUuidMeta));
    } else if (isInserting) {
      context.missing(_employeeUuidMeta);
    }
    if (data.containsKey('hourly_rate')) {
      context.handle(
          _hourlyRateMeta,
          hourlyRate.isAcceptableOrUnknown(
              data['hourly_rate']!, _hourlyRateMeta));
    }
    if (data.containsKey('salary')) {
      context.handle(_salaryMeta,
          salary.isAcceptableOrUnknown(data['salary']!, _salaryMeta));
    }
    if (data.containsKey('pay_type')) {
      context.handle(_payTypeMeta,
          payType.isAcceptableOrUnknown(data['pay_type']!, _payTypeMeta));
    }
    if (data.containsKey('employment_status')) {
      context.handle(
          _employmentStatusMeta,
          employmentStatus.isAcceptableOrUnknown(
              data['employment_status']!, _employmentStatusMeta));
    }
    if (data.containsKey('phone')) {
      context.handle(
          _phoneMeta, phone.isAcceptableOrUnknown(data['phone']!, _phoneMeta));
    }
    if (data.containsKey('email')) {
      context.handle(
          _emailMeta, email.isAcceptableOrUnknown(data['email']!, _emailMeta));
    }
    if (data.containsKey('avatar_url')) {
      context.handle(_avatarUrlMeta,
          avatarUrl.isAcceptableOrUnknown(data['avatar_url']!, _avatarUrlMeta));
    }
    if (data.containsKey('hire_date')) {
      context.handle(_hireDateMeta,
          hireDate.isAcceptableOrUnknown(data['hire_date']!, _hireDateMeta));
    }
    if (data.containsKey('termination_date')) {
      context.handle(
          _terminationDateMeta,
          terminationDate.isAcceptableOrUnknown(
              data['termination_date']!, _terminationDateMeta));
    }
    if (data.containsKey('permissions_json')) {
      context.handle(
          _permissionsJsonMeta,
          permissionsJson.isAcceptableOrUnknown(
              data['permissions_json']!, _permissionsJsonMeta));
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  EmployeeExtendedTableData map(Map<String, dynamic> data,
      {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return EmployeeExtendedTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      employeeUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}employee_uuid'])!,
      hourlyRate: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}hourly_rate'])!,
      salary: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}salary'])!,
      payType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}pay_type'])!,
      employmentStatus: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}employment_status'])!,
      phone: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}phone']),
      email: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}email']),
      avatarUrl: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}avatar_url']),
      hireDate: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}hire_date']),
      terminationDate: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}termination_date']),
      permissionsJson: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}permissions_json'])!,
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $EmployeeExtendedTableTable createAlias(String alias) {
    return $EmployeeExtendedTableTable(attachedDatabase, alias);
  }
}

class EmployeeExtendedTableData extends DataClass
    implements Insertable<EmployeeExtendedTableData> {
  final int id;
  final String employeeUuid;
  final double hourlyRate;
  final double salary;
  final String payType;
  final String employmentStatus;
  final String? phone;
  final String? email;
  final String? avatarUrl;
  final DateTime? hireDate;
  final DateTime? terminationDate;
  final String permissionsJson;
  final DateTime updatedAt;
  const EmployeeExtendedTableData(
      {required this.id,
      required this.employeeUuid,
      required this.hourlyRate,
      required this.salary,
      required this.payType,
      required this.employmentStatus,
      this.phone,
      this.email,
      this.avatarUrl,
      this.hireDate,
      this.terminationDate,
      required this.permissionsJson,
      required this.updatedAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['employee_uuid'] = Variable<String>(employeeUuid);
    map['hourly_rate'] = Variable<double>(hourlyRate);
    map['salary'] = Variable<double>(salary);
    map['pay_type'] = Variable<String>(payType);
    map['employment_status'] = Variable<String>(employmentStatus);
    if (!nullToAbsent || phone != null) {
      map['phone'] = Variable<String>(phone);
    }
    if (!nullToAbsent || email != null) {
      map['email'] = Variable<String>(email);
    }
    if (!nullToAbsent || avatarUrl != null) {
      map['avatar_url'] = Variable<String>(avatarUrl);
    }
    if (!nullToAbsent || hireDate != null) {
      map['hire_date'] = Variable<DateTime>(hireDate);
    }
    if (!nullToAbsent || terminationDate != null) {
      map['termination_date'] = Variable<DateTime>(terminationDate);
    }
    map['permissions_json'] = Variable<String>(permissionsJson);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  EmployeeExtendedTableCompanion toCompanion(bool nullToAbsent) {
    return EmployeeExtendedTableCompanion(
      id: Value(id),
      employeeUuid: Value(employeeUuid),
      hourlyRate: Value(hourlyRate),
      salary: Value(salary),
      payType: Value(payType),
      employmentStatus: Value(employmentStatus),
      phone:
          phone == null && nullToAbsent ? const Value.absent() : Value(phone),
      email:
          email == null && nullToAbsent ? const Value.absent() : Value(email),
      avatarUrl: avatarUrl == null && nullToAbsent
          ? const Value.absent()
          : Value(avatarUrl),
      hireDate: hireDate == null && nullToAbsent
          ? const Value.absent()
          : Value(hireDate),
      terminationDate: terminationDate == null && nullToAbsent
          ? const Value.absent()
          : Value(terminationDate),
      permissionsJson: Value(permissionsJson),
      updatedAt: Value(updatedAt),
    );
  }

  factory EmployeeExtendedTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return EmployeeExtendedTableData(
      id: serializer.fromJson<int>(json['id']),
      employeeUuid: serializer.fromJson<String>(json['employeeUuid']),
      hourlyRate: serializer.fromJson<double>(json['hourlyRate']),
      salary: serializer.fromJson<double>(json['salary']),
      payType: serializer.fromJson<String>(json['payType']),
      employmentStatus: serializer.fromJson<String>(json['employmentStatus']),
      phone: serializer.fromJson<String?>(json['phone']),
      email: serializer.fromJson<String?>(json['email']),
      avatarUrl: serializer.fromJson<String?>(json['avatarUrl']),
      hireDate: serializer.fromJson<DateTime?>(json['hireDate']),
      terminationDate: serializer.fromJson<DateTime?>(json['terminationDate']),
      permissionsJson: serializer.fromJson<String>(json['permissionsJson']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'employeeUuid': serializer.toJson<String>(employeeUuid),
      'hourlyRate': serializer.toJson<double>(hourlyRate),
      'salary': serializer.toJson<double>(salary),
      'payType': serializer.toJson<String>(payType),
      'employmentStatus': serializer.toJson<String>(employmentStatus),
      'phone': serializer.toJson<String?>(phone),
      'email': serializer.toJson<String?>(email),
      'avatarUrl': serializer.toJson<String?>(avatarUrl),
      'hireDate': serializer.toJson<DateTime?>(hireDate),
      'terminationDate': serializer.toJson<DateTime?>(terminationDate),
      'permissionsJson': serializer.toJson<String>(permissionsJson),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  EmployeeExtendedTableData copyWith(
          {int? id,
          String? employeeUuid,
          double? hourlyRate,
          double? salary,
          String? payType,
          String? employmentStatus,
          Value<String?> phone = const Value.absent(),
          Value<String?> email = const Value.absent(),
          Value<String?> avatarUrl = const Value.absent(),
          Value<DateTime?> hireDate = const Value.absent(),
          Value<DateTime?> terminationDate = const Value.absent(),
          String? permissionsJson,
          DateTime? updatedAt}) =>
      EmployeeExtendedTableData(
        id: id ?? this.id,
        employeeUuid: employeeUuid ?? this.employeeUuid,
        hourlyRate: hourlyRate ?? this.hourlyRate,
        salary: salary ?? this.salary,
        payType: payType ?? this.payType,
        employmentStatus: employmentStatus ?? this.employmentStatus,
        phone: phone.present ? phone.value : this.phone,
        email: email.present ? email.value : this.email,
        avatarUrl: avatarUrl.present ? avatarUrl.value : this.avatarUrl,
        hireDate: hireDate.present ? hireDate.value : this.hireDate,
        terminationDate: terminationDate.present
            ? terminationDate.value
            : this.terminationDate,
        permissionsJson: permissionsJson ?? this.permissionsJson,
        updatedAt: updatedAt ?? this.updatedAt,
      );
  EmployeeExtendedTableData copyWithCompanion(
      EmployeeExtendedTableCompanion data) {
    return EmployeeExtendedTableData(
      id: data.id.present ? data.id.value : this.id,
      employeeUuid: data.employeeUuid.present
          ? data.employeeUuid.value
          : this.employeeUuid,
      hourlyRate:
          data.hourlyRate.present ? data.hourlyRate.value : this.hourlyRate,
      salary: data.salary.present ? data.salary.value : this.salary,
      payType: data.payType.present ? data.payType.value : this.payType,
      employmentStatus: data.employmentStatus.present
          ? data.employmentStatus.value
          : this.employmentStatus,
      phone: data.phone.present ? data.phone.value : this.phone,
      email: data.email.present ? data.email.value : this.email,
      avatarUrl: data.avatarUrl.present ? data.avatarUrl.value : this.avatarUrl,
      hireDate: data.hireDate.present ? data.hireDate.value : this.hireDate,
      terminationDate: data.terminationDate.present
          ? data.terminationDate.value
          : this.terminationDate,
      permissionsJson: data.permissionsJson.present
          ? data.permissionsJson.value
          : this.permissionsJson,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('EmployeeExtendedTableData(')
          ..write('id: $id, ')
          ..write('employeeUuid: $employeeUuid, ')
          ..write('hourlyRate: $hourlyRate, ')
          ..write('salary: $salary, ')
          ..write('payType: $payType, ')
          ..write('employmentStatus: $employmentStatus, ')
          ..write('phone: $phone, ')
          ..write('email: $email, ')
          ..write('avatarUrl: $avatarUrl, ')
          ..write('hireDate: $hireDate, ')
          ..write('terminationDate: $terminationDate, ')
          ..write('permissionsJson: $permissionsJson, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      employeeUuid,
      hourlyRate,
      salary,
      payType,
      employmentStatus,
      phone,
      email,
      avatarUrl,
      hireDate,
      terminationDate,
      permissionsJson,
      updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is EmployeeExtendedTableData &&
          other.id == this.id &&
          other.employeeUuid == this.employeeUuid &&
          other.hourlyRate == this.hourlyRate &&
          other.salary == this.salary &&
          other.payType == this.payType &&
          other.employmentStatus == this.employmentStatus &&
          other.phone == this.phone &&
          other.email == this.email &&
          other.avatarUrl == this.avatarUrl &&
          other.hireDate == this.hireDate &&
          other.terminationDate == this.terminationDate &&
          other.permissionsJson == this.permissionsJson &&
          other.updatedAt == this.updatedAt);
}

class EmployeeExtendedTableCompanion
    extends UpdateCompanion<EmployeeExtendedTableData> {
  final Value<int> id;
  final Value<String> employeeUuid;
  final Value<double> hourlyRate;
  final Value<double> salary;
  final Value<String> payType;
  final Value<String> employmentStatus;
  final Value<String?> phone;
  final Value<String?> email;
  final Value<String?> avatarUrl;
  final Value<DateTime?> hireDate;
  final Value<DateTime?> terminationDate;
  final Value<String> permissionsJson;
  final Value<DateTime> updatedAt;
  const EmployeeExtendedTableCompanion({
    this.id = const Value.absent(),
    this.employeeUuid = const Value.absent(),
    this.hourlyRate = const Value.absent(),
    this.salary = const Value.absent(),
    this.payType = const Value.absent(),
    this.employmentStatus = const Value.absent(),
    this.phone = const Value.absent(),
    this.email = const Value.absent(),
    this.avatarUrl = const Value.absent(),
    this.hireDate = const Value.absent(),
    this.terminationDate = const Value.absent(),
    this.permissionsJson = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  EmployeeExtendedTableCompanion.insert({
    this.id = const Value.absent(),
    required String employeeUuid,
    this.hourlyRate = const Value.absent(),
    this.salary = const Value.absent(),
    this.payType = const Value.absent(),
    this.employmentStatus = const Value.absent(),
    this.phone = const Value.absent(),
    this.email = const Value.absent(),
    this.avatarUrl = const Value.absent(),
    this.hireDate = const Value.absent(),
    this.terminationDate = const Value.absent(),
    this.permissionsJson = const Value.absent(),
    required DateTime updatedAt,
  })  : employeeUuid = Value(employeeUuid),
        updatedAt = Value(updatedAt);
  static Insertable<EmployeeExtendedTableData> custom({
    Expression<int>? id,
    Expression<String>? employeeUuid,
    Expression<double>? hourlyRate,
    Expression<double>? salary,
    Expression<String>? payType,
    Expression<String>? employmentStatus,
    Expression<String>? phone,
    Expression<String>? email,
    Expression<String>? avatarUrl,
    Expression<DateTime>? hireDate,
    Expression<DateTime>? terminationDate,
    Expression<String>? permissionsJson,
    Expression<DateTime>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (employeeUuid != null) 'employee_uuid': employeeUuid,
      if (hourlyRate != null) 'hourly_rate': hourlyRate,
      if (salary != null) 'salary': salary,
      if (payType != null) 'pay_type': payType,
      if (employmentStatus != null) 'employment_status': employmentStatus,
      if (phone != null) 'phone': phone,
      if (email != null) 'email': email,
      if (avatarUrl != null) 'avatar_url': avatarUrl,
      if (hireDate != null) 'hire_date': hireDate,
      if (terminationDate != null) 'termination_date': terminationDate,
      if (permissionsJson != null) 'permissions_json': permissionsJson,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  EmployeeExtendedTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? employeeUuid,
      Value<double>? hourlyRate,
      Value<double>? salary,
      Value<String>? payType,
      Value<String>? employmentStatus,
      Value<String?>? phone,
      Value<String?>? email,
      Value<String?>? avatarUrl,
      Value<DateTime?>? hireDate,
      Value<DateTime?>? terminationDate,
      Value<String>? permissionsJson,
      Value<DateTime>? updatedAt}) {
    return EmployeeExtendedTableCompanion(
      id: id ?? this.id,
      employeeUuid: employeeUuid ?? this.employeeUuid,
      hourlyRate: hourlyRate ?? this.hourlyRate,
      salary: salary ?? this.salary,
      payType: payType ?? this.payType,
      employmentStatus: employmentStatus ?? this.employmentStatus,
      phone: phone ?? this.phone,
      email: email ?? this.email,
      avatarUrl: avatarUrl ?? this.avatarUrl,
      hireDate: hireDate ?? this.hireDate,
      terminationDate: terminationDate ?? this.terminationDate,
      permissionsJson: permissionsJson ?? this.permissionsJson,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (employeeUuid.present) {
      map['employee_uuid'] = Variable<String>(employeeUuid.value);
    }
    if (hourlyRate.present) {
      map['hourly_rate'] = Variable<double>(hourlyRate.value);
    }
    if (salary.present) {
      map['salary'] = Variable<double>(salary.value);
    }
    if (payType.present) {
      map['pay_type'] = Variable<String>(payType.value);
    }
    if (employmentStatus.present) {
      map['employment_status'] = Variable<String>(employmentStatus.value);
    }
    if (phone.present) {
      map['phone'] = Variable<String>(phone.value);
    }
    if (email.present) {
      map['email'] = Variable<String>(email.value);
    }
    if (avatarUrl.present) {
      map['avatar_url'] = Variable<String>(avatarUrl.value);
    }
    if (hireDate.present) {
      map['hire_date'] = Variable<DateTime>(hireDate.value);
    }
    if (terminationDate.present) {
      map['termination_date'] = Variable<DateTime>(terminationDate.value);
    }
    if (permissionsJson.present) {
      map['permissions_json'] = Variable<String>(permissionsJson.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('EmployeeExtendedTableCompanion(')
          ..write('id: $id, ')
          ..write('employeeUuid: $employeeUuid, ')
          ..write('hourlyRate: $hourlyRate, ')
          ..write('salary: $salary, ')
          ..write('payType: $payType, ')
          ..write('employmentStatus: $employmentStatus, ')
          ..write('phone: $phone, ')
          ..write('email: $email, ')
          ..write('avatarUrl: $avatarUrl, ')
          ..write('hireDate: $hireDate, ')
          ..write('terminationDate: $terminationDate, ')
          ..write('permissionsJson: $permissionsJson, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class $GiftCardTableTable extends GiftCardTable
    with TableInfo<$GiftCardTableTable, GiftCardTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $GiftCardTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _cardNumberMeta =
      const VerificationMeta('cardNumber');
  @override
  late final GeneratedColumn<String> cardNumber = GeneratedColumn<String>(
      'card_number', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _barcodeMeta =
      const VerificationMeta('barcode');
  @override
  late final GeneratedColumn<String> barcode = GeneratedColumn<String>(
      'barcode', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _initialValueMeta =
      const VerificationMeta('initialValue');
  @override
  late final GeneratedColumn<double> initialValue = GeneratedColumn<double>(
      'initial_value', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _currentBalanceMeta =
      const VerificationMeta('currentBalance');
  @override
  late final GeneratedColumn<double> currentBalance = GeneratedColumn<double>(
      'current_balance', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: false,
      defaultValue: const Constant(0));
  static const VerificationMeta _customerUuidMeta =
      const VerificationMeta('customerUuid');
  @override
  late final GeneratedColumn<String> customerUuid = GeneratedColumn<String>(
      'customer_uuid', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _customerNameMeta =
      const VerificationMeta('customerName');
  @override
  late final GeneratedColumn<String> customerName = GeneratedColumn<String>(
      'customer_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _customerEmailMeta =
      const VerificationMeta('customerEmail');
  @override
  late final GeneratedColumn<String> customerEmail = GeneratedColumn<String>(
      'customer_email', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _customerPhoneMeta =
      const VerificationMeta('customerPhone');
  @override
  late final GeneratedColumn<String> customerPhone = GeneratedColumn<String>(
      'customer_phone', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
      'status', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultValue: const Constant('active'));
  static const VerificationMeta _activatedAtMeta =
      const VerificationMeta('activatedAt');
  @override
  late final GeneratedColumn<DateTime> activatedAt = GeneratedColumn<DateTime>(
      'activated_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _expiresAtMeta =
      const VerificationMeta('expiresAt');
  @override
  late final GeneratedColumn<DateTime> expiresAt = GeneratedColumn<DateTime>(
      'expires_at', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _lastUsedAtMeta =
      const VerificationMeta('lastUsedAt');
  @override
  late final GeneratedColumn<DateTime> lastUsedAt = GeneratedColumn<DateTime>(
      'last_used_at', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _pinMeta = const VerificationMeta('pin');
  @override
  late final GeneratedColumn<String> pin = GeneratedColumn<String>(
      'pin', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _activatedByEmployeeUuidMeta =
      const VerificationMeta('activatedByEmployeeUuid');
  @override
  late final GeneratedColumn<String> activatedByEmployeeUuid =
      GeneratedColumn<String>('activated_by_employee_uuid', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _activatedByEmployeeNameMeta =
      const VerificationMeta('activatedByEmployeeName');
  @override
  late final GeneratedColumn<String> activatedByEmployeeName =
      GeneratedColumn<String>('activated_by_employee_name', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
      'notes', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        cardNumber,
        barcode,
        initialValue,
        currentBalance,
        customerUuid,
        customerName,
        customerEmail,
        customerPhone,
        status,
        activatedAt,
        expiresAt,
        lastUsedAt,
        pin,
        activatedByEmployeeUuid,
        activatedByEmployeeName,
        notes,
        createdAt,
        updatedAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'gift_card_table';
  @override
  VerificationContext validateIntegrity(Insertable<GiftCardTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('card_number')) {
      context.handle(
          _cardNumberMeta,
          cardNumber.isAcceptableOrUnknown(
              data['card_number']!, _cardNumberMeta));
    } else if (isInserting) {
      context.missing(_cardNumberMeta);
    }
    if (data.containsKey('barcode')) {
      context.handle(_barcodeMeta,
          barcode.isAcceptableOrUnknown(data['barcode']!, _barcodeMeta));
    }
    if (data.containsKey('initial_value')) {
      context.handle(
          _initialValueMeta,
          initialValue.isAcceptableOrUnknown(
              data['initial_value']!, _initialValueMeta));
    } else if (isInserting) {
      context.missing(_initialValueMeta);
    }
    if (data.containsKey('current_balance')) {
      context.handle(
          _currentBalanceMeta,
          currentBalance.isAcceptableOrUnknown(
              data['current_balance']!, _currentBalanceMeta));
    }
    if (data.containsKey('customer_uuid')) {
      context.handle(
          _customerUuidMeta,
          customerUuid.isAcceptableOrUnknown(
              data['customer_uuid']!, _customerUuidMeta));
    }
    if (data.containsKey('customer_name')) {
      context.handle(
          _customerNameMeta,
          customerName.isAcceptableOrUnknown(
              data['customer_name']!, _customerNameMeta));
    }
    if (data.containsKey('customer_email')) {
      context.handle(
          _customerEmailMeta,
          customerEmail.isAcceptableOrUnknown(
              data['customer_email']!, _customerEmailMeta));
    }
    if (data.containsKey('customer_phone')) {
      context.handle(
          _customerPhoneMeta,
          customerPhone.isAcceptableOrUnknown(
              data['customer_phone']!, _customerPhoneMeta));
    }
    if (data.containsKey('status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['status']!, _statusMeta));
    }
    if (data.containsKey('activated_at')) {
      context.handle(
          _activatedAtMeta,
          activatedAt.isAcceptableOrUnknown(
              data['activated_at']!, _activatedAtMeta));
    } else if (isInserting) {
      context.missing(_activatedAtMeta);
    }
    if (data.containsKey('expires_at')) {
      context.handle(_expiresAtMeta,
          expiresAt.isAcceptableOrUnknown(data['expires_at']!, _expiresAtMeta));
    }
    if (data.containsKey('last_used_at')) {
      context.handle(
          _lastUsedAtMeta,
          lastUsedAt.isAcceptableOrUnknown(
              data['last_used_at']!, _lastUsedAtMeta));
    }
    if (data.containsKey('pin')) {
      context.handle(
          _pinMeta, pin.isAcceptableOrUnknown(data['pin']!, _pinMeta));
    }
    if (data.containsKey('activated_by_employee_uuid')) {
      context.handle(
          _activatedByEmployeeUuidMeta,
          activatedByEmployeeUuid.isAcceptableOrUnknown(
              data['activated_by_employee_uuid']!,
              _activatedByEmployeeUuidMeta));
    }
    if (data.containsKey('activated_by_employee_name')) {
      context.handle(
          _activatedByEmployeeNameMeta,
          activatedByEmployeeName.isAcceptableOrUnknown(
              data['activated_by_employee_name']!,
              _activatedByEmployeeNameMeta));
    }
    if (data.containsKey('notes')) {
      context.handle(
          _notesMeta, notes.isAcceptableOrUnknown(data['notes']!, _notesMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  GiftCardTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return GiftCardTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      cardNumber: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}card_number'])!,
      barcode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}barcode']),
      initialValue: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}initial_value'])!,
      currentBalance: attachedDatabase.typeMapping.read(
          DriftSqlType.double, data['${effectivePrefix}current_balance'])!,
      customerUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}customer_uuid']),
      customerName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}customer_name']),
      customerEmail: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}customer_email']),
      customerPhone: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}customer_phone']),
      status: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}status'])!,
      activatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}activated_at'])!,
      expiresAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}expires_at']),
      lastUsedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}last_used_at']),
      pin: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}pin']),
      activatedByEmployeeUuid: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}activated_by_employee_uuid']),
      activatedByEmployeeName: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}activated_by_employee_name']),
      notes: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}notes']),
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $GiftCardTableTable createAlias(String alias) {
    return $GiftCardTableTable(attachedDatabase, alias);
  }
}

class GiftCardTableData extends DataClass
    implements Insertable<GiftCardTableData> {
  final int id;
  final String uuid;
  final String cardNumber;
  final String? barcode;
  final double initialValue;
  final double currentBalance;
  final String? customerUuid;
  final String? customerName;
  final String? customerEmail;
  final String? customerPhone;
  final String status;
  final DateTime activatedAt;
  final DateTime? expiresAt;
  final DateTime? lastUsedAt;
  final String? pin;
  final String? activatedByEmployeeUuid;
  final String? activatedByEmployeeName;
  final String? notes;
  final DateTime createdAt;
  final DateTime updatedAt;
  const GiftCardTableData(
      {required this.id,
      required this.uuid,
      required this.cardNumber,
      this.barcode,
      required this.initialValue,
      required this.currentBalance,
      this.customerUuid,
      this.customerName,
      this.customerEmail,
      this.customerPhone,
      required this.status,
      required this.activatedAt,
      this.expiresAt,
      this.lastUsedAt,
      this.pin,
      this.activatedByEmployeeUuid,
      this.activatedByEmployeeName,
      this.notes,
      required this.createdAt,
      required this.updatedAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    map['card_number'] = Variable<String>(cardNumber);
    if (!nullToAbsent || barcode != null) {
      map['barcode'] = Variable<String>(barcode);
    }
    map['initial_value'] = Variable<double>(initialValue);
    map['current_balance'] = Variable<double>(currentBalance);
    if (!nullToAbsent || customerUuid != null) {
      map['customer_uuid'] = Variable<String>(customerUuid);
    }
    if (!nullToAbsent || customerName != null) {
      map['customer_name'] = Variable<String>(customerName);
    }
    if (!nullToAbsent || customerEmail != null) {
      map['customer_email'] = Variable<String>(customerEmail);
    }
    if (!nullToAbsent || customerPhone != null) {
      map['customer_phone'] = Variable<String>(customerPhone);
    }
    map['status'] = Variable<String>(status);
    map['activated_at'] = Variable<DateTime>(activatedAt);
    if (!nullToAbsent || expiresAt != null) {
      map['expires_at'] = Variable<DateTime>(expiresAt);
    }
    if (!nullToAbsent || lastUsedAt != null) {
      map['last_used_at'] = Variable<DateTime>(lastUsedAt);
    }
    if (!nullToAbsent || pin != null) {
      map['pin'] = Variable<String>(pin);
    }
    if (!nullToAbsent || activatedByEmployeeUuid != null) {
      map['activated_by_employee_uuid'] =
          Variable<String>(activatedByEmployeeUuid);
    }
    if (!nullToAbsent || activatedByEmployeeName != null) {
      map['activated_by_employee_name'] =
          Variable<String>(activatedByEmployeeName);
    }
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  GiftCardTableCompanion toCompanion(bool nullToAbsent) {
    return GiftCardTableCompanion(
      id: Value(id),
      uuid: Value(uuid),
      cardNumber: Value(cardNumber),
      barcode: barcode == null && nullToAbsent
          ? const Value.absent()
          : Value(barcode),
      initialValue: Value(initialValue),
      currentBalance: Value(currentBalance),
      customerUuid: customerUuid == null && nullToAbsent
          ? const Value.absent()
          : Value(customerUuid),
      customerName: customerName == null && nullToAbsent
          ? const Value.absent()
          : Value(customerName),
      customerEmail: customerEmail == null && nullToAbsent
          ? const Value.absent()
          : Value(customerEmail),
      customerPhone: customerPhone == null && nullToAbsent
          ? const Value.absent()
          : Value(customerPhone),
      status: Value(status),
      activatedAt: Value(activatedAt),
      expiresAt: expiresAt == null && nullToAbsent
          ? const Value.absent()
          : Value(expiresAt),
      lastUsedAt: lastUsedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(lastUsedAt),
      pin: pin == null && nullToAbsent ? const Value.absent() : Value(pin),
      activatedByEmployeeUuid: activatedByEmployeeUuid == null && nullToAbsent
          ? const Value.absent()
          : Value(activatedByEmployeeUuid),
      activatedByEmployeeName: activatedByEmployeeName == null && nullToAbsent
          ? const Value.absent()
          : Value(activatedByEmployeeName),
      notes:
          notes == null && nullToAbsent ? const Value.absent() : Value(notes),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory GiftCardTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return GiftCardTableData(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      cardNumber: serializer.fromJson<String>(json['cardNumber']),
      barcode: serializer.fromJson<String?>(json['barcode']),
      initialValue: serializer.fromJson<double>(json['initialValue']),
      currentBalance: serializer.fromJson<double>(json['currentBalance']),
      customerUuid: serializer.fromJson<String?>(json['customerUuid']),
      customerName: serializer.fromJson<String?>(json['customerName']),
      customerEmail: serializer.fromJson<String?>(json['customerEmail']),
      customerPhone: serializer.fromJson<String?>(json['customerPhone']),
      status: serializer.fromJson<String>(json['status']),
      activatedAt: serializer.fromJson<DateTime>(json['activatedAt']),
      expiresAt: serializer.fromJson<DateTime?>(json['expiresAt']),
      lastUsedAt: serializer.fromJson<DateTime?>(json['lastUsedAt']),
      pin: serializer.fromJson<String?>(json['pin']),
      activatedByEmployeeUuid:
          serializer.fromJson<String?>(json['activatedByEmployeeUuid']),
      activatedByEmployeeName:
          serializer.fromJson<String?>(json['activatedByEmployeeName']),
      notes: serializer.fromJson<String?>(json['notes']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'cardNumber': serializer.toJson<String>(cardNumber),
      'barcode': serializer.toJson<String?>(barcode),
      'initialValue': serializer.toJson<double>(initialValue),
      'currentBalance': serializer.toJson<double>(currentBalance),
      'customerUuid': serializer.toJson<String?>(customerUuid),
      'customerName': serializer.toJson<String?>(customerName),
      'customerEmail': serializer.toJson<String?>(customerEmail),
      'customerPhone': serializer.toJson<String?>(customerPhone),
      'status': serializer.toJson<String>(status),
      'activatedAt': serializer.toJson<DateTime>(activatedAt),
      'expiresAt': serializer.toJson<DateTime?>(expiresAt),
      'lastUsedAt': serializer.toJson<DateTime?>(lastUsedAt),
      'pin': serializer.toJson<String?>(pin),
      'activatedByEmployeeUuid':
          serializer.toJson<String?>(activatedByEmployeeUuid),
      'activatedByEmployeeName':
          serializer.toJson<String?>(activatedByEmployeeName),
      'notes': serializer.toJson<String?>(notes),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  GiftCardTableData copyWith(
          {int? id,
          String? uuid,
          String? cardNumber,
          Value<String?> barcode = const Value.absent(),
          double? initialValue,
          double? currentBalance,
          Value<String?> customerUuid = const Value.absent(),
          Value<String?> customerName = const Value.absent(),
          Value<String?> customerEmail = const Value.absent(),
          Value<String?> customerPhone = const Value.absent(),
          String? status,
          DateTime? activatedAt,
          Value<DateTime?> expiresAt = const Value.absent(),
          Value<DateTime?> lastUsedAt = const Value.absent(),
          Value<String?> pin = const Value.absent(),
          Value<String?> activatedByEmployeeUuid = const Value.absent(),
          Value<String?> activatedByEmployeeName = const Value.absent(),
          Value<String?> notes = const Value.absent(),
          DateTime? createdAt,
          DateTime? updatedAt}) =>
      GiftCardTableData(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        cardNumber: cardNumber ?? this.cardNumber,
        barcode: barcode.present ? barcode.value : this.barcode,
        initialValue: initialValue ?? this.initialValue,
        currentBalance: currentBalance ?? this.currentBalance,
        customerUuid:
            customerUuid.present ? customerUuid.value : this.customerUuid,
        customerName:
            customerName.present ? customerName.value : this.customerName,
        customerEmail:
            customerEmail.present ? customerEmail.value : this.customerEmail,
        customerPhone:
            customerPhone.present ? customerPhone.value : this.customerPhone,
        status: status ?? this.status,
        activatedAt: activatedAt ?? this.activatedAt,
        expiresAt: expiresAt.present ? expiresAt.value : this.expiresAt,
        lastUsedAt: lastUsedAt.present ? lastUsedAt.value : this.lastUsedAt,
        pin: pin.present ? pin.value : this.pin,
        activatedByEmployeeUuid: activatedByEmployeeUuid.present
            ? activatedByEmployeeUuid.value
            : this.activatedByEmployeeUuid,
        activatedByEmployeeName: activatedByEmployeeName.present
            ? activatedByEmployeeName.value
            : this.activatedByEmployeeName,
        notes: notes.present ? notes.value : this.notes,
        createdAt: createdAt ?? this.createdAt,
        updatedAt: updatedAt ?? this.updatedAt,
      );
  GiftCardTableData copyWithCompanion(GiftCardTableCompanion data) {
    return GiftCardTableData(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      cardNumber:
          data.cardNumber.present ? data.cardNumber.value : this.cardNumber,
      barcode: data.barcode.present ? data.barcode.value : this.barcode,
      initialValue: data.initialValue.present
          ? data.initialValue.value
          : this.initialValue,
      currentBalance: data.currentBalance.present
          ? data.currentBalance.value
          : this.currentBalance,
      customerUuid: data.customerUuid.present
          ? data.customerUuid.value
          : this.customerUuid,
      customerName: data.customerName.present
          ? data.customerName.value
          : this.customerName,
      customerEmail: data.customerEmail.present
          ? data.customerEmail.value
          : this.customerEmail,
      customerPhone: data.customerPhone.present
          ? data.customerPhone.value
          : this.customerPhone,
      status: data.status.present ? data.status.value : this.status,
      activatedAt:
          data.activatedAt.present ? data.activatedAt.value : this.activatedAt,
      expiresAt: data.expiresAt.present ? data.expiresAt.value : this.expiresAt,
      lastUsedAt:
          data.lastUsedAt.present ? data.lastUsedAt.value : this.lastUsedAt,
      pin: data.pin.present ? data.pin.value : this.pin,
      activatedByEmployeeUuid: data.activatedByEmployeeUuid.present
          ? data.activatedByEmployeeUuid.value
          : this.activatedByEmployeeUuid,
      activatedByEmployeeName: data.activatedByEmployeeName.present
          ? data.activatedByEmployeeName.value
          : this.activatedByEmployeeName,
      notes: data.notes.present ? data.notes.value : this.notes,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('GiftCardTableData(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('cardNumber: $cardNumber, ')
          ..write('barcode: $barcode, ')
          ..write('initialValue: $initialValue, ')
          ..write('currentBalance: $currentBalance, ')
          ..write('customerUuid: $customerUuid, ')
          ..write('customerName: $customerName, ')
          ..write('customerEmail: $customerEmail, ')
          ..write('customerPhone: $customerPhone, ')
          ..write('status: $status, ')
          ..write('activatedAt: $activatedAt, ')
          ..write('expiresAt: $expiresAt, ')
          ..write('lastUsedAt: $lastUsedAt, ')
          ..write('pin: $pin, ')
          ..write('activatedByEmployeeUuid: $activatedByEmployeeUuid, ')
          ..write('activatedByEmployeeName: $activatedByEmployeeName, ')
          ..write('notes: $notes, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      uuid,
      cardNumber,
      barcode,
      initialValue,
      currentBalance,
      customerUuid,
      customerName,
      customerEmail,
      customerPhone,
      status,
      activatedAt,
      expiresAt,
      lastUsedAt,
      pin,
      activatedByEmployeeUuid,
      activatedByEmployeeName,
      notes,
      createdAt,
      updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is GiftCardTableData &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.cardNumber == this.cardNumber &&
          other.barcode == this.barcode &&
          other.initialValue == this.initialValue &&
          other.currentBalance == this.currentBalance &&
          other.customerUuid == this.customerUuid &&
          other.customerName == this.customerName &&
          other.customerEmail == this.customerEmail &&
          other.customerPhone == this.customerPhone &&
          other.status == this.status &&
          other.activatedAt == this.activatedAt &&
          other.expiresAt == this.expiresAt &&
          other.lastUsedAt == this.lastUsedAt &&
          other.pin == this.pin &&
          other.activatedByEmployeeUuid == this.activatedByEmployeeUuid &&
          other.activatedByEmployeeName == this.activatedByEmployeeName &&
          other.notes == this.notes &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class GiftCardTableCompanion extends UpdateCompanion<GiftCardTableData> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String> cardNumber;
  final Value<String?> barcode;
  final Value<double> initialValue;
  final Value<double> currentBalance;
  final Value<String?> customerUuid;
  final Value<String?> customerName;
  final Value<String?> customerEmail;
  final Value<String?> customerPhone;
  final Value<String> status;
  final Value<DateTime> activatedAt;
  final Value<DateTime?> expiresAt;
  final Value<DateTime?> lastUsedAt;
  final Value<String?> pin;
  final Value<String?> activatedByEmployeeUuid;
  final Value<String?> activatedByEmployeeName;
  final Value<String?> notes;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  const GiftCardTableCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.cardNumber = const Value.absent(),
    this.barcode = const Value.absent(),
    this.initialValue = const Value.absent(),
    this.currentBalance = const Value.absent(),
    this.customerUuid = const Value.absent(),
    this.customerName = const Value.absent(),
    this.customerEmail = const Value.absent(),
    this.customerPhone = const Value.absent(),
    this.status = const Value.absent(),
    this.activatedAt = const Value.absent(),
    this.expiresAt = const Value.absent(),
    this.lastUsedAt = const Value.absent(),
    this.pin = const Value.absent(),
    this.activatedByEmployeeUuid = const Value.absent(),
    this.activatedByEmployeeName = const Value.absent(),
    this.notes = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  GiftCardTableCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    required String cardNumber,
    this.barcode = const Value.absent(),
    required double initialValue,
    this.currentBalance = const Value.absent(),
    this.customerUuid = const Value.absent(),
    this.customerName = const Value.absent(),
    this.customerEmail = const Value.absent(),
    this.customerPhone = const Value.absent(),
    this.status = const Value.absent(),
    required DateTime activatedAt,
    this.expiresAt = const Value.absent(),
    this.lastUsedAt = const Value.absent(),
    this.pin = const Value.absent(),
    this.activatedByEmployeeUuid = const Value.absent(),
    this.activatedByEmployeeName = const Value.absent(),
    this.notes = const Value.absent(),
    required DateTime createdAt,
    required DateTime updatedAt,
  })  : uuid = Value(uuid),
        cardNumber = Value(cardNumber),
        initialValue = Value(initialValue),
        activatedAt = Value(activatedAt),
        createdAt = Value(createdAt),
        updatedAt = Value(updatedAt);
  static Insertable<GiftCardTableData> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? cardNumber,
    Expression<String>? barcode,
    Expression<double>? initialValue,
    Expression<double>? currentBalance,
    Expression<String>? customerUuid,
    Expression<String>? customerName,
    Expression<String>? customerEmail,
    Expression<String>? customerPhone,
    Expression<String>? status,
    Expression<DateTime>? activatedAt,
    Expression<DateTime>? expiresAt,
    Expression<DateTime>? lastUsedAt,
    Expression<String>? pin,
    Expression<String>? activatedByEmployeeUuid,
    Expression<String>? activatedByEmployeeName,
    Expression<String>? notes,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (cardNumber != null) 'card_number': cardNumber,
      if (barcode != null) 'barcode': barcode,
      if (initialValue != null) 'initial_value': initialValue,
      if (currentBalance != null) 'current_balance': currentBalance,
      if (customerUuid != null) 'customer_uuid': customerUuid,
      if (customerName != null) 'customer_name': customerName,
      if (customerEmail != null) 'customer_email': customerEmail,
      if (customerPhone != null) 'customer_phone': customerPhone,
      if (status != null) 'status': status,
      if (activatedAt != null) 'activated_at': activatedAt,
      if (expiresAt != null) 'expires_at': expiresAt,
      if (lastUsedAt != null) 'last_used_at': lastUsedAt,
      if (pin != null) 'pin': pin,
      if (activatedByEmployeeUuid != null)
        'activated_by_employee_uuid': activatedByEmployeeUuid,
      if (activatedByEmployeeName != null)
        'activated_by_employee_name': activatedByEmployeeName,
      if (notes != null) 'notes': notes,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  GiftCardTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String>? cardNumber,
      Value<String?>? barcode,
      Value<double>? initialValue,
      Value<double>? currentBalance,
      Value<String?>? customerUuid,
      Value<String?>? customerName,
      Value<String?>? customerEmail,
      Value<String?>? customerPhone,
      Value<String>? status,
      Value<DateTime>? activatedAt,
      Value<DateTime?>? expiresAt,
      Value<DateTime?>? lastUsedAt,
      Value<String?>? pin,
      Value<String?>? activatedByEmployeeUuid,
      Value<String?>? activatedByEmployeeName,
      Value<String?>? notes,
      Value<DateTime>? createdAt,
      Value<DateTime>? updatedAt}) {
    return GiftCardTableCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      cardNumber: cardNumber ?? this.cardNumber,
      barcode: barcode ?? this.barcode,
      initialValue: initialValue ?? this.initialValue,
      currentBalance: currentBalance ?? this.currentBalance,
      customerUuid: customerUuid ?? this.customerUuid,
      customerName: customerName ?? this.customerName,
      customerEmail: customerEmail ?? this.customerEmail,
      customerPhone: customerPhone ?? this.customerPhone,
      status: status ?? this.status,
      activatedAt: activatedAt ?? this.activatedAt,
      expiresAt: expiresAt ?? this.expiresAt,
      lastUsedAt: lastUsedAt ?? this.lastUsedAt,
      pin: pin ?? this.pin,
      activatedByEmployeeUuid:
          activatedByEmployeeUuid ?? this.activatedByEmployeeUuid,
      activatedByEmployeeName:
          activatedByEmployeeName ?? this.activatedByEmployeeName,
      notes: notes ?? this.notes,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (cardNumber.present) {
      map['card_number'] = Variable<String>(cardNumber.value);
    }
    if (barcode.present) {
      map['barcode'] = Variable<String>(barcode.value);
    }
    if (initialValue.present) {
      map['initial_value'] = Variable<double>(initialValue.value);
    }
    if (currentBalance.present) {
      map['current_balance'] = Variable<double>(currentBalance.value);
    }
    if (customerUuid.present) {
      map['customer_uuid'] = Variable<String>(customerUuid.value);
    }
    if (customerName.present) {
      map['customer_name'] = Variable<String>(customerName.value);
    }
    if (customerEmail.present) {
      map['customer_email'] = Variable<String>(customerEmail.value);
    }
    if (customerPhone.present) {
      map['customer_phone'] = Variable<String>(customerPhone.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (activatedAt.present) {
      map['activated_at'] = Variable<DateTime>(activatedAt.value);
    }
    if (expiresAt.present) {
      map['expires_at'] = Variable<DateTime>(expiresAt.value);
    }
    if (lastUsedAt.present) {
      map['last_used_at'] = Variable<DateTime>(lastUsedAt.value);
    }
    if (pin.present) {
      map['pin'] = Variable<String>(pin.value);
    }
    if (activatedByEmployeeUuid.present) {
      map['activated_by_employee_uuid'] =
          Variable<String>(activatedByEmployeeUuid.value);
    }
    if (activatedByEmployeeName.present) {
      map['activated_by_employee_name'] =
          Variable<String>(activatedByEmployeeName.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('GiftCardTableCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('cardNumber: $cardNumber, ')
          ..write('barcode: $barcode, ')
          ..write('initialValue: $initialValue, ')
          ..write('currentBalance: $currentBalance, ')
          ..write('customerUuid: $customerUuid, ')
          ..write('customerName: $customerName, ')
          ..write('customerEmail: $customerEmail, ')
          ..write('customerPhone: $customerPhone, ')
          ..write('status: $status, ')
          ..write('activatedAt: $activatedAt, ')
          ..write('expiresAt: $expiresAt, ')
          ..write('lastUsedAt: $lastUsedAt, ')
          ..write('pin: $pin, ')
          ..write('activatedByEmployeeUuid: $activatedByEmployeeUuid, ')
          ..write('activatedByEmployeeName: $activatedByEmployeeName, ')
          ..write('notes: $notes, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class $GiftCardTransactionTableTable extends GiftCardTransactionTable
    with
        TableInfo<$GiftCardTransactionTableTable,
            GiftCardTransactionTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $GiftCardTransactionTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _giftCardUuidMeta =
      const VerificationMeta('giftCardUuid');
  @override
  late final GeneratedColumn<String> giftCardUuid = GeneratedColumn<String>(
      'gift_card_uuid', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _transactionTypeMeta =
      const VerificationMeta('transactionType');
  @override
  late final GeneratedColumn<String> transactionType = GeneratedColumn<String>(
      'transaction_type', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _amountMeta = const VerificationMeta('amount');
  @override
  late final GeneratedColumn<double> amount = GeneratedColumn<double>(
      'amount', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _balanceAfterMeta =
      const VerificationMeta('balanceAfter');
  @override
  late final GeneratedColumn<double> balanceAfter = GeneratedColumn<double>(
      'balance_after', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _orderUuidMeta =
      const VerificationMeta('orderUuid');
  @override
  late final GeneratedColumn<String> orderUuid = GeneratedColumn<String>(
      'order_uuid', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _orderNumberMeta =
      const VerificationMeta('orderNumber');
  @override
  late final GeneratedColumn<String> orderNumber = GeneratedColumn<String>(
      'order_number', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _performedByUuidMeta =
      const VerificationMeta('performedByUuid');
  @override
  late final GeneratedColumn<String> performedByUuid = GeneratedColumn<String>(
      'performed_by_uuid', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _performedByNameMeta =
      const VerificationMeta('performedByName');
  @override
  late final GeneratedColumn<String> performedByName = GeneratedColumn<String>(
      'performed_by_name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
      'notes', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _timestampMeta =
      const VerificationMeta('timestamp');
  @override
  late final GeneratedColumn<DateTime> timestamp = GeneratedColumn<DateTime>(
      'timestamp', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        giftCardUuid,
        transactionType,
        amount,
        balanceAfter,
        orderUuid,
        orderNumber,
        performedByUuid,
        performedByName,
        notes,
        timestamp
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'gift_card_transaction_table';
  @override
  VerificationContext validateIntegrity(
      Insertable<GiftCardTransactionTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('gift_card_uuid')) {
      context.handle(
          _giftCardUuidMeta,
          giftCardUuid.isAcceptableOrUnknown(
              data['gift_card_uuid']!, _giftCardUuidMeta));
    } else if (isInserting) {
      context.missing(_giftCardUuidMeta);
    }
    if (data.containsKey('transaction_type')) {
      context.handle(
          _transactionTypeMeta,
          transactionType.isAcceptableOrUnknown(
              data['transaction_type']!, _transactionTypeMeta));
    } else if (isInserting) {
      context.missing(_transactionTypeMeta);
    }
    if (data.containsKey('amount')) {
      context.handle(_amountMeta,
          amount.isAcceptableOrUnknown(data['amount']!, _amountMeta));
    } else if (isInserting) {
      context.missing(_amountMeta);
    }
    if (data.containsKey('balance_after')) {
      context.handle(
          _balanceAfterMeta,
          balanceAfter.isAcceptableOrUnknown(
              data['balance_after']!, _balanceAfterMeta));
    } else if (isInserting) {
      context.missing(_balanceAfterMeta);
    }
    if (data.containsKey('order_uuid')) {
      context.handle(_orderUuidMeta,
          orderUuid.isAcceptableOrUnknown(data['order_uuid']!, _orderUuidMeta));
    }
    if (data.containsKey('order_number')) {
      context.handle(
          _orderNumberMeta,
          orderNumber.isAcceptableOrUnknown(
              data['order_number']!, _orderNumberMeta));
    }
    if (data.containsKey('performed_by_uuid')) {
      context.handle(
          _performedByUuidMeta,
          performedByUuid.isAcceptableOrUnknown(
              data['performed_by_uuid']!, _performedByUuidMeta));
    } else if (isInserting) {
      context.missing(_performedByUuidMeta);
    }
    if (data.containsKey('performed_by_name')) {
      context.handle(
          _performedByNameMeta,
          performedByName.isAcceptableOrUnknown(
              data['performed_by_name']!, _performedByNameMeta));
    } else if (isInserting) {
      context.missing(_performedByNameMeta);
    }
    if (data.containsKey('notes')) {
      context.handle(
          _notesMeta, notes.isAcceptableOrUnknown(data['notes']!, _notesMeta));
    }
    if (data.containsKey('timestamp')) {
      context.handle(_timestampMeta,
          timestamp.isAcceptableOrUnknown(data['timestamp']!, _timestampMeta));
    } else if (isInserting) {
      context.missing(_timestampMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  GiftCardTransactionTableData map(Map<String, dynamic> data,
      {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return GiftCardTransactionTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      giftCardUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}gift_card_uuid'])!,
      transactionType: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}transaction_type'])!,
      amount: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}amount'])!,
      balanceAfter: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}balance_after'])!,
      orderUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}order_uuid']),
      orderNumber: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}order_number']),
      performedByUuid: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}performed_by_uuid'])!,
      performedByName: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}performed_by_name'])!,
      notes: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}notes']),
      timestamp: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}timestamp'])!,
    );
  }

  @override
  $GiftCardTransactionTableTable createAlias(String alias) {
    return $GiftCardTransactionTableTable(attachedDatabase, alias);
  }
}

class GiftCardTransactionTableData extends DataClass
    implements Insertable<GiftCardTransactionTableData> {
  final int id;
  final String uuid;
  final String giftCardUuid;
  final String transactionType;
  final double amount;
  final double balanceAfter;
  final String? orderUuid;
  final String? orderNumber;
  final String performedByUuid;
  final String performedByName;
  final String? notes;
  final DateTime timestamp;
  const GiftCardTransactionTableData(
      {required this.id,
      required this.uuid,
      required this.giftCardUuid,
      required this.transactionType,
      required this.amount,
      required this.balanceAfter,
      this.orderUuid,
      this.orderNumber,
      required this.performedByUuid,
      required this.performedByName,
      this.notes,
      required this.timestamp});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    map['gift_card_uuid'] = Variable<String>(giftCardUuid);
    map['transaction_type'] = Variable<String>(transactionType);
    map['amount'] = Variable<double>(amount);
    map['balance_after'] = Variable<double>(balanceAfter);
    if (!nullToAbsent || orderUuid != null) {
      map['order_uuid'] = Variable<String>(orderUuid);
    }
    if (!nullToAbsent || orderNumber != null) {
      map['order_number'] = Variable<String>(orderNumber);
    }
    map['performed_by_uuid'] = Variable<String>(performedByUuid);
    map['performed_by_name'] = Variable<String>(performedByName);
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    map['timestamp'] = Variable<DateTime>(timestamp);
    return map;
  }

  GiftCardTransactionTableCompanion toCompanion(bool nullToAbsent) {
    return GiftCardTransactionTableCompanion(
      id: Value(id),
      uuid: Value(uuid),
      giftCardUuid: Value(giftCardUuid),
      transactionType: Value(transactionType),
      amount: Value(amount),
      balanceAfter: Value(balanceAfter),
      orderUuid: orderUuid == null && nullToAbsent
          ? const Value.absent()
          : Value(orderUuid),
      orderNumber: orderNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(orderNumber),
      performedByUuid: Value(performedByUuid),
      performedByName: Value(performedByName),
      notes:
          notes == null && nullToAbsent ? const Value.absent() : Value(notes),
      timestamp: Value(timestamp),
    );
  }

  factory GiftCardTransactionTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return GiftCardTransactionTableData(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      giftCardUuid: serializer.fromJson<String>(json['giftCardUuid']),
      transactionType: serializer.fromJson<String>(json['transactionType']),
      amount: serializer.fromJson<double>(json['amount']),
      balanceAfter: serializer.fromJson<double>(json['balanceAfter']),
      orderUuid: serializer.fromJson<String?>(json['orderUuid']),
      orderNumber: serializer.fromJson<String?>(json['orderNumber']),
      performedByUuid: serializer.fromJson<String>(json['performedByUuid']),
      performedByName: serializer.fromJson<String>(json['performedByName']),
      notes: serializer.fromJson<String?>(json['notes']),
      timestamp: serializer.fromJson<DateTime>(json['timestamp']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'giftCardUuid': serializer.toJson<String>(giftCardUuid),
      'transactionType': serializer.toJson<String>(transactionType),
      'amount': serializer.toJson<double>(amount),
      'balanceAfter': serializer.toJson<double>(balanceAfter),
      'orderUuid': serializer.toJson<String?>(orderUuid),
      'orderNumber': serializer.toJson<String?>(orderNumber),
      'performedByUuid': serializer.toJson<String>(performedByUuid),
      'performedByName': serializer.toJson<String>(performedByName),
      'notes': serializer.toJson<String?>(notes),
      'timestamp': serializer.toJson<DateTime>(timestamp),
    };
  }

  GiftCardTransactionTableData copyWith(
          {int? id,
          String? uuid,
          String? giftCardUuid,
          String? transactionType,
          double? amount,
          double? balanceAfter,
          Value<String?> orderUuid = const Value.absent(),
          Value<String?> orderNumber = const Value.absent(),
          String? performedByUuid,
          String? performedByName,
          Value<String?> notes = const Value.absent(),
          DateTime? timestamp}) =>
      GiftCardTransactionTableData(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        giftCardUuid: giftCardUuid ?? this.giftCardUuid,
        transactionType: transactionType ?? this.transactionType,
        amount: amount ?? this.amount,
        balanceAfter: balanceAfter ?? this.balanceAfter,
        orderUuid: orderUuid.present ? orderUuid.value : this.orderUuid,
        orderNumber: orderNumber.present ? orderNumber.value : this.orderNumber,
        performedByUuid: performedByUuid ?? this.performedByUuid,
        performedByName: performedByName ?? this.performedByName,
        notes: notes.present ? notes.value : this.notes,
        timestamp: timestamp ?? this.timestamp,
      );
  GiftCardTransactionTableData copyWithCompanion(
      GiftCardTransactionTableCompanion data) {
    return GiftCardTransactionTableData(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      giftCardUuid: data.giftCardUuid.present
          ? data.giftCardUuid.value
          : this.giftCardUuid,
      transactionType: data.transactionType.present
          ? data.transactionType.value
          : this.transactionType,
      amount: data.amount.present ? data.amount.value : this.amount,
      balanceAfter: data.balanceAfter.present
          ? data.balanceAfter.value
          : this.balanceAfter,
      orderUuid: data.orderUuid.present ? data.orderUuid.value : this.orderUuid,
      orderNumber:
          data.orderNumber.present ? data.orderNumber.value : this.orderNumber,
      performedByUuid: data.performedByUuid.present
          ? data.performedByUuid.value
          : this.performedByUuid,
      performedByName: data.performedByName.present
          ? data.performedByName.value
          : this.performedByName,
      notes: data.notes.present ? data.notes.value : this.notes,
      timestamp: data.timestamp.present ? data.timestamp.value : this.timestamp,
    );
  }

  @override
  String toString() {
    return (StringBuffer('GiftCardTransactionTableData(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('giftCardUuid: $giftCardUuid, ')
          ..write('transactionType: $transactionType, ')
          ..write('amount: $amount, ')
          ..write('balanceAfter: $balanceAfter, ')
          ..write('orderUuid: $orderUuid, ')
          ..write('orderNumber: $orderNumber, ')
          ..write('performedByUuid: $performedByUuid, ')
          ..write('performedByName: $performedByName, ')
          ..write('notes: $notes, ')
          ..write('timestamp: $timestamp')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      uuid,
      giftCardUuid,
      transactionType,
      amount,
      balanceAfter,
      orderUuid,
      orderNumber,
      performedByUuid,
      performedByName,
      notes,
      timestamp);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is GiftCardTransactionTableData &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.giftCardUuid == this.giftCardUuid &&
          other.transactionType == this.transactionType &&
          other.amount == this.amount &&
          other.balanceAfter == this.balanceAfter &&
          other.orderUuid == this.orderUuid &&
          other.orderNumber == this.orderNumber &&
          other.performedByUuid == this.performedByUuid &&
          other.performedByName == this.performedByName &&
          other.notes == this.notes &&
          other.timestamp == this.timestamp);
}

class GiftCardTransactionTableCompanion
    extends UpdateCompanion<GiftCardTransactionTableData> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String> giftCardUuid;
  final Value<String> transactionType;
  final Value<double> amount;
  final Value<double> balanceAfter;
  final Value<String?> orderUuid;
  final Value<String?> orderNumber;
  final Value<String> performedByUuid;
  final Value<String> performedByName;
  final Value<String?> notes;
  final Value<DateTime> timestamp;
  const GiftCardTransactionTableCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.giftCardUuid = const Value.absent(),
    this.transactionType = const Value.absent(),
    this.amount = const Value.absent(),
    this.balanceAfter = const Value.absent(),
    this.orderUuid = const Value.absent(),
    this.orderNumber = const Value.absent(),
    this.performedByUuid = const Value.absent(),
    this.performedByName = const Value.absent(),
    this.notes = const Value.absent(),
    this.timestamp = const Value.absent(),
  });
  GiftCardTransactionTableCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    required String giftCardUuid,
    required String transactionType,
    required double amount,
    required double balanceAfter,
    this.orderUuid = const Value.absent(),
    this.orderNumber = const Value.absent(),
    required String performedByUuid,
    required String performedByName,
    this.notes = const Value.absent(),
    required DateTime timestamp,
  })  : uuid = Value(uuid),
        giftCardUuid = Value(giftCardUuid),
        transactionType = Value(transactionType),
        amount = Value(amount),
        balanceAfter = Value(balanceAfter),
        performedByUuid = Value(performedByUuid),
        performedByName = Value(performedByName),
        timestamp = Value(timestamp);
  static Insertable<GiftCardTransactionTableData> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? giftCardUuid,
    Expression<String>? transactionType,
    Expression<double>? amount,
    Expression<double>? balanceAfter,
    Expression<String>? orderUuid,
    Expression<String>? orderNumber,
    Expression<String>? performedByUuid,
    Expression<String>? performedByName,
    Expression<String>? notes,
    Expression<DateTime>? timestamp,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (giftCardUuid != null) 'gift_card_uuid': giftCardUuid,
      if (transactionType != null) 'transaction_type': transactionType,
      if (amount != null) 'amount': amount,
      if (balanceAfter != null) 'balance_after': balanceAfter,
      if (orderUuid != null) 'order_uuid': orderUuid,
      if (orderNumber != null) 'order_number': orderNumber,
      if (performedByUuid != null) 'performed_by_uuid': performedByUuid,
      if (performedByName != null) 'performed_by_name': performedByName,
      if (notes != null) 'notes': notes,
      if (timestamp != null) 'timestamp': timestamp,
    });
  }

  GiftCardTransactionTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String>? giftCardUuid,
      Value<String>? transactionType,
      Value<double>? amount,
      Value<double>? balanceAfter,
      Value<String?>? orderUuid,
      Value<String?>? orderNumber,
      Value<String>? performedByUuid,
      Value<String>? performedByName,
      Value<String?>? notes,
      Value<DateTime>? timestamp}) {
    return GiftCardTransactionTableCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      giftCardUuid: giftCardUuid ?? this.giftCardUuid,
      transactionType: transactionType ?? this.transactionType,
      amount: amount ?? this.amount,
      balanceAfter: balanceAfter ?? this.balanceAfter,
      orderUuid: orderUuid ?? this.orderUuid,
      orderNumber: orderNumber ?? this.orderNumber,
      performedByUuid: performedByUuid ?? this.performedByUuid,
      performedByName: performedByName ?? this.performedByName,
      notes: notes ?? this.notes,
      timestamp: timestamp ?? this.timestamp,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (giftCardUuid.present) {
      map['gift_card_uuid'] = Variable<String>(giftCardUuid.value);
    }
    if (transactionType.present) {
      map['transaction_type'] = Variable<String>(transactionType.value);
    }
    if (amount.present) {
      map['amount'] = Variable<double>(amount.value);
    }
    if (balanceAfter.present) {
      map['balance_after'] = Variable<double>(balanceAfter.value);
    }
    if (orderUuid.present) {
      map['order_uuid'] = Variable<String>(orderUuid.value);
    }
    if (orderNumber.present) {
      map['order_number'] = Variable<String>(orderNumber.value);
    }
    if (performedByUuid.present) {
      map['performed_by_uuid'] = Variable<String>(performedByUuid.value);
    }
    if (performedByName.present) {
      map['performed_by_name'] = Variable<String>(performedByName.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (timestamp.present) {
      map['timestamp'] = Variable<DateTime>(timestamp.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('GiftCardTransactionTableCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('giftCardUuid: $giftCardUuid, ')
          ..write('transactionType: $transactionType, ')
          ..write('amount: $amount, ')
          ..write('balanceAfter: $balanceAfter, ')
          ..write('orderUuid: $orderUuid, ')
          ..write('orderNumber: $orderNumber, ')
          ..write('performedByUuid: $performedByUuid, ')
          ..write('performedByName: $performedByName, ')
          ..write('notes: $notes, ')
          ..write('timestamp: $timestamp')
          ..write(')'))
        .toString();
  }
}

class $LoyaltyProgramTableTable extends LoyaltyProgramTable
    with TableInfo<$LoyaltyProgramTableTable, LoyaltyProgramData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $LoyaltyProgramTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultValue: const Constant('Default Loyalty'));
  static const VerificationMeta _pointsPerCurrencyMeta =
      const VerificationMeta('pointsPerCurrency');
  @override
  late final GeneratedColumn<double> pointsPerCurrency =
      GeneratedColumn<double>('points_per_currency', aliasedName, false,
          type: DriftSqlType.double,
          requiredDuringInsert: false,
          defaultValue: const Constant(1.0));
  static const VerificationMeta _exchangeRateMeta =
      const VerificationMeta('exchangeRate');
  @override
  late final GeneratedColumn<double> exchangeRate = GeneratedColumn<double>(
      'exchange_rate', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: false,
      defaultValue: const Constant(0.01));
  static const VerificationMeta _tiersJsonMeta =
      const VerificationMeta('tiersJson');
  @override
  late final GeneratedColumn<String> tiersJson = GeneratedColumn<String>(
      'tiers_json', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  @override
  List<GeneratedColumn> get $columns =>
      [id, uuid, name, pointsPerCurrency, exchangeRate, tiersJson, updatedAt];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'loyalty_program_table';
  @override
  VerificationContext validateIntegrity(Insertable<LoyaltyProgramData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    }
    if (data.containsKey('points_per_currency')) {
      context.handle(
          _pointsPerCurrencyMeta,
          pointsPerCurrency.isAcceptableOrUnknown(
              data['points_per_currency']!, _pointsPerCurrencyMeta));
    }
    if (data.containsKey('exchange_rate')) {
      context.handle(
          _exchangeRateMeta,
          exchangeRate.isAcceptableOrUnknown(
              data['exchange_rate']!, _exchangeRateMeta));
    }
    if (data.containsKey('tiers_json')) {
      context.handle(_tiersJsonMeta,
          tiersJson.isAcceptableOrUnknown(data['tiers_json']!, _tiersJsonMeta));
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  LoyaltyProgramData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return LoyaltyProgramData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
      pointsPerCurrency: attachedDatabase.typeMapping.read(
          DriftSqlType.double, data['${effectivePrefix}points_per_currency'])!,
      exchangeRate: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}exchange_rate'])!,
      tiersJson: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tiers_json']),
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $LoyaltyProgramTableTable createAlias(String alias) {
    return $LoyaltyProgramTableTable(attachedDatabase, alias);
  }
}

class LoyaltyProgramData extends DataClass
    implements Insertable<LoyaltyProgramData> {
  final int id;
  final String uuid;
  final String name;
  final double pointsPerCurrency;
  final double exchangeRate;
  final String? tiersJson;
  final DateTime updatedAt;
  const LoyaltyProgramData(
      {required this.id,
      required this.uuid,
      required this.name,
      required this.pointsPerCurrency,
      required this.exchangeRate,
      this.tiersJson,
      required this.updatedAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    map['name'] = Variable<String>(name);
    map['points_per_currency'] = Variable<double>(pointsPerCurrency);
    map['exchange_rate'] = Variable<double>(exchangeRate);
    if (!nullToAbsent || tiersJson != null) {
      map['tiers_json'] = Variable<String>(tiersJson);
    }
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  LoyaltyProgramTableCompanion toCompanion(bool nullToAbsent) {
    return LoyaltyProgramTableCompanion(
      id: Value(id),
      uuid: Value(uuid),
      name: Value(name),
      pointsPerCurrency: Value(pointsPerCurrency),
      exchangeRate: Value(exchangeRate),
      tiersJson: tiersJson == null && nullToAbsent
          ? const Value.absent()
          : Value(tiersJson),
      updatedAt: Value(updatedAt),
    );
  }

  factory LoyaltyProgramData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return LoyaltyProgramData(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      name: serializer.fromJson<String>(json['name']),
      pointsPerCurrency: serializer.fromJson<double>(json['pointsPerCurrency']),
      exchangeRate: serializer.fromJson<double>(json['exchangeRate']),
      tiersJson: serializer.fromJson<String?>(json['tiersJson']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'name': serializer.toJson<String>(name),
      'pointsPerCurrency': serializer.toJson<double>(pointsPerCurrency),
      'exchangeRate': serializer.toJson<double>(exchangeRate),
      'tiersJson': serializer.toJson<String?>(tiersJson),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  LoyaltyProgramData copyWith(
          {int? id,
          String? uuid,
          String? name,
          double? pointsPerCurrency,
          double? exchangeRate,
          Value<String?> tiersJson = const Value.absent(),
          DateTime? updatedAt}) =>
      LoyaltyProgramData(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        name: name ?? this.name,
        pointsPerCurrency: pointsPerCurrency ?? this.pointsPerCurrency,
        exchangeRate: exchangeRate ?? this.exchangeRate,
        tiersJson: tiersJson.present ? tiersJson.value : this.tiersJson,
        updatedAt: updatedAt ?? this.updatedAt,
      );
  LoyaltyProgramData copyWithCompanion(LoyaltyProgramTableCompanion data) {
    return LoyaltyProgramData(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      name: data.name.present ? data.name.value : this.name,
      pointsPerCurrency: data.pointsPerCurrency.present
          ? data.pointsPerCurrency.value
          : this.pointsPerCurrency,
      exchangeRate: data.exchangeRate.present
          ? data.exchangeRate.value
          : this.exchangeRate,
      tiersJson: data.tiersJson.present ? data.tiersJson.value : this.tiersJson,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('LoyaltyProgramData(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('pointsPerCurrency: $pointsPerCurrency, ')
          ..write('exchangeRate: $exchangeRate, ')
          ..write('tiersJson: $tiersJson, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id, uuid, name, pointsPerCurrency, exchangeRate, tiersJson, updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is LoyaltyProgramData &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.name == this.name &&
          other.pointsPerCurrency == this.pointsPerCurrency &&
          other.exchangeRate == this.exchangeRate &&
          other.tiersJson == this.tiersJson &&
          other.updatedAt == this.updatedAt);
}

class LoyaltyProgramTableCompanion extends UpdateCompanion<LoyaltyProgramData> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String> name;
  final Value<double> pointsPerCurrency;
  final Value<double> exchangeRate;
  final Value<String?> tiersJson;
  final Value<DateTime> updatedAt;
  const LoyaltyProgramTableCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.name = const Value.absent(),
    this.pointsPerCurrency = const Value.absent(),
    this.exchangeRate = const Value.absent(),
    this.tiersJson = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  LoyaltyProgramTableCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    this.name = const Value.absent(),
    this.pointsPerCurrency = const Value.absent(),
    this.exchangeRate = const Value.absent(),
    this.tiersJson = const Value.absent(),
    this.updatedAt = const Value.absent(),
  }) : uuid = Value(uuid);
  static Insertable<LoyaltyProgramData> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? name,
    Expression<double>? pointsPerCurrency,
    Expression<double>? exchangeRate,
    Expression<String>? tiersJson,
    Expression<DateTime>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (name != null) 'name': name,
      if (pointsPerCurrency != null) 'points_per_currency': pointsPerCurrency,
      if (exchangeRate != null) 'exchange_rate': exchangeRate,
      if (tiersJson != null) 'tiers_json': tiersJson,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  LoyaltyProgramTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String>? name,
      Value<double>? pointsPerCurrency,
      Value<double>? exchangeRate,
      Value<String?>? tiersJson,
      Value<DateTime>? updatedAt}) {
    return LoyaltyProgramTableCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      name: name ?? this.name,
      pointsPerCurrency: pointsPerCurrency ?? this.pointsPerCurrency,
      exchangeRate: exchangeRate ?? this.exchangeRate,
      tiersJson: tiersJson ?? this.tiersJson,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (pointsPerCurrency.present) {
      map['points_per_currency'] = Variable<double>(pointsPerCurrency.value);
    }
    if (exchangeRate.present) {
      map['exchange_rate'] = Variable<double>(exchangeRate.value);
    }
    if (tiersJson.present) {
      map['tiers_json'] = Variable<String>(tiersJson.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('LoyaltyProgramTableCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('pointsPerCurrency: $pointsPerCurrency, ')
          ..write('exchangeRate: $exchangeRate, ')
          ..write('tiersJson: $tiersJson, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class $LoyaltyMemberTableTable extends LoyaltyMemberTable
    with TableInfo<$LoyaltyMemberTableTable, LoyaltyMemberData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $LoyaltyMemberTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _customerUuidMeta =
      const VerificationMeta('customerUuid');
  @override
  late final GeneratedColumn<String> customerUuid = GeneratedColumn<String>(
      'customer_uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _pointsBalanceMeta =
      const VerificationMeta('pointsBalance');
  @override
  late final GeneratedColumn<double> pointsBalance = GeneratedColumn<double>(
      'points_balance', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: false,
      defaultValue: const Constant(0.0));
  static const VerificationMeta _lifetimePointsMeta =
      const VerificationMeta('lifetimePoints');
  @override
  late final GeneratedColumn<double> lifetimePoints = GeneratedColumn<double>(
      'lifetime_points', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: false,
      defaultValue: const Constant(0.0));
  static const VerificationMeta _currentTierMeta =
      const VerificationMeta('currentTier');
  @override
  late final GeneratedColumn<String> currentTier = GeneratedColumn<String>(
      'current_tier', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultValue: const Constant('Base'));
  static const VerificationMeta _joinedAtMeta =
      const VerificationMeta('joinedAt');
  @override
  late final GeneratedColumn<DateTime> joinedAt = GeneratedColumn<DateTime>(
      'joined_at', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  static const VerificationMeta _lastTransactionAtMeta =
      const VerificationMeta('lastTransactionAt');
  @override
  late final GeneratedColumn<DateTime> lastTransactionAt =
      GeneratedColumn<DateTime>('last_transaction_at', aliasedName, true,
          type: DriftSqlType.dateTime, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        customerUuid,
        pointsBalance,
        lifetimePoints,
        currentTier,
        joinedAt,
        lastTransactionAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'loyalty_member_table';
  @override
  VerificationContext validateIntegrity(Insertable<LoyaltyMemberData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('customer_uuid')) {
      context.handle(
          _customerUuidMeta,
          customerUuid.isAcceptableOrUnknown(
              data['customer_uuid']!, _customerUuidMeta));
    } else if (isInserting) {
      context.missing(_customerUuidMeta);
    }
    if (data.containsKey('points_balance')) {
      context.handle(
          _pointsBalanceMeta,
          pointsBalance.isAcceptableOrUnknown(
              data['points_balance']!, _pointsBalanceMeta));
    }
    if (data.containsKey('lifetime_points')) {
      context.handle(
          _lifetimePointsMeta,
          lifetimePoints.isAcceptableOrUnknown(
              data['lifetime_points']!, _lifetimePointsMeta));
    }
    if (data.containsKey('current_tier')) {
      context.handle(
          _currentTierMeta,
          currentTier.isAcceptableOrUnknown(
              data['current_tier']!, _currentTierMeta));
    }
    if (data.containsKey('joined_at')) {
      context.handle(_joinedAtMeta,
          joinedAt.isAcceptableOrUnknown(data['joined_at']!, _joinedAtMeta));
    }
    if (data.containsKey('last_transaction_at')) {
      context.handle(
          _lastTransactionAtMeta,
          lastTransactionAt.isAcceptableOrUnknown(
              data['last_transaction_at']!, _lastTransactionAtMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  LoyaltyMemberData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return LoyaltyMemberData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      customerUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}customer_uuid'])!,
      pointsBalance: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}points_balance'])!,
      lifetimePoints: attachedDatabase.typeMapping.read(
          DriftSqlType.double, data['${effectivePrefix}lifetime_points'])!,
      currentTier: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}current_tier'])!,
      joinedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}joined_at'])!,
      lastTransactionAt: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}last_transaction_at']),
    );
  }

  @override
  $LoyaltyMemberTableTable createAlias(String alias) {
    return $LoyaltyMemberTableTable(attachedDatabase, alias);
  }
}

class LoyaltyMemberData extends DataClass
    implements Insertable<LoyaltyMemberData> {
  final int id;
  final String uuid;
  final String customerUuid;
  final double pointsBalance;
  final double lifetimePoints;
  final String currentTier;
  final DateTime joinedAt;
  final DateTime? lastTransactionAt;
  const LoyaltyMemberData(
      {required this.id,
      required this.uuid,
      required this.customerUuid,
      required this.pointsBalance,
      required this.lifetimePoints,
      required this.currentTier,
      required this.joinedAt,
      this.lastTransactionAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    map['customer_uuid'] = Variable<String>(customerUuid);
    map['points_balance'] = Variable<double>(pointsBalance);
    map['lifetime_points'] = Variable<double>(lifetimePoints);
    map['current_tier'] = Variable<String>(currentTier);
    map['joined_at'] = Variable<DateTime>(joinedAt);
    if (!nullToAbsent || lastTransactionAt != null) {
      map['last_transaction_at'] = Variable<DateTime>(lastTransactionAt);
    }
    return map;
  }

  LoyaltyMemberTableCompanion toCompanion(bool nullToAbsent) {
    return LoyaltyMemberTableCompanion(
      id: Value(id),
      uuid: Value(uuid),
      customerUuid: Value(customerUuid),
      pointsBalance: Value(pointsBalance),
      lifetimePoints: Value(lifetimePoints),
      currentTier: Value(currentTier),
      joinedAt: Value(joinedAt),
      lastTransactionAt: lastTransactionAt == null && nullToAbsent
          ? const Value.absent()
          : Value(lastTransactionAt),
    );
  }

  factory LoyaltyMemberData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return LoyaltyMemberData(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      customerUuid: serializer.fromJson<String>(json['customerUuid']),
      pointsBalance: serializer.fromJson<double>(json['pointsBalance']),
      lifetimePoints: serializer.fromJson<double>(json['lifetimePoints']),
      currentTier: serializer.fromJson<String>(json['currentTier']),
      joinedAt: serializer.fromJson<DateTime>(json['joinedAt']),
      lastTransactionAt:
          serializer.fromJson<DateTime?>(json['lastTransactionAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'customerUuid': serializer.toJson<String>(customerUuid),
      'pointsBalance': serializer.toJson<double>(pointsBalance),
      'lifetimePoints': serializer.toJson<double>(lifetimePoints),
      'currentTier': serializer.toJson<String>(currentTier),
      'joinedAt': serializer.toJson<DateTime>(joinedAt),
      'lastTransactionAt': serializer.toJson<DateTime?>(lastTransactionAt),
    };
  }

  LoyaltyMemberData copyWith(
          {int? id,
          String? uuid,
          String? customerUuid,
          double? pointsBalance,
          double? lifetimePoints,
          String? currentTier,
          DateTime? joinedAt,
          Value<DateTime?> lastTransactionAt = const Value.absent()}) =>
      LoyaltyMemberData(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        customerUuid: customerUuid ?? this.customerUuid,
        pointsBalance: pointsBalance ?? this.pointsBalance,
        lifetimePoints: lifetimePoints ?? this.lifetimePoints,
        currentTier: currentTier ?? this.currentTier,
        joinedAt: joinedAt ?? this.joinedAt,
        lastTransactionAt: lastTransactionAt.present
            ? lastTransactionAt.value
            : this.lastTransactionAt,
      );
  LoyaltyMemberData copyWithCompanion(LoyaltyMemberTableCompanion data) {
    return LoyaltyMemberData(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      customerUuid: data.customerUuid.present
          ? data.customerUuid.value
          : this.customerUuid,
      pointsBalance: data.pointsBalance.present
          ? data.pointsBalance.value
          : this.pointsBalance,
      lifetimePoints: data.lifetimePoints.present
          ? data.lifetimePoints.value
          : this.lifetimePoints,
      currentTier:
          data.currentTier.present ? data.currentTier.value : this.currentTier,
      joinedAt: data.joinedAt.present ? data.joinedAt.value : this.joinedAt,
      lastTransactionAt: data.lastTransactionAt.present
          ? data.lastTransactionAt.value
          : this.lastTransactionAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('LoyaltyMemberData(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('customerUuid: $customerUuid, ')
          ..write('pointsBalance: $pointsBalance, ')
          ..write('lifetimePoints: $lifetimePoints, ')
          ..write('currentTier: $currentTier, ')
          ..write('joinedAt: $joinedAt, ')
          ..write('lastTransactionAt: $lastTransactionAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, uuid, customerUuid, pointsBalance,
      lifetimePoints, currentTier, joinedAt, lastTransactionAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is LoyaltyMemberData &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.customerUuid == this.customerUuid &&
          other.pointsBalance == this.pointsBalance &&
          other.lifetimePoints == this.lifetimePoints &&
          other.currentTier == this.currentTier &&
          other.joinedAt == this.joinedAt &&
          other.lastTransactionAt == this.lastTransactionAt);
}

class LoyaltyMemberTableCompanion extends UpdateCompanion<LoyaltyMemberData> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String> customerUuid;
  final Value<double> pointsBalance;
  final Value<double> lifetimePoints;
  final Value<String> currentTier;
  final Value<DateTime> joinedAt;
  final Value<DateTime?> lastTransactionAt;
  const LoyaltyMemberTableCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.customerUuid = const Value.absent(),
    this.pointsBalance = const Value.absent(),
    this.lifetimePoints = const Value.absent(),
    this.currentTier = const Value.absent(),
    this.joinedAt = const Value.absent(),
    this.lastTransactionAt = const Value.absent(),
  });
  LoyaltyMemberTableCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    required String customerUuid,
    this.pointsBalance = const Value.absent(),
    this.lifetimePoints = const Value.absent(),
    this.currentTier = const Value.absent(),
    this.joinedAt = const Value.absent(),
    this.lastTransactionAt = const Value.absent(),
  })  : uuid = Value(uuid),
        customerUuid = Value(customerUuid);
  static Insertable<LoyaltyMemberData> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? customerUuid,
    Expression<double>? pointsBalance,
    Expression<double>? lifetimePoints,
    Expression<String>? currentTier,
    Expression<DateTime>? joinedAt,
    Expression<DateTime>? lastTransactionAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (customerUuid != null) 'customer_uuid': customerUuid,
      if (pointsBalance != null) 'points_balance': pointsBalance,
      if (lifetimePoints != null) 'lifetime_points': lifetimePoints,
      if (currentTier != null) 'current_tier': currentTier,
      if (joinedAt != null) 'joined_at': joinedAt,
      if (lastTransactionAt != null) 'last_transaction_at': lastTransactionAt,
    });
  }

  LoyaltyMemberTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String>? customerUuid,
      Value<double>? pointsBalance,
      Value<double>? lifetimePoints,
      Value<String>? currentTier,
      Value<DateTime>? joinedAt,
      Value<DateTime?>? lastTransactionAt}) {
    return LoyaltyMemberTableCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      customerUuid: customerUuid ?? this.customerUuid,
      pointsBalance: pointsBalance ?? this.pointsBalance,
      lifetimePoints: lifetimePoints ?? this.lifetimePoints,
      currentTier: currentTier ?? this.currentTier,
      joinedAt: joinedAt ?? this.joinedAt,
      lastTransactionAt: lastTransactionAt ?? this.lastTransactionAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (customerUuid.present) {
      map['customer_uuid'] = Variable<String>(customerUuid.value);
    }
    if (pointsBalance.present) {
      map['points_balance'] = Variable<double>(pointsBalance.value);
    }
    if (lifetimePoints.present) {
      map['lifetime_points'] = Variable<double>(lifetimePoints.value);
    }
    if (currentTier.present) {
      map['current_tier'] = Variable<String>(currentTier.value);
    }
    if (joinedAt.present) {
      map['joined_at'] = Variable<DateTime>(joinedAt.value);
    }
    if (lastTransactionAt.present) {
      map['last_transaction_at'] = Variable<DateTime>(lastTransactionAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('LoyaltyMemberTableCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('customerUuid: $customerUuid, ')
          ..write('pointsBalance: $pointsBalance, ')
          ..write('lifetimePoints: $lifetimePoints, ')
          ..write('currentTier: $currentTier, ')
          ..write('joinedAt: $joinedAt, ')
          ..write('lastTransactionAt: $lastTransactionAt')
          ..write(')'))
        .toString();
  }
}

class $LoyaltyTransactionTableTable extends LoyaltyTransactionTable
    with TableInfo<$LoyaltyTransactionTableTable, LoyaltyTransactionData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $LoyaltyTransactionTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _memberUuidMeta =
      const VerificationMeta('memberUuid');
  @override
  late final GeneratedColumn<String> memberUuid = GeneratedColumn<String>(
      'member_uuid', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _typeMeta = const VerificationMeta('type');
  @override
  late final GeneratedColumn<String> type = GeneratedColumn<String>(
      'type', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _pointsDeltaMeta =
      const VerificationMeta('pointsDelta');
  @override
  late final GeneratedColumn<double> pointsDelta = GeneratedColumn<double>(
      'points_delta', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _orderUuidMeta =
      const VerificationMeta('orderUuid');
  @override
  late final GeneratedColumn<String> orderUuid = GeneratedColumn<String>(
      'order_uuid', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _rewardUuidMeta =
      const VerificationMeta('rewardUuid');
  @override
  late final GeneratedColumn<String> rewardUuid = GeneratedColumn<String>(
      'reward_uuid', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _reasonMeta = const VerificationMeta('reason');
  @override
  late final GeneratedColumn<String> reason = GeneratedColumn<String>(
      'reason', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        memberUuid,
        type,
        pointsDelta,
        orderUuid,
        rewardUuid,
        reason,
        createdAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'loyalty_transaction_table';
  @override
  VerificationContext validateIntegrity(
      Insertable<LoyaltyTransactionData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('member_uuid')) {
      context.handle(
          _memberUuidMeta,
          memberUuid.isAcceptableOrUnknown(
              data['member_uuid']!, _memberUuidMeta));
    } else if (isInserting) {
      context.missing(_memberUuidMeta);
    }
    if (data.containsKey('type')) {
      context.handle(
          _typeMeta, type.isAcceptableOrUnknown(data['type']!, _typeMeta));
    } else if (isInserting) {
      context.missing(_typeMeta);
    }
    if (data.containsKey('points_delta')) {
      context.handle(
          _pointsDeltaMeta,
          pointsDelta.isAcceptableOrUnknown(
              data['points_delta']!, _pointsDeltaMeta));
    } else if (isInserting) {
      context.missing(_pointsDeltaMeta);
    }
    if (data.containsKey('order_uuid')) {
      context.handle(_orderUuidMeta,
          orderUuid.isAcceptableOrUnknown(data['order_uuid']!, _orderUuidMeta));
    }
    if (data.containsKey('reward_uuid')) {
      context.handle(
          _rewardUuidMeta,
          rewardUuid.isAcceptableOrUnknown(
              data['reward_uuid']!, _rewardUuidMeta));
    }
    if (data.containsKey('reason')) {
      context.handle(_reasonMeta,
          reason.isAcceptableOrUnknown(data['reason']!, _reasonMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  LoyaltyTransactionData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return LoyaltyTransactionData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      memberUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}member_uuid'])!,
      type: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}type'])!,
      pointsDelta: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}points_delta'])!,
      orderUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}order_uuid']),
      rewardUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}reward_uuid']),
      reason: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}reason']),
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
    );
  }

  @override
  $LoyaltyTransactionTableTable createAlias(String alias) {
    return $LoyaltyTransactionTableTable(attachedDatabase, alias);
  }
}

class LoyaltyTransactionData extends DataClass
    implements Insertable<LoyaltyTransactionData> {
  final int id;
  final String uuid;
  final String memberUuid;
  final String type;
  final double pointsDelta;
  final String? orderUuid;
  final String? rewardUuid;
  final String? reason;
  final DateTime createdAt;
  const LoyaltyTransactionData(
      {required this.id,
      required this.uuid,
      required this.memberUuid,
      required this.type,
      required this.pointsDelta,
      this.orderUuid,
      this.rewardUuid,
      this.reason,
      required this.createdAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    map['member_uuid'] = Variable<String>(memberUuid);
    map['type'] = Variable<String>(type);
    map['points_delta'] = Variable<double>(pointsDelta);
    if (!nullToAbsent || orderUuid != null) {
      map['order_uuid'] = Variable<String>(orderUuid);
    }
    if (!nullToAbsent || rewardUuid != null) {
      map['reward_uuid'] = Variable<String>(rewardUuid);
    }
    if (!nullToAbsent || reason != null) {
      map['reason'] = Variable<String>(reason);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    return map;
  }

  LoyaltyTransactionTableCompanion toCompanion(bool nullToAbsent) {
    return LoyaltyTransactionTableCompanion(
      id: Value(id),
      uuid: Value(uuid),
      memberUuid: Value(memberUuid),
      type: Value(type),
      pointsDelta: Value(pointsDelta),
      orderUuid: orderUuid == null && nullToAbsent
          ? const Value.absent()
          : Value(orderUuid),
      rewardUuid: rewardUuid == null && nullToAbsent
          ? const Value.absent()
          : Value(rewardUuid),
      reason:
          reason == null && nullToAbsent ? const Value.absent() : Value(reason),
      createdAt: Value(createdAt),
    );
  }

  factory LoyaltyTransactionData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return LoyaltyTransactionData(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      memberUuid: serializer.fromJson<String>(json['memberUuid']),
      type: serializer.fromJson<String>(json['type']),
      pointsDelta: serializer.fromJson<double>(json['pointsDelta']),
      orderUuid: serializer.fromJson<String?>(json['orderUuid']),
      rewardUuid: serializer.fromJson<String?>(json['rewardUuid']),
      reason: serializer.fromJson<String?>(json['reason']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'memberUuid': serializer.toJson<String>(memberUuid),
      'type': serializer.toJson<String>(type),
      'pointsDelta': serializer.toJson<double>(pointsDelta),
      'orderUuid': serializer.toJson<String?>(orderUuid),
      'rewardUuid': serializer.toJson<String?>(rewardUuid),
      'reason': serializer.toJson<String?>(reason),
      'createdAt': serializer.toJson<DateTime>(createdAt),
    };
  }

  LoyaltyTransactionData copyWith(
          {int? id,
          String? uuid,
          String? memberUuid,
          String? type,
          double? pointsDelta,
          Value<String?> orderUuid = const Value.absent(),
          Value<String?> rewardUuid = const Value.absent(),
          Value<String?> reason = const Value.absent(),
          DateTime? createdAt}) =>
      LoyaltyTransactionData(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        memberUuid: memberUuid ?? this.memberUuid,
        type: type ?? this.type,
        pointsDelta: pointsDelta ?? this.pointsDelta,
        orderUuid: orderUuid.present ? orderUuid.value : this.orderUuid,
        rewardUuid: rewardUuid.present ? rewardUuid.value : this.rewardUuid,
        reason: reason.present ? reason.value : this.reason,
        createdAt: createdAt ?? this.createdAt,
      );
  LoyaltyTransactionData copyWithCompanion(
      LoyaltyTransactionTableCompanion data) {
    return LoyaltyTransactionData(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      memberUuid:
          data.memberUuid.present ? data.memberUuid.value : this.memberUuid,
      type: data.type.present ? data.type.value : this.type,
      pointsDelta:
          data.pointsDelta.present ? data.pointsDelta.value : this.pointsDelta,
      orderUuid: data.orderUuid.present ? data.orderUuid.value : this.orderUuid,
      rewardUuid:
          data.rewardUuid.present ? data.rewardUuid.value : this.rewardUuid,
      reason: data.reason.present ? data.reason.value : this.reason,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('LoyaltyTransactionData(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('memberUuid: $memberUuid, ')
          ..write('type: $type, ')
          ..write('pointsDelta: $pointsDelta, ')
          ..write('orderUuid: $orderUuid, ')
          ..write('rewardUuid: $rewardUuid, ')
          ..write('reason: $reason, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, uuid, memberUuid, type, pointsDelta,
      orderUuid, rewardUuid, reason, createdAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is LoyaltyTransactionData &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.memberUuid == this.memberUuid &&
          other.type == this.type &&
          other.pointsDelta == this.pointsDelta &&
          other.orderUuid == this.orderUuid &&
          other.rewardUuid == this.rewardUuid &&
          other.reason == this.reason &&
          other.createdAt == this.createdAt);
}

class LoyaltyTransactionTableCompanion
    extends UpdateCompanion<LoyaltyTransactionData> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String> memberUuid;
  final Value<String> type;
  final Value<double> pointsDelta;
  final Value<String?> orderUuid;
  final Value<String?> rewardUuid;
  final Value<String?> reason;
  final Value<DateTime> createdAt;
  const LoyaltyTransactionTableCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.memberUuid = const Value.absent(),
    this.type = const Value.absent(),
    this.pointsDelta = const Value.absent(),
    this.orderUuid = const Value.absent(),
    this.rewardUuid = const Value.absent(),
    this.reason = const Value.absent(),
    this.createdAt = const Value.absent(),
  });
  LoyaltyTransactionTableCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    required String memberUuid,
    required String type,
    required double pointsDelta,
    this.orderUuid = const Value.absent(),
    this.rewardUuid = const Value.absent(),
    this.reason = const Value.absent(),
    this.createdAt = const Value.absent(),
  })  : uuid = Value(uuid),
        memberUuid = Value(memberUuid),
        type = Value(type),
        pointsDelta = Value(pointsDelta);
  static Insertable<LoyaltyTransactionData> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? memberUuid,
    Expression<String>? type,
    Expression<double>? pointsDelta,
    Expression<String>? orderUuid,
    Expression<String>? rewardUuid,
    Expression<String>? reason,
    Expression<DateTime>? createdAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (memberUuid != null) 'member_uuid': memberUuid,
      if (type != null) 'type': type,
      if (pointsDelta != null) 'points_delta': pointsDelta,
      if (orderUuid != null) 'order_uuid': orderUuid,
      if (rewardUuid != null) 'reward_uuid': rewardUuid,
      if (reason != null) 'reason': reason,
      if (createdAt != null) 'created_at': createdAt,
    });
  }

  LoyaltyTransactionTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String>? memberUuid,
      Value<String>? type,
      Value<double>? pointsDelta,
      Value<String?>? orderUuid,
      Value<String?>? rewardUuid,
      Value<String?>? reason,
      Value<DateTime>? createdAt}) {
    return LoyaltyTransactionTableCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      memberUuid: memberUuid ?? this.memberUuid,
      type: type ?? this.type,
      pointsDelta: pointsDelta ?? this.pointsDelta,
      orderUuid: orderUuid ?? this.orderUuid,
      rewardUuid: rewardUuid ?? this.rewardUuid,
      reason: reason ?? this.reason,
      createdAt: createdAt ?? this.createdAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (memberUuid.present) {
      map['member_uuid'] = Variable<String>(memberUuid.value);
    }
    if (type.present) {
      map['type'] = Variable<String>(type.value);
    }
    if (pointsDelta.present) {
      map['points_delta'] = Variable<double>(pointsDelta.value);
    }
    if (orderUuid.present) {
      map['order_uuid'] = Variable<String>(orderUuid.value);
    }
    if (rewardUuid.present) {
      map['reward_uuid'] = Variable<String>(rewardUuid.value);
    }
    if (reason.present) {
      map['reason'] = Variable<String>(reason.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('LoyaltyTransactionTableCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('memberUuid: $memberUuid, ')
          ..write('type: $type, ')
          ..write('pointsDelta: $pointsDelta, ')
          ..write('orderUuid: $orderUuid, ')
          ..write('rewardUuid: $rewardUuid, ')
          ..write('reason: $reason, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }
}

class $LoyaltyRewardTableTable extends LoyaltyRewardTable
    with TableInfo<$LoyaltyRewardTableTable, LoyaltyRewardData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $LoyaltyRewardTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _descriptionMeta =
      const VerificationMeta('description');
  @override
  late final GeneratedColumn<String> description = GeneratedColumn<String>(
      'description', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _pointsCostMeta =
      const VerificationMeta('pointsCost');
  @override
  late final GeneratedColumn<double> pointsCost = GeneratedColumn<double>(
      'points_cost', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _discountTypeMeta =
      const VerificationMeta('discountType');
  @override
  late final GeneratedColumn<String> discountType = GeneratedColumn<String>(
      'discount_type', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _discountValueMeta =
      const VerificationMeta('discountValue');
  @override
  late final GeneratedColumn<double> discountValue = GeneratedColumn<double>(
      'discount_value', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _applicableProductUuidMeta =
      const VerificationMeta('applicableProductUuid');
  @override
  late final GeneratedColumn<String> applicableProductUuid =
      GeneratedColumn<String>('applicable_product_uuid', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isActiveMeta =
      const VerificationMeta('isActive');
  @override
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
      'is_active', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_active" IN (0, 1))'),
      defaultValue: const Constant(true));
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        name,
        description,
        pointsCost,
        discountType,
        discountValue,
        applicableProductUuid,
        isActive
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'loyalty_reward_table';
  @override
  VerificationContext validateIntegrity(Insertable<LoyaltyRewardData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('description')) {
      context.handle(
          _descriptionMeta,
          description.isAcceptableOrUnknown(
              data['description']!, _descriptionMeta));
    }
    if (data.containsKey('points_cost')) {
      context.handle(
          _pointsCostMeta,
          pointsCost.isAcceptableOrUnknown(
              data['points_cost']!, _pointsCostMeta));
    } else if (isInserting) {
      context.missing(_pointsCostMeta);
    }
    if (data.containsKey('discount_type')) {
      context.handle(
          _discountTypeMeta,
          discountType.isAcceptableOrUnknown(
              data['discount_type']!, _discountTypeMeta));
    } else if (isInserting) {
      context.missing(_discountTypeMeta);
    }
    if (data.containsKey('discount_value')) {
      context.handle(
          _discountValueMeta,
          discountValue.isAcceptableOrUnknown(
              data['discount_value']!, _discountValueMeta));
    } else if (isInserting) {
      context.missing(_discountValueMeta);
    }
    if (data.containsKey('applicable_product_uuid')) {
      context.handle(
          _applicableProductUuidMeta,
          applicableProductUuid.isAcceptableOrUnknown(
              data['applicable_product_uuid']!, _applicableProductUuidMeta));
    }
    if (data.containsKey('is_active')) {
      context.handle(_isActiveMeta,
          isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  LoyaltyRewardData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return LoyaltyRewardData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
      description: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}description']),
      pointsCost: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}points_cost'])!,
      discountType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}discount_type'])!,
      discountValue: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}discount_value'])!,
      applicableProductUuid: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}applicable_product_uuid']),
      isActive: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_active'])!,
    );
  }

  @override
  $LoyaltyRewardTableTable createAlias(String alias) {
    return $LoyaltyRewardTableTable(attachedDatabase, alias);
  }
}

class LoyaltyRewardData extends DataClass
    implements Insertable<LoyaltyRewardData> {
  final int id;
  final String uuid;
  final String name;
  final String? description;
  final double pointsCost;
  final String discountType;
  final double discountValue;
  final String? applicableProductUuid;
  final bool isActive;
  const LoyaltyRewardData(
      {required this.id,
      required this.uuid,
      required this.name,
      this.description,
      required this.pointsCost,
      required this.discountType,
      required this.discountValue,
      this.applicableProductUuid,
      required this.isActive});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || description != null) {
      map['description'] = Variable<String>(description);
    }
    map['points_cost'] = Variable<double>(pointsCost);
    map['discount_type'] = Variable<String>(discountType);
    map['discount_value'] = Variable<double>(discountValue);
    if (!nullToAbsent || applicableProductUuid != null) {
      map['applicable_product_uuid'] = Variable<String>(applicableProductUuid);
    }
    map['is_active'] = Variable<bool>(isActive);
    return map;
  }

  LoyaltyRewardTableCompanion toCompanion(bool nullToAbsent) {
    return LoyaltyRewardTableCompanion(
      id: Value(id),
      uuid: Value(uuid),
      name: Value(name),
      description: description == null && nullToAbsent
          ? const Value.absent()
          : Value(description),
      pointsCost: Value(pointsCost),
      discountType: Value(discountType),
      discountValue: Value(discountValue),
      applicableProductUuid: applicableProductUuid == null && nullToAbsent
          ? const Value.absent()
          : Value(applicableProductUuid),
      isActive: Value(isActive),
    );
  }

  factory LoyaltyRewardData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return LoyaltyRewardData(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      name: serializer.fromJson<String>(json['name']),
      description: serializer.fromJson<String?>(json['description']),
      pointsCost: serializer.fromJson<double>(json['pointsCost']),
      discountType: serializer.fromJson<String>(json['discountType']),
      discountValue: serializer.fromJson<double>(json['discountValue']),
      applicableProductUuid:
          serializer.fromJson<String?>(json['applicableProductUuid']),
      isActive: serializer.fromJson<bool>(json['isActive']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'name': serializer.toJson<String>(name),
      'description': serializer.toJson<String?>(description),
      'pointsCost': serializer.toJson<double>(pointsCost),
      'discountType': serializer.toJson<String>(discountType),
      'discountValue': serializer.toJson<double>(discountValue),
      'applicableProductUuid':
          serializer.toJson<String?>(applicableProductUuid),
      'isActive': serializer.toJson<bool>(isActive),
    };
  }

  LoyaltyRewardData copyWith(
          {int? id,
          String? uuid,
          String? name,
          Value<String?> description = const Value.absent(),
          double? pointsCost,
          String? discountType,
          double? discountValue,
          Value<String?> applicableProductUuid = const Value.absent(),
          bool? isActive}) =>
      LoyaltyRewardData(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        name: name ?? this.name,
        description: description.present ? description.value : this.description,
        pointsCost: pointsCost ?? this.pointsCost,
        discountType: discountType ?? this.discountType,
        discountValue: discountValue ?? this.discountValue,
        applicableProductUuid: applicableProductUuid.present
            ? applicableProductUuid.value
            : this.applicableProductUuid,
        isActive: isActive ?? this.isActive,
      );
  LoyaltyRewardData copyWithCompanion(LoyaltyRewardTableCompanion data) {
    return LoyaltyRewardData(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      name: data.name.present ? data.name.value : this.name,
      description:
          data.description.present ? data.description.value : this.description,
      pointsCost:
          data.pointsCost.present ? data.pointsCost.value : this.pointsCost,
      discountType: data.discountType.present
          ? data.discountType.value
          : this.discountType,
      discountValue: data.discountValue.present
          ? data.discountValue.value
          : this.discountValue,
      applicableProductUuid: data.applicableProductUuid.present
          ? data.applicableProductUuid.value
          : this.applicableProductUuid,
      isActive: data.isActive.present ? data.isActive.value : this.isActive,
    );
  }

  @override
  String toString() {
    return (StringBuffer('LoyaltyRewardData(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('description: $description, ')
          ..write('pointsCost: $pointsCost, ')
          ..write('discountType: $discountType, ')
          ..write('discountValue: $discountValue, ')
          ..write('applicableProductUuid: $applicableProductUuid, ')
          ..write('isActive: $isActive')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, uuid, name, description, pointsCost,
      discountType, discountValue, applicableProductUuid, isActive);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is LoyaltyRewardData &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.name == this.name &&
          other.description == this.description &&
          other.pointsCost == this.pointsCost &&
          other.discountType == this.discountType &&
          other.discountValue == this.discountValue &&
          other.applicableProductUuid == this.applicableProductUuid &&
          other.isActive == this.isActive);
}

class LoyaltyRewardTableCompanion extends UpdateCompanion<LoyaltyRewardData> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String> name;
  final Value<String?> description;
  final Value<double> pointsCost;
  final Value<String> discountType;
  final Value<double> discountValue;
  final Value<String?> applicableProductUuid;
  final Value<bool> isActive;
  const LoyaltyRewardTableCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.name = const Value.absent(),
    this.description = const Value.absent(),
    this.pointsCost = const Value.absent(),
    this.discountType = const Value.absent(),
    this.discountValue = const Value.absent(),
    this.applicableProductUuid = const Value.absent(),
    this.isActive = const Value.absent(),
  });
  LoyaltyRewardTableCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    required String name,
    this.description = const Value.absent(),
    required double pointsCost,
    required String discountType,
    required double discountValue,
    this.applicableProductUuid = const Value.absent(),
    this.isActive = const Value.absent(),
  })  : uuid = Value(uuid),
        name = Value(name),
        pointsCost = Value(pointsCost),
        discountType = Value(discountType),
        discountValue = Value(discountValue);
  static Insertable<LoyaltyRewardData> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? name,
    Expression<String>? description,
    Expression<double>? pointsCost,
    Expression<String>? discountType,
    Expression<double>? discountValue,
    Expression<String>? applicableProductUuid,
    Expression<bool>? isActive,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (name != null) 'name': name,
      if (description != null) 'description': description,
      if (pointsCost != null) 'points_cost': pointsCost,
      if (discountType != null) 'discount_type': discountType,
      if (discountValue != null) 'discount_value': discountValue,
      if (applicableProductUuid != null)
        'applicable_product_uuid': applicableProductUuid,
      if (isActive != null) 'is_active': isActive,
    });
  }

  LoyaltyRewardTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String>? name,
      Value<String?>? description,
      Value<double>? pointsCost,
      Value<String>? discountType,
      Value<double>? discountValue,
      Value<String?>? applicableProductUuid,
      Value<bool>? isActive}) {
    return LoyaltyRewardTableCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      name: name ?? this.name,
      description: description ?? this.description,
      pointsCost: pointsCost ?? this.pointsCost,
      discountType: discountType ?? this.discountType,
      discountValue: discountValue ?? this.discountValue,
      applicableProductUuid:
          applicableProductUuid ?? this.applicableProductUuid,
      isActive: isActive ?? this.isActive,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (description.present) {
      map['description'] = Variable<String>(description.value);
    }
    if (pointsCost.present) {
      map['points_cost'] = Variable<double>(pointsCost.value);
    }
    if (discountType.present) {
      map['discount_type'] = Variable<String>(discountType.value);
    }
    if (discountValue.present) {
      map['discount_value'] = Variable<double>(discountValue.value);
    }
    if (applicableProductUuid.present) {
      map['applicable_product_uuid'] =
          Variable<String>(applicableProductUuid.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('LoyaltyRewardTableCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('description: $description, ')
          ..write('pointsCost: $pointsCost, ')
          ..write('discountType: $discountType, ')
          ..write('discountValue: $discountValue, ')
          ..write('applicableProductUuid: $applicableProductUuid, ')
          ..write('isActive: $isActive')
          ..write(')'))
        .toString();
  }
}

class $TipTableTable extends TipTable
    with TableInfo<$TipTableTable, TipTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $TipTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _orderUuidMeta =
      const VerificationMeta('orderUuid');
  @override
  late final GeneratedColumn<String> orderUuid = GeneratedColumn<String>(
      'order_uuid', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _orderNumberMeta =
      const VerificationMeta('orderNumber');
  @override
  late final GeneratedColumn<String> orderNumber = GeneratedColumn<String>(
      'order_number', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _tipTypeMeta =
      const VerificationMeta('tipType');
  @override
  late final GeneratedColumn<String> tipType = GeneratedColumn<String>(
      'tip_type', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _amountMeta = const VerificationMeta('amount');
  @override
  late final GeneratedColumn<double> amount = GeneratedColumn<double>(
      'amount', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _processedByUuidMeta =
      const VerificationMeta('processedByUuid');
  @override
  late final GeneratedColumn<String> processedByUuid = GeneratedColumn<String>(
      'processed_by_uuid', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _processedByNameMeta =
      const VerificationMeta('processedByName');
  @override
  late final GeneratedColumn<String> processedByName = GeneratedColumn<String>(
      'processed_by_name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _isPooledMeta =
      const VerificationMeta('isPooled');
  @override
  late final GeneratedColumn<bool> isPooled = GeneratedColumn<bool>(
      'is_pooled', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_pooled" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _poolUuidMeta =
      const VerificationMeta('poolUuid');
  @override
  late final GeneratedColumn<String> poolUuid = GeneratedColumn<String>(
      'pool_uuid', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
      'notes', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        orderUuid,
        orderNumber,
        tipType,
        amount,
        processedByUuid,
        processedByName,
        isPooled,
        poolUuid,
        notes,
        createdAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'tip_table';
  @override
  VerificationContext validateIntegrity(Insertable<TipTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('order_uuid')) {
      context.handle(_orderUuidMeta,
          orderUuid.isAcceptableOrUnknown(data['order_uuid']!, _orderUuidMeta));
    } else if (isInserting) {
      context.missing(_orderUuidMeta);
    }
    if (data.containsKey('order_number')) {
      context.handle(
          _orderNumberMeta,
          orderNumber.isAcceptableOrUnknown(
              data['order_number']!, _orderNumberMeta));
    } else if (isInserting) {
      context.missing(_orderNumberMeta);
    }
    if (data.containsKey('tip_type')) {
      context.handle(_tipTypeMeta,
          tipType.isAcceptableOrUnknown(data['tip_type']!, _tipTypeMeta));
    } else if (isInserting) {
      context.missing(_tipTypeMeta);
    }
    if (data.containsKey('amount')) {
      context.handle(_amountMeta,
          amount.isAcceptableOrUnknown(data['amount']!, _amountMeta));
    } else if (isInserting) {
      context.missing(_amountMeta);
    }
    if (data.containsKey('processed_by_uuid')) {
      context.handle(
          _processedByUuidMeta,
          processedByUuid.isAcceptableOrUnknown(
              data['processed_by_uuid']!, _processedByUuidMeta));
    } else if (isInserting) {
      context.missing(_processedByUuidMeta);
    }
    if (data.containsKey('processed_by_name')) {
      context.handle(
          _processedByNameMeta,
          processedByName.isAcceptableOrUnknown(
              data['processed_by_name']!, _processedByNameMeta));
    } else if (isInserting) {
      context.missing(_processedByNameMeta);
    }
    if (data.containsKey('is_pooled')) {
      context.handle(_isPooledMeta,
          isPooled.isAcceptableOrUnknown(data['is_pooled']!, _isPooledMeta));
    }
    if (data.containsKey('pool_uuid')) {
      context.handle(_poolUuidMeta,
          poolUuid.isAcceptableOrUnknown(data['pool_uuid']!, _poolUuidMeta));
    }
    if (data.containsKey('notes')) {
      context.handle(
          _notesMeta, notes.isAcceptableOrUnknown(data['notes']!, _notesMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  TipTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return TipTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      orderUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}order_uuid'])!,
      orderNumber: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}order_number'])!,
      tipType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tip_type'])!,
      amount: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}amount'])!,
      processedByUuid: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}processed_by_uuid'])!,
      processedByName: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}processed_by_name'])!,
      isPooled: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_pooled'])!,
      poolUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}pool_uuid']),
      notes: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}notes']),
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
    );
  }

  @override
  $TipTableTable createAlias(String alias) {
    return $TipTableTable(attachedDatabase, alias);
  }
}

class TipTableData extends DataClass implements Insertable<TipTableData> {
  final int id;
  final String uuid;
  final String orderUuid;
  final String orderNumber;
  final String tipType;
  final double amount;
  final String processedByUuid;
  final String processedByName;
  final bool isPooled;
  final String? poolUuid;
  final String? notes;
  final DateTime createdAt;
  const TipTableData(
      {required this.id,
      required this.uuid,
      required this.orderUuid,
      required this.orderNumber,
      required this.tipType,
      required this.amount,
      required this.processedByUuid,
      required this.processedByName,
      required this.isPooled,
      this.poolUuid,
      this.notes,
      required this.createdAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    map['order_uuid'] = Variable<String>(orderUuid);
    map['order_number'] = Variable<String>(orderNumber);
    map['tip_type'] = Variable<String>(tipType);
    map['amount'] = Variable<double>(amount);
    map['processed_by_uuid'] = Variable<String>(processedByUuid);
    map['processed_by_name'] = Variable<String>(processedByName);
    map['is_pooled'] = Variable<bool>(isPooled);
    if (!nullToAbsent || poolUuid != null) {
      map['pool_uuid'] = Variable<String>(poolUuid);
    }
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    return map;
  }

  TipTableCompanion toCompanion(bool nullToAbsent) {
    return TipTableCompanion(
      id: Value(id),
      uuid: Value(uuid),
      orderUuid: Value(orderUuid),
      orderNumber: Value(orderNumber),
      tipType: Value(tipType),
      amount: Value(amount),
      processedByUuid: Value(processedByUuid),
      processedByName: Value(processedByName),
      isPooled: Value(isPooled),
      poolUuid: poolUuid == null && nullToAbsent
          ? const Value.absent()
          : Value(poolUuid),
      notes:
          notes == null && nullToAbsent ? const Value.absent() : Value(notes),
      createdAt: Value(createdAt),
    );
  }

  factory TipTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return TipTableData(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      orderUuid: serializer.fromJson<String>(json['orderUuid']),
      orderNumber: serializer.fromJson<String>(json['orderNumber']),
      tipType: serializer.fromJson<String>(json['tipType']),
      amount: serializer.fromJson<double>(json['amount']),
      processedByUuid: serializer.fromJson<String>(json['processedByUuid']),
      processedByName: serializer.fromJson<String>(json['processedByName']),
      isPooled: serializer.fromJson<bool>(json['isPooled']),
      poolUuid: serializer.fromJson<String?>(json['poolUuid']),
      notes: serializer.fromJson<String?>(json['notes']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'orderUuid': serializer.toJson<String>(orderUuid),
      'orderNumber': serializer.toJson<String>(orderNumber),
      'tipType': serializer.toJson<String>(tipType),
      'amount': serializer.toJson<double>(amount),
      'processedByUuid': serializer.toJson<String>(processedByUuid),
      'processedByName': serializer.toJson<String>(processedByName),
      'isPooled': serializer.toJson<bool>(isPooled),
      'poolUuid': serializer.toJson<String?>(poolUuid),
      'notes': serializer.toJson<String?>(notes),
      'createdAt': serializer.toJson<DateTime>(createdAt),
    };
  }

  TipTableData copyWith(
          {int? id,
          String? uuid,
          String? orderUuid,
          String? orderNumber,
          String? tipType,
          double? amount,
          String? processedByUuid,
          String? processedByName,
          bool? isPooled,
          Value<String?> poolUuid = const Value.absent(),
          Value<String?> notes = const Value.absent(),
          DateTime? createdAt}) =>
      TipTableData(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        orderUuid: orderUuid ?? this.orderUuid,
        orderNumber: orderNumber ?? this.orderNumber,
        tipType: tipType ?? this.tipType,
        amount: amount ?? this.amount,
        processedByUuid: processedByUuid ?? this.processedByUuid,
        processedByName: processedByName ?? this.processedByName,
        isPooled: isPooled ?? this.isPooled,
        poolUuid: poolUuid.present ? poolUuid.value : this.poolUuid,
        notes: notes.present ? notes.value : this.notes,
        createdAt: createdAt ?? this.createdAt,
      );
  TipTableData copyWithCompanion(TipTableCompanion data) {
    return TipTableData(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      orderUuid: data.orderUuid.present ? data.orderUuid.value : this.orderUuid,
      orderNumber:
          data.orderNumber.present ? data.orderNumber.value : this.orderNumber,
      tipType: data.tipType.present ? data.tipType.value : this.tipType,
      amount: data.amount.present ? data.amount.value : this.amount,
      processedByUuid: data.processedByUuid.present
          ? data.processedByUuid.value
          : this.processedByUuid,
      processedByName: data.processedByName.present
          ? data.processedByName.value
          : this.processedByName,
      isPooled: data.isPooled.present ? data.isPooled.value : this.isPooled,
      poolUuid: data.poolUuid.present ? data.poolUuid.value : this.poolUuid,
      notes: data.notes.present ? data.notes.value : this.notes,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('TipTableData(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('orderUuid: $orderUuid, ')
          ..write('orderNumber: $orderNumber, ')
          ..write('tipType: $tipType, ')
          ..write('amount: $amount, ')
          ..write('processedByUuid: $processedByUuid, ')
          ..write('processedByName: $processedByName, ')
          ..write('isPooled: $isPooled, ')
          ..write('poolUuid: $poolUuid, ')
          ..write('notes: $notes, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      uuid,
      orderUuid,
      orderNumber,
      tipType,
      amount,
      processedByUuid,
      processedByName,
      isPooled,
      poolUuid,
      notes,
      createdAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is TipTableData &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.orderUuid == this.orderUuid &&
          other.orderNumber == this.orderNumber &&
          other.tipType == this.tipType &&
          other.amount == this.amount &&
          other.processedByUuid == this.processedByUuid &&
          other.processedByName == this.processedByName &&
          other.isPooled == this.isPooled &&
          other.poolUuid == this.poolUuid &&
          other.notes == this.notes &&
          other.createdAt == this.createdAt);
}

class TipTableCompanion extends UpdateCompanion<TipTableData> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String> orderUuid;
  final Value<String> orderNumber;
  final Value<String> tipType;
  final Value<double> amount;
  final Value<String> processedByUuid;
  final Value<String> processedByName;
  final Value<bool> isPooled;
  final Value<String?> poolUuid;
  final Value<String?> notes;
  final Value<DateTime> createdAt;
  const TipTableCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.orderUuid = const Value.absent(),
    this.orderNumber = const Value.absent(),
    this.tipType = const Value.absent(),
    this.amount = const Value.absent(),
    this.processedByUuid = const Value.absent(),
    this.processedByName = const Value.absent(),
    this.isPooled = const Value.absent(),
    this.poolUuid = const Value.absent(),
    this.notes = const Value.absent(),
    this.createdAt = const Value.absent(),
  });
  TipTableCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    required String orderUuid,
    required String orderNumber,
    required String tipType,
    required double amount,
    required String processedByUuid,
    required String processedByName,
    this.isPooled = const Value.absent(),
    this.poolUuid = const Value.absent(),
    this.notes = const Value.absent(),
    required DateTime createdAt,
  })  : uuid = Value(uuid),
        orderUuid = Value(orderUuid),
        orderNumber = Value(orderNumber),
        tipType = Value(tipType),
        amount = Value(amount),
        processedByUuid = Value(processedByUuid),
        processedByName = Value(processedByName),
        createdAt = Value(createdAt);
  static Insertable<TipTableData> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? orderUuid,
    Expression<String>? orderNumber,
    Expression<String>? tipType,
    Expression<double>? amount,
    Expression<String>? processedByUuid,
    Expression<String>? processedByName,
    Expression<bool>? isPooled,
    Expression<String>? poolUuid,
    Expression<String>? notes,
    Expression<DateTime>? createdAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (orderUuid != null) 'order_uuid': orderUuid,
      if (orderNumber != null) 'order_number': orderNumber,
      if (tipType != null) 'tip_type': tipType,
      if (amount != null) 'amount': amount,
      if (processedByUuid != null) 'processed_by_uuid': processedByUuid,
      if (processedByName != null) 'processed_by_name': processedByName,
      if (isPooled != null) 'is_pooled': isPooled,
      if (poolUuid != null) 'pool_uuid': poolUuid,
      if (notes != null) 'notes': notes,
      if (createdAt != null) 'created_at': createdAt,
    });
  }

  TipTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String>? orderUuid,
      Value<String>? orderNumber,
      Value<String>? tipType,
      Value<double>? amount,
      Value<String>? processedByUuid,
      Value<String>? processedByName,
      Value<bool>? isPooled,
      Value<String?>? poolUuid,
      Value<String?>? notes,
      Value<DateTime>? createdAt}) {
    return TipTableCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      orderUuid: orderUuid ?? this.orderUuid,
      orderNumber: orderNumber ?? this.orderNumber,
      tipType: tipType ?? this.tipType,
      amount: amount ?? this.amount,
      processedByUuid: processedByUuid ?? this.processedByUuid,
      processedByName: processedByName ?? this.processedByName,
      isPooled: isPooled ?? this.isPooled,
      poolUuid: poolUuid ?? this.poolUuid,
      notes: notes ?? this.notes,
      createdAt: createdAt ?? this.createdAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (orderUuid.present) {
      map['order_uuid'] = Variable<String>(orderUuid.value);
    }
    if (orderNumber.present) {
      map['order_number'] = Variable<String>(orderNumber.value);
    }
    if (tipType.present) {
      map['tip_type'] = Variable<String>(tipType.value);
    }
    if (amount.present) {
      map['amount'] = Variable<double>(amount.value);
    }
    if (processedByUuid.present) {
      map['processed_by_uuid'] = Variable<String>(processedByUuid.value);
    }
    if (processedByName.present) {
      map['processed_by_name'] = Variable<String>(processedByName.value);
    }
    if (isPooled.present) {
      map['is_pooled'] = Variable<bool>(isPooled.value);
    }
    if (poolUuid.present) {
      map['pool_uuid'] = Variable<String>(poolUuid.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('TipTableCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('orderUuid: $orderUuid, ')
          ..write('orderNumber: $orderNumber, ')
          ..write('tipType: $tipType, ')
          ..write('amount: $amount, ')
          ..write('processedByUuid: $processedByUuid, ')
          ..write('processedByName: $processedByName, ')
          ..write('isPooled: $isPooled, ')
          ..write('poolUuid: $poolUuid, ')
          ..write('notes: $notes, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }
}

class $TipPoolConfigTableTable extends TipPoolConfigTable
    with TableInfo<$TipPoolConfigTableTable, TipPoolConfigTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $TipPoolConfigTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _methodMeta = const VerificationMeta('method');
  @override
  late final GeneratedColumn<String> method = GeneratedColumn<String>(
      'method', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultValue: const Constant('equal'));
  static const VerificationMeta _isActiveMeta =
      const VerificationMeta('isActive');
  @override
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
      'is_active', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_active" IN (0, 1))'),
      defaultValue: const Constant(true));
  static const VerificationMeta _rolePercentagesJsonMeta =
      const VerificationMeta('rolePercentagesJson');
  @override
  late final GeneratedColumn<String> rolePercentagesJson =
      GeneratedColumn<String>('role_percentages_json', aliasedName, false,
          type: DriftSqlType.string,
          requiredDuringInsert: false,
          defaultValue: const Constant('{}'));
  static const VerificationMeta _rolePointsJsonMeta =
      const VerificationMeta('rolePointsJson');
  @override
  late final GeneratedColumn<String> rolePointsJson = GeneratedColumn<String>(
      'role_points_json', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultValue: const Constant('{}'));
  static const VerificationMeta _excludedRolesJsonMeta =
      const VerificationMeta('excludedRolesJson');
  @override
  late final GeneratedColumn<String> excludedRolesJson =
      GeneratedColumn<String>('excluded_roles_json', aliasedName, false,
          type: DriftSqlType.string,
          requiredDuringInsert: false,
          defaultValue: const Constant('[]'));
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        name,
        method,
        isActive,
        rolePercentagesJson,
        rolePointsJson,
        excludedRolesJson,
        createdAt,
        updatedAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'tip_pool_config_table';
  @override
  VerificationContext validateIntegrity(
      Insertable<TipPoolConfigTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('method')) {
      context.handle(_methodMeta,
          method.isAcceptableOrUnknown(data['method']!, _methodMeta));
    }
    if (data.containsKey('is_active')) {
      context.handle(_isActiveMeta,
          isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta));
    }
    if (data.containsKey('role_percentages_json')) {
      context.handle(
          _rolePercentagesJsonMeta,
          rolePercentagesJson.isAcceptableOrUnknown(
              data['role_percentages_json']!, _rolePercentagesJsonMeta));
    }
    if (data.containsKey('role_points_json')) {
      context.handle(
          _rolePointsJsonMeta,
          rolePointsJson.isAcceptableOrUnknown(
              data['role_points_json']!, _rolePointsJsonMeta));
    }
    if (data.containsKey('excluded_roles_json')) {
      context.handle(
          _excludedRolesJsonMeta,
          excludedRolesJson.isAcceptableOrUnknown(
              data['excluded_roles_json']!, _excludedRolesJsonMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  TipPoolConfigTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return TipPoolConfigTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
      method: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}method'])!,
      isActive: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_active'])!,
      rolePercentagesJson: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}role_percentages_json'])!,
      rolePointsJson: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}role_points_json'])!,
      excludedRolesJson: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}excluded_roles_json'])!,
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $TipPoolConfigTableTable createAlias(String alias) {
    return $TipPoolConfigTableTable(attachedDatabase, alias);
  }
}

class TipPoolConfigTableData extends DataClass
    implements Insertable<TipPoolConfigTableData> {
  final int id;
  final String uuid;
  final String name;
  final String method;
  final bool isActive;
  final String rolePercentagesJson;
  final String rolePointsJson;
  final String excludedRolesJson;
  final DateTime createdAt;
  final DateTime updatedAt;
  const TipPoolConfigTableData(
      {required this.id,
      required this.uuid,
      required this.name,
      required this.method,
      required this.isActive,
      required this.rolePercentagesJson,
      required this.rolePointsJson,
      required this.excludedRolesJson,
      required this.createdAt,
      required this.updatedAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    map['name'] = Variable<String>(name);
    map['method'] = Variable<String>(method);
    map['is_active'] = Variable<bool>(isActive);
    map['role_percentages_json'] = Variable<String>(rolePercentagesJson);
    map['role_points_json'] = Variable<String>(rolePointsJson);
    map['excluded_roles_json'] = Variable<String>(excludedRolesJson);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  TipPoolConfigTableCompanion toCompanion(bool nullToAbsent) {
    return TipPoolConfigTableCompanion(
      id: Value(id),
      uuid: Value(uuid),
      name: Value(name),
      method: Value(method),
      isActive: Value(isActive),
      rolePercentagesJson: Value(rolePercentagesJson),
      rolePointsJson: Value(rolePointsJson),
      excludedRolesJson: Value(excludedRolesJson),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory TipPoolConfigTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return TipPoolConfigTableData(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      name: serializer.fromJson<String>(json['name']),
      method: serializer.fromJson<String>(json['method']),
      isActive: serializer.fromJson<bool>(json['isActive']),
      rolePercentagesJson:
          serializer.fromJson<String>(json['rolePercentagesJson']),
      rolePointsJson: serializer.fromJson<String>(json['rolePointsJson']),
      excludedRolesJson: serializer.fromJson<String>(json['excludedRolesJson']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'name': serializer.toJson<String>(name),
      'method': serializer.toJson<String>(method),
      'isActive': serializer.toJson<bool>(isActive),
      'rolePercentagesJson': serializer.toJson<String>(rolePercentagesJson),
      'rolePointsJson': serializer.toJson<String>(rolePointsJson),
      'excludedRolesJson': serializer.toJson<String>(excludedRolesJson),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  TipPoolConfigTableData copyWith(
          {int? id,
          String? uuid,
          String? name,
          String? method,
          bool? isActive,
          String? rolePercentagesJson,
          String? rolePointsJson,
          String? excludedRolesJson,
          DateTime? createdAt,
          DateTime? updatedAt}) =>
      TipPoolConfigTableData(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        name: name ?? this.name,
        method: method ?? this.method,
        isActive: isActive ?? this.isActive,
        rolePercentagesJson: rolePercentagesJson ?? this.rolePercentagesJson,
        rolePointsJson: rolePointsJson ?? this.rolePointsJson,
        excludedRolesJson: excludedRolesJson ?? this.excludedRolesJson,
        createdAt: createdAt ?? this.createdAt,
        updatedAt: updatedAt ?? this.updatedAt,
      );
  TipPoolConfigTableData copyWithCompanion(TipPoolConfigTableCompanion data) {
    return TipPoolConfigTableData(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      name: data.name.present ? data.name.value : this.name,
      method: data.method.present ? data.method.value : this.method,
      isActive: data.isActive.present ? data.isActive.value : this.isActive,
      rolePercentagesJson: data.rolePercentagesJson.present
          ? data.rolePercentagesJson.value
          : this.rolePercentagesJson,
      rolePointsJson: data.rolePointsJson.present
          ? data.rolePointsJson.value
          : this.rolePointsJson,
      excludedRolesJson: data.excludedRolesJson.present
          ? data.excludedRolesJson.value
          : this.excludedRolesJson,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('TipPoolConfigTableData(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('method: $method, ')
          ..write('isActive: $isActive, ')
          ..write('rolePercentagesJson: $rolePercentagesJson, ')
          ..write('rolePointsJson: $rolePointsJson, ')
          ..write('excludedRolesJson: $excludedRolesJson, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      uuid,
      name,
      method,
      isActive,
      rolePercentagesJson,
      rolePointsJson,
      excludedRolesJson,
      createdAt,
      updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is TipPoolConfigTableData &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.name == this.name &&
          other.method == this.method &&
          other.isActive == this.isActive &&
          other.rolePercentagesJson == this.rolePercentagesJson &&
          other.rolePointsJson == this.rolePointsJson &&
          other.excludedRolesJson == this.excludedRolesJson &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class TipPoolConfigTableCompanion
    extends UpdateCompanion<TipPoolConfigTableData> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String> name;
  final Value<String> method;
  final Value<bool> isActive;
  final Value<String> rolePercentagesJson;
  final Value<String> rolePointsJson;
  final Value<String> excludedRolesJson;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  const TipPoolConfigTableCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.name = const Value.absent(),
    this.method = const Value.absent(),
    this.isActive = const Value.absent(),
    this.rolePercentagesJson = const Value.absent(),
    this.rolePointsJson = const Value.absent(),
    this.excludedRolesJson = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  TipPoolConfigTableCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    required String name,
    this.method = const Value.absent(),
    this.isActive = const Value.absent(),
    this.rolePercentagesJson = const Value.absent(),
    this.rolePointsJson = const Value.absent(),
    this.excludedRolesJson = const Value.absent(),
    required DateTime createdAt,
    required DateTime updatedAt,
  })  : uuid = Value(uuid),
        name = Value(name),
        createdAt = Value(createdAt),
        updatedAt = Value(updatedAt);
  static Insertable<TipPoolConfigTableData> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? name,
    Expression<String>? method,
    Expression<bool>? isActive,
    Expression<String>? rolePercentagesJson,
    Expression<String>? rolePointsJson,
    Expression<String>? excludedRolesJson,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (name != null) 'name': name,
      if (method != null) 'method': method,
      if (isActive != null) 'is_active': isActive,
      if (rolePercentagesJson != null)
        'role_percentages_json': rolePercentagesJson,
      if (rolePointsJson != null) 'role_points_json': rolePointsJson,
      if (excludedRolesJson != null) 'excluded_roles_json': excludedRolesJson,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  TipPoolConfigTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String>? name,
      Value<String>? method,
      Value<bool>? isActive,
      Value<String>? rolePercentagesJson,
      Value<String>? rolePointsJson,
      Value<String>? excludedRolesJson,
      Value<DateTime>? createdAt,
      Value<DateTime>? updatedAt}) {
    return TipPoolConfigTableCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      name: name ?? this.name,
      method: method ?? this.method,
      isActive: isActive ?? this.isActive,
      rolePercentagesJson: rolePercentagesJson ?? this.rolePercentagesJson,
      rolePointsJson: rolePointsJson ?? this.rolePointsJson,
      excludedRolesJson: excludedRolesJson ?? this.excludedRolesJson,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (method.present) {
      map['method'] = Variable<String>(method.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (rolePercentagesJson.present) {
      map['role_percentages_json'] =
          Variable<String>(rolePercentagesJson.value);
    }
    if (rolePointsJson.present) {
      map['role_points_json'] = Variable<String>(rolePointsJson.value);
    }
    if (excludedRolesJson.present) {
      map['excluded_roles_json'] = Variable<String>(excludedRolesJson.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('TipPoolConfigTableCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('method: $method, ')
          ..write('isActive: $isActive, ')
          ..write('rolePercentagesJson: $rolePercentagesJson, ')
          ..write('rolePointsJson: $rolePointsJson, ')
          ..write('excludedRolesJson: $excludedRolesJson, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class $TipDistributionTableTable extends TipDistributionTable
    with TableInfo<$TipDistributionTableTable, TipDistributionTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $TipDistributionTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _tipUuidMeta =
      const VerificationMeta('tipUuid');
  @override
  late final GeneratedColumn<String> tipUuid = GeneratedColumn<String>(
      'tip_uuid', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _employeeUuidMeta =
      const VerificationMeta('employeeUuid');
  @override
  late final GeneratedColumn<String> employeeUuid = GeneratedColumn<String>(
      'employee_uuid', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _employeeNameMeta =
      const VerificationMeta('employeeName');
  @override
  late final GeneratedColumn<String> employeeName = GeneratedColumn<String>(
      'employee_name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _employeeRoleMeta =
      const VerificationMeta('employeeRole');
  @override
  late final GeneratedColumn<String> employeeRole = GeneratedColumn<String>(
      'employee_role', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _amountMeta = const VerificationMeta('amount');
  @override
  late final GeneratedColumn<double> amount = GeneratedColumn<double>(
      'amount', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _percentageMeta =
      const VerificationMeta('percentage');
  @override
  late final GeneratedColumn<double> percentage = GeneratedColumn<double>(
      'percentage', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _hoursWorkedMeta =
      const VerificationMeta('hoursWorked');
  @override
  late final GeneratedColumn<double> hoursWorked = GeneratedColumn<double>(
      'hours_worked', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _pointsEarnedMeta =
      const VerificationMeta('pointsEarned');
  @override
  late final GeneratedColumn<double> pointsEarned = GeneratedColumn<double>(
      'points_earned', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _isPaidOutMeta =
      const VerificationMeta('isPaidOut');
  @override
  late final GeneratedColumn<bool> isPaidOut = GeneratedColumn<bool>(
      'is_paid_out', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_paid_out" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _paidOutAtMeta =
      const VerificationMeta('paidOutAt');
  @override
  late final GeneratedColumn<DateTime> paidOutAt = GeneratedColumn<DateTime>(
      'paid_out_at', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _paidOutByUuidMeta =
      const VerificationMeta('paidOutByUuid');
  @override
  late final GeneratedColumn<String> paidOutByUuid = GeneratedColumn<String>(
      'paid_out_by_uuid', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _distributedAtMeta =
      const VerificationMeta('distributedAt');
  @override
  late final GeneratedColumn<DateTime> distributedAt =
      GeneratedColumn<DateTime>('distributed_at', aliasedName, false,
          type: DriftSqlType.dateTime, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        tipUuid,
        employeeUuid,
        employeeName,
        employeeRole,
        amount,
        percentage,
        hoursWorked,
        pointsEarned,
        isPaidOut,
        paidOutAt,
        paidOutByUuid,
        distributedAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'tip_distribution_table';
  @override
  VerificationContext validateIntegrity(
      Insertable<TipDistributionTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('tip_uuid')) {
      context.handle(_tipUuidMeta,
          tipUuid.isAcceptableOrUnknown(data['tip_uuid']!, _tipUuidMeta));
    } else if (isInserting) {
      context.missing(_tipUuidMeta);
    }
    if (data.containsKey('employee_uuid')) {
      context.handle(
          _employeeUuidMeta,
          employeeUuid.isAcceptableOrUnknown(
              data['employee_uuid']!, _employeeUuidMeta));
    } else if (isInserting) {
      context.missing(_employeeUuidMeta);
    }
    if (data.containsKey('employee_name')) {
      context.handle(
          _employeeNameMeta,
          employeeName.isAcceptableOrUnknown(
              data['employee_name']!, _employeeNameMeta));
    } else if (isInserting) {
      context.missing(_employeeNameMeta);
    }
    if (data.containsKey('employee_role')) {
      context.handle(
          _employeeRoleMeta,
          employeeRole.isAcceptableOrUnknown(
              data['employee_role']!, _employeeRoleMeta));
    } else if (isInserting) {
      context.missing(_employeeRoleMeta);
    }
    if (data.containsKey('amount')) {
      context.handle(_amountMeta,
          amount.isAcceptableOrUnknown(data['amount']!, _amountMeta));
    } else if (isInserting) {
      context.missing(_amountMeta);
    }
    if (data.containsKey('percentage')) {
      context.handle(
          _percentageMeta,
          percentage.isAcceptableOrUnknown(
              data['percentage']!, _percentageMeta));
    } else if (isInserting) {
      context.missing(_percentageMeta);
    }
    if (data.containsKey('hours_worked')) {
      context.handle(
          _hoursWorkedMeta,
          hoursWorked.isAcceptableOrUnknown(
              data['hours_worked']!, _hoursWorkedMeta));
    }
    if (data.containsKey('points_earned')) {
      context.handle(
          _pointsEarnedMeta,
          pointsEarned.isAcceptableOrUnknown(
              data['points_earned']!, _pointsEarnedMeta));
    }
    if (data.containsKey('is_paid_out')) {
      context.handle(
          _isPaidOutMeta,
          isPaidOut.isAcceptableOrUnknown(
              data['is_paid_out']!, _isPaidOutMeta));
    }
    if (data.containsKey('paid_out_at')) {
      context.handle(
          _paidOutAtMeta,
          paidOutAt.isAcceptableOrUnknown(
              data['paid_out_at']!, _paidOutAtMeta));
    }
    if (data.containsKey('paid_out_by_uuid')) {
      context.handle(
          _paidOutByUuidMeta,
          paidOutByUuid.isAcceptableOrUnknown(
              data['paid_out_by_uuid']!, _paidOutByUuidMeta));
    }
    if (data.containsKey('distributed_at')) {
      context.handle(
          _distributedAtMeta,
          distributedAt.isAcceptableOrUnknown(
              data['distributed_at']!, _distributedAtMeta));
    } else if (isInserting) {
      context.missing(_distributedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  TipDistributionTableData map(Map<String, dynamic> data,
      {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return TipDistributionTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      tipUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tip_uuid'])!,
      employeeUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}employee_uuid'])!,
      employeeName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}employee_name'])!,
      employeeRole: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}employee_role'])!,
      amount: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}amount'])!,
      percentage: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}percentage'])!,
      hoursWorked: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}hours_worked']),
      pointsEarned: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}points_earned']),
      isPaidOut: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_paid_out'])!,
      paidOutAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}paid_out_at']),
      paidOutByUuid: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}paid_out_by_uuid']),
      distributedAt: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}distributed_at'])!,
    );
  }

  @override
  $TipDistributionTableTable createAlias(String alias) {
    return $TipDistributionTableTable(attachedDatabase, alias);
  }
}

class TipDistributionTableData extends DataClass
    implements Insertable<TipDistributionTableData> {
  final int id;
  final String uuid;
  final String tipUuid;
  final String employeeUuid;
  final String employeeName;
  final String employeeRole;
  final double amount;
  final double percentage;
  final double? hoursWorked;
  final double? pointsEarned;
  final bool isPaidOut;
  final DateTime? paidOutAt;
  final String? paidOutByUuid;
  final DateTime distributedAt;
  const TipDistributionTableData(
      {required this.id,
      required this.uuid,
      required this.tipUuid,
      required this.employeeUuid,
      required this.employeeName,
      required this.employeeRole,
      required this.amount,
      required this.percentage,
      this.hoursWorked,
      this.pointsEarned,
      required this.isPaidOut,
      this.paidOutAt,
      this.paidOutByUuid,
      required this.distributedAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    map['tip_uuid'] = Variable<String>(tipUuid);
    map['employee_uuid'] = Variable<String>(employeeUuid);
    map['employee_name'] = Variable<String>(employeeName);
    map['employee_role'] = Variable<String>(employeeRole);
    map['amount'] = Variable<double>(amount);
    map['percentage'] = Variable<double>(percentage);
    if (!nullToAbsent || hoursWorked != null) {
      map['hours_worked'] = Variable<double>(hoursWorked);
    }
    if (!nullToAbsent || pointsEarned != null) {
      map['points_earned'] = Variable<double>(pointsEarned);
    }
    map['is_paid_out'] = Variable<bool>(isPaidOut);
    if (!nullToAbsent || paidOutAt != null) {
      map['paid_out_at'] = Variable<DateTime>(paidOutAt);
    }
    if (!nullToAbsent || paidOutByUuid != null) {
      map['paid_out_by_uuid'] = Variable<String>(paidOutByUuid);
    }
    map['distributed_at'] = Variable<DateTime>(distributedAt);
    return map;
  }

  TipDistributionTableCompanion toCompanion(bool nullToAbsent) {
    return TipDistributionTableCompanion(
      id: Value(id),
      uuid: Value(uuid),
      tipUuid: Value(tipUuid),
      employeeUuid: Value(employeeUuid),
      employeeName: Value(employeeName),
      employeeRole: Value(employeeRole),
      amount: Value(amount),
      percentage: Value(percentage),
      hoursWorked: hoursWorked == null && nullToAbsent
          ? const Value.absent()
          : Value(hoursWorked),
      pointsEarned: pointsEarned == null && nullToAbsent
          ? const Value.absent()
          : Value(pointsEarned),
      isPaidOut: Value(isPaidOut),
      paidOutAt: paidOutAt == null && nullToAbsent
          ? const Value.absent()
          : Value(paidOutAt),
      paidOutByUuid: paidOutByUuid == null && nullToAbsent
          ? const Value.absent()
          : Value(paidOutByUuid),
      distributedAt: Value(distributedAt),
    );
  }

  factory TipDistributionTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return TipDistributionTableData(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      tipUuid: serializer.fromJson<String>(json['tipUuid']),
      employeeUuid: serializer.fromJson<String>(json['employeeUuid']),
      employeeName: serializer.fromJson<String>(json['employeeName']),
      employeeRole: serializer.fromJson<String>(json['employeeRole']),
      amount: serializer.fromJson<double>(json['amount']),
      percentage: serializer.fromJson<double>(json['percentage']),
      hoursWorked: serializer.fromJson<double?>(json['hoursWorked']),
      pointsEarned: serializer.fromJson<double?>(json['pointsEarned']),
      isPaidOut: serializer.fromJson<bool>(json['isPaidOut']),
      paidOutAt: serializer.fromJson<DateTime?>(json['paidOutAt']),
      paidOutByUuid: serializer.fromJson<String?>(json['paidOutByUuid']),
      distributedAt: serializer.fromJson<DateTime>(json['distributedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'tipUuid': serializer.toJson<String>(tipUuid),
      'employeeUuid': serializer.toJson<String>(employeeUuid),
      'employeeName': serializer.toJson<String>(employeeName),
      'employeeRole': serializer.toJson<String>(employeeRole),
      'amount': serializer.toJson<double>(amount),
      'percentage': serializer.toJson<double>(percentage),
      'hoursWorked': serializer.toJson<double?>(hoursWorked),
      'pointsEarned': serializer.toJson<double?>(pointsEarned),
      'isPaidOut': serializer.toJson<bool>(isPaidOut),
      'paidOutAt': serializer.toJson<DateTime?>(paidOutAt),
      'paidOutByUuid': serializer.toJson<String?>(paidOutByUuid),
      'distributedAt': serializer.toJson<DateTime>(distributedAt),
    };
  }

  TipDistributionTableData copyWith(
          {int? id,
          String? uuid,
          String? tipUuid,
          String? employeeUuid,
          String? employeeName,
          String? employeeRole,
          double? amount,
          double? percentage,
          Value<double?> hoursWorked = const Value.absent(),
          Value<double?> pointsEarned = const Value.absent(),
          bool? isPaidOut,
          Value<DateTime?> paidOutAt = const Value.absent(),
          Value<String?> paidOutByUuid = const Value.absent(),
          DateTime? distributedAt}) =>
      TipDistributionTableData(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        tipUuid: tipUuid ?? this.tipUuid,
        employeeUuid: employeeUuid ?? this.employeeUuid,
        employeeName: employeeName ?? this.employeeName,
        employeeRole: employeeRole ?? this.employeeRole,
        amount: amount ?? this.amount,
        percentage: percentage ?? this.percentage,
        hoursWorked: hoursWorked.present ? hoursWorked.value : this.hoursWorked,
        pointsEarned:
            pointsEarned.present ? pointsEarned.value : this.pointsEarned,
        isPaidOut: isPaidOut ?? this.isPaidOut,
        paidOutAt: paidOutAt.present ? paidOutAt.value : this.paidOutAt,
        paidOutByUuid:
            paidOutByUuid.present ? paidOutByUuid.value : this.paidOutByUuid,
        distributedAt: distributedAt ?? this.distributedAt,
      );
  TipDistributionTableData copyWithCompanion(
      TipDistributionTableCompanion data) {
    return TipDistributionTableData(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      tipUuid: data.tipUuid.present ? data.tipUuid.value : this.tipUuid,
      employeeUuid: data.employeeUuid.present
          ? data.employeeUuid.value
          : this.employeeUuid,
      employeeName: data.employeeName.present
          ? data.employeeName.value
          : this.employeeName,
      employeeRole: data.employeeRole.present
          ? data.employeeRole.value
          : this.employeeRole,
      amount: data.amount.present ? data.amount.value : this.amount,
      percentage:
          data.percentage.present ? data.percentage.value : this.percentage,
      hoursWorked:
          data.hoursWorked.present ? data.hoursWorked.value : this.hoursWorked,
      pointsEarned: data.pointsEarned.present
          ? data.pointsEarned.value
          : this.pointsEarned,
      isPaidOut: data.isPaidOut.present ? data.isPaidOut.value : this.isPaidOut,
      paidOutAt: data.paidOutAt.present ? data.paidOutAt.value : this.paidOutAt,
      paidOutByUuid: data.paidOutByUuid.present
          ? data.paidOutByUuid.value
          : this.paidOutByUuid,
      distributedAt: data.distributedAt.present
          ? data.distributedAt.value
          : this.distributedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('TipDistributionTableData(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('tipUuid: $tipUuid, ')
          ..write('employeeUuid: $employeeUuid, ')
          ..write('employeeName: $employeeName, ')
          ..write('employeeRole: $employeeRole, ')
          ..write('amount: $amount, ')
          ..write('percentage: $percentage, ')
          ..write('hoursWorked: $hoursWorked, ')
          ..write('pointsEarned: $pointsEarned, ')
          ..write('isPaidOut: $isPaidOut, ')
          ..write('paidOutAt: $paidOutAt, ')
          ..write('paidOutByUuid: $paidOutByUuid, ')
          ..write('distributedAt: $distributedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      uuid,
      tipUuid,
      employeeUuid,
      employeeName,
      employeeRole,
      amount,
      percentage,
      hoursWorked,
      pointsEarned,
      isPaidOut,
      paidOutAt,
      paidOutByUuid,
      distributedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is TipDistributionTableData &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.tipUuid == this.tipUuid &&
          other.employeeUuid == this.employeeUuid &&
          other.employeeName == this.employeeName &&
          other.employeeRole == this.employeeRole &&
          other.amount == this.amount &&
          other.percentage == this.percentage &&
          other.hoursWorked == this.hoursWorked &&
          other.pointsEarned == this.pointsEarned &&
          other.isPaidOut == this.isPaidOut &&
          other.paidOutAt == this.paidOutAt &&
          other.paidOutByUuid == this.paidOutByUuid &&
          other.distributedAt == this.distributedAt);
}

class TipDistributionTableCompanion
    extends UpdateCompanion<TipDistributionTableData> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String> tipUuid;
  final Value<String> employeeUuid;
  final Value<String> employeeName;
  final Value<String> employeeRole;
  final Value<double> amount;
  final Value<double> percentage;
  final Value<double?> hoursWorked;
  final Value<double?> pointsEarned;
  final Value<bool> isPaidOut;
  final Value<DateTime?> paidOutAt;
  final Value<String?> paidOutByUuid;
  final Value<DateTime> distributedAt;
  const TipDistributionTableCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.tipUuid = const Value.absent(),
    this.employeeUuid = const Value.absent(),
    this.employeeName = const Value.absent(),
    this.employeeRole = const Value.absent(),
    this.amount = const Value.absent(),
    this.percentage = const Value.absent(),
    this.hoursWorked = const Value.absent(),
    this.pointsEarned = const Value.absent(),
    this.isPaidOut = const Value.absent(),
    this.paidOutAt = const Value.absent(),
    this.paidOutByUuid = const Value.absent(),
    this.distributedAt = const Value.absent(),
  });
  TipDistributionTableCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    required String tipUuid,
    required String employeeUuid,
    required String employeeName,
    required String employeeRole,
    required double amount,
    required double percentage,
    this.hoursWorked = const Value.absent(),
    this.pointsEarned = const Value.absent(),
    this.isPaidOut = const Value.absent(),
    this.paidOutAt = const Value.absent(),
    this.paidOutByUuid = const Value.absent(),
    required DateTime distributedAt,
  })  : uuid = Value(uuid),
        tipUuid = Value(tipUuid),
        employeeUuid = Value(employeeUuid),
        employeeName = Value(employeeName),
        employeeRole = Value(employeeRole),
        amount = Value(amount),
        percentage = Value(percentage),
        distributedAt = Value(distributedAt);
  static Insertable<TipDistributionTableData> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? tipUuid,
    Expression<String>? employeeUuid,
    Expression<String>? employeeName,
    Expression<String>? employeeRole,
    Expression<double>? amount,
    Expression<double>? percentage,
    Expression<double>? hoursWorked,
    Expression<double>? pointsEarned,
    Expression<bool>? isPaidOut,
    Expression<DateTime>? paidOutAt,
    Expression<String>? paidOutByUuid,
    Expression<DateTime>? distributedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (tipUuid != null) 'tip_uuid': tipUuid,
      if (employeeUuid != null) 'employee_uuid': employeeUuid,
      if (employeeName != null) 'employee_name': employeeName,
      if (employeeRole != null) 'employee_role': employeeRole,
      if (amount != null) 'amount': amount,
      if (percentage != null) 'percentage': percentage,
      if (hoursWorked != null) 'hours_worked': hoursWorked,
      if (pointsEarned != null) 'points_earned': pointsEarned,
      if (isPaidOut != null) 'is_paid_out': isPaidOut,
      if (paidOutAt != null) 'paid_out_at': paidOutAt,
      if (paidOutByUuid != null) 'paid_out_by_uuid': paidOutByUuid,
      if (distributedAt != null) 'distributed_at': distributedAt,
    });
  }

  TipDistributionTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String>? tipUuid,
      Value<String>? employeeUuid,
      Value<String>? employeeName,
      Value<String>? employeeRole,
      Value<double>? amount,
      Value<double>? percentage,
      Value<double?>? hoursWorked,
      Value<double?>? pointsEarned,
      Value<bool>? isPaidOut,
      Value<DateTime?>? paidOutAt,
      Value<String?>? paidOutByUuid,
      Value<DateTime>? distributedAt}) {
    return TipDistributionTableCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      tipUuid: tipUuid ?? this.tipUuid,
      employeeUuid: employeeUuid ?? this.employeeUuid,
      employeeName: employeeName ?? this.employeeName,
      employeeRole: employeeRole ?? this.employeeRole,
      amount: amount ?? this.amount,
      percentage: percentage ?? this.percentage,
      hoursWorked: hoursWorked ?? this.hoursWorked,
      pointsEarned: pointsEarned ?? this.pointsEarned,
      isPaidOut: isPaidOut ?? this.isPaidOut,
      paidOutAt: paidOutAt ?? this.paidOutAt,
      paidOutByUuid: paidOutByUuid ?? this.paidOutByUuid,
      distributedAt: distributedAt ?? this.distributedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (tipUuid.present) {
      map['tip_uuid'] = Variable<String>(tipUuid.value);
    }
    if (employeeUuid.present) {
      map['employee_uuid'] = Variable<String>(employeeUuid.value);
    }
    if (employeeName.present) {
      map['employee_name'] = Variable<String>(employeeName.value);
    }
    if (employeeRole.present) {
      map['employee_role'] = Variable<String>(employeeRole.value);
    }
    if (amount.present) {
      map['amount'] = Variable<double>(amount.value);
    }
    if (percentage.present) {
      map['percentage'] = Variable<double>(percentage.value);
    }
    if (hoursWorked.present) {
      map['hours_worked'] = Variable<double>(hoursWorked.value);
    }
    if (pointsEarned.present) {
      map['points_earned'] = Variable<double>(pointsEarned.value);
    }
    if (isPaidOut.present) {
      map['is_paid_out'] = Variable<bool>(isPaidOut.value);
    }
    if (paidOutAt.present) {
      map['paid_out_at'] = Variable<DateTime>(paidOutAt.value);
    }
    if (paidOutByUuid.present) {
      map['paid_out_by_uuid'] = Variable<String>(paidOutByUuid.value);
    }
    if (distributedAt.present) {
      map['distributed_at'] = Variable<DateTime>(distributedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('TipDistributionTableCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('tipUuid: $tipUuid, ')
          ..write('employeeUuid: $employeeUuid, ')
          ..write('employeeName: $employeeName, ')
          ..write('employeeRole: $employeeRole, ')
          ..write('amount: $amount, ')
          ..write('percentage: $percentage, ')
          ..write('hoursWorked: $hoursWorked, ')
          ..write('pointsEarned: $pointsEarned, ')
          ..write('isPaidOut: $isPaidOut, ')
          ..write('paidOutAt: $paidOutAt, ')
          ..write('paidOutByUuid: $paidOutByUuid, ')
          ..write('distributedAt: $distributedAt')
          ..write(')'))
        .toString();
  }
}

class $SplitBillTableTable extends SplitBillTable
    with TableInfo<$SplitBillTableTable, SplitBillTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SplitBillTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _orderUuidMeta =
      const VerificationMeta('orderUuid');
  @override
  late final GeneratedColumn<String> orderUuid = GeneratedColumn<String>(
      'order_uuid', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _orderNumberMeta =
      const VerificationMeta('orderNumber');
  @override
  late final GeneratedColumn<String> orderNumber = GeneratedColumn<String>(
      'order_number', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _originalTotalMeta =
      const VerificationMeta('originalTotal');
  @override
  late final GeneratedColumn<double> originalTotal = GeneratedColumn<double>(
      'original_total', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _guestCountMeta =
      const VerificationMeta('guestCount');
  @override
  late final GeneratedColumn<int> guestCount = GeneratedColumn<int>(
      'guest_count', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _splitModeMeta =
      const VerificationMeta('splitMode');
  @override
  late final GeneratedColumn<String> splitMode = GeneratedColumn<String>(
      'split_mode', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
      'status', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultValue: const Constant('active'));
  static const VerificationMeta _createdByUuidMeta =
      const VerificationMeta('createdByUuid');
  @override
  late final GeneratedColumn<String> createdByUuid = GeneratedColumn<String>(
      'created_by_uuid', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _createdByNameMeta =
      const VerificationMeta('createdByName');
  @override
  late final GeneratedColumn<String> createdByName = GeneratedColumn<String>(
      'created_by_name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _completedAtMeta =
      const VerificationMeta('completedAt');
  @override
  late final GeneratedColumn<DateTime> completedAt = GeneratedColumn<DateTime>(
      'completed_at', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        orderUuid,
        orderNumber,
        originalTotal,
        guestCount,
        splitMode,
        status,
        createdByUuid,
        createdByName,
        createdAt,
        completedAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'split_bill_table';
  @override
  VerificationContext validateIntegrity(Insertable<SplitBillTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('order_uuid')) {
      context.handle(_orderUuidMeta,
          orderUuid.isAcceptableOrUnknown(data['order_uuid']!, _orderUuidMeta));
    } else if (isInserting) {
      context.missing(_orderUuidMeta);
    }
    if (data.containsKey('order_number')) {
      context.handle(
          _orderNumberMeta,
          orderNumber.isAcceptableOrUnknown(
              data['order_number']!, _orderNumberMeta));
    } else if (isInserting) {
      context.missing(_orderNumberMeta);
    }
    if (data.containsKey('original_total')) {
      context.handle(
          _originalTotalMeta,
          originalTotal.isAcceptableOrUnknown(
              data['original_total']!, _originalTotalMeta));
    } else if (isInserting) {
      context.missing(_originalTotalMeta);
    }
    if (data.containsKey('guest_count')) {
      context.handle(
          _guestCountMeta,
          guestCount.isAcceptableOrUnknown(
              data['guest_count']!, _guestCountMeta));
    } else if (isInserting) {
      context.missing(_guestCountMeta);
    }
    if (data.containsKey('split_mode')) {
      context.handle(_splitModeMeta,
          splitMode.isAcceptableOrUnknown(data['split_mode']!, _splitModeMeta));
    } else if (isInserting) {
      context.missing(_splitModeMeta);
    }
    if (data.containsKey('status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['status']!, _statusMeta));
    }
    if (data.containsKey('created_by_uuid')) {
      context.handle(
          _createdByUuidMeta,
          createdByUuid.isAcceptableOrUnknown(
              data['created_by_uuid']!, _createdByUuidMeta));
    } else if (isInserting) {
      context.missing(_createdByUuidMeta);
    }
    if (data.containsKey('created_by_name')) {
      context.handle(
          _createdByNameMeta,
          createdByName.isAcceptableOrUnknown(
              data['created_by_name']!, _createdByNameMeta));
    } else if (isInserting) {
      context.missing(_createdByNameMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('completed_at')) {
      context.handle(
          _completedAtMeta,
          completedAt.isAcceptableOrUnknown(
              data['completed_at']!, _completedAtMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  SplitBillTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SplitBillTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      orderUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}order_uuid'])!,
      orderNumber: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}order_number'])!,
      originalTotal: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}original_total'])!,
      guestCount: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}guest_count'])!,
      splitMode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}split_mode'])!,
      status: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}status'])!,
      createdByUuid: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}created_by_uuid'])!,
      createdByName: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}created_by_name'])!,
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      completedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}completed_at']),
    );
  }

  @override
  $SplitBillTableTable createAlias(String alias) {
    return $SplitBillTableTable(attachedDatabase, alias);
  }
}

class SplitBillTableData extends DataClass
    implements Insertable<SplitBillTableData> {
  final int id;
  final String uuid;
  final String orderUuid;
  final String orderNumber;
  final double originalTotal;
  final int guestCount;
  final String splitMode;
  final String status;
  final String createdByUuid;
  final String createdByName;
  final DateTime createdAt;
  final DateTime? completedAt;
  const SplitBillTableData(
      {required this.id,
      required this.uuid,
      required this.orderUuid,
      required this.orderNumber,
      required this.originalTotal,
      required this.guestCount,
      required this.splitMode,
      required this.status,
      required this.createdByUuid,
      required this.createdByName,
      required this.createdAt,
      this.completedAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    map['order_uuid'] = Variable<String>(orderUuid);
    map['order_number'] = Variable<String>(orderNumber);
    map['original_total'] = Variable<double>(originalTotal);
    map['guest_count'] = Variable<int>(guestCount);
    map['split_mode'] = Variable<String>(splitMode);
    map['status'] = Variable<String>(status);
    map['created_by_uuid'] = Variable<String>(createdByUuid);
    map['created_by_name'] = Variable<String>(createdByName);
    map['created_at'] = Variable<DateTime>(createdAt);
    if (!nullToAbsent || completedAt != null) {
      map['completed_at'] = Variable<DateTime>(completedAt);
    }
    return map;
  }

  SplitBillTableCompanion toCompanion(bool nullToAbsent) {
    return SplitBillTableCompanion(
      id: Value(id),
      uuid: Value(uuid),
      orderUuid: Value(orderUuid),
      orderNumber: Value(orderNumber),
      originalTotal: Value(originalTotal),
      guestCount: Value(guestCount),
      splitMode: Value(splitMode),
      status: Value(status),
      createdByUuid: Value(createdByUuid),
      createdByName: Value(createdByName),
      createdAt: Value(createdAt),
      completedAt: completedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(completedAt),
    );
  }

  factory SplitBillTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SplitBillTableData(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      orderUuid: serializer.fromJson<String>(json['orderUuid']),
      orderNumber: serializer.fromJson<String>(json['orderNumber']),
      originalTotal: serializer.fromJson<double>(json['originalTotal']),
      guestCount: serializer.fromJson<int>(json['guestCount']),
      splitMode: serializer.fromJson<String>(json['splitMode']),
      status: serializer.fromJson<String>(json['status']),
      createdByUuid: serializer.fromJson<String>(json['createdByUuid']),
      createdByName: serializer.fromJson<String>(json['createdByName']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      completedAt: serializer.fromJson<DateTime?>(json['completedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'orderUuid': serializer.toJson<String>(orderUuid),
      'orderNumber': serializer.toJson<String>(orderNumber),
      'originalTotal': serializer.toJson<double>(originalTotal),
      'guestCount': serializer.toJson<int>(guestCount),
      'splitMode': serializer.toJson<String>(splitMode),
      'status': serializer.toJson<String>(status),
      'createdByUuid': serializer.toJson<String>(createdByUuid),
      'createdByName': serializer.toJson<String>(createdByName),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'completedAt': serializer.toJson<DateTime?>(completedAt),
    };
  }

  SplitBillTableData copyWith(
          {int? id,
          String? uuid,
          String? orderUuid,
          String? orderNumber,
          double? originalTotal,
          int? guestCount,
          String? splitMode,
          String? status,
          String? createdByUuid,
          String? createdByName,
          DateTime? createdAt,
          Value<DateTime?> completedAt = const Value.absent()}) =>
      SplitBillTableData(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        orderUuid: orderUuid ?? this.orderUuid,
        orderNumber: orderNumber ?? this.orderNumber,
        originalTotal: originalTotal ?? this.originalTotal,
        guestCount: guestCount ?? this.guestCount,
        splitMode: splitMode ?? this.splitMode,
        status: status ?? this.status,
        createdByUuid: createdByUuid ?? this.createdByUuid,
        createdByName: createdByName ?? this.createdByName,
        createdAt: createdAt ?? this.createdAt,
        completedAt: completedAt.present ? completedAt.value : this.completedAt,
      );
  SplitBillTableData copyWithCompanion(SplitBillTableCompanion data) {
    return SplitBillTableData(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      orderUuid: data.orderUuid.present ? data.orderUuid.value : this.orderUuid,
      orderNumber:
          data.orderNumber.present ? data.orderNumber.value : this.orderNumber,
      originalTotal: data.originalTotal.present
          ? data.originalTotal.value
          : this.originalTotal,
      guestCount:
          data.guestCount.present ? data.guestCount.value : this.guestCount,
      splitMode: data.splitMode.present ? data.splitMode.value : this.splitMode,
      status: data.status.present ? data.status.value : this.status,
      createdByUuid: data.createdByUuid.present
          ? data.createdByUuid.value
          : this.createdByUuid,
      createdByName: data.createdByName.present
          ? data.createdByName.value
          : this.createdByName,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      completedAt:
          data.completedAt.present ? data.completedAt.value : this.completedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('SplitBillTableData(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('orderUuid: $orderUuid, ')
          ..write('orderNumber: $orderNumber, ')
          ..write('originalTotal: $originalTotal, ')
          ..write('guestCount: $guestCount, ')
          ..write('splitMode: $splitMode, ')
          ..write('status: $status, ')
          ..write('createdByUuid: $createdByUuid, ')
          ..write('createdByName: $createdByName, ')
          ..write('createdAt: $createdAt, ')
          ..write('completedAt: $completedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      uuid,
      orderUuid,
      orderNumber,
      originalTotal,
      guestCount,
      splitMode,
      status,
      createdByUuid,
      createdByName,
      createdAt,
      completedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SplitBillTableData &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.orderUuid == this.orderUuid &&
          other.orderNumber == this.orderNumber &&
          other.originalTotal == this.originalTotal &&
          other.guestCount == this.guestCount &&
          other.splitMode == this.splitMode &&
          other.status == this.status &&
          other.createdByUuid == this.createdByUuid &&
          other.createdByName == this.createdByName &&
          other.createdAt == this.createdAt &&
          other.completedAt == this.completedAt);
}

class SplitBillTableCompanion extends UpdateCompanion<SplitBillTableData> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String> orderUuid;
  final Value<String> orderNumber;
  final Value<double> originalTotal;
  final Value<int> guestCount;
  final Value<String> splitMode;
  final Value<String> status;
  final Value<String> createdByUuid;
  final Value<String> createdByName;
  final Value<DateTime> createdAt;
  final Value<DateTime?> completedAt;
  const SplitBillTableCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.orderUuid = const Value.absent(),
    this.orderNumber = const Value.absent(),
    this.originalTotal = const Value.absent(),
    this.guestCount = const Value.absent(),
    this.splitMode = const Value.absent(),
    this.status = const Value.absent(),
    this.createdByUuid = const Value.absent(),
    this.createdByName = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.completedAt = const Value.absent(),
  });
  SplitBillTableCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    required String orderUuid,
    required String orderNumber,
    required double originalTotal,
    required int guestCount,
    required String splitMode,
    this.status = const Value.absent(),
    required String createdByUuid,
    required String createdByName,
    required DateTime createdAt,
    this.completedAt = const Value.absent(),
  })  : uuid = Value(uuid),
        orderUuid = Value(orderUuid),
        orderNumber = Value(orderNumber),
        originalTotal = Value(originalTotal),
        guestCount = Value(guestCount),
        splitMode = Value(splitMode),
        createdByUuid = Value(createdByUuid),
        createdByName = Value(createdByName),
        createdAt = Value(createdAt);
  static Insertable<SplitBillTableData> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? orderUuid,
    Expression<String>? orderNumber,
    Expression<double>? originalTotal,
    Expression<int>? guestCount,
    Expression<String>? splitMode,
    Expression<String>? status,
    Expression<String>? createdByUuid,
    Expression<String>? createdByName,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? completedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (orderUuid != null) 'order_uuid': orderUuid,
      if (orderNumber != null) 'order_number': orderNumber,
      if (originalTotal != null) 'original_total': originalTotal,
      if (guestCount != null) 'guest_count': guestCount,
      if (splitMode != null) 'split_mode': splitMode,
      if (status != null) 'status': status,
      if (createdByUuid != null) 'created_by_uuid': createdByUuid,
      if (createdByName != null) 'created_by_name': createdByName,
      if (createdAt != null) 'created_at': createdAt,
      if (completedAt != null) 'completed_at': completedAt,
    });
  }

  SplitBillTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String>? orderUuid,
      Value<String>? orderNumber,
      Value<double>? originalTotal,
      Value<int>? guestCount,
      Value<String>? splitMode,
      Value<String>? status,
      Value<String>? createdByUuid,
      Value<String>? createdByName,
      Value<DateTime>? createdAt,
      Value<DateTime?>? completedAt}) {
    return SplitBillTableCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      orderUuid: orderUuid ?? this.orderUuid,
      orderNumber: orderNumber ?? this.orderNumber,
      originalTotal: originalTotal ?? this.originalTotal,
      guestCount: guestCount ?? this.guestCount,
      splitMode: splitMode ?? this.splitMode,
      status: status ?? this.status,
      createdByUuid: createdByUuid ?? this.createdByUuid,
      createdByName: createdByName ?? this.createdByName,
      createdAt: createdAt ?? this.createdAt,
      completedAt: completedAt ?? this.completedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (orderUuid.present) {
      map['order_uuid'] = Variable<String>(orderUuid.value);
    }
    if (orderNumber.present) {
      map['order_number'] = Variable<String>(orderNumber.value);
    }
    if (originalTotal.present) {
      map['original_total'] = Variable<double>(originalTotal.value);
    }
    if (guestCount.present) {
      map['guest_count'] = Variable<int>(guestCount.value);
    }
    if (splitMode.present) {
      map['split_mode'] = Variable<String>(splitMode.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (createdByUuid.present) {
      map['created_by_uuid'] = Variable<String>(createdByUuid.value);
    }
    if (createdByName.present) {
      map['created_by_name'] = Variable<String>(createdByName.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (completedAt.present) {
      map['completed_at'] = Variable<DateTime>(completedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SplitBillTableCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('orderUuid: $orderUuid, ')
          ..write('orderNumber: $orderNumber, ')
          ..write('originalTotal: $originalTotal, ')
          ..write('guestCount: $guestCount, ')
          ..write('splitMode: $splitMode, ')
          ..write('status: $status, ')
          ..write('createdByUuid: $createdByUuid, ')
          ..write('createdByName: $createdByName, ')
          ..write('createdAt: $createdAt, ')
          ..write('completedAt: $completedAt')
          ..write(')'))
        .toString();
  }
}

class $GuestBillTableTable extends GuestBillTable
    with TableInfo<$GuestBillTableTable, GuestBillTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $GuestBillTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _splitBillUuidMeta =
      const VerificationMeta('splitBillUuid');
  @override
  late final GeneratedColumn<String> splitBillUuid = GeneratedColumn<String>(
      'split_bill_uuid', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _guestNumberMeta =
      const VerificationMeta('guestNumber');
  @override
  late final GeneratedColumn<int> guestNumber = GeneratedColumn<int>(
      'guest_number', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _guestNameMeta =
      const VerificationMeta('guestName');
  @override
  late final GeneratedColumn<String> guestName = GeneratedColumn<String>(
      'guest_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _totalAmountMeta =
      const VerificationMeta('totalAmount');
  @override
  late final GeneratedColumn<double> totalAmount = GeneratedColumn<double>(
      'total_amount', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _tipAmountMeta =
      const VerificationMeta('tipAmount');
  @override
  late final GeneratedColumn<double> tipAmount = GeneratedColumn<double>(
      'tip_amount', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _isPaidMeta = const VerificationMeta('isPaid');
  @override
  late final GeneratedColumn<bool> isPaid = GeneratedColumn<bool>(
      'is_paid', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_paid" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _paymentMethodMeta =
      const VerificationMeta('paymentMethod');
  @override
  late final GeneratedColumn<String> paymentMethod = GeneratedColumn<String>(
      'payment_method', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _paymentTransactionUuidMeta =
      const VerificationMeta('paymentTransactionUuid');
  @override
  late final GeneratedColumn<String> paymentTransactionUuid =
      GeneratedColumn<String>('payment_transaction_uuid', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _paidAtMeta = const VerificationMeta('paidAt');
  @override
  late final GeneratedColumn<DateTime> paidAt = GeneratedColumn<DateTime>(
      'paid_at', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        splitBillUuid,
        guestNumber,
        guestName,
        totalAmount,
        tipAmount,
        isPaid,
        paymentMethod,
        paymentTransactionUuid,
        paidAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'guest_bill_table';
  @override
  VerificationContext validateIntegrity(Insertable<GuestBillTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('split_bill_uuid')) {
      context.handle(
          _splitBillUuidMeta,
          splitBillUuid.isAcceptableOrUnknown(
              data['split_bill_uuid']!, _splitBillUuidMeta));
    } else if (isInserting) {
      context.missing(_splitBillUuidMeta);
    }
    if (data.containsKey('guest_number')) {
      context.handle(
          _guestNumberMeta,
          guestNumber.isAcceptableOrUnknown(
              data['guest_number']!, _guestNumberMeta));
    } else if (isInserting) {
      context.missing(_guestNumberMeta);
    }
    if (data.containsKey('guest_name')) {
      context.handle(_guestNameMeta,
          guestName.isAcceptableOrUnknown(data['guest_name']!, _guestNameMeta));
    }
    if (data.containsKey('total_amount')) {
      context.handle(
          _totalAmountMeta,
          totalAmount.isAcceptableOrUnknown(
              data['total_amount']!, _totalAmountMeta));
    } else if (isInserting) {
      context.missing(_totalAmountMeta);
    }
    if (data.containsKey('tip_amount')) {
      context.handle(_tipAmountMeta,
          tipAmount.isAcceptableOrUnknown(data['tip_amount']!, _tipAmountMeta));
    }
    if (data.containsKey('is_paid')) {
      context.handle(_isPaidMeta,
          isPaid.isAcceptableOrUnknown(data['is_paid']!, _isPaidMeta));
    }
    if (data.containsKey('payment_method')) {
      context.handle(
          _paymentMethodMeta,
          paymentMethod.isAcceptableOrUnknown(
              data['payment_method']!, _paymentMethodMeta));
    }
    if (data.containsKey('payment_transaction_uuid')) {
      context.handle(
          _paymentTransactionUuidMeta,
          paymentTransactionUuid.isAcceptableOrUnknown(
              data['payment_transaction_uuid']!, _paymentTransactionUuidMeta));
    }
    if (data.containsKey('paid_at')) {
      context.handle(_paidAtMeta,
          paidAt.isAcceptableOrUnknown(data['paid_at']!, _paidAtMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  GuestBillTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return GuestBillTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      splitBillUuid: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}split_bill_uuid'])!,
      guestNumber: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}guest_number'])!,
      guestName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}guest_name']),
      totalAmount: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}total_amount'])!,
      tipAmount: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}tip_amount']),
      isPaid: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_paid'])!,
      paymentMethod: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}payment_method']),
      paymentTransactionUuid: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}payment_transaction_uuid']),
      paidAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}paid_at']),
    );
  }

  @override
  $GuestBillTableTable createAlias(String alias) {
    return $GuestBillTableTable(attachedDatabase, alias);
  }
}

class GuestBillTableData extends DataClass
    implements Insertable<GuestBillTableData> {
  final int id;
  final String uuid;
  final String splitBillUuid;
  final int guestNumber;
  final String? guestName;
  final double totalAmount;
  final double? tipAmount;
  final bool isPaid;
  final String? paymentMethod;
  final String? paymentTransactionUuid;
  final DateTime? paidAt;
  const GuestBillTableData(
      {required this.id,
      required this.uuid,
      required this.splitBillUuid,
      required this.guestNumber,
      this.guestName,
      required this.totalAmount,
      this.tipAmount,
      required this.isPaid,
      this.paymentMethod,
      this.paymentTransactionUuid,
      this.paidAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    map['split_bill_uuid'] = Variable<String>(splitBillUuid);
    map['guest_number'] = Variable<int>(guestNumber);
    if (!nullToAbsent || guestName != null) {
      map['guest_name'] = Variable<String>(guestName);
    }
    map['total_amount'] = Variable<double>(totalAmount);
    if (!nullToAbsent || tipAmount != null) {
      map['tip_amount'] = Variable<double>(tipAmount);
    }
    map['is_paid'] = Variable<bool>(isPaid);
    if (!nullToAbsent || paymentMethod != null) {
      map['payment_method'] = Variable<String>(paymentMethod);
    }
    if (!nullToAbsent || paymentTransactionUuid != null) {
      map['payment_transaction_uuid'] =
          Variable<String>(paymentTransactionUuid);
    }
    if (!nullToAbsent || paidAt != null) {
      map['paid_at'] = Variable<DateTime>(paidAt);
    }
    return map;
  }

  GuestBillTableCompanion toCompanion(bool nullToAbsent) {
    return GuestBillTableCompanion(
      id: Value(id),
      uuid: Value(uuid),
      splitBillUuid: Value(splitBillUuid),
      guestNumber: Value(guestNumber),
      guestName: guestName == null && nullToAbsent
          ? const Value.absent()
          : Value(guestName),
      totalAmount: Value(totalAmount),
      tipAmount: tipAmount == null && nullToAbsent
          ? const Value.absent()
          : Value(tipAmount),
      isPaid: Value(isPaid),
      paymentMethod: paymentMethod == null && nullToAbsent
          ? const Value.absent()
          : Value(paymentMethod),
      paymentTransactionUuid: paymentTransactionUuid == null && nullToAbsent
          ? const Value.absent()
          : Value(paymentTransactionUuid),
      paidAt:
          paidAt == null && nullToAbsent ? const Value.absent() : Value(paidAt),
    );
  }

  factory GuestBillTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return GuestBillTableData(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      splitBillUuid: serializer.fromJson<String>(json['splitBillUuid']),
      guestNumber: serializer.fromJson<int>(json['guestNumber']),
      guestName: serializer.fromJson<String?>(json['guestName']),
      totalAmount: serializer.fromJson<double>(json['totalAmount']),
      tipAmount: serializer.fromJson<double?>(json['tipAmount']),
      isPaid: serializer.fromJson<bool>(json['isPaid']),
      paymentMethod: serializer.fromJson<String?>(json['paymentMethod']),
      paymentTransactionUuid:
          serializer.fromJson<String?>(json['paymentTransactionUuid']),
      paidAt: serializer.fromJson<DateTime?>(json['paidAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'splitBillUuid': serializer.toJson<String>(splitBillUuid),
      'guestNumber': serializer.toJson<int>(guestNumber),
      'guestName': serializer.toJson<String?>(guestName),
      'totalAmount': serializer.toJson<double>(totalAmount),
      'tipAmount': serializer.toJson<double?>(tipAmount),
      'isPaid': serializer.toJson<bool>(isPaid),
      'paymentMethod': serializer.toJson<String?>(paymentMethod),
      'paymentTransactionUuid':
          serializer.toJson<String?>(paymentTransactionUuid),
      'paidAt': serializer.toJson<DateTime?>(paidAt),
    };
  }

  GuestBillTableData copyWith(
          {int? id,
          String? uuid,
          String? splitBillUuid,
          int? guestNumber,
          Value<String?> guestName = const Value.absent(),
          double? totalAmount,
          Value<double?> tipAmount = const Value.absent(),
          bool? isPaid,
          Value<String?> paymentMethod = const Value.absent(),
          Value<String?> paymentTransactionUuid = const Value.absent(),
          Value<DateTime?> paidAt = const Value.absent()}) =>
      GuestBillTableData(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        splitBillUuid: splitBillUuid ?? this.splitBillUuid,
        guestNumber: guestNumber ?? this.guestNumber,
        guestName: guestName.present ? guestName.value : this.guestName,
        totalAmount: totalAmount ?? this.totalAmount,
        tipAmount: tipAmount.present ? tipAmount.value : this.tipAmount,
        isPaid: isPaid ?? this.isPaid,
        paymentMethod:
            paymentMethod.present ? paymentMethod.value : this.paymentMethod,
        paymentTransactionUuid: paymentTransactionUuid.present
            ? paymentTransactionUuid.value
            : this.paymentTransactionUuid,
        paidAt: paidAt.present ? paidAt.value : this.paidAt,
      );
  GuestBillTableData copyWithCompanion(GuestBillTableCompanion data) {
    return GuestBillTableData(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      splitBillUuid: data.splitBillUuid.present
          ? data.splitBillUuid.value
          : this.splitBillUuid,
      guestNumber:
          data.guestNumber.present ? data.guestNumber.value : this.guestNumber,
      guestName: data.guestName.present ? data.guestName.value : this.guestName,
      totalAmount:
          data.totalAmount.present ? data.totalAmount.value : this.totalAmount,
      tipAmount: data.tipAmount.present ? data.tipAmount.value : this.tipAmount,
      isPaid: data.isPaid.present ? data.isPaid.value : this.isPaid,
      paymentMethod: data.paymentMethod.present
          ? data.paymentMethod.value
          : this.paymentMethod,
      paymentTransactionUuid: data.paymentTransactionUuid.present
          ? data.paymentTransactionUuid.value
          : this.paymentTransactionUuid,
      paidAt: data.paidAt.present ? data.paidAt.value : this.paidAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('GuestBillTableData(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('splitBillUuid: $splitBillUuid, ')
          ..write('guestNumber: $guestNumber, ')
          ..write('guestName: $guestName, ')
          ..write('totalAmount: $totalAmount, ')
          ..write('tipAmount: $tipAmount, ')
          ..write('isPaid: $isPaid, ')
          ..write('paymentMethod: $paymentMethod, ')
          ..write('paymentTransactionUuid: $paymentTransactionUuid, ')
          ..write('paidAt: $paidAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      uuid,
      splitBillUuid,
      guestNumber,
      guestName,
      totalAmount,
      tipAmount,
      isPaid,
      paymentMethod,
      paymentTransactionUuid,
      paidAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is GuestBillTableData &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.splitBillUuid == this.splitBillUuid &&
          other.guestNumber == this.guestNumber &&
          other.guestName == this.guestName &&
          other.totalAmount == this.totalAmount &&
          other.tipAmount == this.tipAmount &&
          other.isPaid == this.isPaid &&
          other.paymentMethod == this.paymentMethod &&
          other.paymentTransactionUuid == this.paymentTransactionUuid &&
          other.paidAt == this.paidAt);
}

class GuestBillTableCompanion extends UpdateCompanion<GuestBillTableData> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String> splitBillUuid;
  final Value<int> guestNumber;
  final Value<String?> guestName;
  final Value<double> totalAmount;
  final Value<double?> tipAmount;
  final Value<bool> isPaid;
  final Value<String?> paymentMethod;
  final Value<String?> paymentTransactionUuid;
  final Value<DateTime?> paidAt;
  const GuestBillTableCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.splitBillUuid = const Value.absent(),
    this.guestNumber = const Value.absent(),
    this.guestName = const Value.absent(),
    this.totalAmount = const Value.absent(),
    this.tipAmount = const Value.absent(),
    this.isPaid = const Value.absent(),
    this.paymentMethod = const Value.absent(),
    this.paymentTransactionUuid = const Value.absent(),
    this.paidAt = const Value.absent(),
  });
  GuestBillTableCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    required String splitBillUuid,
    required int guestNumber,
    this.guestName = const Value.absent(),
    required double totalAmount,
    this.tipAmount = const Value.absent(),
    this.isPaid = const Value.absent(),
    this.paymentMethod = const Value.absent(),
    this.paymentTransactionUuid = const Value.absent(),
    this.paidAt = const Value.absent(),
  })  : uuid = Value(uuid),
        splitBillUuid = Value(splitBillUuid),
        guestNumber = Value(guestNumber),
        totalAmount = Value(totalAmount);
  static Insertable<GuestBillTableData> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? splitBillUuid,
    Expression<int>? guestNumber,
    Expression<String>? guestName,
    Expression<double>? totalAmount,
    Expression<double>? tipAmount,
    Expression<bool>? isPaid,
    Expression<String>? paymentMethod,
    Expression<String>? paymentTransactionUuid,
    Expression<DateTime>? paidAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (splitBillUuid != null) 'split_bill_uuid': splitBillUuid,
      if (guestNumber != null) 'guest_number': guestNumber,
      if (guestName != null) 'guest_name': guestName,
      if (totalAmount != null) 'total_amount': totalAmount,
      if (tipAmount != null) 'tip_amount': tipAmount,
      if (isPaid != null) 'is_paid': isPaid,
      if (paymentMethod != null) 'payment_method': paymentMethod,
      if (paymentTransactionUuid != null)
        'payment_transaction_uuid': paymentTransactionUuid,
      if (paidAt != null) 'paid_at': paidAt,
    });
  }

  GuestBillTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String>? splitBillUuid,
      Value<int>? guestNumber,
      Value<String?>? guestName,
      Value<double>? totalAmount,
      Value<double?>? tipAmount,
      Value<bool>? isPaid,
      Value<String?>? paymentMethod,
      Value<String?>? paymentTransactionUuid,
      Value<DateTime?>? paidAt}) {
    return GuestBillTableCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      splitBillUuid: splitBillUuid ?? this.splitBillUuid,
      guestNumber: guestNumber ?? this.guestNumber,
      guestName: guestName ?? this.guestName,
      totalAmount: totalAmount ?? this.totalAmount,
      tipAmount: tipAmount ?? this.tipAmount,
      isPaid: isPaid ?? this.isPaid,
      paymentMethod: paymentMethod ?? this.paymentMethod,
      paymentTransactionUuid:
          paymentTransactionUuid ?? this.paymentTransactionUuid,
      paidAt: paidAt ?? this.paidAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (splitBillUuid.present) {
      map['split_bill_uuid'] = Variable<String>(splitBillUuid.value);
    }
    if (guestNumber.present) {
      map['guest_number'] = Variable<int>(guestNumber.value);
    }
    if (guestName.present) {
      map['guest_name'] = Variable<String>(guestName.value);
    }
    if (totalAmount.present) {
      map['total_amount'] = Variable<double>(totalAmount.value);
    }
    if (tipAmount.present) {
      map['tip_amount'] = Variable<double>(tipAmount.value);
    }
    if (isPaid.present) {
      map['is_paid'] = Variable<bool>(isPaid.value);
    }
    if (paymentMethod.present) {
      map['payment_method'] = Variable<String>(paymentMethod.value);
    }
    if (paymentTransactionUuid.present) {
      map['payment_transaction_uuid'] =
          Variable<String>(paymentTransactionUuid.value);
    }
    if (paidAt.present) {
      map['paid_at'] = Variable<DateTime>(paidAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('GuestBillTableCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('splitBillUuid: $splitBillUuid, ')
          ..write('guestNumber: $guestNumber, ')
          ..write('guestName: $guestName, ')
          ..write('totalAmount: $totalAmount, ')
          ..write('tipAmount: $tipAmount, ')
          ..write('isPaid: $isPaid, ')
          ..write('paymentMethod: $paymentMethod, ')
          ..write('paymentTransactionUuid: $paymentTransactionUuid, ')
          ..write('paidAt: $paidAt')
          ..write(')'))
        .toString();
  }
}

class $SplitBillItemTableTable extends SplitBillItemTable
    with TableInfo<$SplitBillItemTableTable, SplitBillItemTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SplitBillItemTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _guestBillUuidMeta =
      const VerificationMeta('guestBillUuid');
  @override
  late final GeneratedColumn<String> guestBillUuid = GeneratedColumn<String>(
      'guest_bill_uuid', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _orderItemUuidMeta =
      const VerificationMeta('orderItemUuid');
  @override
  late final GeneratedColumn<String> orderItemUuid = GeneratedColumn<String>(
      'order_item_uuid', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _productNameMeta =
      const VerificationMeta('productName');
  @override
  late final GeneratedColumn<String> productName = GeneratedColumn<String>(
      'product_name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _priceMeta = const VerificationMeta('price');
  @override
  late final GeneratedColumn<double> price = GeneratedColumn<double>(
      'price', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _quantityMeta =
      const VerificationMeta('quantity');
  @override
  late final GeneratedColumn<int> quantity = GeneratedColumn<int>(
      'quantity', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _shareCountMeta =
      const VerificationMeta('shareCount');
  @override
  late final GeneratedColumn<int> shareCount = GeneratedColumn<int>(
      'share_count', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultValue: const Constant(1));
  static const VerificationMeta _shareIndexMeta =
      const VerificationMeta('shareIndex');
  @override
  late final GeneratedColumn<int> shareIndex = GeneratedColumn<int>(
      'share_index', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultValue: const Constant(1));
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        guestBillUuid,
        orderItemUuid,
        productName,
        price,
        quantity,
        shareCount,
        shareIndex
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'split_bill_item_table';
  @override
  VerificationContext validateIntegrity(
      Insertable<SplitBillItemTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('guest_bill_uuid')) {
      context.handle(
          _guestBillUuidMeta,
          guestBillUuid.isAcceptableOrUnknown(
              data['guest_bill_uuid']!, _guestBillUuidMeta));
    } else if (isInserting) {
      context.missing(_guestBillUuidMeta);
    }
    if (data.containsKey('order_item_uuid')) {
      context.handle(
          _orderItemUuidMeta,
          orderItemUuid.isAcceptableOrUnknown(
              data['order_item_uuid']!, _orderItemUuidMeta));
    } else if (isInserting) {
      context.missing(_orderItemUuidMeta);
    }
    if (data.containsKey('product_name')) {
      context.handle(
          _productNameMeta,
          productName.isAcceptableOrUnknown(
              data['product_name']!, _productNameMeta));
    } else if (isInserting) {
      context.missing(_productNameMeta);
    }
    if (data.containsKey('price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['price']!, _priceMeta));
    } else if (isInserting) {
      context.missing(_priceMeta);
    }
    if (data.containsKey('quantity')) {
      context.handle(_quantityMeta,
          quantity.isAcceptableOrUnknown(data['quantity']!, _quantityMeta));
    } else if (isInserting) {
      context.missing(_quantityMeta);
    }
    if (data.containsKey('share_count')) {
      context.handle(
          _shareCountMeta,
          shareCount.isAcceptableOrUnknown(
              data['share_count']!, _shareCountMeta));
    }
    if (data.containsKey('share_index')) {
      context.handle(
          _shareIndexMeta,
          shareIndex.isAcceptableOrUnknown(
              data['share_index']!, _shareIndexMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  SplitBillItemTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SplitBillItemTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      guestBillUuid: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}guest_bill_uuid'])!,
      orderItemUuid: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}order_item_uuid'])!,
      productName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}product_name'])!,
      price: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}price'])!,
      quantity: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}quantity'])!,
      shareCount: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}share_count'])!,
      shareIndex: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}share_index'])!,
    );
  }

  @override
  $SplitBillItemTableTable createAlias(String alias) {
    return $SplitBillItemTableTable(attachedDatabase, alias);
  }
}

class SplitBillItemTableData extends DataClass
    implements Insertable<SplitBillItemTableData> {
  final int id;
  final String uuid;
  final String guestBillUuid;
  final String orderItemUuid;
  final String productName;
  final double price;
  final int quantity;
  final int shareCount;
  final int shareIndex;
  const SplitBillItemTableData(
      {required this.id,
      required this.uuid,
      required this.guestBillUuid,
      required this.orderItemUuid,
      required this.productName,
      required this.price,
      required this.quantity,
      required this.shareCount,
      required this.shareIndex});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    map['guest_bill_uuid'] = Variable<String>(guestBillUuid);
    map['order_item_uuid'] = Variable<String>(orderItemUuid);
    map['product_name'] = Variable<String>(productName);
    map['price'] = Variable<double>(price);
    map['quantity'] = Variable<int>(quantity);
    map['share_count'] = Variable<int>(shareCount);
    map['share_index'] = Variable<int>(shareIndex);
    return map;
  }

  SplitBillItemTableCompanion toCompanion(bool nullToAbsent) {
    return SplitBillItemTableCompanion(
      id: Value(id),
      uuid: Value(uuid),
      guestBillUuid: Value(guestBillUuid),
      orderItemUuid: Value(orderItemUuid),
      productName: Value(productName),
      price: Value(price),
      quantity: Value(quantity),
      shareCount: Value(shareCount),
      shareIndex: Value(shareIndex),
    );
  }

  factory SplitBillItemTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SplitBillItemTableData(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      guestBillUuid: serializer.fromJson<String>(json['guestBillUuid']),
      orderItemUuid: serializer.fromJson<String>(json['orderItemUuid']),
      productName: serializer.fromJson<String>(json['productName']),
      price: serializer.fromJson<double>(json['price']),
      quantity: serializer.fromJson<int>(json['quantity']),
      shareCount: serializer.fromJson<int>(json['shareCount']),
      shareIndex: serializer.fromJson<int>(json['shareIndex']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'guestBillUuid': serializer.toJson<String>(guestBillUuid),
      'orderItemUuid': serializer.toJson<String>(orderItemUuid),
      'productName': serializer.toJson<String>(productName),
      'price': serializer.toJson<double>(price),
      'quantity': serializer.toJson<int>(quantity),
      'shareCount': serializer.toJson<int>(shareCount),
      'shareIndex': serializer.toJson<int>(shareIndex),
    };
  }

  SplitBillItemTableData copyWith(
          {int? id,
          String? uuid,
          String? guestBillUuid,
          String? orderItemUuid,
          String? productName,
          double? price,
          int? quantity,
          int? shareCount,
          int? shareIndex}) =>
      SplitBillItemTableData(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        guestBillUuid: guestBillUuid ?? this.guestBillUuid,
        orderItemUuid: orderItemUuid ?? this.orderItemUuid,
        productName: productName ?? this.productName,
        price: price ?? this.price,
        quantity: quantity ?? this.quantity,
        shareCount: shareCount ?? this.shareCount,
        shareIndex: shareIndex ?? this.shareIndex,
      );
  SplitBillItemTableData copyWithCompanion(SplitBillItemTableCompanion data) {
    return SplitBillItemTableData(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      guestBillUuid: data.guestBillUuid.present
          ? data.guestBillUuid.value
          : this.guestBillUuid,
      orderItemUuid: data.orderItemUuid.present
          ? data.orderItemUuid.value
          : this.orderItemUuid,
      productName:
          data.productName.present ? data.productName.value : this.productName,
      price: data.price.present ? data.price.value : this.price,
      quantity: data.quantity.present ? data.quantity.value : this.quantity,
      shareCount:
          data.shareCount.present ? data.shareCount.value : this.shareCount,
      shareIndex:
          data.shareIndex.present ? data.shareIndex.value : this.shareIndex,
    );
  }

  @override
  String toString() {
    return (StringBuffer('SplitBillItemTableData(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('guestBillUuid: $guestBillUuid, ')
          ..write('orderItemUuid: $orderItemUuid, ')
          ..write('productName: $productName, ')
          ..write('price: $price, ')
          ..write('quantity: $quantity, ')
          ..write('shareCount: $shareCount, ')
          ..write('shareIndex: $shareIndex')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, uuid, guestBillUuid, orderItemUuid,
      productName, price, quantity, shareCount, shareIndex);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SplitBillItemTableData &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.guestBillUuid == this.guestBillUuid &&
          other.orderItemUuid == this.orderItemUuid &&
          other.productName == this.productName &&
          other.price == this.price &&
          other.quantity == this.quantity &&
          other.shareCount == this.shareCount &&
          other.shareIndex == this.shareIndex);
}

class SplitBillItemTableCompanion
    extends UpdateCompanion<SplitBillItemTableData> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String> guestBillUuid;
  final Value<String> orderItemUuid;
  final Value<String> productName;
  final Value<double> price;
  final Value<int> quantity;
  final Value<int> shareCount;
  final Value<int> shareIndex;
  const SplitBillItemTableCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.guestBillUuid = const Value.absent(),
    this.orderItemUuid = const Value.absent(),
    this.productName = const Value.absent(),
    this.price = const Value.absent(),
    this.quantity = const Value.absent(),
    this.shareCount = const Value.absent(),
    this.shareIndex = const Value.absent(),
  });
  SplitBillItemTableCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    required String guestBillUuid,
    required String orderItemUuid,
    required String productName,
    required double price,
    required int quantity,
    this.shareCount = const Value.absent(),
    this.shareIndex = const Value.absent(),
  })  : uuid = Value(uuid),
        guestBillUuid = Value(guestBillUuid),
        orderItemUuid = Value(orderItemUuid),
        productName = Value(productName),
        price = Value(price),
        quantity = Value(quantity);
  static Insertable<SplitBillItemTableData> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? guestBillUuid,
    Expression<String>? orderItemUuid,
    Expression<String>? productName,
    Expression<double>? price,
    Expression<int>? quantity,
    Expression<int>? shareCount,
    Expression<int>? shareIndex,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (guestBillUuid != null) 'guest_bill_uuid': guestBillUuid,
      if (orderItemUuid != null) 'order_item_uuid': orderItemUuid,
      if (productName != null) 'product_name': productName,
      if (price != null) 'price': price,
      if (quantity != null) 'quantity': quantity,
      if (shareCount != null) 'share_count': shareCount,
      if (shareIndex != null) 'share_index': shareIndex,
    });
  }

  SplitBillItemTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String>? guestBillUuid,
      Value<String>? orderItemUuid,
      Value<String>? productName,
      Value<double>? price,
      Value<int>? quantity,
      Value<int>? shareCount,
      Value<int>? shareIndex}) {
    return SplitBillItemTableCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      guestBillUuid: guestBillUuid ?? this.guestBillUuid,
      orderItemUuid: orderItemUuid ?? this.orderItemUuid,
      productName: productName ?? this.productName,
      price: price ?? this.price,
      quantity: quantity ?? this.quantity,
      shareCount: shareCount ?? this.shareCount,
      shareIndex: shareIndex ?? this.shareIndex,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (guestBillUuid.present) {
      map['guest_bill_uuid'] = Variable<String>(guestBillUuid.value);
    }
    if (orderItemUuid.present) {
      map['order_item_uuid'] = Variable<String>(orderItemUuid.value);
    }
    if (productName.present) {
      map['product_name'] = Variable<String>(productName.value);
    }
    if (price.present) {
      map['price'] = Variable<double>(price.value);
    }
    if (quantity.present) {
      map['quantity'] = Variable<int>(quantity.value);
    }
    if (shareCount.present) {
      map['share_count'] = Variable<int>(shareCount.value);
    }
    if (shareIndex.present) {
      map['share_index'] = Variable<int>(shareIndex.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SplitBillItemTableCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('guestBillUuid: $guestBillUuid, ')
          ..write('orderItemUuid: $orderItemUuid, ')
          ..write('productName: $productName, ')
          ..write('price: $price, ')
          ..write('quantity: $quantity, ')
          ..write('shareCount: $shareCount, ')
          ..write('shareIndex: $shareIndex')
          ..write(')'))
        .toString();
  }
}

class $DiscountTableTable extends DiscountTable
    with TableInfo<$DiscountTableTable, DiscountTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $DiscountTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
      'code', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _descriptionMeta =
      const VerificationMeta('description');
  @override
  late final GeneratedColumn<String> description = GeneratedColumn<String>(
      'description', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _typeMeta = const VerificationMeta('type');
  @override
  late final GeneratedColumn<String> type = GeneratedColumn<String>(
      'type', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _scopeMeta = const VerificationMeta('scope');
  @override
  late final GeneratedColumn<String> scope = GeneratedColumn<String>(
      'scope', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
      'status', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultValue: const Constant('active'));
  static const VerificationMeta _percentageOffMeta =
      const VerificationMeta('percentageOff');
  @override
  late final GeneratedColumn<double> percentageOff = GeneratedColumn<double>(
      'percentage_off', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _fixedAmountOffMeta =
      const VerificationMeta('fixedAmountOff');
  @override
  late final GeneratedColumn<double> fixedAmountOff = GeneratedColumn<double>(
      'fixed_amount_off', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _buyQuantityMeta =
      const VerificationMeta('buyQuantity');
  @override
  late final GeneratedColumn<int> buyQuantity = GeneratedColumn<int>(
      'buy_quantity', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _getQuantityMeta =
      const VerificationMeta('getQuantity');
  @override
  late final GeneratedColumn<int> getQuantity = GeneratedColumn<int>(
      'get_quantity', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _getDiscountPercentMeta =
      const VerificationMeta('getDiscountPercent');
  @override
  late final GeneratedColumn<double> getDiscountPercent =
      GeneratedColumn<double>('get_discount_percent', aliasedName, true,
          type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _tiersJsonMeta =
      const VerificationMeta('tiersJson');
  @override
  late final GeneratedColumn<String> tiersJson = GeneratedColumn<String>(
      'tiers_json', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultValue: const Constant('[]'));
  static const VerificationMeta _applicableProductUuidsJsonMeta =
      const VerificationMeta('applicableProductUuidsJson');
  @override
  late final GeneratedColumn<String> applicableProductUuidsJson =
      GeneratedColumn<String>(
          'applicable_product_uuids_json', aliasedName, false,
          type: DriftSqlType.string,
          requiredDuringInsert: false,
          defaultValue: const Constant('[]'));
  static const VerificationMeta _applicableCategoryUuidsJsonMeta =
      const VerificationMeta('applicableCategoryUuidsJson');
  @override
  late final GeneratedColumn<String> applicableCategoryUuidsJson =
      GeneratedColumn<String>(
          'applicable_category_uuids_json', aliasedName, false,
          type: DriftSqlType.string,
          requiredDuringInsert: false,
          defaultValue: const Constant('[]'));
  static const VerificationMeta _applicableCustomerUuidsJsonMeta =
      const VerificationMeta('applicableCustomerUuidsJson');
  @override
  late final GeneratedColumn<String> applicableCustomerUuidsJson =
      GeneratedColumn<String>(
          'applicable_customer_uuids_json', aliasedName, false,
          type: DriftSqlType.string,
          requiredDuringInsert: false,
          defaultValue: const Constant('[]'));
  static const VerificationMeta _minOrderAmountMeta =
      const VerificationMeta('minOrderAmount');
  @override
  late final GeneratedColumn<double> minOrderAmount = GeneratedColumn<double>(
      'min_order_amount', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _maxDiscountAmountMeta =
      const VerificationMeta('maxDiscountAmount');
  @override
  late final GeneratedColumn<double> maxDiscountAmount =
      GeneratedColumn<double>('max_discount_amount', aliasedName, true,
          type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _maxUsesTotalMeta =
      const VerificationMeta('maxUsesTotal');
  @override
  late final GeneratedColumn<int> maxUsesTotal = GeneratedColumn<int>(
      'max_uses_total', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _maxUsesPerCustomerMeta =
      const VerificationMeta('maxUsesPerCustomer');
  @override
  late final GeneratedColumn<int> maxUsesPerCustomer = GeneratedColumn<int>(
      'max_uses_per_customer', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _currentUsageCountMeta =
      const VerificationMeta('currentUsageCount');
  @override
  late final GeneratedColumn<int> currentUsageCount = GeneratedColumn<int>(
      'current_usage_count', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultValue: const Constant(0));
  static const VerificationMeta _validFromMeta =
      const VerificationMeta('validFrom');
  @override
  late final GeneratedColumn<DateTime> validFrom = GeneratedColumn<DateTime>(
      'valid_from', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _validUntilMeta =
      const VerificationMeta('validUntil');
  @override
  late final GeneratedColumn<DateTime> validUntil = GeneratedColumn<DateTime>(
      'valid_until', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _validDaysOfWeekJsonMeta =
      const VerificationMeta('validDaysOfWeekJson');
  @override
  late final GeneratedColumn<String> validDaysOfWeekJson =
      GeneratedColumn<String>('valid_days_of_week_json', aliasedName, false,
          type: DriftSqlType.string,
          requiredDuringInsert: false,
          defaultValue: const Constant('[]'));
  static const VerificationMeta _validTimeStartMeta =
      const VerificationMeta('validTimeStart');
  @override
  late final GeneratedColumn<String> validTimeStart = GeneratedColumn<String>(
      'valid_time_start', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _validTimeEndMeta =
      const VerificationMeta('validTimeEnd');
  @override
  late final GeneratedColumn<String> validTimeEnd = GeneratedColumn<String>(
      'valid_time_end', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _canStackWithOthersMeta =
      const VerificationMeta('canStackWithOthers');
  @override
  late final GeneratedColumn<bool> canStackWithOthers = GeneratedColumn<bool>(
      'can_stack_with_others', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("can_stack_with_others" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _stackPriorityMeta =
      const VerificationMeta('stackPriority');
  @override
  late final GeneratedColumn<int> stackPriority = GeneratedColumn<int>(
      'stack_priority', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultValue: const Constant(0));
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        name,
        code,
        description,
        type,
        scope,
        status,
        percentageOff,
        fixedAmountOff,
        buyQuantity,
        getQuantity,
        getDiscountPercent,
        tiersJson,
        applicableProductUuidsJson,
        applicableCategoryUuidsJson,
        applicableCustomerUuidsJson,
        minOrderAmount,
        maxDiscountAmount,
        maxUsesTotal,
        maxUsesPerCustomer,
        currentUsageCount,
        validFrom,
        validUntil,
        validDaysOfWeekJson,
        validTimeStart,
        validTimeEnd,
        canStackWithOthers,
        stackPriority,
        createdAt,
        updatedAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'discount_table';
  @override
  VerificationContext validateIntegrity(Insertable<DiscountTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('description')) {
      context.handle(
          _descriptionMeta,
          description.isAcceptableOrUnknown(
              data['description']!, _descriptionMeta));
    }
    if (data.containsKey('type')) {
      context.handle(
          _typeMeta, type.isAcceptableOrUnknown(data['type']!, _typeMeta));
    } else if (isInserting) {
      context.missing(_typeMeta);
    }
    if (data.containsKey('scope')) {
      context.handle(
          _scopeMeta, scope.isAcceptableOrUnknown(data['scope']!, _scopeMeta));
    } else if (isInserting) {
      context.missing(_scopeMeta);
    }
    if (data.containsKey('status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['status']!, _statusMeta));
    }
    if (data.containsKey('percentage_off')) {
      context.handle(
          _percentageOffMeta,
          percentageOff.isAcceptableOrUnknown(
              data['percentage_off']!, _percentageOffMeta));
    }
    if (data.containsKey('fixed_amount_off')) {
      context.handle(
          _fixedAmountOffMeta,
          fixedAmountOff.isAcceptableOrUnknown(
              data['fixed_amount_off']!, _fixedAmountOffMeta));
    }
    if (data.containsKey('buy_quantity')) {
      context.handle(
          _buyQuantityMeta,
          buyQuantity.isAcceptableOrUnknown(
              data['buy_quantity']!, _buyQuantityMeta));
    }
    if (data.containsKey('get_quantity')) {
      context.handle(
          _getQuantityMeta,
          getQuantity.isAcceptableOrUnknown(
              data['get_quantity']!, _getQuantityMeta));
    }
    if (data.containsKey('get_discount_percent')) {
      context.handle(
          _getDiscountPercentMeta,
          getDiscountPercent.isAcceptableOrUnknown(
              data['get_discount_percent']!, _getDiscountPercentMeta));
    }
    if (data.containsKey('tiers_json')) {
      context.handle(_tiersJsonMeta,
          tiersJson.isAcceptableOrUnknown(data['tiers_json']!, _tiersJsonMeta));
    }
    if (data.containsKey('applicable_product_uuids_json')) {
      context.handle(
          _applicableProductUuidsJsonMeta,
          applicableProductUuidsJson.isAcceptableOrUnknown(
              data['applicable_product_uuids_json']!,
              _applicableProductUuidsJsonMeta));
    }
    if (data.containsKey('applicable_category_uuids_json')) {
      context.handle(
          _applicableCategoryUuidsJsonMeta,
          applicableCategoryUuidsJson.isAcceptableOrUnknown(
              data['applicable_category_uuids_json']!,
              _applicableCategoryUuidsJsonMeta));
    }
    if (data.containsKey('applicable_customer_uuids_json')) {
      context.handle(
          _applicableCustomerUuidsJsonMeta,
          applicableCustomerUuidsJson.isAcceptableOrUnknown(
              data['applicable_customer_uuids_json']!,
              _applicableCustomerUuidsJsonMeta));
    }
    if (data.containsKey('min_order_amount')) {
      context.handle(
          _minOrderAmountMeta,
          minOrderAmount.isAcceptableOrUnknown(
              data['min_order_amount']!, _minOrderAmountMeta));
    }
    if (data.containsKey('max_discount_amount')) {
      context.handle(
          _maxDiscountAmountMeta,
          maxDiscountAmount.isAcceptableOrUnknown(
              data['max_discount_amount']!, _maxDiscountAmountMeta));
    }
    if (data.containsKey('max_uses_total')) {
      context.handle(
          _maxUsesTotalMeta,
          maxUsesTotal.isAcceptableOrUnknown(
              data['max_uses_total']!, _maxUsesTotalMeta));
    }
    if (data.containsKey('max_uses_per_customer')) {
      context.handle(
          _maxUsesPerCustomerMeta,
          maxUsesPerCustomer.isAcceptableOrUnknown(
              data['max_uses_per_customer']!, _maxUsesPerCustomerMeta));
    }
    if (data.containsKey('current_usage_count')) {
      context.handle(
          _currentUsageCountMeta,
          currentUsageCount.isAcceptableOrUnknown(
              data['current_usage_count']!, _currentUsageCountMeta));
    }
    if (data.containsKey('valid_from')) {
      context.handle(_validFromMeta,
          validFrom.isAcceptableOrUnknown(data['valid_from']!, _validFromMeta));
    }
    if (data.containsKey('valid_until')) {
      context.handle(
          _validUntilMeta,
          validUntil.isAcceptableOrUnknown(
              data['valid_until']!, _validUntilMeta));
    }
    if (data.containsKey('valid_days_of_week_json')) {
      context.handle(
          _validDaysOfWeekJsonMeta,
          validDaysOfWeekJson.isAcceptableOrUnknown(
              data['valid_days_of_week_json']!, _validDaysOfWeekJsonMeta));
    }
    if (data.containsKey('valid_time_start')) {
      context.handle(
          _validTimeStartMeta,
          validTimeStart.isAcceptableOrUnknown(
              data['valid_time_start']!, _validTimeStartMeta));
    }
    if (data.containsKey('valid_time_end')) {
      context.handle(
          _validTimeEndMeta,
          validTimeEnd.isAcceptableOrUnknown(
              data['valid_time_end']!, _validTimeEndMeta));
    }
    if (data.containsKey('can_stack_with_others')) {
      context.handle(
          _canStackWithOthersMeta,
          canStackWithOthers.isAcceptableOrUnknown(
              data['can_stack_with_others']!, _canStackWithOthersMeta));
    }
    if (data.containsKey('stack_priority')) {
      context.handle(
          _stackPriorityMeta,
          stackPriority.isAcceptableOrUnknown(
              data['stack_priority']!, _stackPriorityMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  DiscountTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return DiscountTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      description: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}description']),
      type: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}type'])!,
      scope: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}scope'])!,
      status: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}status'])!,
      percentageOff: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}percentage_off']),
      fixedAmountOff: attachedDatabase.typeMapping.read(
          DriftSqlType.double, data['${effectivePrefix}fixed_amount_off']),
      buyQuantity: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}buy_quantity']),
      getQuantity: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}get_quantity']),
      getDiscountPercent: attachedDatabase.typeMapping.read(
          DriftSqlType.double, data['${effectivePrefix}get_discount_percent']),
      tiersJson: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tiers_json'])!,
      applicableProductUuidsJson: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}applicable_product_uuids_json'])!,
      applicableCategoryUuidsJson: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}applicable_category_uuids_json'])!,
      applicableCustomerUuidsJson: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}applicable_customer_uuids_json'])!,
      minOrderAmount: attachedDatabase.typeMapping.read(
          DriftSqlType.double, data['${effectivePrefix}min_order_amount']),
      maxDiscountAmount: attachedDatabase.typeMapping.read(
          DriftSqlType.double, data['${effectivePrefix}max_discount_amount']),
      maxUsesTotal: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}max_uses_total']),
      maxUsesPerCustomer: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}max_uses_per_customer']),
      currentUsageCount: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}current_usage_count'])!,
      validFrom: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}valid_from']),
      validUntil: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}valid_until']),
      validDaysOfWeekJson: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}valid_days_of_week_json'])!,
      validTimeStart: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}valid_time_start']),
      validTimeEnd: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}valid_time_end']),
      canStackWithOthers: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}can_stack_with_others'])!,
      stackPriority: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}stack_priority'])!,
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at']),
    );
  }

  @override
  $DiscountTableTable createAlias(String alias) {
    return $DiscountTableTable(attachedDatabase, alias);
  }
}

class DiscountTableData extends DataClass
    implements Insertable<DiscountTableData> {
  final int id;
  final String uuid;
  final String name;
  final String code;
  final String? description;
  final String type;
  final String scope;
  final String status;
  final double? percentageOff;
  final double? fixedAmountOff;
  final int? buyQuantity;
  final int? getQuantity;
  final double? getDiscountPercent;
  final String tiersJson;
  final String applicableProductUuidsJson;
  final String applicableCategoryUuidsJson;
  final String applicableCustomerUuidsJson;
  final double? minOrderAmount;
  final double? maxDiscountAmount;
  final int? maxUsesTotal;
  final int? maxUsesPerCustomer;
  final int currentUsageCount;
  final DateTime? validFrom;
  final DateTime? validUntil;
  final String validDaysOfWeekJson;
  final String? validTimeStart;
  final String? validTimeEnd;
  final bool canStackWithOthers;
  final int stackPriority;
  final DateTime createdAt;
  final DateTime? updatedAt;
  const DiscountTableData(
      {required this.id,
      required this.uuid,
      required this.name,
      required this.code,
      this.description,
      required this.type,
      required this.scope,
      required this.status,
      this.percentageOff,
      this.fixedAmountOff,
      this.buyQuantity,
      this.getQuantity,
      this.getDiscountPercent,
      required this.tiersJson,
      required this.applicableProductUuidsJson,
      required this.applicableCategoryUuidsJson,
      required this.applicableCustomerUuidsJson,
      this.minOrderAmount,
      this.maxDiscountAmount,
      this.maxUsesTotal,
      this.maxUsesPerCustomer,
      required this.currentUsageCount,
      this.validFrom,
      this.validUntil,
      required this.validDaysOfWeekJson,
      this.validTimeStart,
      this.validTimeEnd,
      required this.canStackWithOthers,
      required this.stackPriority,
      required this.createdAt,
      this.updatedAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    map['name'] = Variable<String>(name);
    map['code'] = Variable<String>(code);
    if (!nullToAbsent || description != null) {
      map['description'] = Variable<String>(description);
    }
    map['type'] = Variable<String>(type);
    map['scope'] = Variable<String>(scope);
    map['status'] = Variable<String>(status);
    if (!nullToAbsent || percentageOff != null) {
      map['percentage_off'] = Variable<double>(percentageOff);
    }
    if (!nullToAbsent || fixedAmountOff != null) {
      map['fixed_amount_off'] = Variable<double>(fixedAmountOff);
    }
    if (!nullToAbsent || buyQuantity != null) {
      map['buy_quantity'] = Variable<int>(buyQuantity);
    }
    if (!nullToAbsent || getQuantity != null) {
      map['get_quantity'] = Variable<int>(getQuantity);
    }
    if (!nullToAbsent || getDiscountPercent != null) {
      map['get_discount_percent'] = Variable<double>(getDiscountPercent);
    }
    map['tiers_json'] = Variable<String>(tiersJson);
    map['applicable_product_uuids_json'] =
        Variable<String>(applicableProductUuidsJson);
    map['applicable_category_uuids_json'] =
        Variable<String>(applicableCategoryUuidsJson);
    map['applicable_customer_uuids_json'] =
        Variable<String>(applicableCustomerUuidsJson);
    if (!nullToAbsent || minOrderAmount != null) {
      map['min_order_amount'] = Variable<double>(minOrderAmount);
    }
    if (!nullToAbsent || maxDiscountAmount != null) {
      map['max_discount_amount'] = Variable<double>(maxDiscountAmount);
    }
    if (!nullToAbsent || maxUsesTotal != null) {
      map['max_uses_total'] = Variable<int>(maxUsesTotal);
    }
    if (!nullToAbsent || maxUsesPerCustomer != null) {
      map['max_uses_per_customer'] = Variable<int>(maxUsesPerCustomer);
    }
    map['current_usage_count'] = Variable<int>(currentUsageCount);
    if (!nullToAbsent || validFrom != null) {
      map['valid_from'] = Variable<DateTime>(validFrom);
    }
    if (!nullToAbsent || validUntil != null) {
      map['valid_until'] = Variable<DateTime>(validUntil);
    }
    map['valid_days_of_week_json'] = Variable<String>(validDaysOfWeekJson);
    if (!nullToAbsent || validTimeStart != null) {
      map['valid_time_start'] = Variable<String>(validTimeStart);
    }
    if (!nullToAbsent || validTimeEnd != null) {
      map['valid_time_end'] = Variable<String>(validTimeEnd);
    }
    map['can_stack_with_others'] = Variable<bool>(canStackWithOthers);
    map['stack_priority'] = Variable<int>(stackPriority);
    map['created_at'] = Variable<DateTime>(createdAt);
    if (!nullToAbsent || updatedAt != null) {
      map['updated_at'] = Variable<DateTime>(updatedAt);
    }
    return map;
  }

  DiscountTableCompanion toCompanion(bool nullToAbsent) {
    return DiscountTableCompanion(
      id: Value(id),
      uuid: Value(uuid),
      name: Value(name),
      code: Value(code),
      description: description == null && nullToAbsent
          ? const Value.absent()
          : Value(description),
      type: Value(type),
      scope: Value(scope),
      status: Value(status),
      percentageOff: percentageOff == null && nullToAbsent
          ? const Value.absent()
          : Value(percentageOff),
      fixedAmountOff: fixedAmountOff == null && nullToAbsent
          ? const Value.absent()
          : Value(fixedAmountOff),
      buyQuantity: buyQuantity == null && nullToAbsent
          ? const Value.absent()
          : Value(buyQuantity),
      getQuantity: getQuantity == null && nullToAbsent
          ? const Value.absent()
          : Value(getQuantity),
      getDiscountPercent: getDiscountPercent == null && nullToAbsent
          ? const Value.absent()
          : Value(getDiscountPercent),
      tiersJson: Value(tiersJson),
      applicableProductUuidsJson: Value(applicableProductUuidsJson),
      applicableCategoryUuidsJson: Value(applicableCategoryUuidsJson),
      applicableCustomerUuidsJson: Value(applicableCustomerUuidsJson),
      minOrderAmount: minOrderAmount == null && nullToAbsent
          ? const Value.absent()
          : Value(minOrderAmount),
      maxDiscountAmount: maxDiscountAmount == null && nullToAbsent
          ? const Value.absent()
          : Value(maxDiscountAmount),
      maxUsesTotal: maxUsesTotal == null && nullToAbsent
          ? const Value.absent()
          : Value(maxUsesTotal),
      maxUsesPerCustomer: maxUsesPerCustomer == null && nullToAbsent
          ? const Value.absent()
          : Value(maxUsesPerCustomer),
      currentUsageCount: Value(currentUsageCount),
      validFrom: validFrom == null && nullToAbsent
          ? const Value.absent()
          : Value(validFrom),
      validUntil: validUntil == null && nullToAbsent
          ? const Value.absent()
          : Value(validUntil),
      validDaysOfWeekJson: Value(validDaysOfWeekJson),
      validTimeStart: validTimeStart == null && nullToAbsent
          ? const Value.absent()
          : Value(validTimeStart),
      validTimeEnd: validTimeEnd == null && nullToAbsent
          ? const Value.absent()
          : Value(validTimeEnd),
      canStackWithOthers: Value(canStackWithOthers),
      stackPriority: Value(stackPriority),
      createdAt: Value(createdAt),
      updatedAt: updatedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(updatedAt),
    );
  }

  factory DiscountTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return DiscountTableData(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      name: serializer.fromJson<String>(json['name']),
      code: serializer.fromJson<String>(json['code']),
      description: serializer.fromJson<String?>(json['description']),
      type: serializer.fromJson<String>(json['type']),
      scope: serializer.fromJson<String>(json['scope']),
      status: serializer.fromJson<String>(json['status']),
      percentageOff: serializer.fromJson<double?>(json['percentageOff']),
      fixedAmountOff: serializer.fromJson<double?>(json['fixedAmountOff']),
      buyQuantity: serializer.fromJson<int?>(json['buyQuantity']),
      getQuantity: serializer.fromJson<int?>(json['getQuantity']),
      getDiscountPercent:
          serializer.fromJson<double?>(json['getDiscountPercent']),
      tiersJson: serializer.fromJson<String>(json['tiersJson']),
      applicableProductUuidsJson:
          serializer.fromJson<String>(json['applicableProductUuidsJson']),
      applicableCategoryUuidsJson:
          serializer.fromJson<String>(json['applicableCategoryUuidsJson']),
      applicableCustomerUuidsJson:
          serializer.fromJson<String>(json['applicableCustomerUuidsJson']),
      minOrderAmount: serializer.fromJson<double?>(json['minOrderAmount']),
      maxDiscountAmount:
          serializer.fromJson<double?>(json['maxDiscountAmount']),
      maxUsesTotal: serializer.fromJson<int?>(json['maxUsesTotal']),
      maxUsesPerCustomer: serializer.fromJson<int?>(json['maxUsesPerCustomer']),
      currentUsageCount: serializer.fromJson<int>(json['currentUsageCount']),
      validFrom: serializer.fromJson<DateTime?>(json['validFrom']),
      validUntil: serializer.fromJson<DateTime?>(json['validUntil']),
      validDaysOfWeekJson:
          serializer.fromJson<String>(json['validDaysOfWeekJson']),
      validTimeStart: serializer.fromJson<String?>(json['validTimeStart']),
      validTimeEnd: serializer.fromJson<String?>(json['validTimeEnd']),
      canStackWithOthers: serializer.fromJson<bool>(json['canStackWithOthers']),
      stackPriority: serializer.fromJson<int>(json['stackPriority']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime?>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'name': serializer.toJson<String>(name),
      'code': serializer.toJson<String>(code),
      'description': serializer.toJson<String?>(description),
      'type': serializer.toJson<String>(type),
      'scope': serializer.toJson<String>(scope),
      'status': serializer.toJson<String>(status),
      'percentageOff': serializer.toJson<double?>(percentageOff),
      'fixedAmountOff': serializer.toJson<double?>(fixedAmountOff),
      'buyQuantity': serializer.toJson<int?>(buyQuantity),
      'getQuantity': serializer.toJson<int?>(getQuantity),
      'getDiscountPercent': serializer.toJson<double?>(getDiscountPercent),
      'tiersJson': serializer.toJson<String>(tiersJson),
      'applicableProductUuidsJson':
          serializer.toJson<String>(applicableProductUuidsJson),
      'applicableCategoryUuidsJson':
          serializer.toJson<String>(applicableCategoryUuidsJson),
      'applicableCustomerUuidsJson':
          serializer.toJson<String>(applicableCustomerUuidsJson),
      'minOrderAmount': serializer.toJson<double?>(minOrderAmount),
      'maxDiscountAmount': serializer.toJson<double?>(maxDiscountAmount),
      'maxUsesTotal': serializer.toJson<int?>(maxUsesTotal),
      'maxUsesPerCustomer': serializer.toJson<int?>(maxUsesPerCustomer),
      'currentUsageCount': serializer.toJson<int>(currentUsageCount),
      'validFrom': serializer.toJson<DateTime?>(validFrom),
      'validUntil': serializer.toJson<DateTime?>(validUntil),
      'validDaysOfWeekJson': serializer.toJson<String>(validDaysOfWeekJson),
      'validTimeStart': serializer.toJson<String?>(validTimeStart),
      'validTimeEnd': serializer.toJson<String?>(validTimeEnd),
      'canStackWithOthers': serializer.toJson<bool>(canStackWithOthers),
      'stackPriority': serializer.toJson<int>(stackPriority),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime?>(updatedAt),
    };
  }

  DiscountTableData copyWith(
          {int? id,
          String? uuid,
          String? name,
          String? code,
          Value<String?> description = const Value.absent(),
          String? type,
          String? scope,
          String? status,
          Value<double?> percentageOff = const Value.absent(),
          Value<double?> fixedAmountOff = const Value.absent(),
          Value<int?> buyQuantity = const Value.absent(),
          Value<int?> getQuantity = const Value.absent(),
          Value<double?> getDiscountPercent = const Value.absent(),
          String? tiersJson,
          String? applicableProductUuidsJson,
          String? applicableCategoryUuidsJson,
          String? applicableCustomerUuidsJson,
          Value<double?> minOrderAmount = const Value.absent(),
          Value<double?> maxDiscountAmount = const Value.absent(),
          Value<int?> maxUsesTotal = const Value.absent(),
          Value<int?> maxUsesPerCustomer = const Value.absent(),
          int? currentUsageCount,
          Value<DateTime?> validFrom = const Value.absent(),
          Value<DateTime?> validUntil = const Value.absent(),
          String? validDaysOfWeekJson,
          Value<String?> validTimeStart = const Value.absent(),
          Value<String?> validTimeEnd = const Value.absent(),
          bool? canStackWithOthers,
          int? stackPriority,
          DateTime? createdAt,
          Value<DateTime?> updatedAt = const Value.absent()}) =>
      DiscountTableData(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        name: name ?? this.name,
        code: code ?? this.code,
        description: description.present ? description.value : this.description,
        type: type ?? this.type,
        scope: scope ?? this.scope,
        status: status ?? this.status,
        percentageOff:
            percentageOff.present ? percentageOff.value : this.percentageOff,
        fixedAmountOff:
            fixedAmountOff.present ? fixedAmountOff.value : this.fixedAmountOff,
        buyQuantity: buyQuantity.present ? buyQuantity.value : this.buyQuantity,
        getQuantity: getQuantity.present ? getQuantity.value : this.getQuantity,
        getDiscountPercent: getDiscountPercent.present
            ? getDiscountPercent.value
            : this.getDiscountPercent,
        tiersJson: tiersJson ?? this.tiersJson,
        applicableProductUuidsJson:
            applicableProductUuidsJson ?? this.applicableProductUuidsJson,
        applicableCategoryUuidsJson:
            applicableCategoryUuidsJson ?? this.applicableCategoryUuidsJson,
        applicableCustomerUuidsJson:
            applicableCustomerUuidsJson ?? this.applicableCustomerUuidsJson,
        minOrderAmount:
            minOrderAmount.present ? minOrderAmount.value : this.minOrderAmount,
        maxDiscountAmount: maxDiscountAmount.present
            ? maxDiscountAmount.value
            : this.maxDiscountAmount,
        maxUsesTotal:
            maxUsesTotal.present ? maxUsesTotal.value : this.maxUsesTotal,
        maxUsesPerCustomer: maxUsesPerCustomer.present
            ? maxUsesPerCustomer.value
            : this.maxUsesPerCustomer,
        currentUsageCount: currentUsageCount ?? this.currentUsageCount,
        validFrom: validFrom.present ? validFrom.value : this.validFrom,
        validUntil: validUntil.present ? validUntil.value : this.validUntil,
        validDaysOfWeekJson: validDaysOfWeekJson ?? this.validDaysOfWeekJson,
        validTimeStart:
            validTimeStart.present ? validTimeStart.value : this.validTimeStart,
        validTimeEnd:
            validTimeEnd.present ? validTimeEnd.value : this.validTimeEnd,
        canStackWithOthers: canStackWithOthers ?? this.canStackWithOthers,
        stackPriority: stackPriority ?? this.stackPriority,
        createdAt: createdAt ?? this.createdAt,
        updatedAt: updatedAt.present ? updatedAt.value : this.updatedAt,
      );
  DiscountTableData copyWithCompanion(DiscountTableCompanion data) {
    return DiscountTableData(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      name: data.name.present ? data.name.value : this.name,
      code: data.code.present ? data.code.value : this.code,
      description:
          data.description.present ? data.description.value : this.description,
      type: data.type.present ? data.type.value : this.type,
      scope: data.scope.present ? data.scope.value : this.scope,
      status: data.status.present ? data.status.value : this.status,
      percentageOff: data.percentageOff.present
          ? data.percentageOff.value
          : this.percentageOff,
      fixedAmountOff: data.fixedAmountOff.present
          ? data.fixedAmountOff.value
          : this.fixedAmountOff,
      buyQuantity:
          data.buyQuantity.present ? data.buyQuantity.value : this.buyQuantity,
      getQuantity:
          data.getQuantity.present ? data.getQuantity.value : this.getQuantity,
      getDiscountPercent: data.getDiscountPercent.present
          ? data.getDiscountPercent.value
          : this.getDiscountPercent,
      tiersJson: data.tiersJson.present ? data.tiersJson.value : this.tiersJson,
      applicableProductUuidsJson: data.applicableProductUuidsJson.present
          ? data.applicableProductUuidsJson.value
          : this.applicableProductUuidsJson,
      applicableCategoryUuidsJson: data.applicableCategoryUuidsJson.present
          ? data.applicableCategoryUuidsJson.value
          : this.applicableCategoryUuidsJson,
      applicableCustomerUuidsJson: data.applicableCustomerUuidsJson.present
          ? data.applicableCustomerUuidsJson.value
          : this.applicableCustomerUuidsJson,
      minOrderAmount: data.minOrderAmount.present
          ? data.minOrderAmount.value
          : this.minOrderAmount,
      maxDiscountAmount: data.maxDiscountAmount.present
          ? data.maxDiscountAmount.value
          : this.maxDiscountAmount,
      maxUsesTotal: data.maxUsesTotal.present
          ? data.maxUsesTotal.value
          : this.maxUsesTotal,
      maxUsesPerCustomer: data.maxUsesPerCustomer.present
          ? data.maxUsesPerCustomer.value
          : this.maxUsesPerCustomer,
      currentUsageCount: data.currentUsageCount.present
          ? data.currentUsageCount.value
          : this.currentUsageCount,
      validFrom: data.validFrom.present ? data.validFrom.value : this.validFrom,
      validUntil:
          data.validUntil.present ? data.validUntil.value : this.validUntil,
      validDaysOfWeekJson: data.validDaysOfWeekJson.present
          ? data.validDaysOfWeekJson.value
          : this.validDaysOfWeekJson,
      validTimeStart: data.validTimeStart.present
          ? data.validTimeStart.value
          : this.validTimeStart,
      validTimeEnd: data.validTimeEnd.present
          ? data.validTimeEnd.value
          : this.validTimeEnd,
      canStackWithOthers: data.canStackWithOthers.present
          ? data.canStackWithOthers.value
          : this.canStackWithOthers,
      stackPriority: data.stackPriority.present
          ? data.stackPriority.value
          : this.stackPriority,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('DiscountTableData(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('code: $code, ')
          ..write('description: $description, ')
          ..write('type: $type, ')
          ..write('scope: $scope, ')
          ..write('status: $status, ')
          ..write('percentageOff: $percentageOff, ')
          ..write('fixedAmountOff: $fixedAmountOff, ')
          ..write('buyQuantity: $buyQuantity, ')
          ..write('getQuantity: $getQuantity, ')
          ..write('getDiscountPercent: $getDiscountPercent, ')
          ..write('tiersJson: $tiersJson, ')
          ..write('applicableProductUuidsJson: $applicableProductUuidsJson, ')
          ..write('applicableCategoryUuidsJson: $applicableCategoryUuidsJson, ')
          ..write('applicableCustomerUuidsJson: $applicableCustomerUuidsJson, ')
          ..write('minOrderAmount: $minOrderAmount, ')
          ..write('maxDiscountAmount: $maxDiscountAmount, ')
          ..write('maxUsesTotal: $maxUsesTotal, ')
          ..write('maxUsesPerCustomer: $maxUsesPerCustomer, ')
          ..write('currentUsageCount: $currentUsageCount, ')
          ..write('validFrom: $validFrom, ')
          ..write('validUntil: $validUntil, ')
          ..write('validDaysOfWeekJson: $validDaysOfWeekJson, ')
          ..write('validTimeStart: $validTimeStart, ')
          ..write('validTimeEnd: $validTimeEnd, ')
          ..write('canStackWithOthers: $canStackWithOthers, ')
          ..write('stackPriority: $stackPriority, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        id,
        uuid,
        name,
        code,
        description,
        type,
        scope,
        status,
        percentageOff,
        fixedAmountOff,
        buyQuantity,
        getQuantity,
        getDiscountPercent,
        tiersJson,
        applicableProductUuidsJson,
        applicableCategoryUuidsJson,
        applicableCustomerUuidsJson,
        minOrderAmount,
        maxDiscountAmount,
        maxUsesTotal,
        maxUsesPerCustomer,
        currentUsageCount,
        validFrom,
        validUntil,
        validDaysOfWeekJson,
        validTimeStart,
        validTimeEnd,
        canStackWithOthers,
        stackPriority,
        createdAt,
        updatedAt
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is DiscountTableData &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.name == this.name &&
          other.code == this.code &&
          other.description == this.description &&
          other.type == this.type &&
          other.scope == this.scope &&
          other.status == this.status &&
          other.percentageOff == this.percentageOff &&
          other.fixedAmountOff == this.fixedAmountOff &&
          other.buyQuantity == this.buyQuantity &&
          other.getQuantity == this.getQuantity &&
          other.getDiscountPercent == this.getDiscountPercent &&
          other.tiersJson == this.tiersJson &&
          other.applicableProductUuidsJson == this.applicableProductUuidsJson &&
          other.applicableCategoryUuidsJson ==
              this.applicableCategoryUuidsJson &&
          other.applicableCustomerUuidsJson ==
              this.applicableCustomerUuidsJson &&
          other.minOrderAmount == this.minOrderAmount &&
          other.maxDiscountAmount == this.maxDiscountAmount &&
          other.maxUsesTotal == this.maxUsesTotal &&
          other.maxUsesPerCustomer == this.maxUsesPerCustomer &&
          other.currentUsageCount == this.currentUsageCount &&
          other.validFrom == this.validFrom &&
          other.validUntil == this.validUntil &&
          other.validDaysOfWeekJson == this.validDaysOfWeekJson &&
          other.validTimeStart == this.validTimeStart &&
          other.validTimeEnd == this.validTimeEnd &&
          other.canStackWithOthers == this.canStackWithOthers &&
          other.stackPriority == this.stackPriority &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class DiscountTableCompanion extends UpdateCompanion<DiscountTableData> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String> name;
  final Value<String> code;
  final Value<String?> description;
  final Value<String> type;
  final Value<String> scope;
  final Value<String> status;
  final Value<double?> percentageOff;
  final Value<double?> fixedAmountOff;
  final Value<int?> buyQuantity;
  final Value<int?> getQuantity;
  final Value<double?> getDiscountPercent;
  final Value<String> tiersJson;
  final Value<String> applicableProductUuidsJson;
  final Value<String> applicableCategoryUuidsJson;
  final Value<String> applicableCustomerUuidsJson;
  final Value<double?> minOrderAmount;
  final Value<double?> maxDiscountAmount;
  final Value<int?> maxUsesTotal;
  final Value<int?> maxUsesPerCustomer;
  final Value<int> currentUsageCount;
  final Value<DateTime?> validFrom;
  final Value<DateTime?> validUntil;
  final Value<String> validDaysOfWeekJson;
  final Value<String?> validTimeStart;
  final Value<String?> validTimeEnd;
  final Value<bool> canStackWithOthers;
  final Value<int> stackPriority;
  final Value<DateTime> createdAt;
  final Value<DateTime?> updatedAt;
  const DiscountTableCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.name = const Value.absent(),
    this.code = const Value.absent(),
    this.description = const Value.absent(),
    this.type = const Value.absent(),
    this.scope = const Value.absent(),
    this.status = const Value.absent(),
    this.percentageOff = const Value.absent(),
    this.fixedAmountOff = const Value.absent(),
    this.buyQuantity = const Value.absent(),
    this.getQuantity = const Value.absent(),
    this.getDiscountPercent = const Value.absent(),
    this.tiersJson = const Value.absent(),
    this.applicableProductUuidsJson = const Value.absent(),
    this.applicableCategoryUuidsJson = const Value.absent(),
    this.applicableCustomerUuidsJson = const Value.absent(),
    this.minOrderAmount = const Value.absent(),
    this.maxDiscountAmount = const Value.absent(),
    this.maxUsesTotal = const Value.absent(),
    this.maxUsesPerCustomer = const Value.absent(),
    this.currentUsageCount = const Value.absent(),
    this.validFrom = const Value.absent(),
    this.validUntil = const Value.absent(),
    this.validDaysOfWeekJson = const Value.absent(),
    this.validTimeStart = const Value.absent(),
    this.validTimeEnd = const Value.absent(),
    this.canStackWithOthers = const Value.absent(),
    this.stackPriority = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  DiscountTableCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    required String name,
    required String code,
    this.description = const Value.absent(),
    required String type,
    required String scope,
    this.status = const Value.absent(),
    this.percentageOff = const Value.absent(),
    this.fixedAmountOff = const Value.absent(),
    this.buyQuantity = const Value.absent(),
    this.getQuantity = const Value.absent(),
    this.getDiscountPercent = const Value.absent(),
    this.tiersJson = const Value.absent(),
    this.applicableProductUuidsJson = const Value.absent(),
    this.applicableCategoryUuidsJson = const Value.absent(),
    this.applicableCustomerUuidsJson = const Value.absent(),
    this.minOrderAmount = const Value.absent(),
    this.maxDiscountAmount = const Value.absent(),
    this.maxUsesTotal = const Value.absent(),
    this.maxUsesPerCustomer = const Value.absent(),
    this.currentUsageCount = const Value.absent(),
    this.validFrom = const Value.absent(),
    this.validUntil = const Value.absent(),
    this.validDaysOfWeekJson = const Value.absent(),
    this.validTimeStart = const Value.absent(),
    this.validTimeEnd = const Value.absent(),
    this.canStackWithOthers = const Value.absent(),
    this.stackPriority = const Value.absent(),
    required DateTime createdAt,
    this.updatedAt = const Value.absent(),
  })  : uuid = Value(uuid),
        name = Value(name),
        code = Value(code),
        type = Value(type),
        scope = Value(scope),
        createdAt = Value(createdAt);
  static Insertable<DiscountTableData> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? name,
    Expression<String>? code,
    Expression<String>? description,
    Expression<String>? type,
    Expression<String>? scope,
    Expression<String>? status,
    Expression<double>? percentageOff,
    Expression<double>? fixedAmountOff,
    Expression<int>? buyQuantity,
    Expression<int>? getQuantity,
    Expression<double>? getDiscountPercent,
    Expression<String>? tiersJson,
    Expression<String>? applicableProductUuidsJson,
    Expression<String>? applicableCategoryUuidsJson,
    Expression<String>? applicableCustomerUuidsJson,
    Expression<double>? minOrderAmount,
    Expression<double>? maxDiscountAmount,
    Expression<int>? maxUsesTotal,
    Expression<int>? maxUsesPerCustomer,
    Expression<int>? currentUsageCount,
    Expression<DateTime>? validFrom,
    Expression<DateTime>? validUntil,
    Expression<String>? validDaysOfWeekJson,
    Expression<String>? validTimeStart,
    Expression<String>? validTimeEnd,
    Expression<bool>? canStackWithOthers,
    Expression<int>? stackPriority,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (name != null) 'name': name,
      if (code != null) 'code': code,
      if (description != null) 'description': description,
      if (type != null) 'type': type,
      if (scope != null) 'scope': scope,
      if (status != null) 'status': status,
      if (percentageOff != null) 'percentage_off': percentageOff,
      if (fixedAmountOff != null) 'fixed_amount_off': fixedAmountOff,
      if (buyQuantity != null) 'buy_quantity': buyQuantity,
      if (getQuantity != null) 'get_quantity': getQuantity,
      if (getDiscountPercent != null)
        'get_discount_percent': getDiscountPercent,
      if (tiersJson != null) 'tiers_json': tiersJson,
      if (applicableProductUuidsJson != null)
        'applicable_product_uuids_json': applicableProductUuidsJson,
      if (applicableCategoryUuidsJson != null)
        'applicable_category_uuids_json': applicableCategoryUuidsJson,
      if (applicableCustomerUuidsJson != null)
        'applicable_customer_uuids_json': applicableCustomerUuidsJson,
      if (minOrderAmount != null) 'min_order_amount': minOrderAmount,
      if (maxDiscountAmount != null) 'max_discount_amount': maxDiscountAmount,
      if (maxUsesTotal != null) 'max_uses_total': maxUsesTotal,
      if (maxUsesPerCustomer != null)
        'max_uses_per_customer': maxUsesPerCustomer,
      if (currentUsageCount != null) 'current_usage_count': currentUsageCount,
      if (validFrom != null) 'valid_from': validFrom,
      if (validUntil != null) 'valid_until': validUntil,
      if (validDaysOfWeekJson != null)
        'valid_days_of_week_json': validDaysOfWeekJson,
      if (validTimeStart != null) 'valid_time_start': validTimeStart,
      if (validTimeEnd != null) 'valid_time_end': validTimeEnd,
      if (canStackWithOthers != null)
        'can_stack_with_others': canStackWithOthers,
      if (stackPriority != null) 'stack_priority': stackPriority,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  DiscountTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String>? name,
      Value<String>? code,
      Value<String?>? description,
      Value<String>? type,
      Value<String>? scope,
      Value<String>? status,
      Value<double?>? percentageOff,
      Value<double?>? fixedAmountOff,
      Value<int?>? buyQuantity,
      Value<int?>? getQuantity,
      Value<double?>? getDiscountPercent,
      Value<String>? tiersJson,
      Value<String>? applicableProductUuidsJson,
      Value<String>? applicableCategoryUuidsJson,
      Value<String>? applicableCustomerUuidsJson,
      Value<double?>? minOrderAmount,
      Value<double?>? maxDiscountAmount,
      Value<int?>? maxUsesTotal,
      Value<int?>? maxUsesPerCustomer,
      Value<int>? currentUsageCount,
      Value<DateTime?>? validFrom,
      Value<DateTime?>? validUntil,
      Value<String>? validDaysOfWeekJson,
      Value<String?>? validTimeStart,
      Value<String?>? validTimeEnd,
      Value<bool>? canStackWithOthers,
      Value<int>? stackPriority,
      Value<DateTime>? createdAt,
      Value<DateTime?>? updatedAt}) {
    return DiscountTableCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      name: name ?? this.name,
      code: code ?? this.code,
      description: description ?? this.description,
      type: type ?? this.type,
      scope: scope ?? this.scope,
      status: status ?? this.status,
      percentageOff: percentageOff ?? this.percentageOff,
      fixedAmountOff: fixedAmountOff ?? this.fixedAmountOff,
      buyQuantity: buyQuantity ?? this.buyQuantity,
      getQuantity: getQuantity ?? this.getQuantity,
      getDiscountPercent: getDiscountPercent ?? this.getDiscountPercent,
      tiersJson: tiersJson ?? this.tiersJson,
      applicableProductUuidsJson:
          applicableProductUuidsJson ?? this.applicableProductUuidsJson,
      applicableCategoryUuidsJson:
          applicableCategoryUuidsJson ?? this.applicableCategoryUuidsJson,
      applicableCustomerUuidsJson:
          applicableCustomerUuidsJson ?? this.applicableCustomerUuidsJson,
      minOrderAmount: minOrderAmount ?? this.minOrderAmount,
      maxDiscountAmount: maxDiscountAmount ?? this.maxDiscountAmount,
      maxUsesTotal: maxUsesTotal ?? this.maxUsesTotal,
      maxUsesPerCustomer: maxUsesPerCustomer ?? this.maxUsesPerCustomer,
      currentUsageCount: currentUsageCount ?? this.currentUsageCount,
      validFrom: validFrom ?? this.validFrom,
      validUntil: validUntil ?? this.validUntil,
      validDaysOfWeekJson: validDaysOfWeekJson ?? this.validDaysOfWeekJson,
      validTimeStart: validTimeStart ?? this.validTimeStart,
      validTimeEnd: validTimeEnd ?? this.validTimeEnd,
      canStackWithOthers: canStackWithOthers ?? this.canStackWithOthers,
      stackPriority: stackPriority ?? this.stackPriority,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (description.present) {
      map['description'] = Variable<String>(description.value);
    }
    if (type.present) {
      map['type'] = Variable<String>(type.value);
    }
    if (scope.present) {
      map['scope'] = Variable<String>(scope.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (percentageOff.present) {
      map['percentage_off'] = Variable<double>(percentageOff.value);
    }
    if (fixedAmountOff.present) {
      map['fixed_amount_off'] = Variable<double>(fixedAmountOff.value);
    }
    if (buyQuantity.present) {
      map['buy_quantity'] = Variable<int>(buyQuantity.value);
    }
    if (getQuantity.present) {
      map['get_quantity'] = Variable<int>(getQuantity.value);
    }
    if (getDiscountPercent.present) {
      map['get_discount_percent'] = Variable<double>(getDiscountPercent.value);
    }
    if (tiersJson.present) {
      map['tiers_json'] = Variable<String>(tiersJson.value);
    }
    if (applicableProductUuidsJson.present) {
      map['applicable_product_uuids_json'] =
          Variable<String>(applicableProductUuidsJson.value);
    }
    if (applicableCategoryUuidsJson.present) {
      map['applicable_category_uuids_json'] =
          Variable<String>(applicableCategoryUuidsJson.value);
    }
    if (applicableCustomerUuidsJson.present) {
      map['applicable_customer_uuids_json'] =
          Variable<String>(applicableCustomerUuidsJson.value);
    }
    if (minOrderAmount.present) {
      map['min_order_amount'] = Variable<double>(minOrderAmount.value);
    }
    if (maxDiscountAmount.present) {
      map['max_discount_amount'] = Variable<double>(maxDiscountAmount.value);
    }
    if (maxUsesTotal.present) {
      map['max_uses_total'] = Variable<int>(maxUsesTotal.value);
    }
    if (maxUsesPerCustomer.present) {
      map['max_uses_per_customer'] = Variable<int>(maxUsesPerCustomer.value);
    }
    if (currentUsageCount.present) {
      map['current_usage_count'] = Variable<int>(currentUsageCount.value);
    }
    if (validFrom.present) {
      map['valid_from'] = Variable<DateTime>(validFrom.value);
    }
    if (validUntil.present) {
      map['valid_until'] = Variable<DateTime>(validUntil.value);
    }
    if (validDaysOfWeekJson.present) {
      map['valid_days_of_week_json'] =
          Variable<String>(validDaysOfWeekJson.value);
    }
    if (validTimeStart.present) {
      map['valid_time_start'] = Variable<String>(validTimeStart.value);
    }
    if (validTimeEnd.present) {
      map['valid_time_end'] = Variable<String>(validTimeEnd.value);
    }
    if (canStackWithOthers.present) {
      map['can_stack_with_others'] = Variable<bool>(canStackWithOthers.value);
    }
    if (stackPriority.present) {
      map['stack_priority'] = Variable<int>(stackPriority.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('DiscountTableCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('code: $code, ')
          ..write('description: $description, ')
          ..write('type: $type, ')
          ..write('scope: $scope, ')
          ..write('status: $status, ')
          ..write('percentageOff: $percentageOff, ')
          ..write('fixedAmountOff: $fixedAmountOff, ')
          ..write('buyQuantity: $buyQuantity, ')
          ..write('getQuantity: $getQuantity, ')
          ..write('getDiscountPercent: $getDiscountPercent, ')
          ..write('tiersJson: $tiersJson, ')
          ..write('applicableProductUuidsJson: $applicableProductUuidsJson, ')
          ..write('applicableCategoryUuidsJson: $applicableCategoryUuidsJson, ')
          ..write('applicableCustomerUuidsJson: $applicableCustomerUuidsJson, ')
          ..write('minOrderAmount: $minOrderAmount, ')
          ..write('maxDiscountAmount: $maxDiscountAmount, ')
          ..write('maxUsesTotal: $maxUsesTotal, ')
          ..write('maxUsesPerCustomer: $maxUsesPerCustomer, ')
          ..write('currentUsageCount: $currentUsageCount, ')
          ..write('validFrom: $validFrom, ')
          ..write('validUntil: $validUntil, ')
          ..write('validDaysOfWeekJson: $validDaysOfWeekJson, ')
          ..write('validTimeStart: $validTimeStart, ')
          ..write('validTimeEnd: $validTimeEnd, ')
          ..write('canStackWithOthers: $canStackWithOthers, ')
          ..write('stackPriority: $stackPriority, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class $AppliedDiscountTableTable extends AppliedDiscountTable
    with TableInfo<$AppliedDiscountTableTable, AppliedDiscountTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $AppliedDiscountTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _orderUuidMeta =
      const VerificationMeta('orderUuid');
  @override
  late final GeneratedColumn<String> orderUuid = GeneratedColumn<String>(
      'order_uuid', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _discountUuidMeta =
      const VerificationMeta('discountUuid');
  @override
  late final GeneratedColumn<String> discountUuid = GeneratedColumn<String>(
      'discount_uuid', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _discountNameMeta =
      const VerificationMeta('discountName');
  @override
  late final GeneratedColumn<String> discountName = GeneratedColumn<String>(
      'discount_name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _discountCodeMeta =
      const VerificationMeta('discountCode');
  @override
  late final GeneratedColumn<String> discountCode = GeneratedColumn<String>(
      'discount_code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _typeMeta = const VerificationMeta('type');
  @override
  late final GeneratedColumn<String> type = GeneratedColumn<String>(
      'type', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _discountAmountMeta =
      const VerificationMeta('discountAmount');
  @override
  late final GeneratedColumn<double> discountAmount = GeneratedColumn<double>(
      'discount_amount', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _appliedToItemUuidMeta =
      const VerificationMeta('appliedToItemUuid');
  @override
  late final GeneratedColumn<String> appliedToItemUuid =
      GeneratedColumn<String>('applied_to_item_uuid', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _appliedToItemNameMeta =
      const VerificationMeta('appliedToItemName');
  @override
  late final GeneratedColumn<String> appliedToItemName =
      GeneratedColumn<String>('applied_to_item_name', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _appliedAtMeta =
      const VerificationMeta('appliedAt');
  @override
  late final GeneratedColumn<DateTime> appliedAt = GeneratedColumn<DateTime>(
      'applied_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _appliedByUuidMeta =
      const VerificationMeta('appliedByUuid');
  @override
  late final GeneratedColumn<String> appliedByUuid = GeneratedColumn<String>(
      'applied_by_uuid', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        orderUuid,
        discountUuid,
        discountName,
        discountCode,
        type,
        discountAmount,
        appliedToItemUuid,
        appliedToItemName,
        appliedAt,
        appliedByUuid
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'applied_discount_table';
  @override
  VerificationContext validateIntegrity(
      Insertable<AppliedDiscountTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('order_uuid')) {
      context.handle(_orderUuidMeta,
          orderUuid.isAcceptableOrUnknown(data['order_uuid']!, _orderUuidMeta));
    } else if (isInserting) {
      context.missing(_orderUuidMeta);
    }
    if (data.containsKey('discount_uuid')) {
      context.handle(
          _discountUuidMeta,
          discountUuid.isAcceptableOrUnknown(
              data['discount_uuid']!, _discountUuidMeta));
    } else if (isInserting) {
      context.missing(_discountUuidMeta);
    }
    if (data.containsKey('discount_name')) {
      context.handle(
          _discountNameMeta,
          discountName.isAcceptableOrUnknown(
              data['discount_name']!, _discountNameMeta));
    } else if (isInserting) {
      context.missing(_discountNameMeta);
    }
    if (data.containsKey('discount_code')) {
      context.handle(
          _discountCodeMeta,
          discountCode.isAcceptableOrUnknown(
              data['discount_code']!, _discountCodeMeta));
    } else if (isInserting) {
      context.missing(_discountCodeMeta);
    }
    if (data.containsKey('type')) {
      context.handle(
          _typeMeta, type.isAcceptableOrUnknown(data['type']!, _typeMeta));
    } else if (isInserting) {
      context.missing(_typeMeta);
    }
    if (data.containsKey('discount_amount')) {
      context.handle(
          _discountAmountMeta,
          discountAmount.isAcceptableOrUnknown(
              data['discount_amount']!, _discountAmountMeta));
    } else if (isInserting) {
      context.missing(_discountAmountMeta);
    }
    if (data.containsKey('applied_to_item_uuid')) {
      context.handle(
          _appliedToItemUuidMeta,
          appliedToItemUuid.isAcceptableOrUnknown(
              data['applied_to_item_uuid']!, _appliedToItemUuidMeta));
    }
    if (data.containsKey('applied_to_item_name')) {
      context.handle(
          _appliedToItemNameMeta,
          appliedToItemName.isAcceptableOrUnknown(
              data['applied_to_item_name']!, _appliedToItemNameMeta));
    }
    if (data.containsKey('applied_at')) {
      context.handle(_appliedAtMeta,
          appliedAt.isAcceptableOrUnknown(data['applied_at']!, _appliedAtMeta));
    } else if (isInserting) {
      context.missing(_appliedAtMeta);
    }
    if (data.containsKey('applied_by_uuid')) {
      context.handle(
          _appliedByUuidMeta,
          appliedByUuid.isAcceptableOrUnknown(
              data['applied_by_uuid']!, _appliedByUuidMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  AppliedDiscountTableData map(Map<String, dynamic> data,
      {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return AppliedDiscountTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      orderUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}order_uuid'])!,
      discountUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}discount_uuid'])!,
      discountName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}discount_name'])!,
      discountCode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}discount_code'])!,
      type: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}type'])!,
      discountAmount: attachedDatabase.typeMapping.read(
          DriftSqlType.double, data['${effectivePrefix}discount_amount'])!,
      appliedToItemUuid: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}applied_to_item_uuid']),
      appliedToItemName: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}applied_to_item_name']),
      appliedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}applied_at'])!,
      appliedByUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}applied_by_uuid']),
    );
  }

  @override
  $AppliedDiscountTableTable createAlias(String alias) {
    return $AppliedDiscountTableTable(attachedDatabase, alias);
  }
}

class AppliedDiscountTableData extends DataClass
    implements Insertable<AppliedDiscountTableData> {
  final int id;
  final String uuid;
  final String orderUuid;
  final String discountUuid;
  final String discountName;
  final String discountCode;
  final String type;
  final double discountAmount;
  final String? appliedToItemUuid;
  final String? appliedToItemName;
  final DateTime appliedAt;
  final String? appliedByUuid;
  const AppliedDiscountTableData(
      {required this.id,
      required this.uuid,
      required this.orderUuid,
      required this.discountUuid,
      required this.discountName,
      required this.discountCode,
      required this.type,
      required this.discountAmount,
      this.appliedToItemUuid,
      this.appliedToItemName,
      required this.appliedAt,
      this.appliedByUuid});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    map['order_uuid'] = Variable<String>(orderUuid);
    map['discount_uuid'] = Variable<String>(discountUuid);
    map['discount_name'] = Variable<String>(discountName);
    map['discount_code'] = Variable<String>(discountCode);
    map['type'] = Variable<String>(type);
    map['discount_amount'] = Variable<double>(discountAmount);
    if (!nullToAbsent || appliedToItemUuid != null) {
      map['applied_to_item_uuid'] = Variable<String>(appliedToItemUuid);
    }
    if (!nullToAbsent || appliedToItemName != null) {
      map['applied_to_item_name'] = Variable<String>(appliedToItemName);
    }
    map['applied_at'] = Variable<DateTime>(appliedAt);
    if (!nullToAbsent || appliedByUuid != null) {
      map['applied_by_uuid'] = Variable<String>(appliedByUuid);
    }
    return map;
  }

  AppliedDiscountTableCompanion toCompanion(bool nullToAbsent) {
    return AppliedDiscountTableCompanion(
      id: Value(id),
      uuid: Value(uuid),
      orderUuid: Value(orderUuid),
      discountUuid: Value(discountUuid),
      discountName: Value(discountName),
      discountCode: Value(discountCode),
      type: Value(type),
      discountAmount: Value(discountAmount),
      appliedToItemUuid: appliedToItemUuid == null && nullToAbsent
          ? const Value.absent()
          : Value(appliedToItemUuid),
      appliedToItemName: appliedToItemName == null && nullToAbsent
          ? const Value.absent()
          : Value(appliedToItemName),
      appliedAt: Value(appliedAt),
      appliedByUuid: appliedByUuid == null && nullToAbsent
          ? const Value.absent()
          : Value(appliedByUuid),
    );
  }

  factory AppliedDiscountTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AppliedDiscountTableData(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      orderUuid: serializer.fromJson<String>(json['orderUuid']),
      discountUuid: serializer.fromJson<String>(json['discountUuid']),
      discountName: serializer.fromJson<String>(json['discountName']),
      discountCode: serializer.fromJson<String>(json['discountCode']),
      type: serializer.fromJson<String>(json['type']),
      discountAmount: serializer.fromJson<double>(json['discountAmount']),
      appliedToItemUuid:
          serializer.fromJson<String?>(json['appliedToItemUuid']),
      appliedToItemName:
          serializer.fromJson<String?>(json['appliedToItemName']),
      appliedAt: serializer.fromJson<DateTime>(json['appliedAt']),
      appliedByUuid: serializer.fromJson<String?>(json['appliedByUuid']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'orderUuid': serializer.toJson<String>(orderUuid),
      'discountUuid': serializer.toJson<String>(discountUuid),
      'discountName': serializer.toJson<String>(discountName),
      'discountCode': serializer.toJson<String>(discountCode),
      'type': serializer.toJson<String>(type),
      'discountAmount': serializer.toJson<double>(discountAmount),
      'appliedToItemUuid': serializer.toJson<String?>(appliedToItemUuid),
      'appliedToItemName': serializer.toJson<String?>(appliedToItemName),
      'appliedAt': serializer.toJson<DateTime>(appliedAt),
      'appliedByUuid': serializer.toJson<String?>(appliedByUuid),
    };
  }

  AppliedDiscountTableData copyWith(
          {int? id,
          String? uuid,
          String? orderUuid,
          String? discountUuid,
          String? discountName,
          String? discountCode,
          String? type,
          double? discountAmount,
          Value<String?> appliedToItemUuid = const Value.absent(),
          Value<String?> appliedToItemName = const Value.absent(),
          DateTime? appliedAt,
          Value<String?> appliedByUuid = const Value.absent()}) =>
      AppliedDiscountTableData(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        orderUuid: orderUuid ?? this.orderUuid,
        discountUuid: discountUuid ?? this.discountUuid,
        discountName: discountName ?? this.discountName,
        discountCode: discountCode ?? this.discountCode,
        type: type ?? this.type,
        discountAmount: discountAmount ?? this.discountAmount,
        appliedToItemUuid: appliedToItemUuid.present
            ? appliedToItemUuid.value
            : this.appliedToItemUuid,
        appliedToItemName: appliedToItemName.present
            ? appliedToItemName.value
            : this.appliedToItemName,
        appliedAt: appliedAt ?? this.appliedAt,
        appliedByUuid:
            appliedByUuid.present ? appliedByUuid.value : this.appliedByUuid,
      );
  AppliedDiscountTableData copyWithCompanion(
      AppliedDiscountTableCompanion data) {
    return AppliedDiscountTableData(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      orderUuid: data.orderUuid.present ? data.orderUuid.value : this.orderUuid,
      discountUuid: data.discountUuid.present
          ? data.discountUuid.value
          : this.discountUuid,
      discountName: data.discountName.present
          ? data.discountName.value
          : this.discountName,
      discountCode: data.discountCode.present
          ? data.discountCode.value
          : this.discountCode,
      type: data.type.present ? data.type.value : this.type,
      discountAmount: data.discountAmount.present
          ? data.discountAmount.value
          : this.discountAmount,
      appliedToItemUuid: data.appliedToItemUuid.present
          ? data.appliedToItemUuid.value
          : this.appliedToItemUuid,
      appliedToItemName: data.appliedToItemName.present
          ? data.appliedToItemName.value
          : this.appliedToItemName,
      appliedAt: data.appliedAt.present ? data.appliedAt.value : this.appliedAt,
      appliedByUuid: data.appliedByUuid.present
          ? data.appliedByUuid.value
          : this.appliedByUuid,
    );
  }

  @override
  String toString() {
    return (StringBuffer('AppliedDiscountTableData(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('orderUuid: $orderUuid, ')
          ..write('discountUuid: $discountUuid, ')
          ..write('discountName: $discountName, ')
          ..write('discountCode: $discountCode, ')
          ..write('type: $type, ')
          ..write('discountAmount: $discountAmount, ')
          ..write('appliedToItemUuid: $appliedToItemUuid, ')
          ..write('appliedToItemName: $appliedToItemName, ')
          ..write('appliedAt: $appliedAt, ')
          ..write('appliedByUuid: $appliedByUuid')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      uuid,
      orderUuid,
      discountUuid,
      discountName,
      discountCode,
      type,
      discountAmount,
      appliedToItemUuid,
      appliedToItemName,
      appliedAt,
      appliedByUuid);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AppliedDiscountTableData &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.orderUuid == this.orderUuid &&
          other.discountUuid == this.discountUuid &&
          other.discountName == this.discountName &&
          other.discountCode == this.discountCode &&
          other.type == this.type &&
          other.discountAmount == this.discountAmount &&
          other.appliedToItemUuid == this.appliedToItemUuid &&
          other.appliedToItemName == this.appliedToItemName &&
          other.appliedAt == this.appliedAt &&
          other.appliedByUuid == this.appliedByUuid);
}

class AppliedDiscountTableCompanion
    extends UpdateCompanion<AppliedDiscountTableData> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String> orderUuid;
  final Value<String> discountUuid;
  final Value<String> discountName;
  final Value<String> discountCode;
  final Value<String> type;
  final Value<double> discountAmount;
  final Value<String?> appliedToItemUuid;
  final Value<String?> appliedToItemName;
  final Value<DateTime> appliedAt;
  final Value<String?> appliedByUuid;
  const AppliedDiscountTableCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.orderUuid = const Value.absent(),
    this.discountUuid = const Value.absent(),
    this.discountName = const Value.absent(),
    this.discountCode = const Value.absent(),
    this.type = const Value.absent(),
    this.discountAmount = const Value.absent(),
    this.appliedToItemUuid = const Value.absent(),
    this.appliedToItemName = const Value.absent(),
    this.appliedAt = const Value.absent(),
    this.appliedByUuid = const Value.absent(),
  });
  AppliedDiscountTableCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    required String orderUuid,
    required String discountUuid,
    required String discountName,
    required String discountCode,
    required String type,
    required double discountAmount,
    this.appliedToItemUuid = const Value.absent(),
    this.appliedToItemName = const Value.absent(),
    required DateTime appliedAt,
    this.appliedByUuid = const Value.absent(),
  })  : uuid = Value(uuid),
        orderUuid = Value(orderUuid),
        discountUuid = Value(discountUuid),
        discountName = Value(discountName),
        discountCode = Value(discountCode),
        type = Value(type),
        discountAmount = Value(discountAmount),
        appliedAt = Value(appliedAt);
  static Insertable<AppliedDiscountTableData> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? orderUuid,
    Expression<String>? discountUuid,
    Expression<String>? discountName,
    Expression<String>? discountCode,
    Expression<String>? type,
    Expression<double>? discountAmount,
    Expression<String>? appliedToItemUuid,
    Expression<String>? appliedToItemName,
    Expression<DateTime>? appliedAt,
    Expression<String>? appliedByUuid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (orderUuid != null) 'order_uuid': orderUuid,
      if (discountUuid != null) 'discount_uuid': discountUuid,
      if (discountName != null) 'discount_name': discountName,
      if (discountCode != null) 'discount_code': discountCode,
      if (type != null) 'type': type,
      if (discountAmount != null) 'discount_amount': discountAmount,
      if (appliedToItemUuid != null) 'applied_to_item_uuid': appliedToItemUuid,
      if (appliedToItemName != null) 'applied_to_item_name': appliedToItemName,
      if (appliedAt != null) 'applied_at': appliedAt,
      if (appliedByUuid != null) 'applied_by_uuid': appliedByUuid,
    });
  }

  AppliedDiscountTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String>? orderUuid,
      Value<String>? discountUuid,
      Value<String>? discountName,
      Value<String>? discountCode,
      Value<String>? type,
      Value<double>? discountAmount,
      Value<String?>? appliedToItemUuid,
      Value<String?>? appliedToItemName,
      Value<DateTime>? appliedAt,
      Value<String?>? appliedByUuid}) {
    return AppliedDiscountTableCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      orderUuid: orderUuid ?? this.orderUuid,
      discountUuid: discountUuid ?? this.discountUuid,
      discountName: discountName ?? this.discountName,
      discountCode: discountCode ?? this.discountCode,
      type: type ?? this.type,
      discountAmount: discountAmount ?? this.discountAmount,
      appliedToItemUuid: appliedToItemUuid ?? this.appliedToItemUuid,
      appliedToItemName: appliedToItemName ?? this.appliedToItemName,
      appliedAt: appliedAt ?? this.appliedAt,
      appliedByUuid: appliedByUuid ?? this.appliedByUuid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (orderUuid.present) {
      map['order_uuid'] = Variable<String>(orderUuid.value);
    }
    if (discountUuid.present) {
      map['discount_uuid'] = Variable<String>(discountUuid.value);
    }
    if (discountName.present) {
      map['discount_name'] = Variable<String>(discountName.value);
    }
    if (discountCode.present) {
      map['discount_code'] = Variable<String>(discountCode.value);
    }
    if (type.present) {
      map['type'] = Variable<String>(type.value);
    }
    if (discountAmount.present) {
      map['discount_amount'] = Variable<double>(discountAmount.value);
    }
    if (appliedToItemUuid.present) {
      map['applied_to_item_uuid'] = Variable<String>(appliedToItemUuid.value);
    }
    if (appliedToItemName.present) {
      map['applied_to_item_name'] = Variable<String>(appliedToItemName.value);
    }
    if (appliedAt.present) {
      map['applied_at'] = Variable<DateTime>(appliedAt.value);
    }
    if (appliedByUuid.present) {
      map['applied_by_uuid'] = Variable<String>(appliedByUuid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AppliedDiscountTableCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('orderUuid: $orderUuid, ')
          ..write('discountUuid: $discountUuid, ')
          ..write('discountName: $discountName, ')
          ..write('discountCode: $discountCode, ')
          ..write('type: $type, ')
          ..write('discountAmount: $discountAmount, ')
          ..write('appliedToItemUuid: $appliedToItemUuid, ')
          ..write('appliedToItemName: $appliedToItemName, ')
          ..write('appliedAt: $appliedAt, ')
          ..write('appliedByUuid: $appliedByUuid')
          ..write(')'))
        .toString();
  }
}

class $WaitlistTableTable extends WaitlistTable
    with TableInfo<$WaitlistTableTable, WaitlistTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $WaitlistTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _guestNameMeta =
      const VerificationMeta('guestName');
  @override
  late final GeneratedColumn<String> guestName = GeneratedColumn<String>(
      'guest_name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _phoneNumberMeta =
      const VerificationMeta('phoneNumber');
  @override
  late final GeneratedColumn<String> phoneNumber = GeneratedColumn<String>(
      'phone_number', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _partySizeMeta =
      const VerificationMeta('partySize');
  @override
  late final GeneratedColumn<int> partySize = GeneratedColumn<int>(
      'party_size', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _specialRequestsMeta =
      const VerificationMeta('specialRequests');
  @override
  late final GeneratedColumn<String> specialRequests = GeneratedColumn<String>(
      'special_requests', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _highchairNeededMeta =
      const VerificationMeta('highchairNeeded');
  @override
  late final GeneratedColumn<bool> highchairNeeded = GeneratedColumn<bool>(
      'highchair_needed', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("highchair_needed" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _wheelchairAccessibleMeta =
      const VerificationMeta('wheelchairAccessible');
  @override
  late final GeneratedColumn<bool> wheelchairAccessible = GeneratedColumn<bool>(
      'wheelchair_accessible', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("wheelchair_accessible" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _tablePreferenceMeta =
      const VerificationMeta('tablePreference');
  @override
  late final GeneratedColumn<String> tablePreference = GeneratedColumn<String>(
      'table_preference', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
      'status', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultValue: const Constant('waiting'));
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _quotedWaitTimeMeta =
      const VerificationMeta('quotedWaitTime');
  @override
  late final GeneratedColumn<DateTime> quotedWaitTime =
      GeneratedColumn<DateTime>('quoted_wait_time', aliasedName, true,
          type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _notifiedAtMeta =
      const VerificationMeta('notifiedAt');
  @override
  late final GeneratedColumn<DateTime> notifiedAt = GeneratedColumn<DateTime>(
      'notified_at', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _seatedAtMeta =
      const VerificationMeta('seatedAt');
  @override
  late final GeneratedColumn<DateTime> seatedAt = GeneratedColumn<DateTime>(
      'seated_at', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _seatedTableUuidMeta =
      const VerificationMeta('seatedTableUuid');
  @override
  late final GeneratedColumn<String> seatedTableUuid = GeneratedColumn<String>(
      'seated_table_uuid', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _queuePositionMeta =
      const VerificationMeta('queuePosition');
  @override
  late final GeneratedColumn<int> queuePosition = GeneratedColumn<int>(
      'queue_position', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        guestName,
        phoneNumber,
        partySize,
        specialRequests,
        highchairNeeded,
        wheelchairAccessible,
        tablePreference,
        status,
        createdAt,
        quotedWaitTime,
        notifiedAt,
        seatedAt,
        seatedTableUuid,
        queuePosition
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'waitlist_table';
  @override
  VerificationContext validateIntegrity(Insertable<WaitlistTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('guest_name')) {
      context.handle(_guestNameMeta,
          guestName.isAcceptableOrUnknown(data['guest_name']!, _guestNameMeta));
    } else if (isInserting) {
      context.missing(_guestNameMeta);
    }
    if (data.containsKey('phone_number')) {
      context.handle(
          _phoneNumberMeta,
          phoneNumber.isAcceptableOrUnknown(
              data['phone_number']!, _phoneNumberMeta));
    } else if (isInserting) {
      context.missing(_phoneNumberMeta);
    }
    if (data.containsKey('party_size')) {
      context.handle(_partySizeMeta,
          partySize.isAcceptableOrUnknown(data['party_size']!, _partySizeMeta));
    } else if (isInserting) {
      context.missing(_partySizeMeta);
    }
    if (data.containsKey('special_requests')) {
      context.handle(
          _specialRequestsMeta,
          specialRequests.isAcceptableOrUnknown(
              data['special_requests']!, _specialRequestsMeta));
    }
    if (data.containsKey('highchair_needed')) {
      context.handle(
          _highchairNeededMeta,
          highchairNeeded.isAcceptableOrUnknown(
              data['highchair_needed']!, _highchairNeededMeta));
    }
    if (data.containsKey('wheelchair_accessible')) {
      context.handle(
          _wheelchairAccessibleMeta,
          wheelchairAccessible.isAcceptableOrUnknown(
              data['wheelchair_accessible']!, _wheelchairAccessibleMeta));
    }
    if (data.containsKey('table_preference')) {
      context.handle(
          _tablePreferenceMeta,
          tablePreference.isAcceptableOrUnknown(
              data['table_preference']!, _tablePreferenceMeta));
    }
    if (data.containsKey('status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['status']!, _statusMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('quoted_wait_time')) {
      context.handle(
          _quotedWaitTimeMeta,
          quotedWaitTime.isAcceptableOrUnknown(
              data['quoted_wait_time']!, _quotedWaitTimeMeta));
    }
    if (data.containsKey('notified_at')) {
      context.handle(
          _notifiedAtMeta,
          notifiedAt.isAcceptableOrUnknown(
              data['notified_at']!, _notifiedAtMeta));
    }
    if (data.containsKey('seated_at')) {
      context.handle(_seatedAtMeta,
          seatedAt.isAcceptableOrUnknown(data['seated_at']!, _seatedAtMeta));
    }
    if (data.containsKey('seated_table_uuid')) {
      context.handle(
          _seatedTableUuidMeta,
          seatedTableUuid.isAcceptableOrUnknown(
              data['seated_table_uuid']!, _seatedTableUuidMeta));
    }
    if (data.containsKey('queue_position')) {
      context.handle(
          _queuePositionMeta,
          queuePosition.isAcceptableOrUnknown(
              data['queue_position']!, _queuePositionMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  WaitlistTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return WaitlistTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      guestName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}guest_name'])!,
      phoneNumber: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}phone_number'])!,
      partySize: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}party_size'])!,
      specialRequests: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}special_requests']),
      highchairNeeded: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}highchair_needed'])!,
      wheelchairAccessible: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}wheelchair_accessible'])!,
      tablePreference: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}table_preference']),
      status: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}status'])!,
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      quotedWaitTime: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}quoted_wait_time']),
      notifiedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}notified_at']),
      seatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}seated_at']),
      seatedTableUuid: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}seated_table_uuid']),
      queuePosition: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}queue_position']),
    );
  }

  @override
  $WaitlistTableTable createAlias(String alias) {
    return $WaitlistTableTable(attachedDatabase, alias);
  }
}

class WaitlistTableData extends DataClass
    implements Insertable<WaitlistTableData> {
  final int id;
  final String uuid;
  final String guestName;
  final String phoneNumber;
  final int partySize;
  final String? specialRequests;
  final bool highchairNeeded;
  final bool wheelchairAccessible;
  final String? tablePreference;
  final String status;
  final DateTime createdAt;
  final DateTime? quotedWaitTime;
  final DateTime? notifiedAt;
  final DateTime? seatedAt;
  final String? seatedTableUuid;
  final int? queuePosition;
  const WaitlistTableData(
      {required this.id,
      required this.uuid,
      required this.guestName,
      required this.phoneNumber,
      required this.partySize,
      this.specialRequests,
      required this.highchairNeeded,
      required this.wheelchairAccessible,
      this.tablePreference,
      required this.status,
      required this.createdAt,
      this.quotedWaitTime,
      this.notifiedAt,
      this.seatedAt,
      this.seatedTableUuid,
      this.queuePosition});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    map['guest_name'] = Variable<String>(guestName);
    map['phone_number'] = Variable<String>(phoneNumber);
    map['party_size'] = Variable<int>(partySize);
    if (!nullToAbsent || specialRequests != null) {
      map['special_requests'] = Variable<String>(specialRequests);
    }
    map['highchair_needed'] = Variable<bool>(highchairNeeded);
    map['wheelchair_accessible'] = Variable<bool>(wheelchairAccessible);
    if (!nullToAbsent || tablePreference != null) {
      map['table_preference'] = Variable<String>(tablePreference);
    }
    map['status'] = Variable<String>(status);
    map['created_at'] = Variable<DateTime>(createdAt);
    if (!nullToAbsent || quotedWaitTime != null) {
      map['quoted_wait_time'] = Variable<DateTime>(quotedWaitTime);
    }
    if (!nullToAbsent || notifiedAt != null) {
      map['notified_at'] = Variable<DateTime>(notifiedAt);
    }
    if (!nullToAbsent || seatedAt != null) {
      map['seated_at'] = Variable<DateTime>(seatedAt);
    }
    if (!nullToAbsent || seatedTableUuid != null) {
      map['seated_table_uuid'] = Variable<String>(seatedTableUuid);
    }
    if (!nullToAbsent || queuePosition != null) {
      map['queue_position'] = Variable<int>(queuePosition);
    }
    return map;
  }

  WaitlistTableCompanion toCompanion(bool nullToAbsent) {
    return WaitlistTableCompanion(
      id: Value(id),
      uuid: Value(uuid),
      guestName: Value(guestName),
      phoneNumber: Value(phoneNumber),
      partySize: Value(partySize),
      specialRequests: specialRequests == null && nullToAbsent
          ? const Value.absent()
          : Value(specialRequests),
      highchairNeeded: Value(highchairNeeded),
      wheelchairAccessible: Value(wheelchairAccessible),
      tablePreference: tablePreference == null && nullToAbsent
          ? const Value.absent()
          : Value(tablePreference),
      status: Value(status),
      createdAt: Value(createdAt),
      quotedWaitTime: quotedWaitTime == null && nullToAbsent
          ? const Value.absent()
          : Value(quotedWaitTime),
      notifiedAt: notifiedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(notifiedAt),
      seatedAt: seatedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(seatedAt),
      seatedTableUuid: seatedTableUuid == null && nullToAbsent
          ? const Value.absent()
          : Value(seatedTableUuid),
      queuePosition: queuePosition == null && nullToAbsent
          ? const Value.absent()
          : Value(queuePosition),
    );
  }

  factory WaitlistTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return WaitlistTableData(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      guestName: serializer.fromJson<String>(json['guestName']),
      phoneNumber: serializer.fromJson<String>(json['phoneNumber']),
      partySize: serializer.fromJson<int>(json['partySize']),
      specialRequests: serializer.fromJson<String?>(json['specialRequests']),
      highchairNeeded: serializer.fromJson<bool>(json['highchairNeeded']),
      wheelchairAccessible:
          serializer.fromJson<bool>(json['wheelchairAccessible']),
      tablePreference: serializer.fromJson<String?>(json['tablePreference']),
      status: serializer.fromJson<String>(json['status']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      quotedWaitTime: serializer.fromJson<DateTime?>(json['quotedWaitTime']),
      notifiedAt: serializer.fromJson<DateTime?>(json['notifiedAt']),
      seatedAt: serializer.fromJson<DateTime?>(json['seatedAt']),
      seatedTableUuid: serializer.fromJson<String?>(json['seatedTableUuid']),
      queuePosition: serializer.fromJson<int?>(json['queuePosition']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'guestName': serializer.toJson<String>(guestName),
      'phoneNumber': serializer.toJson<String>(phoneNumber),
      'partySize': serializer.toJson<int>(partySize),
      'specialRequests': serializer.toJson<String?>(specialRequests),
      'highchairNeeded': serializer.toJson<bool>(highchairNeeded),
      'wheelchairAccessible': serializer.toJson<bool>(wheelchairAccessible),
      'tablePreference': serializer.toJson<String?>(tablePreference),
      'status': serializer.toJson<String>(status),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'quotedWaitTime': serializer.toJson<DateTime?>(quotedWaitTime),
      'notifiedAt': serializer.toJson<DateTime?>(notifiedAt),
      'seatedAt': serializer.toJson<DateTime?>(seatedAt),
      'seatedTableUuid': serializer.toJson<String?>(seatedTableUuid),
      'queuePosition': serializer.toJson<int?>(queuePosition),
    };
  }

  WaitlistTableData copyWith(
          {int? id,
          String? uuid,
          String? guestName,
          String? phoneNumber,
          int? partySize,
          Value<String?> specialRequests = const Value.absent(),
          bool? highchairNeeded,
          bool? wheelchairAccessible,
          Value<String?> tablePreference = const Value.absent(),
          String? status,
          DateTime? createdAt,
          Value<DateTime?> quotedWaitTime = const Value.absent(),
          Value<DateTime?> notifiedAt = const Value.absent(),
          Value<DateTime?> seatedAt = const Value.absent(),
          Value<String?> seatedTableUuid = const Value.absent(),
          Value<int?> queuePosition = const Value.absent()}) =>
      WaitlistTableData(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        guestName: guestName ?? this.guestName,
        phoneNumber: phoneNumber ?? this.phoneNumber,
        partySize: partySize ?? this.partySize,
        specialRequests: specialRequests.present
            ? specialRequests.value
            : this.specialRequests,
        highchairNeeded: highchairNeeded ?? this.highchairNeeded,
        wheelchairAccessible: wheelchairAccessible ?? this.wheelchairAccessible,
        tablePreference: tablePreference.present
            ? tablePreference.value
            : this.tablePreference,
        status: status ?? this.status,
        createdAt: createdAt ?? this.createdAt,
        quotedWaitTime:
            quotedWaitTime.present ? quotedWaitTime.value : this.quotedWaitTime,
        notifiedAt: notifiedAt.present ? notifiedAt.value : this.notifiedAt,
        seatedAt: seatedAt.present ? seatedAt.value : this.seatedAt,
        seatedTableUuid: seatedTableUuid.present
            ? seatedTableUuid.value
            : this.seatedTableUuid,
        queuePosition:
            queuePosition.present ? queuePosition.value : this.queuePosition,
      );
  WaitlistTableData copyWithCompanion(WaitlistTableCompanion data) {
    return WaitlistTableData(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      guestName: data.guestName.present ? data.guestName.value : this.guestName,
      phoneNumber:
          data.phoneNumber.present ? data.phoneNumber.value : this.phoneNumber,
      partySize: data.partySize.present ? data.partySize.value : this.partySize,
      specialRequests: data.specialRequests.present
          ? data.specialRequests.value
          : this.specialRequests,
      highchairNeeded: data.highchairNeeded.present
          ? data.highchairNeeded.value
          : this.highchairNeeded,
      wheelchairAccessible: data.wheelchairAccessible.present
          ? data.wheelchairAccessible.value
          : this.wheelchairAccessible,
      tablePreference: data.tablePreference.present
          ? data.tablePreference.value
          : this.tablePreference,
      status: data.status.present ? data.status.value : this.status,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      quotedWaitTime: data.quotedWaitTime.present
          ? data.quotedWaitTime.value
          : this.quotedWaitTime,
      notifiedAt:
          data.notifiedAt.present ? data.notifiedAt.value : this.notifiedAt,
      seatedAt: data.seatedAt.present ? data.seatedAt.value : this.seatedAt,
      seatedTableUuid: data.seatedTableUuid.present
          ? data.seatedTableUuid.value
          : this.seatedTableUuid,
      queuePosition: data.queuePosition.present
          ? data.queuePosition.value
          : this.queuePosition,
    );
  }

  @override
  String toString() {
    return (StringBuffer('WaitlistTableData(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('guestName: $guestName, ')
          ..write('phoneNumber: $phoneNumber, ')
          ..write('partySize: $partySize, ')
          ..write('specialRequests: $specialRequests, ')
          ..write('highchairNeeded: $highchairNeeded, ')
          ..write('wheelchairAccessible: $wheelchairAccessible, ')
          ..write('tablePreference: $tablePreference, ')
          ..write('status: $status, ')
          ..write('createdAt: $createdAt, ')
          ..write('quotedWaitTime: $quotedWaitTime, ')
          ..write('notifiedAt: $notifiedAt, ')
          ..write('seatedAt: $seatedAt, ')
          ..write('seatedTableUuid: $seatedTableUuid, ')
          ..write('queuePosition: $queuePosition')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      uuid,
      guestName,
      phoneNumber,
      partySize,
      specialRequests,
      highchairNeeded,
      wheelchairAccessible,
      tablePreference,
      status,
      createdAt,
      quotedWaitTime,
      notifiedAt,
      seatedAt,
      seatedTableUuid,
      queuePosition);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is WaitlistTableData &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.guestName == this.guestName &&
          other.phoneNumber == this.phoneNumber &&
          other.partySize == this.partySize &&
          other.specialRequests == this.specialRequests &&
          other.highchairNeeded == this.highchairNeeded &&
          other.wheelchairAccessible == this.wheelchairAccessible &&
          other.tablePreference == this.tablePreference &&
          other.status == this.status &&
          other.createdAt == this.createdAt &&
          other.quotedWaitTime == this.quotedWaitTime &&
          other.notifiedAt == this.notifiedAt &&
          other.seatedAt == this.seatedAt &&
          other.seatedTableUuid == this.seatedTableUuid &&
          other.queuePosition == this.queuePosition);
}

class WaitlistTableCompanion extends UpdateCompanion<WaitlistTableData> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String> guestName;
  final Value<String> phoneNumber;
  final Value<int> partySize;
  final Value<String?> specialRequests;
  final Value<bool> highchairNeeded;
  final Value<bool> wheelchairAccessible;
  final Value<String?> tablePreference;
  final Value<String> status;
  final Value<DateTime> createdAt;
  final Value<DateTime?> quotedWaitTime;
  final Value<DateTime?> notifiedAt;
  final Value<DateTime?> seatedAt;
  final Value<String?> seatedTableUuid;
  final Value<int?> queuePosition;
  const WaitlistTableCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.guestName = const Value.absent(),
    this.phoneNumber = const Value.absent(),
    this.partySize = const Value.absent(),
    this.specialRequests = const Value.absent(),
    this.highchairNeeded = const Value.absent(),
    this.wheelchairAccessible = const Value.absent(),
    this.tablePreference = const Value.absent(),
    this.status = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.quotedWaitTime = const Value.absent(),
    this.notifiedAt = const Value.absent(),
    this.seatedAt = const Value.absent(),
    this.seatedTableUuid = const Value.absent(),
    this.queuePosition = const Value.absent(),
  });
  WaitlistTableCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    required String guestName,
    required String phoneNumber,
    required int partySize,
    this.specialRequests = const Value.absent(),
    this.highchairNeeded = const Value.absent(),
    this.wheelchairAccessible = const Value.absent(),
    this.tablePreference = const Value.absent(),
    this.status = const Value.absent(),
    required DateTime createdAt,
    this.quotedWaitTime = const Value.absent(),
    this.notifiedAt = const Value.absent(),
    this.seatedAt = const Value.absent(),
    this.seatedTableUuid = const Value.absent(),
    this.queuePosition = const Value.absent(),
  })  : uuid = Value(uuid),
        guestName = Value(guestName),
        phoneNumber = Value(phoneNumber),
        partySize = Value(partySize),
        createdAt = Value(createdAt);
  static Insertable<WaitlistTableData> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? guestName,
    Expression<String>? phoneNumber,
    Expression<int>? partySize,
    Expression<String>? specialRequests,
    Expression<bool>? highchairNeeded,
    Expression<bool>? wheelchairAccessible,
    Expression<String>? tablePreference,
    Expression<String>? status,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? quotedWaitTime,
    Expression<DateTime>? notifiedAt,
    Expression<DateTime>? seatedAt,
    Expression<String>? seatedTableUuid,
    Expression<int>? queuePosition,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (guestName != null) 'guest_name': guestName,
      if (phoneNumber != null) 'phone_number': phoneNumber,
      if (partySize != null) 'party_size': partySize,
      if (specialRequests != null) 'special_requests': specialRequests,
      if (highchairNeeded != null) 'highchair_needed': highchairNeeded,
      if (wheelchairAccessible != null)
        'wheelchair_accessible': wheelchairAccessible,
      if (tablePreference != null) 'table_preference': tablePreference,
      if (status != null) 'status': status,
      if (createdAt != null) 'created_at': createdAt,
      if (quotedWaitTime != null) 'quoted_wait_time': quotedWaitTime,
      if (notifiedAt != null) 'notified_at': notifiedAt,
      if (seatedAt != null) 'seated_at': seatedAt,
      if (seatedTableUuid != null) 'seated_table_uuid': seatedTableUuid,
      if (queuePosition != null) 'queue_position': queuePosition,
    });
  }

  WaitlistTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String>? guestName,
      Value<String>? phoneNumber,
      Value<int>? partySize,
      Value<String?>? specialRequests,
      Value<bool>? highchairNeeded,
      Value<bool>? wheelchairAccessible,
      Value<String?>? tablePreference,
      Value<String>? status,
      Value<DateTime>? createdAt,
      Value<DateTime?>? quotedWaitTime,
      Value<DateTime?>? notifiedAt,
      Value<DateTime?>? seatedAt,
      Value<String?>? seatedTableUuid,
      Value<int?>? queuePosition}) {
    return WaitlistTableCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      guestName: guestName ?? this.guestName,
      phoneNumber: phoneNumber ?? this.phoneNumber,
      partySize: partySize ?? this.partySize,
      specialRequests: specialRequests ?? this.specialRequests,
      highchairNeeded: highchairNeeded ?? this.highchairNeeded,
      wheelchairAccessible: wheelchairAccessible ?? this.wheelchairAccessible,
      tablePreference: tablePreference ?? this.tablePreference,
      status: status ?? this.status,
      createdAt: createdAt ?? this.createdAt,
      quotedWaitTime: quotedWaitTime ?? this.quotedWaitTime,
      notifiedAt: notifiedAt ?? this.notifiedAt,
      seatedAt: seatedAt ?? this.seatedAt,
      seatedTableUuid: seatedTableUuid ?? this.seatedTableUuid,
      queuePosition: queuePosition ?? this.queuePosition,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (guestName.present) {
      map['guest_name'] = Variable<String>(guestName.value);
    }
    if (phoneNumber.present) {
      map['phone_number'] = Variable<String>(phoneNumber.value);
    }
    if (partySize.present) {
      map['party_size'] = Variable<int>(partySize.value);
    }
    if (specialRequests.present) {
      map['special_requests'] = Variable<String>(specialRequests.value);
    }
    if (highchairNeeded.present) {
      map['highchair_needed'] = Variable<bool>(highchairNeeded.value);
    }
    if (wheelchairAccessible.present) {
      map['wheelchair_accessible'] = Variable<bool>(wheelchairAccessible.value);
    }
    if (tablePreference.present) {
      map['table_preference'] = Variable<String>(tablePreference.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (quotedWaitTime.present) {
      map['quoted_wait_time'] = Variable<DateTime>(quotedWaitTime.value);
    }
    if (notifiedAt.present) {
      map['notified_at'] = Variable<DateTime>(notifiedAt.value);
    }
    if (seatedAt.present) {
      map['seated_at'] = Variable<DateTime>(seatedAt.value);
    }
    if (seatedTableUuid.present) {
      map['seated_table_uuid'] = Variable<String>(seatedTableUuid.value);
    }
    if (queuePosition.present) {
      map['queue_position'] = Variable<int>(queuePosition.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('WaitlistTableCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('guestName: $guestName, ')
          ..write('phoneNumber: $phoneNumber, ')
          ..write('partySize: $partySize, ')
          ..write('specialRequests: $specialRequests, ')
          ..write('highchairNeeded: $highchairNeeded, ')
          ..write('wheelchairAccessible: $wheelchairAccessible, ')
          ..write('tablePreference: $tablePreference, ')
          ..write('status: $status, ')
          ..write('createdAt: $createdAt, ')
          ..write('quotedWaitTime: $quotedWaitTime, ')
          ..write('notifiedAt: $notifiedAt, ')
          ..write('seatedAt: $seatedAt, ')
          ..write('seatedTableUuid: $seatedTableUuid, ')
          ..write('queuePosition: $queuePosition')
          ..write(')'))
        .toString();
  }
}

class $StaffAlertTableTable extends StaffAlertTable
    with TableInfo<$StaffAlertTableTable, StaffAlertTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $StaffAlertTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _typeMeta = const VerificationMeta('type');
  @override
  late final GeneratedColumn<String> type = GeneratedColumn<String>(
      'type', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _priorityMeta =
      const VerificationMeta('priority');
  @override
  late final GeneratedColumn<String> priority = GeneratedColumn<String>(
      'priority', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _titleMeta = const VerificationMeta('title');
  @override
  late final GeneratedColumn<String> title = GeneratedColumn<String>(
      'title', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _messageMeta =
      const VerificationMeta('message');
  @override
  late final GeneratedColumn<String> message = GeneratedColumn<String>(
      'message', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
      'status', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultValue: const Constant('active'));
  static const VerificationMeta _targetRolesJsonMeta =
      const VerificationMeta('targetRolesJson');
  @override
  late final GeneratedColumn<String> targetRolesJson = GeneratedColumn<String>(
      'target_roles_json', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultValue: const Constant('[]'));
  static const VerificationMeta _targetUserUuidsJsonMeta =
      const VerificationMeta('targetUserUuidsJson');
  @override
  late final GeneratedColumn<String> targetUserUuidsJson =
      GeneratedColumn<String>('target_user_uuids_json', aliasedName, false,
          type: DriftSqlType.string,
          requiredDuringInsert: false,
          defaultValue: const Constant('[]'));
  static const VerificationMeta _broadcastToAllMeta =
      const VerificationMeta('broadcastToAll');
  @override
  late final GeneratedColumn<bool> broadcastToAll = GeneratedColumn<bool>(
      'broadcast_to_all', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("broadcast_to_all" IN (0, 1))'),
      defaultValue: const Constant(true));
  static const VerificationMeta _relatedOrderUuidMeta =
      const VerificationMeta('relatedOrderUuid');
  @override
  late final GeneratedColumn<String> relatedOrderUuid = GeneratedColumn<String>(
      'related_order_uuid', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _relatedTableUuidMeta =
      const VerificationMeta('relatedTableUuid');
  @override
  late final GeneratedColumn<String> relatedTableUuid = GeneratedColumn<String>(
      'related_table_uuid', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _relatedCustomerUuidMeta =
      const VerificationMeta('relatedCustomerUuid');
  @override
  late final GeneratedColumn<String> relatedCustomerUuid =
      GeneratedColumn<String>('related_customer_uuid', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _actionLabelMeta =
      const VerificationMeta('actionLabel');
  @override
  late final GeneratedColumn<String> actionLabel = GeneratedColumn<String>(
      'action_label', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _actionRouteMeta =
      const VerificationMeta('actionRoute');
  @override
  late final GeneratedColumn<String> actionRoute = GeneratedColumn<String>(
      'action_route', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _expiresAtMeta =
      const VerificationMeta('expiresAt');
  @override
  late final GeneratedColumn<DateTime> expiresAt = GeneratedColumn<DateTime>(
      'expires_at', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _acknowledgedAtMeta =
      const VerificationMeta('acknowledgedAt');
  @override
  late final GeneratedColumn<DateTime> acknowledgedAt =
      GeneratedColumn<DateTime>('acknowledged_at', aliasedName, true,
          type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _acknowledgedByUuidMeta =
      const VerificationMeta('acknowledgedByUuid');
  @override
  late final GeneratedColumn<String> acknowledgedByUuid =
      GeneratedColumn<String>('acknowledged_by_uuid', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _resolvedAtMeta =
      const VerificationMeta('resolvedAt');
  @override
  late final GeneratedColumn<DateTime> resolvedAt = GeneratedColumn<DateTime>(
      'resolved_at', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _resolvedByUuidMeta =
      const VerificationMeta('resolvedByUuid');
  @override
  late final GeneratedColumn<String> resolvedByUuid = GeneratedColumn<String>(
      'resolved_by_uuid', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _playSoundMeta =
      const VerificationMeta('playSound');
  @override
  late final GeneratedColumn<bool> playSound = GeneratedColumn<bool>(
      'play_sound', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("play_sound" IN (0, 1))'),
      defaultValue: const Constant(true));
  static const VerificationMeta _vibrateMeta =
      const VerificationMeta('vibrate');
  @override
  late final GeneratedColumn<bool> vibrate = GeneratedColumn<bool>(
      'vibrate', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("vibrate" IN (0, 1))'),
      defaultValue: const Constant(true));
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        type,
        priority,
        title,
        message,
        status,
        targetRolesJson,
        targetUserUuidsJson,
        broadcastToAll,
        relatedOrderUuid,
        relatedTableUuid,
        relatedCustomerUuid,
        actionLabel,
        actionRoute,
        createdAt,
        expiresAt,
        acknowledgedAt,
        acknowledgedByUuid,
        resolvedAt,
        resolvedByUuid,
        playSound,
        vibrate
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'staff_alert_table';
  @override
  VerificationContext validateIntegrity(
      Insertable<StaffAlertTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('type')) {
      context.handle(
          _typeMeta, type.isAcceptableOrUnknown(data['type']!, _typeMeta));
    } else if (isInserting) {
      context.missing(_typeMeta);
    }
    if (data.containsKey('priority')) {
      context.handle(_priorityMeta,
          priority.isAcceptableOrUnknown(data['priority']!, _priorityMeta));
    } else if (isInserting) {
      context.missing(_priorityMeta);
    }
    if (data.containsKey('title')) {
      context.handle(
          _titleMeta, title.isAcceptableOrUnknown(data['title']!, _titleMeta));
    } else if (isInserting) {
      context.missing(_titleMeta);
    }
    if (data.containsKey('message')) {
      context.handle(_messageMeta,
          message.isAcceptableOrUnknown(data['message']!, _messageMeta));
    } else if (isInserting) {
      context.missing(_messageMeta);
    }
    if (data.containsKey('status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['status']!, _statusMeta));
    }
    if (data.containsKey('target_roles_json')) {
      context.handle(
          _targetRolesJsonMeta,
          targetRolesJson.isAcceptableOrUnknown(
              data['target_roles_json']!, _targetRolesJsonMeta));
    }
    if (data.containsKey('target_user_uuids_json')) {
      context.handle(
          _targetUserUuidsJsonMeta,
          targetUserUuidsJson.isAcceptableOrUnknown(
              data['target_user_uuids_json']!, _targetUserUuidsJsonMeta));
    }
    if (data.containsKey('broadcast_to_all')) {
      context.handle(
          _broadcastToAllMeta,
          broadcastToAll.isAcceptableOrUnknown(
              data['broadcast_to_all']!, _broadcastToAllMeta));
    }
    if (data.containsKey('related_order_uuid')) {
      context.handle(
          _relatedOrderUuidMeta,
          relatedOrderUuid.isAcceptableOrUnknown(
              data['related_order_uuid']!, _relatedOrderUuidMeta));
    }
    if (data.containsKey('related_table_uuid')) {
      context.handle(
          _relatedTableUuidMeta,
          relatedTableUuid.isAcceptableOrUnknown(
              data['related_table_uuid']!, _relatedTableUuidMeta));
    }
    if (data.containsKey('related_customer_uuid')) {
      context.handle(
          _relatedCustomerUuidMeta,
          relatedCustomerUuid.isAcceptableOrUnknown(
              data['related_customer_uuid']!, _relatedCustomerUuidMeta));
    }
    if (data.containsKey('action_label')) {
      context.handle(
          _actionLabelMeta,
          actionLabel.isAcceptableOrUnknown(
              data['action_label']!, _actionLabelMeta));
    }
    if (data.containsKey('action_route')) {
      context.handle(
          _actionRouteMeta,
          actionRoute.isAcceptableOrUnknown(
              data['action_route']!, _actionRouteMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('expires_at')) {
      context.handle(_expiresAtMeta,
          expiresAt.isAcceptableOrUnknown(data['expires_at']!, _expiresAtMeta));
    }
    if (data.containsKey('acknowledged_at')) {
      context.handle(
          _acknowledgedAtMeta,
          acknowledgedAt.isAcceptableOrUnknown(
              data['acknowledged_at']!, _acknowledgedAtMeta));
    }
    if (data.containsKey('acknowledged_by_uuid')) {
      context.handle(
          _acknowledgedByUuidMeta,
          acknowledgedByUuid.isAcceptableOrUnknown(
              data['acknowledged_by_uuid']!, _acknowledgedByUuidMeta));
    }
    if (data.containsKey('resolved_at')) {
      context.handle(
          _resolvedAtMeta,
          resolvedAt.isAcceptableOrUnknown(
              data['resolved_at']!, _resolvedAtMeta));
    }
    if (data.containsKey('resolved_by_uuid')) {
      context.handle(
          _resolvedByUuidMeta,
          resolvedByUuid.isAcceptableOrUnknown(
              data['resolved_by_uuid']!, _resolvedByUuidMeta));
    }
    if (data.containsKey('play_sound')) {
      context.handle(_playSoundMeta,
          playSound.isAcceptableOrUnknown(data['play_sound']!, _playSoundMeta));
    }
    if (data.containsKey('vibrate')) {
      context.handle(_vibrateMeta,
          vibrate.isAcceptableOrUnknown(data['vibrate']!, _vibrateMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  StaffAlertTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return StaffAlertTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      type: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}type'])!,
      priority: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}priority'])!,
      title: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}title'])!,
      message: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}message'])!,
      status: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}status'])!,
      targetRolesJson: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}target_roles_json'])!,
      targetUserUuidsJson: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}target_user_uuids_json'])!,
      broadcastToAll: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}broadcast_to_all'])!,
      relatedOrderUuid: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}related_order_uuid']),
      relatedTableUuid: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}related_table_uuid']),
      relatedCustomerUuid: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}related_customer_uuid']),
      actionLabel: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}action_label']),
      actionRoute: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}action_route']),
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      expiresAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}expires_at']),
      acknowledgedAt: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}acknowledged_at']),
      acknowledgedByUuid: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}acknowledged_by_uuid']),
      resolvedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}resolved_at']),
      resolvedByUuid: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}resolved_by_uuid']),
      playSound: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}play_sound'])!,
      vibrate: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}vibrate'])!,
    );
  }

  @override
  $StaffAlertTableTable createAlias(String alias) {
    return $StaffAlertTableTable(attachedDatabase, alias);
  }
}

class StaffAlertTableData extends DataClass
    implements Insertable<StaffAlertTableData> {
  final int id;
  final String uuid;
  final String type;
  final String priority;
  final String title;
  final String message;
  final String status;
  final String targetRolesJson;
  final String targetUserUuidsJson;
  final bool broadcastToAll;
  final String? relatedOrderUuid;
  final String? relatedTableUuid;
  final String? relatedCustomerUuid;
  final String? actionLabel;
  final String? actionRoute;
  final DateTime createdAt;
  final DateTime? expiresAt;
  final DateTime? acknowledgedAt;
  final String? acknowledgedByUuid;
  final DateTime? resolvedAt;
  final String? resolvedByUuid;
  final bool playSound;
  final bool vibrate;
  const StaffAlertTableData(
      {required this.id,
      required this.uuid,
      required this.type,
      required this.priority,
      required this.title,
      required this.message,
      required this.status,
      required this.targetRolesJson,
      required this.targetUserUuidsJson,
      required this.broadcastToAll,
      this.relatedOrderUuid,
      this.relatedTableUuid,
      this.relatedCustomerUuid,
      this.actionLabel,
      this.actionRoute,
      required this.createdAt,
      this.expiresAt,
      this.acknowledgedAt,
      this.acknowledgedByUuid,
      this.resolvedAt,
      this.resolvedByUuid,
      required this.playSound,
      required this.vibrate});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    map['type'] = Variable<String>(type);
    map['priority'] = Variable<String>(priority);
    map['title'] = Variable<String>(title);
    map['message'] = Variable<String>(message);
    map['status'] = Variable<String>(status);
    map['target_roles_json'] = Variable<String>(targetRolesJson);
    map['target_user_uuids_json'] = Variable<String>(targetUserUuidsJson);
    map['broadcast_to_all'] = Variable<bool>(broadcastToAll);
    if (!nullToAbsent || relatedOrderUuid != null) {
      map['related_order_uuid'] = Variable<String>(relatedOrderUuid);
    }
    if (!nullToAbsent || relatedTableUuid != null) {
      map['related_table_uuid'] = Variable<String>(relatedTableUuid);
    }
    if (!nullToAbsent || relatedCustomerUuid != null) {
      map['related_customer_uuid'] = Variable<String>(relatedCustomerUuid);
    }
    if (!nullToAbsent || actionLabel != null) {
      map['action_label'] = Variable<String>(actionLabel);
    }
    if (!nullToAbsent || actionRoute != null) {
      map['action_route'] = Variable<String>(actionRoute);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    if (!nullToAbsent || expiresAt != null) {
      map['expires_at'] = Variable<DateTime>(expiresAt);
    }
    if (!nullToAbsent || acknowledgedAt != null) {
      map['acknowledged_at'] = Variable<DateTime>(acknowledgedAt);
    }
    if (!nullToAbsent || acknowledgedByUuid != null) {
      map['acknowledged_by_uuid'] = Variable<String>(acknowledgedByUuid);
    }
    if (!nullToAbsent || resolvedAt != null) {
      map['resolved_at'] = Variable<DateTime>(resolvedAt);
    }
    if (!nullToAbsent || resolvedByUuid != null) {
      map['resolved_by_uuid'] = Variable<String>(resolvedByUuid);
    }
    map['play_sound'] = Variable<bool>(playSound);
    map['vibrate'] = Variable<bool>(vibrate);
    return map;
  }

  StaffAlertTableCompanion toCompanion(bool nullToAbsent) {
    return StaffAlertTableCompanion(
      id: Value(id),
      uuid: Value(uuid),
      type: Value(type),
      priority: Value(priority),
      title: Value(title),
      message: Value(message),
      status: Value(status),
      targetRolesJson: Value(targetRolesJson),
      targetUserUuidsJson: Value(targetUserUuidsJson),
      broadcastToAll: Value(broadcastToAll),
      relatedOrderUuid: relatedOrderUuid == null && nullToAbsent
          ? const Value.absent()
          : Value(relatedOrderUuid),
      relatedTableUuid: relatedTableUuid == null && nullToAbsent
          ? const Value.absent()
          : Value(relatedTableUuid),
      relatedCustomerUuid: relatedCustomerUuid == null && nullToAbsent
          ? const Value.absent()
          : Value(relatedCustomerUuid),
      actionLabel: actionLabel == null && nullToAbsent
          ? const Value.absent()
          : Value(actionLabel),
      actionRoute: actionRoute == null && nullToAbsent
          ? const Value.absent()
          : Value(actionRoute),
      createdAt: Value(createdAt),
      expiresAt: expiresAt == null && nullToAbsent
          ? const Value.absent()
          : Value(expiresAt),
      acknowledgedAt: acknowledgedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(acknowledgedAt),
      acknowledgedByUuid: acknowledgedByUuid == null && nullToAbsent
          ? const Value.absent()
          : Value(acknowledgedByUuid),
      resolvedAt: resolvedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(resolvedAt),
      resolvedByUuid: resolvedByUuid == null && nullToAbsent
          ? const Value.absent()
          : Value(resolvedByUuid),
      playSound: Value(playSound),
      vibrate: Value(vibrate),
    );
  }

  factory StaffAlertTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return StaffAlertTableData(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      type: serializer.fromJson<String>(json['type']),
      priority: serializer.fromJson<String>(json['priority']),
      title: serializer.fromJson<String>(json['title']),
      message: serializer.fromJson<String>(json['message']),
      status: serializer.fromJson<String>(json['status']),
      targetRolesJson: serializer.fromJson<String>(json['targetRolesJson']),
      targetUserUuidsJson:
          serializer.fromJson<String>(json['targetUserUuidsJson']),
      broadcastToAll: serializer.fromJson<bool>(json['broadcastToAll']),
      relatedOrderUuid: serializer.fromJson<String?>(json['relatedOrderUuid']),
      relatedTableUuid: serializer.fromJson<String?>(json['relatedTableUuid']),
      relatedCustomerUuid:
          serializer.fromJson<String?>(json['relatedCustomerUuid']),
      actionLabel: serializer.fromJson<String?>(json['actionLabel']),
      actionRoute: serializer.fromJson<String?>(json['actionRoute']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      expiresAt: serializer.fromJson<DateTime?>(json['expiresAt']),
      acknowledgedAt: serializer.fromJson<DateTime?>(json['acknowledgedAt']),
      acknowledgedByUuid:
          serializer.fromJson<String?>(json['acknowledgedByUuid']),
      resolvedAt: serializer.fromJson<DateTime?>(json['resolvedAt']),
      resolvedByUuid: serializer.fromJson<String?>(json['resolvedByUuid']),
      playSound: serializer.fromJson<bool>(json['playSound']),
      vibrate: serializer.fromJson<bool>(json['vibrate']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'type': serializer.toJson<String>(type),
      'priority': serializer.toJson<String>(priority),
      'title': serializer.toJson<String>(title),
      'message': serializer.toJson<String>(message),
      'status': serializer.toJson<String>(status),
      'targetRolesJson': serializer.toJson<String>(targetRolesJson),
      'targetUserUuidsJson': serializer.toJson<String>(targetUserUuidsJson),
      'broadcastToAll': serializer.toJson<bool>(broadcastToAll),
      'relatedOrderUuid': serializer.toJson<String?>(relatedOrderUuid),
      'relatedTableUuid': serializer.toJson<String?>(relatedTableUuid),
      'relatedCustomerUuid': serializer.toJson<String?>(relatedCustomerUuid),
      'actionLabel': serializer.toJson<String?>(actionLabel),
      'actionRoute': serializer.toJson<String?>(actionRoute),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'expiresAt': serializer.toJson<DateTime?>(expiresAt),
      'acknowledgedAt': serializer.toJson<DateTime?>(acknowledgedAt),
      'acknowledgedByUuid': serializer.toJson<String?>(acknowledgedByUuid),
      'resolvedAt': serializer.toJson<DateTime?>(resolvedAt),
      'resolvedByUuid': serializer.toJson<String?>(resolvedByUuid),
      'playSound': serializer.toJson<bool>(playSound),
      'vibrate': serializer.toJson<bool>(vibrate),
    };
  }

  StaffAlertTableData copyWith(
          {int? id,
          String? uuid,
          String? type,
          String? priority,
          String? title,
          String? message,
          String? status,
          String? targetRolesJson,
          String? targetUserUuidsJson,
          bool? broadcastToAll,
          Value<String?> relatedOrderUuid = const Value.absent(),
          Value<String?> relatedTableUuid = const Value.absent(),
          Value<String?> relatedCustomerUuid = const Value.absent(),
          Value<String?> actionLabel = const Value.absent(),
          Value<String?> actionRoute = const Value.absent(),
          DateTime? createdAt,
          Value<DateTime?> expiresAt = const Value.absent(),
          Value<DateTime?> acknowledgedAt = const Value.absent(),
          Value<String?> acknowledgedByUuid = const Value.absent(),
          Value<DateTime?> resolvedAt = const Value.absent(),
          Value<String?> resolvedByUuid = const Value.absent(),
          bool? playSound,
          bool? vibrate}) =>
      StaffAlertTableData(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        type: type ?? this.type,
        priority: priority ?? this.priority,
        title: title ?? this.title,
        message: message ?? this.message,
        status: status ?? this.status,
        targetRolesJson: targetRolesJson ?? this.targetRolesJson,
        targetUserUuidsJson: targetUserUuidsJson ?? this.targetUserUuidsJson,
        broadcastToAll: broadcastToAll ?? this.broadcastToAll,
        relatedOrderUuid: relatedOrderUuid.present
            ? relatedOrderUuid.value
            : this.relatedOrderUuid,
        relatedTableUuid: relatedTableUuid.present
            ? relatedTableUuid.value
            : this.relatedTableUuid,
        relatedCustomerUuid: relatedCustomerUuid.present
            ? relatedCustomerUuid.value
            : this.relatedCustomerUuid,
        actionLabel: actionLabel.present ? actionLabel.value : this.actionLabel,
        actionRoute: actionRoute.present ? actionRoute.value : this.actionRoute,
        createdAt: createdAt ?? this.createdAt,
        expiresAt: expiresAt.present ? expiresAt.value : this.expiresAt,
        acknowledgedAt:
            acknowledgedAt.present ? acknowledgedAt.value : this.acknowledgedAt,
        acknowledgedByUuid: acknowledgedByUuid.present
            ? acknowledgedByUuid.value
            : this.acknowledgedByUuid,
        resolvedAt: resolvedAt.present ? resolvedAt.value : this.resolvedAt,
        resolvedByUuid:
            resolvedByUuid.present ? resolvedByUuid.value : this.resolvedByUuid,
        playSound: playSound ?? this.playSound,
        vibrate: vibrate ?? this.vibrate,
      );
  StaffAlertTableData copyWithCompanion(StaffAlertTableCompanion data) {
    return StaffAlertTableData(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      type: data.type.present ? data.type.value : this.type,
      priority: data.priority.present ? data.priority.value : this.priority,
      title: data.title.present ? data.title.value : this.title,
      message: data.message.present ? data.message.value : this.message,
      status: data.status.present ? data.status.value : this.status,
      targetRolesJson: data.targetRolesJson.present
          ? data.targetRolesJson.value
          : this.targetRolesJson,
      targetUserUuidsJson: data.targetUserUuidsJson.present
          ? data.targetUserUuidsJson.value
          : this.targetUserUuidsJson,
      broadcastToAll: data.broadcastToAll.present
          ? data.broadcastToAll.value
          : this.broadcastToAll,
      relatedOrderUuid: data.relatedOrderUuid.present
          ? data.relatedOrderUuid.value
          : this.relatedOrderUuid,
      relatedTableUuid: data.relatedTableUuid.present
          ? data.relatedTableUuid.value
          : this.relatedTableUuid,
      relatedCustomerUuid: data.relatedCustomerUuid.present
          ? data.relatedCustomerUuid.value
          : this.relatedCustomerUuid,
      actionLabel:
          data.actionLabel.present ? data.actionLabel.value : this.actionLabel,
      actionRoute:
          data.actionRoute.present ? data.actionRoute.value : this.actionRoute,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      expiresAt: data.expiresAt.present ? data.expiresAt.value : this.expiresAt,
      acknowledgedAt: data.acknowledgedAt.present
          ? data.acknowledgedAt.value
          : this.acknowledgedAt,
      acknowledgedByUuid: data.acknowledgedByUuid.present
          ? data.acknowledgedByUuid.value
          : this.acknowledgedByUuid,
      resolvedAt:
          data.resolvedAt.present ? data.resolvedAt.value : this.resolvedAt,
      resolvedByUuid: data.resolvedByUuid.present
          ? data.resolvedByUuid.value
          : this.resolvedByUuid,
      playSound: data.playSound.present ? data.playSound.value : this.playSound,
      vibrate: data.vibrate.present ? data.vibrate.value : this.vibrate,
    );
  }

  @override
  String toString() {
    return (StringBuffer('StaffAlertTableData(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('type: $type, ')
          ..write('priority: $priority, ')
          ..write('title: $title, ')
          ..write('message: $message, ')
          ..write('status: $status, ')
          ..write('targetRolesJson: $targetRolesJson, ')
          ..write('targetUserUuidsJson: $targetUserUuidsJson, ')
          ..write('broadcastToAll: $broadcastToAll, ')
          ..write('relatedOrderUuid: $relatedOrderUuid, ')
          ..write('relatedTableUuid: $relatedTableUuid, ')
          ..write('relatedCustomerUuid: $relatedCustomerUuid, ')
          ..write('actionLabel: $actionLabel, ')
          ..write('actionRoute: $actionRoute, ')
          ..write('createdAt: $createdAt, ')
          ..write('expiresAt: $expiresAt, ')
          ..write('acknowledgedAt: $acknowledgedAt, ')
          ..write('acknowledgedByUuid: $acknowledgedByUuid, ')
          ..write('resolvedAt: $resolvedAt, ')
          ..write('resolvedByUuid: $resolvedByUuid, ')
          ..write('playSound: $playSound, ')
          ..write('vibrate: $vibrate')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        id,
        uuid,
        type,
        priority,
        title,
        message,
        status,
        targetRolesJson,
        targetUserUuidsJson,
        broadcastToAll,
        relatedOrderUuid,
        relatedTableUuid,
        relatedCustomerUuid,
        actionLabel,
        actionRoute,
        createdAt,
        expiresAt,
        acknowledgedAt,
        acknowledgedByUuid,
        resolvedAt,
        resolvedByUuid,
        playSound,
        vibrate
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is StaffAlertTableData &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.type == this.type &&
          other.priority == this.priority &&
          other.title == this.title &&
          other.message == this.message &&
          other.status == this.status &&
          other.targetRolesJson == this.targetRolesJson &&
          other.targetUserUuidsJson == this.targetUserUuidsJson &&
          other.broadcastToAll == this.broadcastToAll &&
          other.relatedOrderUuid == this.relatedOrderUuid &&
          other.relatedTableUuid == this.relatedTableUuid &&
          other.relatedCustomerUuid == this.relatedCustomerUuid &&
          other.actionLabel == this.actionLabel &&
          other.actionRoute == this.actionRoute &&
          other.createdAt == this.createdAt &&
          other.expiresAt == this.expiresAt &&
          other.acknowledgedAt == this.acknowledgedAt &&
          other.acknowledgedByUuid == this.acknowledgedByUuid &&
          other.resolvedAt == this.resolvedAt &&
          other.resolvedByUuid == this.resolvedByUuid &&
          other.playSound == this.playSound &&
          other.vibrate == this.vibrate);
}

class StaffAlertTableCompanion extends UpdateCompanion<StaffAlertTableData> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String> type;
  final Value<String> priority;
  final Value<String> title;
  final Value<String> message;
  final Value<String> status;
  final Value<String> targetRolesJson;
  final Value<String> targetUserUuidsJson;
  final Value<bool> broadcastToAll;
  final Value<String?> relatedOrderUuid;
  final Value<String?> relatedTableUuid;
  final Value<String?> relatedCustomerUuid;
  final Value<String?> actionLabel;
  final Value<String?> actionRoute;
  final Value<DateTime> createdAt;
  final Value<DateTime?> expiresAt;
  final Value<DateTime?> acknowledgedAt;
  final Value<String?> acknowledgedByUuid;
  final Value<DateTime?> resolvedAt;
  final Value<String?> resolvedByUuid;
  final Value<bool> playSound;
  final Value<bool> vibrate;
  const StaffAlertTableCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.type = const Value.absent(),
    this.priority = const Value.absent(),
    this.title = const Value.absent(),
    this.message = const Value.absent(),
    this.status = const Value.absent(),
    this.targetRolesJson = const Value.absent(),
    this.targetUserUuidsJson = const Value.absent(),
    this.broadcastToAll = const Value.absent(),
    this.relatedOrderUuid = const Value.absent(),
    this.relatedTableUuid = const Value.absent(),
    this.relatedCustomerUuid = const Value.absent(),
    this.actionLabel = const Value.absent(),
    this.actionRoute = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.expiresAt = const Value.absent(),
    this.acknowledgedAt = const Value.absent(),
    this.acknowledgedByUuid = const Value.absent(),
    this.resolvedAt = const Value.absent(),
    this.resolvedByUuid = const Value.absent(),
    this.playSound = const Value.absent(),
    this.vibrate = const Value.absent(),
  });
  StaffAlertTableCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    required String type,
    required String priority,
    required String title,
    required String message,
    this.status = const Value.absent(),
    this.targetRolesJson = const Value.absent(),
    this.targetUserUuidsJson = const Value.absent(),
    this.broadcastToAll = const Value.absent(),
    this.relatedOrderUuid = const Value.absent(),
    this.relatedTableUuid = const Value.absent(),
    this.relatedCustomerUuid = const Value.absent(),
    this.actionLabel = const Value.absent(),
    this.actionRoute = const Value.absent(),
    required DateTime createdAt,
    this.expiresAt = const Value.absent(),
    this.acknowledgedAt = const Value.absent(),
    this.acknowledgedByUuid = const Value.absent(),
    this.resolvedAt = const Value.absent(),
    this.resolvedByUuid = const Value.absent(),
    this.playSound = const Value.absent(),
    this.vibrate = const Value.absent(),
  })  : uuid = Value(uuid),
        type = Value(type),
        priority = Value(priority),
        title = Value(title),
        message = Value(message),
        createdAt = Value(createdAt);
  static Insertable<StaffAlertTableData> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? type,
    Expression<String>? priority,
    Expression<String>? title,
    Expression<String>? message,
    Expression<String>? status,
    Expression<String>? targetRolesJson,
    Expression<String>? targetUserUuidsJson,
    Expression<bool>? broadcastToAll,
    Expression<String>? relatedOrderUuid,
    Expression<String>? relatedTableUuid,
    Expression<String>? relatedCustomerUuid,
    Expression<String>? actionLabel,
    Expression<String>? actionRoute,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? expiresAt,
    Expression<DateTime>? acknowledgedAt,
    Expression<String>? acknowledgedByUuid,
    Expression<DateTime>? resolvedAt,
    Expression<String>? resolvedByUuid,
    Expression<bool>? playSound,
    Expression<bool>? vibrate,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (type != null) 'type': type,
      if (priority != null) 'priority': priority,
      if (title != null) 'title': title,
      if (message != null) 'message': message,
      if (status != null) 'status': status,
      if (targetRolesJson != null) 'target_roles_json': targetRolesJson,
      if (targetUserUuidsJson != null)
        'target_user_uuids_json': targetUserUuidsJson,
      if (broadcastToAll != null) 'broadcast_to_all': broadcastToAll,
      if (relatedOrderUuid != null) 'related_order_uuid': relatedOrderUuid,
      if (relatedTableUuid != null) 'related_table_uuid': relatedTableUuid,
      if (relatedCustomerUuid != null)
        'related_customer_uuid': relatedCustomerUuid,
      if (actionLabel != null) 'action_label': actionLabel,
      if (actionRoute != null) 'action_route': actionRoute,
      if (createdAt != null) 'created_at': createdAt,
      if (expiresAt != null) 'expires_at': expiresAt,
      if (acknowledgedAt != null) 'acknowledged_at': acknowledgedAt,
      if (acknowledgedByUuid != null)
        'acknowledged_by_uuid': acknowledgedByUuid,
      if (resolvedAt != null) 'resolved_at': resolvedAt,
      if (resolvedByUuid != null) 'resolved_by_uuid': resolvedByUuid,
      if (playSound != null) 'play_sound': playSound,
      if (vibrate != null) 'vibrate': vibrate,
    });
  }

  StaffAlertTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String>? type,
      Value<String>? priority,
      Value<String>? title,
      Value<String>? message,
      Value<String>? status,
      Value<String>? targetRolesJson,
      Value<String>? targetUserUuidsJson,
      Value<bool>? broadcastToAll,
      Value<String?>? relatedOrderUuid,
      Value<String?>? relatedTableUuid,
      Value<String?>? relatedCustomerUuid,
      Value<String?>? actionLabel,
      Value<String?>? actionRoute,
      Value<DateTime>? createdAt,
      Value<DateTime?>? expiresAt,
      Value<DateTime?>? acknowledgedAt,
      Value<String?>? acknowledgedByUuid,
      Value<DateTime?>? resolvedAt,
      Value<String?>? resolvedByUuid,
      Value<bool>? playSound,
      Value<bool>? vibrate}) {
    return StaffAlertTableCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      type: type ?? this.type,
      priority: priority ?? this.priority,
      title: title ?? this.title,
      message: message ?? this.message,
      status: status ?? this.status,
      targetRolesJson: targetRolesJson ?? this.targetRolesJson,
      targetUserUuidsJson: targetUserUuidsJson ?? this.targetUserUuidsJson,
      broadcastToAll: broadcastToAll ?? this.broadcastToAll,
      relatedOrderUuid: relatedOrderUuid ?? this.relatedOrderUuid,
      relatedTableUuid: relatedTableUuid ?? this.relatedTableUuid,
      relatedCustomerUuid: relatedCustomerUuid ?? this.relatedCustomerUuid,
      actionLabel: actionLabel ?? this.actionLabel,
      actionRoute: actionRoute ?? this.actionRoute,
      createdAt: createdAt ?? this.createdAt,
      expiresAt: expiresAt ?? this.expiresAt,
      acknowledgedAt: acknowledgedAt ?? this.acknowledgedAt,
      acknowledgedByUuid: acknowledgedByUuid ?? this.acknowledgedByUuid,
      resolvedAt: resolvedAt ?? this.resolvedAt,
      resolvedByUuid: resolvedByUuid ?? this.resolvedByUuid,
      playSound: playSound ?? this.playSound,
      vibrate: vibrate ?? this.vibrate,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (type.present) {
      map['type'] = Variable<String>(type.value);
    }
    if (priority.present) {
      map['priority'] = Variable<String>(priority.value);
    }
    if (title.present) {
      map['title'] = Variable<String>(title.value);
    }
    if (message.present) {
      map['message'] = Variable<String>(message.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (targetRolesJson.present) {
      map['target_roles_json'] = Variable<String>(targetRolesJson.value);
    }
    if (targetUserUuidsJson.present) {
      map['target_user_uuids_json'] =
          Variable<String>(targetUserUuidsJson.value);
    }
    if (broadcastToAll.present) {
      map['broadcast_to_all'] = Variable<bool>(broadcastToAll.value);
    }
    if (relatedOrderUuid.present) {
      map['related_order_uuid'] = Variable<String>(relatedOrderUuid.value);
    }
    if (relatedTableUuid.present) {
      map['related_table_uuid'] = Variable<String>(relatedTableUuid.value);
    }
    if (relatedCustomerUuid.present) {
      map['related_customer_uuid'] =
          Variable<String>(relatedCustomerUuid.value);
    }
    if (actionLabel.present) {
      map['action_label'] = Variable<String>(actionLabel.value);
    }
    if (actionRoute.present) {
      map['action_route'] = Variable<String>(actionRoute.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (expiresAt.present) {
      map['expires_at'] = Variable<DateTime>(expiresAt.value);
    }
    if (acknowledgedAt.present) {
      map['acknowledged_at'] = Variable<DateTime>(acknowledgedAt.value);
    }
    if (acknowledgedByUuid.present) {
      map['acknowledged_by_uuid'] = Variable<String>(acknowledgedByUuid.value);
    }
    if (resolvedAt.present) {
      map['resolved_at'] = Variable<DateTime>(resolvedAt.value);
    }
    if (resolvedByUuid.present) {
      map['resolved_by_uuid'] = Variable<String>(resolvedByUuid.value);
    }
    if (playSound.present) {
      map['play_sound'] = Variable<bool>(playSound.value);
    }
    if (vibrate.present) {
      map['vibrate'] = Variable<bool>(vibrate.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('StaffAlertTableCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('type: $type, ')
          ..write('priority: $priority, ')
          ..write('title: $title, ')
          ..write('message: $message, ')
          ..write('status: $status, ')
          ..write('targetRolesJson: $targetRolesJson, ')
          ..write('targetUserUuidsJson: $targetUserUuidsJson, ')
          ..write('broadcastToAll: $broadcastToAll, ')
          ..write('relatedOrderUuid: $relatedOrderUuid, ')
          ..write('relatedTableUuid: $relatedTableUuid, ')
          ..write('relatedCustomerUuid: $relatedCustomerUuid, ')
          ..write('actionLabel: $actionLabel, ')
          ..write('actionRoute: $actionRoute, ')
          ..write('createdAt: $createdAt, ')
          ..write('expiresAt: $expiresAt, ')
          ..write('acknowledgedAt: $acknowledgedAt, ')
          ..write('acknowledgedByUuid: $acknowledgedByUuid, ')
          ..write('resolvedAt: $resolvedAt, ')
          ..write('resolvedByUuid: $resolvedByUuid, ')
          ..write('playSound: $playSound, ')
          ..write('vibrate: $vibrate')
          ..write(')'))
        .toString();
  }
}

class $KitchenTicketTableTable extends KitchenTicketTable
    with TableInfo<$KitchenTicketTableTable, KitchenTicketTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $KitchenTicketTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _orderUuidMeta =
      const VerificationMeta('orderUuid');
  @override
  late final GeneratedColumn<String> orderUuid = GeneratedColumn<String>(
      'order_uuid', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _orderNumberMeta =
      const VerificationMeta('orderNumber');
  @override
  late final GeneratedColumn<String> orderNumber = GeneratedColumn<String>(
      'order_number', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _tableUuidMeta =
      const VerificationMeta('tableUuid');
  @override
  late final GeneratedColumn<String> tableUuid = GeneratedColumn<String>(
      'table_uuid', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _guestTableNameMeta =
      const VerificationMeta('guestTableName');
  @override
  late final GeneratedColumn<String> guestTableName = GeneratedColumn<String>(
      'guest_table_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _serverNameMeta =
      const VerificationMeta('serverName');
  @override
  late final GeneratedColumn<String> serverName = GeneratedColumn<String>(
      'server_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
      'status', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultValue: const Constant('fired'));
  static const VerificationMeta _firedAtMeta =
      const VerificationMeta('firedAt');
  @override
  late final GeneratedColumn<DateTime> firedAt = GeneratedColumn<DateTime>(
      'fired_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _startedAtMeta =
      const VerificationMeta('startedAt');
  @override
  late final GeneratedColumn<DateTime> startedAt = GeneratedColumn<DateTime>(
      'started_at', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _completedAtMeta =
      const VerificationMeta('completedAt');
  @override
  late final GeneratedColumn<DateTime> completedAt = GeneratedColumn<DateTime>(
      'completed_at', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _targetTimeMeta =
      const VerificationMeta('targetTime');
  @override
  late final GeneratedColumn<DateTime> targetTime = GeneratedColumn<DateTime>(
      'target_time', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _noteMeta = const VerificationMeta('note');
  @override
  late final GeneratedColumn<String> note = GeneratedColumn<String>(
      'note', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isRushMeta = const VerificationMeta('isRush');
  @override
  late final GeneratedColumn<bool> isRush = GeneratedColumn<bool>(
      'is_rush', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_rush" IN (0, 1))'),
      defaultValue: const Constant(false));
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        orderUuid,
        orderNumber,
        tableUuid,
        guestTableName,
        serverName,
        status,
        firedAt,
        startedAt,
        completedAt,
        targetTime,
        note,
        isRush
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'kitchen_ticket_table';
  @override
  VerificationContext validateIntegrity(
      Insertable<KitchenTicketTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('order_uuid')) {
      context.handle(_orderUuidMeta,
          orderUuid.isAcceptableOrUnknown(data['order_uuid']!, _orderUuidMeta));
    } else if (isInserting) {
      context.missing(_orderUuidMeta);
    }
    if (data.containsKey('order_number')) {
      context.handle(
          _orderNumberMeta,
          orderNumber.isAcceptableOrUnknown(
              data['order_number']!, _orderNumberMeta));
    } else if (isInserting) {
      context.missing(_orderNumberMeta);
    }
    if (data.containsKey('table_uuid')) {
      context.handle(_tableUuidMeta,
          tableUuid.isAcceptableOrUnknown(data['table_uuid']!, _tableUuidMeta));
    }
    if (data.containsKey('guest_table_name')) {
      context.handle(
          _guestTableNameMeta,
          guestTableName.isAcceptableOrUnknown(
              data['guest_table_name']!, _guestTableNameMeta));
    }
    if (data.containsKey('server_name')) {
      context.handle(
          _serverNameMeta,
          serverName.isAcceptableOrUnknown(
              data['server_name']!, _serverNameMeta));
    }
    if (data.containsKey('status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['status']!, _statusMeta));
    }
    if (data.containsKey('fired_at')) {
      context.handle(_firedAtMeta,
          firedAt.isAcceptableOrUnknown(data['fired_at']!, _firedAtMeta));
    } else if (isInserting) {
      context.missing(_firedAtMeta);
    }
    if (data.containsKey('started_at')) {
      context.handle(_startedAtMeta,
          startedAt.isAcceptableOrUnknown(data['started_at']!, _startedAtMeta));
    }
    if (data.containsKey('completed_at')) {
      context.handle(
          _completedAtMeta,
          completedAt.isAcceptableOrUnknown(
              data['completed_at']!, _completedAtMeta));
    }
    if (data.containsKey('target_time')) {
      context.handle(
          _targetTimeMeta,
          targetTime.isAcceptableOrUnknown(
              data['target_time']!, _targetTimeMeta));
    }
    if (data.containsKey('note')) {
      context.handle(
          _noteMeta, note.isAcceptableOrUnknown(data['note']!, _noteMeta));
    }
    if (data.containsKey('is_rush')) {
      context.handle(_isRushMeta,
          isRush.isAcceptableOrUnknown(data['is_rush']!, _isRushMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  KitchenTicketTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return KitchenTicketTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      orderUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}order_uuid'])!,
      orderNumber: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}order_number'])!,
      tableUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}table_uuid']),
      guestTableName: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}guest_table_name']),
      serverName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}server_name']),
      status: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}status'])!,
      firedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}fired_at'])!,
      startedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}started_at']),
      completedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}completed_at']),
      targetTime: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}target_time']),
      note: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}note']),
      isRush: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_rush'])!,
    );
  }

  @override
  $KitchenTicketTableTable createAlias(String alias) {
    return $KitchenTicketTableTable(attachedDatabase, alias);
  }
}

class KitchenTicketTableData extends DataClass
    implements Insertable<KitchenTicketTableData> {
  final int id;
  final String uuid;
  final String orderUuid;
  final String orderNumber;
  final String? tableUuid;
  final String? guestTableName;
  final String? serverName;
  final String status;
  final DateTime firedAt;
  final DateTime? startedAt;
  final DateTime? completedAt;
  final DateTime? targetTime;
  final String? note;
  final bool isRush;
  const KitchenTicketTableData(
      {required this.id,
      required this.uuid,
      required this.orderUuid,
      required this.orderNumber,
      this.tableUuid,
      this.guestTableName,
      this.serverName,
      required this.status,
      required this.firedAt,
      this.startedAt,
      this.completedAt,
      this.targetTime,
      this.note,
      required this.isRush});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    map['order_uuid'] = Variable<String>(orderUuid);
    map['order_number'] = Variable<String>(orderNumber);
    if (!nullToAbsent || tableUuid != null) {
      map['table_uuid'] = Variable<String>(tableUuid);
    }
    if (!nullToAbsent || guestTableName != null) {
      map['guest_table_name'] = Variable<String>(guestTableName);
    }
    if (!nullToAbsent || serverName != null) {
      map['server_name'] = Variable<String>(serverName);
    }
    map['status'] = Variable<String>(status);
    map['fired_at'] = Variable<DateTime>(firedAt);
    if (!nullToAbsent || startedAt != null) {
      map['started_at'] = Variable<DateTime>(startedAt);
    }
    if (!nullToAbsent || completedAt != null) {
      map['completed_at'] = Variable<DateTime>(completedAt);
    }
    if (!nullToAbsent || targetTime != null) {
      map['target_time'] = Variable<DateTime>(targetTime);
    }
    if (!nullToAbsent || note != null) {
      map['note'] = Variable<String>(note);
    }
    map['is_rush'] = Variable<bool>(isRush);
    return map;
  }

  KitchenTicketTableCompanion toCompanion(bool nullToAbsent) {
    return KitchenTicketTableCompanion(
      id: Value(id),
      uuid: Value(uuid),
      orderUuid: Value(orderUuid),
      orderNumber: Value(orderNumber),
      tableUuid: tableUuid == null && nullToAbsent
          ? const Value.absent()
          : Value(tableUuid),
      guestTableName: guestTableName == null && nullToAbsent
          ? const Value.absent()
          : Value(guestTableName),
      serverName: serverName == null && nullToAbsent
          ? const Value.absent()
          : Value(serverName),
      status: Value(status),
      firedAt: Value(firedAt),
      startedAt: startedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(startedAt),
      completedAt: completedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(completedAt),
      targetTime: targetTime == null && nullToAbsent
          ? const Value.absent()
          : Value(targetTime),
      note: note == null && nullToAbsent ? const Value.absent() : Value(note),
      isRush: Value(isRush),
    );
  }

  factory KitchenTicketTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return KitchenTicketTableData(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      orderUuid: serializer.fromJson<String>(json['orderUuid']),
      orderNumber: serializer.fromJson<String>(json['orderNumber']),
      tableUuid: serializer.fromJson<String?>(json['tableUuid']),
      guestTableName: serializer.fromJson<String?>(json['guestTableName']),
      serverName: serializer.fromJson<String?>(json['serverName']),
      status: serializer.fromJson<String>(json['status']),
      firedAt: serializer.fromJson<DateTime>(json['firedAt']),
      startedAt: serializer.fromJson<DateTime?>(json['startedAt']),
      completedAt: serializer.fromJson<DateTime?>(json['completedAt']),
      targetTime: serializer.fromJson<DateTime?>(json['targetTime']),
      note: serializer.fromJson<String?>(json['note']),
      isRush: serializer.fromJson<bool>(json['isRush']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'orderUuid': serializer.toJson<String>(orderUuid),
      'orderNumber': serializer.toJson<String>(orderNumber),
      'tableUuid': serializer.toJson<String?>(tableUuid),
      'guestTableName': serializer.toJson<String?>(guestTableName),
      'serverName': serializer.toJson<String?>(serverName),
      'status': serializer.toJson<String>(status),
      'firedAt': serializer.toJson<DateTime>(firedAt),
      'startedAt': serializer.toJson<DateTime?>(startedAt),
      'completedAt': serializer.toJson<DateTime?>(completedAt),
      'targetTime': serializer.toJson<DateTime?>(targetTime),
      'note': serializer.toJson<String?>(note),
      'isRush': serializer.toJson<bool>(isRush),
    };
  }

  KitchenTicketTableData copyWith(
          {int? id,
          String? uuid,
          String? orderUuid,
          String? orderNumber,
          Value<String?> tableUuid = const Value.absent(),
          Value<String?> guestTableName = const Value.absent(),
          Value<String?> serverName = const Value.absent(),
          String? status,
          DateTime? firedAt,
          Value<DateTime?> startedAt = const Value.absent(),
          Value<DateTime?> completedAt = const Value.absent(),
          Value<DateTime?> targetTime = const Value.absent(),
          Value<String?> note = const Value.absent(),
          bool? isRush}) =>
      KitchenTicketTableData(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        orderUuid: orderUuid ?? this.orderUuid,
        orderNumber: orderNumber ?? this.orderNumber,
        tableUuid: tableUuid.present ? tableUuid.value : this.tableUuid,
        guestTableName:
            guestTableName.present ? guestTableName.value : this.guestTableName,
        serverName: serverName.present ? serverName.value : this.serverName,
        status: status ?? this.status,
        firedAt: firedAt ?? this.firedAt,
        startedAt: startedAt.present ? startedAt.value : this.startedAt,
        completedAt: completedAt.present ? completedAt.value : this.completedAt,
        targetTime: targetTime.present ? targetTime.value : this.targetTime,
        note: note.present ? note.value : this.note,
        isRush: isRush ?? this.isRush,
      );
  KitchenTicketTableData copyWithCompanion(KitchenTicketTableCompanion data) {
    return KitchenTicketTableData(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      orderUuid: data.orderUuid.present ? data.orderUuid.value : this.orderUuid,
      orderNumber:
          data.orderNumber.present ? data.orderNumber.value : this.orderNumber,
      tableUuid: data.tableUuid.present ? data.tableUuid.value : this.tableUuid,
      guestTableName: data.guestTableName.present
          ? data.guestTableName.value
          : this.guestTableName,
      serverName:
          data.serverName.present ? data.serverName.value : this.serverName,
      status: data.status.present ? data.status.value : this.status,
      firedAt: data.firedAt.present ? data.firedAt.value : this.firedAt,
      startedAt: data.startedAt.present ? data.startedAt.value : this.startedAt,
      completedAt:
          data.completedAt.present ? data.completedAt.value : this.completedAt,
      targetTime:
          data.targetTime.present ? data.targetTime.value : this.targetTime,
      note: data.note.present ? data.note.value : this.note,
      isRush: data.isRush.present ? data.isRush.value : this.isRush,
    );
  }

  @override
  String toString() {
    return (StringBuffer('KitchenTicketTableData(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('orderUuid: $orderUuid, ')
          ..write('orderNumber: $orderNumber, ')
          ..write('tableUuid: $tableUuid, ')
          ..write('guestTableName: $guestTableName, ')
          ..write('serverName: $serverName, ')
          ..write('status: $status, ')
          ..write('firedAt: $firedAt, ')
          ..write('startedAt: $startedAt, ')
          ..write('completedAt: $completedAt, ')
          ..write('targetTime: $targetTime, ')
          ..write('note: $note, ')
          ..write('isRush: $isRush')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      uuid,
      orderUuid,
      orderNumber,
      tableUuid,
      guestTableName,
      serverName,
      status,
      firedAt,
      startedAt,
      completedAt,
      targetTime,
      note,
      isRush);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is KitchenTicketTableData &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.orderUuid == this.orderUuid &&
          other.orderNumber == this.orderNumber &&
          other.tableUuid == this.tableUuid &&
          other.guestTableName == this.guestTableName &&
          other.serverName == this.serverName &&
          other.status == this.status &&
          other.firedAt == this.firedAt &&
          other.startedAt == this.startedAt &&
          other.completedAt == this.completedAt &&
          other.targetTime == this.targetTime &&
          other.note == this.note &&
          other.isRush == this.isRush);
}

class KitchenTicketTableCompanion
    extends UpdateCompanion<KitchenTicketTableData> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String> orderUuid;
  final Value<String> orderNumber;
  final Value<String?> tableUuid;
  final Value<String?> guestTableName;
  final Value<String?> serverName;
  final Value<String> status;
  final Value<DateTime> firedAt;
  final Value<DateTime?> startedAt;
  final Value<DateTime?> completedAt;
  final Value<DateTime?> targetTime;
  final Value<String?> note;
  final Value<bool> isRush;
  const KitchenTicketTableCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.orderUuid = const Value.absent(),
    this.orderNumber = const Value.absent(),
    this.tableUuid = const Value.absent(),
    this.guestTableName = const Value.absent(),
    this.serverName = const Value.absent(),
    this.status = const Value.absent(),
    this.firedAt = const Value.absent(),
    this.startedAt = const Value.absent(),
    this.completedAt = const Value.absent(),
    this.targetTime = const Value.absent(),
    this.note = const Value.absent(),
    this.isRush = const Value.absent(),
  });
  KitchenTicketTableCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    required String orderUuid,
    required String orderNumber,
    this.tableUuid = const Value.absent(),
    this.guestTableName = const Value.absent(),
    this.serverName = const Value.absent(),
    this.status = const Value.absent(),
    required DateTime firedAt,
    this.startedAt = const Value.absent(),
    this.completedAt = const Value.absent(),
    this.targetTime = const Value.absent(),
    this.note = const Value.absent(),
    this.isRush = const Value.absent(),
  })  : uuid = Value(uuid),
        orderUuid = Value(orderUuid),
        orderNumber = Value(orderNumber),
        firedAt = Value(firedAt);
  static Insertable<KitchenTicketTableData> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? orderUuid,
    Expression<String>? orderNumber,
    Expression<String>? tableUuid,
    Expression<String>? guestTableName,
    Expression<String>? serverName,
    Expression<String>? status,
    Expression<DateTime>? firedAt,
    Expression<DateTime>? startedAt,
    Expression<DateTime>? completedAt,
    Expression<DateTime>? targetTime,
    Expression<String>? note,
    Expression<bool>? isRush,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (orderUuid != null) 'order_uuid': orderUuid,
      if (orderNumber != null) 'order_number': orderNumber,
      if (tableUuid != null) 'table_uuid': tableUuid,
      if (guestTableName != null) 'guest_table_name': guestTableName,
      if (serverName != null) 'server_name': serverName,
      if (status != null) 'status': status,
      if (firedAt != null) 'fired_at': firedAt,
      if (startedAt != null) 'started_at': startedAt,
      if (completedAt != null) 'completed_at': completedAt,
      if (targetTime != null) 'target_time': targetTime,
      if (note != null) 'note': note,
      if (isRush != null) 'is_rush': isRush,
    });
  }

  KitchenTicketTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String>? orderUuid,
      Value<String>? orderNumber,
      Value<String?>? tableUuid,
      Value<String?>? guestTableName,
      Value<String?>? serverName,
      Value<String>? status,
      Value<DateTime>? firedAt,
      Value<DateTime?>? startedAt,
      Value<DateTime?>? completedAt,
      Value<DateTime?>? targetTime,
      Value<String?>? note,
      Value<bool>? isRush}) {
    return KitchenTicketTableCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      orderUuid: orderUuid ?? this.orderUuid,
      orderNumber: orderNumber ?? this.orderNumber,
      tableUuid: tableUuid ?? this.tableUuid,
      guestTableName: guestTableName ?? this.guestTableName,
      serverName: serverName ?? this.serverName,
      status: status ?? this.status,
      firedAt: firedAt ?? this.firedAt,
      startedAt: startedAt ?? this.startedAt,
      completedAt: completedAt ?? this.completedAt,
      targetTime: targetTime ?? this.targetTime,
      note: note ?? this.note,
      isRush: isRush ?? this.isRush,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (orderUuid.present) {
      map['order_uuid'] = Variable<String>(orderUuid.value);
    }
    if (orderNumber.present) {
      map['order_number'] = Variable<String>(orderNumber.value);
    }
    if (tableUuid.present) {
      map['table_uuid'] = Variable<String>(tableUuid.value);
    }
    if (guestTableName.present) {
      map['guest_table_name'] = Variable<String>(guestTableName.value);
    }
    if (serverName.present) {
      map['server_name'] = Variable<String>(serverName.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (firedAt.present) {
      map['fired_at'] = Variable<DateTime>(firedAt.value);
    }
    if (startedAt.present) {
      map['started_at'] = Variable<DateTime>(startedAt.value);
    }
    if (completedAt.present) {
      map['completed_at'] = Variable<DateTime>(completedAt.value);
    }
    if (targetTime.present) {
      map['target_time'] = Variable<DateTime>(targetTime.value);
    }
    if (note.present) {
      map['note'] = Variable<String>(note.value);
    }
    if (isRush.present) {
      map['is_rush'] = Variable<bool>(isRush.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('KitchenTicketTableCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('orderUuid: $orderUuid, ')
          ..write('orderNumber: $orderNumber, ')
          ..write('tableUuid: $tableUuid, ')
          ..write('guestTableName: $guestTableName, ')
          ..write('serverName: $serverName, ')
          ..write('status: $status, ')
          ..write('firedAt: $firedAt, ')
          ..write('startedAt: $startedAt, ')
          ..write('completedAt: $completedAt, ')
          ..write('targetTime: $targetTime, ')
          ..write('note: $note, ')
          ..write('isRush: $isRush')
          ..write(')'))
        .toString();
  }
}

class $KitchenItemTableTable extends KitchenItemTable
    with TableInfo<$KitchenItemTableTable, KitchenItemTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $KitchenItemTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _ticketUuidMeta =
      const VerificationMeta('ticketUuid');
  @override
  late final GeneratedColumn<String> ticketUuid = GeneratedColumn<String>(
      'ticket_uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES kitchen_ticket_table (uuid) ON DELETE CASCADE'));
  static const VerificationMeta _orderItemUuidMeta =
      const VerificationMeta('orderItemUuid');
  @override
  late final GeneratedColumn<String> orderItemUuid = GeneratedColumn<String>(
      'order_item_uuid', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _quantityMeta =
      const VerificationMeta('quantity');
  @override
  late final GeneratedColumn<int> quantity = GeneratedColumn<int>(
      'quantity', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _modifiersJsonMeta =
      const VerificationMeta('modifiersJson');
  @override
  late final GeneratedColumn<String> modifiersJson = GeneratedColumn<String>(
      'modifiers_json', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultValue: const Constant('[]'));
  static const VerificationMeta _noteMeta = const VerificationMeta('note');
  @override
  late final GeneratedColumn<String> note = GeneratedColumn<String>(
      'note', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _courseMeta = const VerificationMeta('course');
  @override
  late final GeneratedColumn<String> course = GeneratedColumn<String>(
      'course', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultValue: const Constant('main'));
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
      'status', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultValue: const Constant('fired'));
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        ticketUuid,
        orderItemUuid,
        name,
        quantity,
        modifiersJson,
        note,
        course,
        status
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'kitchen_item_table';
  @override
  VerificationContext validateIntegrity(
      Insertable<KitchenItemTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('ticket_uuid')) {
      context.handle(
          _ticketUuidMeta,
          ticketUuid.isAcceptableOrUnknown(
              data['ticket_uuid']!, _ticketUuidMeta));
    } else if (isInserting) {
      context.missing(_ticketUuidMeta);
    }
    if (data.containsKey('order_item_uuid')) {
      context.handle(
          _orderItemUuidMeta,
          orderItemUuid.isAcceptableOrUnknown(
              data['order_item_uuid']!, _orderItemUuidMeta));
    } else if (isInserting) {
      context.missing(_orderItemUuidMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('quantity')) {
      context.handle(_quantityMeta,
          quantity.isAcceptableOrUnknown(data['quantity']!, _quantityMeta));
    } else if (isInserting) {
      context.missing(_quantityMeta);
    }
    if (data.containsKey('modifiers_json')) {
      context.handle(
          _modifiersJsonMeta,
          modifiersJson.isAcceptableOrUnknown(
              data['modifiers_json']!, _modifiersJsonMeta));
    }
    if (data.containsKey('note')) {
      context.handle(
          _noteMeta, note.isAcceptableOrUnknown(data['note']!, _noteMeta));
    }
    if (data.containsKey('course')) {
      context.handle(_courseMeta,
          course.isAcceptableOrUnknown(data['course']!, _courseMeta));
    }
    if (data.containsKey('status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['status']!, _statusMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  KitchenItemTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return KitchenItemTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      ticketUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}ticket_uuid'])!,
      orderItemUuid: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}order_item_uuid'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
      quantity: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}quantity'])!,
      modifiersJson: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}modifiers_json'])!,
      note: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}note']),
      course: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}course'])!,
      status: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}status'])!,
    );
  }

  @override
  $KitchenItemTableTable createAlias(String alias) {
    return $KitchenItemTableTable(attachedDatabase, alias);
  }
}

class KitchenItemTableData extends DataClass
    implements Insertable<KitchenItemTableData> {
  final int id;
  final String uuid;
  final String ticketUuid;
  final String orderItemUuid;
  final String name;
  final int quantity;
  final String modifiersJson;
  final String? note;
  final String course;
  final String status;
  const KitchenItemTableData(
      {required this.id,
      required this.uuid,
      required this.ticketUuid,
      required this.orderItemUuid,
      required this.name,
      required this.quantity,
      required this.modifiersJson,
      this.note,
      required this.course,
      required this.status});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    map['ticket_uuid'] = Variable<String>(ticketUuid);
    map['order_item_uuid'] = Variable<String>(orderItemUuid);
    map['name'] = Variable<String>(name);
    map['quantity'] = Variable<int>(quantity);
    map['modifiers_json'] = Variable<String>(modifiersJson);
    if (!nullToAbsent || note != null) {
      map['note'] = Variable<String>(note);
    }
    map['course'] = Variable<String>(course);
    map['status'] = Variable<String>(status);
    return map;
  }

  KitchenItemTableCompanion toCompanion(bool nullToAbsent) {
    return KitchenItemTableCompanion(
      id: Value(id),
      uuid: Value(uuid),
      ticketUuid: Value(ticketUuid),
      orderItemUuid: Value(orderItemUuid),
      name: Value(name),
      quantity: Value(quantity),
      modifiersJson: Value(modifiersJson),
      note: note == null && nullToAbsent ? const Value.absent() : Value(note),
      course: Value(course),
      status: Value(status),
    );
  }

  factory KitchenItemTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return KitchenItemTableData(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      ticketUuid: serializer.fromJson<String>(json['ticketUuid']),
      orderItemUuid: serializer.fromJson<String>(json['orderItemUuid']),
      name: serializer.fromJson<String>(json['name']),
      quantity: serializer.fromJson<int>(json['quantity']),
      modifiersJson: serializer.fromJson<String>(json['modifiersJson']),
      note: serializer.fromJson<String?>(json['note']),
      course: serializer.fromJson<String>(json['course']),
      status: serializer.fromJson<String>(json['status']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'ticketUuid': serializer.toJson<String>(ticketUuid),
      'orderItemUuid': serializer.toJson<String>(orderItemUuid),
      'name': serializer.toJson<String>(name),
      'quantity': serializer.toJson<int>(quantity),
      'modifiersJson': serializer.toJson<String>(modifiersJson),
      'note': serializer.toJson<String?>(note),
      'course': serializer.toJson<String>(course),
      'status': serializer.toJson<String>(status),
    };
  }

  KitchenItemTableData copyWith(
          {int? id,
          String? uuid,
          String? ticketUuid,
          String? orderItemUuid,
          String? name,
          int? quantity,
          String? modifiersJson,
          Value<String?> note = const Value.absent(),
          String? course,
          String? status}) =>
      KitchenItemTableData(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        ticketUuid: ticketUuid ?? this.ticketUuid,
        orderItemUuid: orderItemUuid ?? this.orderItemUuid,
        name: name ?? this.name,
        quantity: quantity ?? this.quantity,
        modifiersJson: modifiersJson ?? this.modifiersJson,
        note: note.present ? note.value : this.note,
        course: course ?? this.course,
        status: status ?? this.status,
      );
  KitchenItemTableData copyWithCompanion(KitchenItemTableCompanion data) {
    return KitchenItemTableData(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      ticketUuid:
          data.ticketUuid.present ? data.ticketUuid.value : this.ticketUuid,
      orderItemUuid: data.orderItemUuid.present
          ? data.orderItemUuid.value
          : this.orderItemUuid,
      name: data.name.present ? data.name.value : this.name,
      quantity: data.quantity.present ? data.quantity.value : this.quantity,
      modifiersJson: data.modifiersJson.present
          ? data.modifiersJson.value
          : this.modifiersJson,
      note: data.note.present ? data.note.value : this.note,
      course: data.course.present ? data.course.value : this.course,
      status: data.status.present ? data.status.value : this.status,
    );
  }

  @override
  String toString() {
    return (StringBuffer('KitchenItemTableData(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('ticketUuid: $ticketUuid, ')
          ..write('orderItemUuid: $orderItemUuid, ')
          ..write('name: $name, ')
          ..write('quantity: $quantity, ')
          ..write('modifiersJson: $modifiersJson, ')
          ..write('note: $note, ')
          ..write('course: $course, ')
          ..write('status: $status')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, uuid, ticketUuid, orderItemUuid, name,
      quantity, modifiersJson, note, course, status);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is KitchenItemTableData &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.ticketUuid == this.ticketUuid &&
          other.orderItemUuid == this.orderItemUuid &&
          other.name == this.name &&
          other.quantity == this.quantity &&
          other.modifiersJson == this.modifiersJson &&
          other.note == this.note &&
          other.course == this.course &&
          other.status == this.status);
}

class KitchenItemTableCompanion extends UpdateCompanion<KitchenItemTableData> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String> ticketUuid;
  final Value<String> orderItemUuid;
  final Value<String> name;
  final Value<int> quantity;
  final Value<String> modifiersJson;
  final Value<String?> note;
  final Value<String> course;
  final Value<String> status;
  const KitchenItemTableCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.ticketUuid = const Value.absent(),
    this.orderItemUuid = const Value.absent(),
    this.name = const Value.absent(),
    this.quantity = const Value.absent(),
    this.modifiersJson = const Value.absent(),
    this.note = const Value.absent(),
    this.course = const Value.absent(),
    this.status = const Value.absent(),
  });
  KitchenItemTableCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    required String ticketUuid,
    required String orderItemUuid,
    required String name,
    required int quantity,
    this.modifiersJson = const Value.absent(),
    this.note = const Value.absent(),
    this.course = const Value.absent(),
    this.status = const Value.absent(),
  })  : uuid = Value(uuid),
        ticketUuid = Value(ticketUuid),
        orderItemUuid = Value(orderItemUuid),
        name = Value(name),
        quantity = Value(quantity);
  static Insertable<KitchenItemTableData> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? ticketUuid,
    Expression<String>? orderItemUuid,
    Expression<String>? name,
    Expression<int>? quantity,
    Expression<String>? modifiersJson,
    Expression<String>? note,
    Expression<String>? course,
    Expression<String>? status,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (ticketUuid != null) 'ticket_uuid': ticketUuid,
      if (orderItemUuid != null) 'order_item_uuid': orderItemUuid,
      if (name != null) 'name': name,
      if (quantity != null) 'quantity': quantity,
      if (modifiersJson != null) 'modifiers_json': modifiersJson,
      if (note != null) 'note': note,
      if (course != null) 'course': course,
      if (status != null) 'status': status,
    });
  }

  KitchenItemTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String>? ticketUuid,
      Value<String>? orderItemUuid,
      Value<String>? name,
      Value<int>? quantity,
      Value<String>? modifiersJson,
      Value<String?>? note,
      Value<String>? course,
      Value<String>? status}) {
    return KitchenItemTableCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      ticketUuid: ticketUuid ?? this.ticketUuid,
      orderItemUuid: orderItemUuid ?? this.orderItemUuid,
      name: name ?? this.name,
      quantity: quantity ?? this.quantity,
      modifiersJson: modifiersJson ?? this.modifiersJson,
      note: note ?? this.note,
      course: course ?? this.course,
      status: status ?? this.status,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (ticketUuid.present) {
      map['ticket_uuid'] = Variable<String>(ticketUuid.value);
    }
    if (orderItemUuid.present) {
      map['order_item_uuid'] = Variable<String>(orderItemUuid.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (quantity.present) {
      map['quantity'] = Variable<int>(quantity.value);
    }
    if (modifiersJson.present) {
      map['modifiers_json'] = Variable<String>(modifiersJson.value);
    }
    if (note.present) {
      map['note'] = Variable<String>(note.value);
    }
    if (course.present) {
      map['course'] = Variable<String>(course.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('KitchenItemTableCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('ticketUuid: $ticketUuid, ')
          ..write('orderItemUuid: $orderItemUuid, ')
          ..write('name: $name, ')
          ..write('quantity: $quantity, ')
          ..write('modifiersJson: $modifiersJson, ')
          ..write('note: $note, ')
          ..write('course: $course, ')
          ..write('status: $status')
          ..write(')'))
        .toString();
  }
}

class $CustomerFeedbackTableTable extends CustomerFeedbackTable
    with TableInfo<$CustomerFeedbackTableTable, CustomerFeedbackTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $CustomerFeedbackTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _orderUuidMeta =
      const VerificationMeta('orderUuid');
  @override
  late final GeneratedColumn<String> orderUuid = GeneratedColumn<String>(
      'order_uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES order_table (uuid)'));
  static const VerificationMeta _customerUuidMeta =
      const VerificationMeta('customerUuid');
  @override
  late final GeneratedColumn<String> customerUuid = GeneratedColumn<String>(
      'customer_uuid', aliasedName, true,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES customer_table (uuid)'));
  static const VerificationMeta _ratingMeta = const VerificationMeta('rating');
  @override
  late final GeneratedColumn<int> rating = GeneratedColumn<int>(
      'rating', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _sentimentMeta =
      const VerificationMeta('sentiment');
  @override
  late final GeneratedColumn<String> sentiment = GeneratedColumn<String>(
      'sentiment', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultValue: const Constant('neutral'));
  static const VerificationMeta _tagsMeta = const VerificationMeta('tags');
  @override
  late final GeneratedColumn<String> tags = GeneratedColumn<String>(
      'tags', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _commentMeta =
      const VerificationMeta('comment');
  @override
  late final GeneratedColumn<String> comment = GeneratedColumn<String>(
      'comment', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isActionedMeta =
      const VerificationMeta('isActioned');
  @override
  late final GeneratedColumn<bool> isActioned = GeneratedColumn<bool>(
      'is_actioned', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_actioned" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        orderUuid,
        customerUuid,
        rating,
        sentiment,
        tags,
        comment,
        isActioned,
        createdAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'customer_feedback_table';
  @override
  VerificationContext validateIntegrity(
      Insertable<CustomerFeedbackTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('order_uuid')) {
      context.handle(_orderUuidMeta,
          orderUuid.isAcceptableOrUnknown(data['order_uuid']!, _orderUuidMeta));
    } else if (isInserting) {
      context.missing(_orderUuidMeta);
    }
    if (data.containsKey('customer_uuid')) {
      context.handle(
          _customerUuidMeta,
          customerUuid.isAcceptableOrUnknown(
              data['customer_uuid']!, _customerUuidMeta));
    }
    if (data.containsKey('rating')) {
      context.handle(_ratingMeta,
          rating.isAcceptableOrUnknown(data['rating']!, _ratingMeta));
    } else if (isInserting) {
      context.missing(_ratingMeta);
    }
    if (data.containsKey('sentiment')) {
      context.handle(_sentimentMeta,
          sentiment.isAcceptableOrUnknown(data['sentiment']!, _sentimentMeta));
    }
    if (data.containsKey('tags')) {
      context.handle(
          _tagsMeta, tags.isAcceptableOrUnknown(data['tags']!, _tagsMeta));
    }
    if (data.containsKey('comment')) {
      context.handle(_commentMeta,
          comment.isAcceptableOrUnknown(data['comment']!, _commentMeta));
    }
    if (data.containsKey('is_actioned')) {
      context.handle(
          _isActionedMeta,
          isActioned.isAcceptableOrUnknown(
              data['is_actioned']!, _isActionedMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
        {uuid},
      ];
  @override
  CustomerFeedbackTableData map(Map<String, dynamic> data,
      {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return CustomerFeedbackTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      orderUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}order_uuid'])!,
      customerUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}customer_uuid']),
      rating: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}rating'])!,
      sentiment: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}sentiment'])!,
      tags: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tags']),
      comment: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}comment']),
      isActioned: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_actioned'])!,
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
    );
  }

  @override
  $CustomerFeedbackTableTable createAlias(String alias) {
    return $CustomerFeedbackTableTable(attachedDatabase, alias);
  }
}

class CustomerFeedbackTableData extends DataClass
    implements Insertable<CustomerFeedbackTableData> {
  final int id;
  final String uuid;
  final String orderUuid;
  final String? customerUuid;
  final int rating;
  final String sentiment;
  final String? tags;
  final String? comment;
  final bool isActioned;
  final DateTime createdAt;
  const CustomerFeedbackTableData(
      {required this.id,
      required this.uuid,
      required this.orderUuid,
      this.customerUuid,
      required this.rating,
      required this.sentiment,
      this.tags,
      this.comment,
      required this.isActioned,
      required this.createdAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    map['order_uuid'] = Variable<String>(orderUuid);
    if (!nullToAbsent || customerUuid != null) {
      map['customer_uuid'] = Variable<String>(customerUuid);
    }
    map['rating'] = Variable<int>(rating);
    map['sentiment'] = Variable<String>(sentiment);
    if (!nullToAbsent || tags != null) {
      map['tags'] = Variable<String>(tags);
    }
    if (!nullToAbsent || comment != null) {
      map['comment'] = Variable<String>(comment);
    }
    map['is_actioned'] = Variable<bool>(isActioned);
    map['created_at'] = Variable<DateTime>(createdAt);
    return map;
  }

  CustomerFeedbackTableCompanion toCompanion(bool nullToAbsent) {
    return CustomerFeedbackTableCompanion(
      id: Value(id),
      uuid: Value(uuid),
      orderUuid: Value(orderUuid),
      customerUuid: customerUuid == null && nullToAbsent
          ? const Value.absent()
          : Value(customerUuid),
      rating: Value(rating),
      sentiment: Value(sentiment),
      tags: tags == null && nullToAbsent ? const Value.absent() : Value(tags),
      comment: comment == null && nullToAbsent
          ? const Value.absent()
          : Value(comment),
      isActioned: Value(isActioned),
      createdAt: Value(createdAt),
    );
  }

  factory CustomerFeedbackTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return CustomerFeedbackTableData(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      orderUuid: serializer.fromJson<String>(json['orderUuid']),
      customerUuid: serializer.fromJson<String?>(json['customerUuid']),
      rating: serializer.fromJson<int>(json['rating']),
      sentiment: serializer.fromJson<String>(json['sentiment']),
      tags: serializer.fromJson<String?>(json['tags']),
      comment: serializer.fromJson<String?>(json['comment']),
      isActioned: serializer.fromJson<bool>(json['isActioned']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'orderUuid': serializer.toJson<String>(orderUuid),
      'customerUuid': serializer.toJson<String?>(customerUuid),
      'rating': serializer.toJson<int>(rating),
      'sentiment': serializer.toJson<String>(sentiment),
      'tags': serializer.toJson<String?>(tags),
      'comment': serializer.toJson<String?>(comment),
      'isActioned': serializer.toJson<bool>(isActioned),
      'createdAt': serializer.toJson<DateTime>(createdAt),
    };
  }

  CustomerFeedbackTableData copyWith(
          {int? id,
          String? uuid,
          String? orderUuid,
          Value<String?> customerUuid = const Value.absent(),
          int? rating,
          String? sentiment,
          Value<String?> tags = const Value.absent(),
          Value<String?> comment = const Value.absent(),
          bool? isActioned,
          DateTime? createdAt}) =>
      CustomerFeedbackTableData(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        orderUuid: orderUuid ?? this.orderUuid,
        customerUuid:
            customerUuid.present ? customerUuid.value : this.customerUuid,
        rating: rating ?? this.rating,
        sentiment: sentiment ?? this.sentiment,
        tags: tags.present ? tags.value : this.tags,
        comment: comment.present ? comment.value : this.comment,
        isActioned: isActioned ?? this.isActioned,
        createdAt: createdAt ?? this.createdAt,
      );
  CustomerFeedbackTableData copyWithCompanion(
      CustomerFeedbackTableCompanion data) {
    return CustomerFeedbackTableData(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      orderUuid: data.orderUuid.present ? data.orderUuid.value : this.orderUuid,
      customerUuid: data.customerUuid.present
          ? data.customerUuid.value
          : this.customerUuid,
      rating: data.rating.present ? data.rating.value : this.rating,
      sentiment: data.sentiment.present ? data.sentiment.value : this.sentiment,
      tags: data.tags.present ? data.tags.value : this.tags,
      comment: data.comment.present ? data.comment.value : this.comment,
      isActioned:
          data.isActioned.present ? data.isActioned.value : this.isActioned,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('CustomerFeedbackTableData(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('orderUuid: $orderUuid, ')
          ..write('customerUuid: $customerUuid, ')
          ..write('rating: $rating, ')
          ..write('sentiment: $sentiment, ')
          ..write('tags: $tags, ')
          ..write('comment: $comment, ')
          ..write('isActioned: $isActioned, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, uuid, orderUuid, customerUuid, rating,
      sentiment, tags, comment, isActioned, createdAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is CustomerFeedbackTableData &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.orderUuid == this.orderUuid &&
          other.customerUuid == this.customerUuid &&
          other.rating == this.rating &&
          other.sentiment == this.sentiment &&
          other.tags == this.tags &&
          other.comment == this.comment &&
          other.isActioned == this.isActioned &&
          other.createdAt == this.createdAt);
}

class CustomerFeedbackTableCompanion
    extends UpdateCompanion<CustomerFeedbackTableData> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String> orderUuid;
  final Value<String?> customerUuid;
  final Value<int> rating;
  final Value<String> sentiment;
  final Value<String?> tags;
  final Value<String?> comment;
  final Value<bool> isActioned;
  final Value<DateTime> createdAt;
  const CustomerFeedbackTableCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.orderUuid = const Value.absent(),
    this.customerUuid = const Value.absent(),
    this.rating = const Value.absent(),
    this.sentiment = const Value.absent(),
    this.tags = const Value.absent(),
    this.comment = const Value.absent(),
    this.isActioned = const Value.absent(),
    this.createdAt = const Value.absent(),
  });
  CustomerFeedbackTableCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    required String orderUuid,
    this.customerUuid = const Value.absent(),
    required int rating,
    this.sentiment = const Value.absent(),
    this.tags = const Value.absent(),
    this.comment = const Value.absent(),
    this.isActioned = const Value.absent(),
    required DateTime createdAt,
  })  : uuid = Value(uuid),
        orderUuid = Value(orderUuid),
        rating = Value(rating),
        createdAt = Value(createdAt);
  static Insertable<CustomerFeedbackTableData> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? orderUuid,
    Expression<String>? customerUuid,
    Expression<int>? rating,
    Expression<String>? sentiment,
    Expression<String>? tags,
    Expression<String>? comment,
    Expression<bool>? isActioned,
    Expression<DateTime>? createdAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (orderUuid != null) 'order_uuid': orderUuid,
      if (customerUuid != null) 'customer_uuid': customerUuid,
      if (rating != null) 'rating': rating,
      if (sentiment != null) 'sentiment': sentiment,
      if (tags != null) 'tags': tags,
      if (comment != null) 'comment': comment,
      if (isActioned != null) 'is_actioned': isActioned,
      if (createdAt != null) 'created_at': createdAt,
    });
  }

  CustomerFeedbackTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String>? orderUuid,
      Value<String?>? customerUuid,
      Value<int>? rating,
      Value<String>? sentiment,
      Value<String?>? tags,
      Value<String?>? comment,
      Value<bool>? isActioned,
      Value<DateTime>? createdAt}) {
    return CustomerFeedbackTableCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      orderUuid: orderUuid ?? this.orderUuid,
      customerUuid: customerUuid ?? this.customerUuid,
      rating: rating ?? this.rating,
      sentiment: sentiment ?? this.sentiment,
      tags: tags ?? this.tags,
      comment: comment ?? this.comment,
      isActioned: isActioned ?? this.isActioned,
      createdAt: createdAt ?? this.createdAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (orderUuid.present) {
      map['order_uuid'] = Variable<String>(orderUuid.value);
    }
    if (customerUuid.present) {
      map['customer_uuid'] = Variable<String>(customerUuid.value);
    }
    if (rating.present) {
      map['rating'] = Variable<int>(rating.value);
    }
    if (sentiment.present) {
      map['sentiment'] = Variable<String>(sentiment.value);
    }
    if (tags.present) {
      map['tags'] = Variable<String>(tags.value);
    }
    if (comment.present) {
      map['comment'] = Variable<String>(comment.value);
    }
    if (isActioned.present) {
      map['is_actioned'] = Variable<bool>(isActioned.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('CustomerFeedbackTableCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('orderUuid: $orderUuid, ')
          ..write('customerUuid: $customerUuid, ')
          ..write('rating: $rating, ')
          ..write('sentiment: $sentiment, ')
          ..write('tags: $tags, ')
          ..write('comment: $comment, ')
          ..write('isActioned: $isActioned, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }
}

class $AuditLogTableTable extends AuditLogTable
    with TableInfo<$AuditLogTableTable, AuditLogTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $AuditLogTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _timestampMeta =
      const VerificationMeta('timestamp');
  @override
  late final GeneratedColumn<DateTime> timestamp = GeneratedColumn<DateTime>(
      'timestamp', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _cashierIdMeta =
      const VerificationMeta('cashierId');
  @override
  late final GeneratedColumn<String> cashierId = GeneratedColumn<String>(
      'cashier_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _cashierNameMeta =
      const VerificationMeta('cashierName');
  @override
  late final GeneratedColumn<String> cashierName = GeneratedColumn<String>(
      'cashier_name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _supervisorIdMeta =
      const VerificationMeta('supervisorId');
  @override
  late final GeneratedColumn<String> supervisorId = GeneratedColumn<String>(
      'supervisor_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _supervisorNameMeta =
      const VerificationMeta('supervisorName');
  @override
  late final GeneratedColumn<String> supervisorName = GeneratedColumn<String>(
      'supervisor_name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _supervisorRoleMeta =
      const VerificationMeta('supervisorRole');
  @override
  late final GeneratedColumn<String> supervisorRole = GeneratedColumn<String>(
      'supervisor_role', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _actionMeta = const VerificationMeta('action');
  @override
  late final GeneratedColumn<String> action = GeneratedColumn<String>(
      'action', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _orderUuidMeta =
      const VerificationMeta('orderUuid');
  @override
  late final GeneratedColumn<String> orderUuid = GeneratedColumn<String>(
      'order_uuid', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _orderItemUuidMeta =
      const VerificationMeta('orderItemUuid');
  @override
  late final GeneratedColumn<String> orderItemUuid = GeneratedColumn<String>(
      'order_item_uuid', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _detailMeta = const VerificationMeta('detail');
  @override
  late final GeneratedColumn<String> detail = GeneratedColumn<String>(
      'detail', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _shiftSessionUuidMeta =
      const VerificationMeta('shiftSessionUuid');
  @override
  late final GeneratedColumn<String> shiftSessionUuid = GeneratedColumn<String>(
      'shift_session_uuid', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _stationIdMeta =
      const VerificationMeta('stationId');
  @override
  late final GeneratedColumn<String> stationId = GeneratedColumn<String>(
      'station_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isSyncedMeta =
      const VerificationMeta('isSynced');
  @override
  late final GeneratedColumn<bool> isSynced = GeneratedColumn<bool>(
      'is_synced', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_synced" IN (0, 1))'),
      defaultValue: const Constant(false));
  @override
  List<GeneratedColumn> get $columns => [
        id,
        timestamp,
        cashierId,
        cashierName,
        supervisorId,
        supervisorName,
        supervisorRole,
        action,
        orderUuid,
        orderItemUuid,
        detail,
        shiftSessionUuid,
        stationId,
        isSynced
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'audit_logs';
  @override
  VerificationContext validateIntegrity(Insertable<AuditLogTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('timestamp')) {
      context.handle(_timestampMeta,
          timestamp.isAcceptableOrUnknown(data['timestamp']!, _timestampMeta));
    } else if (isInserting) {
      context.missing(_timestampMeta);
    }
    if (data.containsKey('cashier_id')) {
      context.handle(_cashierIdMeta,
          cashierId.isAcceptableOrUnknown(data['cashier_id']!, _cashierIdMeta));
    } else if (isInserting) {
      context.missing(_cashierIdMeta);
    }
    if (data.containsKey('cashier_name')) {
      context.handle(
          _cashierNameMeta,
          cashierName.isAcceptableOrUnknown(
              data['cashier_name']!, _cashierNameMeta));
    } else if (isInserting) {
      context.missing(_cashierNameMeta);
    }
    if (data.containsKey('supervisor_id')) {
      context.handle(
          _supervisorIdMeta,
          supervisorId.isAcceptableOrUnknown(
              data['supervisor_id']!, _supervisorIdMeta));
    } else if (isInserting) {
      context.missing(_supervisorIdMeta);
    }
    if (data.containsKey('supervisor_name')) {
      context.handle(
          _supervisorNameMeta,
          supervisorName.isAcceptableOrUnknown(
              data['supervisor_name']!, _supervisorNameMeta));
    } else if (isInserting) {
      context.missing(_supervisorNameMeta);
    }
    if (data.containsKey('supervisor_role')) {
      context.handle(
          _supervisorRoleMeta,
          supervisorRole.isAcceptableOrUnknown(
              data['supervisor_role']!, _supervisorRoleMeta));
    } else if (isInserting) {
      context.missing(_supervisorRoleMeta);
    }
    if (data.containsKey('action')) {
      context.handle(_actionMeta,
          action.isAcceptableOrUnknown(data['action']!, _actionMeta));
    } else if (isInserting) {
      context.missing(_actionMeta);
    }
    if (data.containsKey('order_uuid')) {
      context.handle(_orderUuidMeta,
          orderUuid.isAcceptableOrUnknown(data['order_uuid']!, _orderUuidMeta));
    }
    if (data.containsKey('order_item_uuid')) {
      context.handle(
          _orderItemUuidMeta,
          orderItemUuid.isAcceptableOrUnknown(
              data['order_item_uuid']!, _orderItemUuidMeta));
    }
    if (data.containsKey('detail')) {
      context.handle(_detailMeta,
          detail.isAcceptableOrUnknown(data['detail']!, _detailMeta));
    } else if (isInserting) {
      context.missing(_detailMeta);
    }
    if (data.containsKey('shift_session_uuid')) {
      context.handle(
          _shiftSessionUuidMeta,
          shiftSessionUuid.isAcceptableOrUnknown(
              data['shift_session_uuid']!, _shiftSessionUuidMeta));
    }
    if (data.containsKey('station_id')) {
      context.handle(_stationIdMeta,
          stationId.isAcceptableOrUnknown(data['station_id']!, _stationIdMeta));
    }
    if (data.containsKey('is_synced')) {
      context.handle(_isSyncedMeta,
          isSynced.isAcceptableOrUnknown(data['is_synced']!, _isSyncedMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  AuditLogTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return AuditLogTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      timestamp: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}timestamp'])!,
      cashierId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}cashier_id'])!,
      cashierName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}cashier_name'])!,
      supervisorId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}supervisor_id'])!,
      supervisorName: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}supervisor_name'])!,
      supervisorRole: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}supervisor_role'])!,
      action: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}action'])!,
      orderUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}order_uuid']),
      orderItemUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}order_item_uuid']),
      detail: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}detail'])!,
      shiftSessionUuid: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}shift_session_uuid']),
      stationId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}station_id']),
      isSynced: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_synced'])!,
    );
  }

  @override
  $AuditLogTableTable createAlias(String alias) {
    return $AuditLogTableTable(attachedDatabase, alias);
  }
}

class AuditLogTableData extends DataClass
    implements Insertable<AuditLogTableData> {
  final int id;
  final DateTime timestamp;
  final String cashierId;
  final String cashierName;
  final String supervisorId;
  final String supervisorName;
  final String supervisorRole;
  final String action;
  final String? orderUuid;
  final String? orderItemUuid;
  final String detail;
  final String? shiftSessionUuid;
  final String? stationId;
  final bool isSynced;
  const AuditLogTableData(
      {required this.id,
      required this.timestamp,
      required this.cashierId,
      required this.cashierName,
      required this.supervisorId,
      required this.supervisorName,
      required this.supervisorRole,
      required this.action,
      this.orderUuid,
      this.orderItemUuid,
      required this.detail,
      this.shiftSessionUuid,
      this.stationId,
      required this.isSynced});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['timestamp'] = Variable<DateTime>(timestamp);
    map['cashier_id'] = Variable<String>(cashierId);
    map['cashier_name'] = Variable<String>(cashierName);
    map['supervisor_id'] = Variable<String>(supervisorId);
    map['supervisor_name'] = Variable<String>(supervisorName);
    map['supervisor_role'] = Variable<String>(supervisorRole);
    map['action'] = Variable<String>(action);
    if (!nullToAbsent || orderUuid != null) {
      map['order_uuid'] = Variable<String>(orderUuid);
    }
    if (!nullToAbsent || orderItemUuid != null) {
      map['order_item_uuid'] = Variable<String>(orderItemUuid);
    }
    map['detail'] = Variable<String>(detail);
    if (!nullToAbsent || shiftSessionUuid != null) {
      map['shift_session_uuid'] = Variable<String>(shiftSessionUuid);
    }
    if (!nullToAbsent || stationId != null) {
      map['station_id'] = Variable<String>(stationId);
    }
    map['is_synced'] = Variable<bool>(isSynced);
    return map;
  }

  AuditLogTableCompanion toCompanion(bool nullToAbsent) {
    return AuditLogTableCompanion(
      id: Value(id),
      timestamp: Value(timestamp),
      cashierId: Value(cashierId),
      cashierName: Value(cashierName),
      supervisorId: Value(supervisorId),
      supervisorName: Value(supervisorName),
      supervisorRole: Value(supervisorRole),
      action: Value(action),
      orderUuid: orderUuid == null && nullToAbsent
          ? const Value.absent()
          : Value(orderUuid),
      orderItemUuid: orderItemUuid == null && nullToAbsent
          ? const Value.absent()
          : Value(orderItemUuid),
      detail: Value(detail),
      shiftSessionUuid: shiftSessionUuid == null && nullToAbsent
          ? const Value.absent()
          : Value(shiftSessionUuid),
      stationId: stationId == null && nullToAbsent
          ? const Value.absent()
          : Value(stationId),
      isSynced: Value(isSynced),
    );
  }

  factory AuditLogTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AuditLogTableData(
      id: serializer.fromJson<int>(json['id']),
      timestamp: serializer.fromJson<DateTime>(json['timestamp']),
      cashierId: serializer.fromJson<String>(json['cashierId']),
      cashierName: serializer.fromJson<String>(json['cashierName']),
      supervisorId: serializer.fromJson<String>(json['supervisorId']),
      supervisorName: serializer.fromJson<String>(json['supervisorName']),
      supervisorRole: serializer.fromJson<String>(json['supervisorRole']),
      action: serializer.fromJson<String>(json['action']),
      orderUuid: serializer.fromJson<String?>(json['orderUuid']),
      orderItemUuid: serializer.fromJson<String?>(json['orderItemUuid']),
      detail: serializer.fromJson<String>(json['detail']),
      shiftSessionUuid: serializer.fromJson<String?>(json['shiftSessionUuid']),
      stationId: serializer.fromJson<String?>(json['stationId']),
      isSynced: serializer.fromJson<bool>(json['isSynced']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'timestamp': serializer.toJson<DateTime>(timestamp),
      'cashierId': serializer.toJson<String>(cashierId),
      'cashierName': serializer.toJson<String>(cashierName),
      'supervisorId': serializer.toJson<String>(supervisorId),
      'supervisorName': serializer.toJson<String>(supervisorName),
      'supervisorRole': serializer.toJson<String>(supervisorRole),
      'action': serializer.toJson<String>(action),
      'orderUuid': serializer.toJson<String?>(orderUuid),
      'orderItemUuid': serializer.toJson<String?>(orderItemUuid),
      'detail': serializer.toJson<String>(detail),
      'shiftSessionUuid': serializer.toJson<String?>(shiftSessionUuid),
      'stationId': serializer.toJson<String?>(stationId),
      'isSynced': serializer.toJson<bool>(isSynced),
    };
  }

  AuditLogTableData copyWith(
          {int? id,
          DateTime? timestamp,
          String? cashierId,
          String? cashierName,
          String? supervisorId,
          String? supervisorName,
          String? supervisorRole,
          String? action,
          Value<String?> orderUuid = const Value.absent(),
          Value<String?> orderItemUuid = const Value.absent(),
          String? detail,
          Value<String?> shiftSessionUuid = const Value.absent(),
          Value<String?> stationId = const Value.absent(),
          bool? isSynced}) =>
      AuditLogTableData(
        id: id ?? this.id,
        timestamp: timestamp ?? this.timestamp,
        cashierId: cashierId ?? this.cashierId,
        cashierName: cashierName ?? this.cashierName,
        supervisorId: supervisorId ?? this.supervisorId,
        supervisorName: supervisorName ?? this.supervisorName,
        supervisorRole: supervisorRole ?? this.supervisorRole,
        action: action ?? this.action,
        orderUuid: orderUuid.present ? orderUuid.value : this.orderUuid,
        orderItemUuid:
            orderItemUuid.present ? orderItemUuid.value : this.orderItemUuid,
        detail: detail ?? this.detail,
        shiftSessionUuid: shiftSessionUuid.present
            ? shiftSessionUuid.value
            : this.shiftSessionUuid,
        stationId: stationId.present ? stationId.value : this.stationId,
        isSynced: isSynced ?? this.isSynced,
      );
  AuditLogTableData copyWithCompanion(AuditLogTableCompanion data) {
    return AuditLogTableData(
      id: data.id.present ? data.id.value : this.id,
      timestamp: data.timestamp.present ? data.timestamp.value : this.timestamp,
      cashierId: data.cashierId.present ? data.cashierId.value : this.cashierId,
      cashierName:
          data.cashierName.present ? data.cashierName.value : this.cashierName,
      supervisorId: data.supervisorId.present
          ? data.supervisorId.value
          : this.supervisorId,
      supervisorName: data.supervisorName.present
          ? data.supervisorName.value
          : this.supervisorName,
      supervisorRole: data.supervisorRole.present
          ? data.supervisorRole.value
          : this.supervisorRole,
      action: data.action.present ? data.action.value : this.action,
      orderUuid: data.orderUuid.present ? data.orderUuid.value : this.orderUuid,
      orderItemUuid: data.orderItemUuid.present
          ? data.orderItemUuid.value
          : this.orderItemUuid,
      detail: data.detail.present ? data.detail.value : this.detail,
      shiftSessionUuid: data.shiftSessionUuid.present
          ? data.shiftSessionUuid.value
          : this.shiftSessionUuid,
      stationId: data.stationId.present ? data.stationId.value : this.stationId,
      isSynced: data.isSynced.present ? data.isSynced.value : this.isSynced,
    );
  }

  @override
  String toString() {
    return (StringBuffer('AuditLogTableData(')
          ..write('id: $id, ')
          ..write('timestamp: $timestamp, ')
          ..write('cashierId: $cashierId, ')
          ..write('cashierName: $cashierName, ')
          ..write('supervisorId: $supervisorId, ')
          ..write('supervisorName: $supervisorName, ')
          ..write('supervisorRole: $supervisorRole, ')
          ..write('action: $action, ')
          ..write('orderUuid: $orderUuid, ')
          ..write('orderItemUuid: $orderItemUuid, ')
          ..write('detail: $detail, ')
          ..write('shiftSessionUuid: $shiftSessionUuid, ')
          ..write('stationId: $stationId, ')
          ..write('isSynced: $isSynced')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      timestamp,
      cashierId,
      cashierName,
      supervisorId,
      supervisorName,
      supervisorRole,
      action,
      orderUuid,
      orderItemUuid,
      detail,
      shiftSessionUuid,
      stationId,
      isSynced);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AuditLogTableData &&
          other.id == this.id &&
          other.timestamp == this.timestamp &&
          other.cashierId == this.cashierId &&
          other.cashierName == this.cashierName &&
          other.supervisorId == this.supervisorId &&
          other.supervisorName == this.supervisorName &&
          other.supervisorRole == this.supervisorRole &&
          other.action == this.action &&
          other.orderUuid == this.orderUuid &&
          other.orderItemUuid == this.orderItemUuid &&
          other.detail == this.detail &&
          other.shiftSessionUuid == this.shiftSessionUuid &&
          other.stationId == this.stationId &&
          other.isSynced == this.isSynced);
}

class AuditLogTableCompanion extends UpdateCompanion<AuditLogTableData> {
  final Value<int> id;
  final Value<DateTime> timestamp;
  final Value<String> cashierId;
  final Value<String> cashierName;
  final Value<String> supervisorId;
  final Value<String> supervisorName;
  final Value<String> supervisorRole;
  final Value<String> action;
  final Value<String?> orderUuid;
  final Value<String?> orderItemUuid;
  final Value<String> detail;
  final Value<String?> shiftSessionUuid;
  final Value<String?> stationId;
  final Value<bool> isSynced;
  const AuditLogTableCompanion({
    this.id = const Value.absent(),
    this.timestamp = const Value.absent(),
    this.cashierId = const Value.absent(),
    this.cashierName = const Value.absent(),
    this.supervisorId = const Value.absent(),
    this.supervisorName = const Value.absent(),
    this.supervisorRole = const Value.absent(),
    this.action = const Value.absent(),
    this.orderUuid = const Value.absent(),
    this.orderItemUuid = const Value.absent(),
    this.detail = const Value.absent(),
    this.shiftSessionUuid = const Value.absent(),
    this.stationId = const Value.absent(),
    this.isSynced = const Value.absent(),
  });
  AuditLogTableCompanion.insert({
    this.id = const Value.absent(),
    required DateTime timestamp,
    required String cashierId,
    required String cashierName,
    required String supervisorId,
    required String supervisorName,
    required String supervisorRole,
    required String action,
    this.orderUuid = const Value.absent(),
    this.orderItemUuid = const Value.absent(),
    required String detail,
    this.shiftSessionUuid = const Value.absent(),
    this.stationId = const Value.absent(),
    this.isSynced = const Value.absent(),
  })  : timestamp = Value(timestamp),
        cashierId = Value(cashierId),
        cashierName = Value(cashierName),
        supervisorId = Value(supervisorId),
        supervisorName = Value(supervisorName),
        supervisorRole = Value(supervisorRole),
        action = Value(action),
        detail = Value(detail);
  static Insertable<AuditLogTableData> custom({
    Expression<int>? id,
    Expression<DateTime>? timestamp,
    Expression<String>? cashierId,
    Expression<String>? cashierName,
    Expression<String>? supervisorId,
    Expression<String>? supervisorName,
    Expression<String>? supervisorRole,
    Expression<String>? action,
    Expression<String>? orderUuid,
    Expression<String>? orderItemUuid,
    Expression<String>? detail,
    Expression<String>? shiftSessionUuid,
    Expression<String>? stationId,
    Expression<bool>? isSynced,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (timestamp != null) 'timestamp': timestamp,
      if (cashierId != null) 'cashier_id': cashierId,
      if (cashierName != null) 'cashier_name': cashierName,
      if (supervisorId != null) 'supervisor_id': supervisorId,
      if (supervisorName != null) 'supervisor_name': supervisorName,
      if (supervisorRole != null) 'supervisor_role': supervisorRole,
      if (action != null) 'action': action,
      if (orderUuid != null) 'order_uuid': orderUuid,
      if (orderItemUuid != null) 'order_item_uuid': orderItemUuid,
      if (detail != null) 'detail': detail,
      if (shiftSessionUuid != null) 'shift_session_uuid': shiftSessionUuid,
      if (stationId != null) 'station_id': stationId,
      if (isSynced != null) 'is_synced': isSynced,
    });
  }

  AuditLogTableCompanion copyWith(
      {Value<int>? id,
      Value<DateTime>? timestamp,
      Value<String>? cashierId,
      Value<String>? cashierName,
      Value<String>? supervisorId,
      Value<String>? supervisorName,
      Value<String>? supervisorRole,
      Value<String>? action,
      Value<String?>? orderUuid,
      Value<String?>? orderItemUuid,
      Value<String>? detail,
      Value<String?>? shiftSessionUuid,
      Value<String?>? stationId,
      Value<bool>? isSynced}) {
    return AuditLogTableCompanion(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
      cashierId: cashierId ?? this.cashierId,
      cashierName: cashierName ?? this.cashierName,
      supervisorId: supervisorId ?? this.supervisorId,
      supervisorName: supervisorName ?? this.supervisorName,
      supervisorRole: supervisorRole ?? this.supervisorRole,
      action: action ?? this.action,
      orderUuid: orderUuid ?? this.orderUuid,
      orderItemUuid: orderItemUuid ?? this.orderItemUuid,
      detail: detail ?? this.detail,
      shiftSessionUuid: shiftSessionUuid ?? this.shiftSessionUuid,
      stationId: stationId ?? this.stationId,
      isSynced: isSynced ?? this.isSynced,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (timestamp.present) {
      map['timestamp'] = Variable<DateTime>(timestamp.value);
    }
    if (cashierId.present) {
      map['cashier_id'] = Variable<String>(cashierId.value);
    }
    if (cashierName.present) {
      map['cashier_name'] = Variable<String>(cashierName.value);
    }
    if (supervisorId.present) {
      map['supervisor_id'] = Variable<String>(supervisorId.value);
    }
    if (supervisorName.present) {
      map['supervisor_name'] = Variable<String>(supervisorName.value);
    }
    if (supervisorRole.present) {
      map['supervisor_role'] = Variable<String>(supervisorRole.value);
    }
    if (action.present) {
      map['action'] = Variable<String>(action.value);
    }
    if (orderUuid.present) {
      map['order_uuid'] = Variable<String>(orderUuid.value);
    }
    if (orderItemUuid.present) {
      map['order_item_uuid'] = Variable<String>(orderItemUuid.value);
    }
    if (detail.present) {
      map['detail'] = Variable<String>(detail.value);
    }
    if (shiftSessionUuid.present) {
      map['shift_session_uuid'] = Variable<String>(shiftSessionUuid.value);
    }
    if (stationId.present) {
      map['station_id'] = Variable<String>(stationId.value);
    }
    if (isSynced.present) {
      map['is_synced'] = Variable<bool>(isSynced.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AuditLogTableCompanion(')
          ..write('id: $id, ')
          ..write('timestamp: $timestamp, ')
          ..write('cashierId: $cashierId, ')
          ..write('cashierName: $cashierName, ')
          ..write('supervisorId: $supervisorId, ')
          ..write('supervisorName: $supervisorName, ')
          ..write('supervisorRole: $supervisorRole, ')
          ..write('action: $action, ')
          ..write('orderUuid: $orderUuid, ')
          ..write('orderItemUuid: $orderItemUuid, ')
          ..write('detail: $detail, ')
          ..write('shiftSessionUuid: $shiftSessionUuid, ')
          ..write('stationId: $stationId, ')
          ..write('isSynced: $isSynced')
          ..write(')'))
        .toString();
  }
}

class $PrintJobTableTable extends PrintJobTable
    with TableInfo<$PrintJobTableTable, PrintJobTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $PrintJobTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _targetPrinterAddressMeta =
      const VerificationMeta('targetPrinterAddress');
  @override
  late final GeneratedColumn<String> targetPrinterAddress =
      GeneratedColumn<String>('target_printer_address', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _targetPrinterTypeMeta =
      const VerificationMeta('targetPrinterType');
  @override
  late final GeneratedColumn<String> targetPrinterType =
      GeneratedColumn<String>('target_printer_type', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _bytesMeta = const VerificationMeta('bytes');
  @override
  late final GeneratedColumn<Uint8List> bytes = GeneratedColumn<Uint8List>(
      'bytes', aliasedName, false,
      type: DriftSqlType.blob, requiredDuringInsert: true);
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
      'status', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultValue: const Constant('PENDING'));
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _retryCountMeta =
      const VerificationMeta('retryCount');
  @override
  late final GeneratedColumn<int> retryCount = GeneratedColumn<int>(
      'retry_count', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultValue: const Constant(0));
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        targetPrinterAddress,
        targetPrinterType,
        bytes,
        status,
        createdAt,
        retryCount
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'print_job_table';
  @override
  VerificationContext validateIntegrity(Insertable<PrintJobTableData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('target_printer_address')) {
      context.handle(
          _targetPrinterAddressMeta,
          targetPrinterAddress.isAcceptableOrUnknown(
              data['target_printer_address']!, _targetPrinterAddressMeta));
    } else if (isInserting) {
      context.missing(_targetPrinterAddressMeta);
    }
    if (data.containsKey('target_printer_type')) {
      context.handle(
          _targetPrinterTypeMeta,
          targetPrinterType.isAcceptableOrUnknown(
              data['target_printer_type']!, _targetPrinterTypeMeta));
    } else if (isInserting) {
      context.missing(_targetPrinterTypeMeta);
    }
    if (data.containsKey('bytes')) {
      context.handle(
          _bytesMeta, bytes.isAcceptableOrUnknown(data['bytes']!, _bytesMeta));
    } else if (isInserting) {
      context.missing(_bytesMeta);
    }
    if (data.containsKey('status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['status']!, _statusMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('retry_count')) {
      context.handle(
          _retryCountMeta,
          retryCount.isAcceptableOrUnknown(
              data['retry_count']!, _retryCountMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  PrintJobTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return PrintJobTableData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      targetPrinterAddress: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}target_printer_address'])!,
      targetPrinterType: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}target_printer_type'])!,
      bytes: attachedDatabase.typeMapping
          .read(DriftSqlType.blob, data['${effectivePrefix}bytes'])!,
      status: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}status'])!,
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      retryCount: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}retry_count'])!,
    );
  }

  @override
  $PrintJobTableTable createAlias(String alias) {
    return $PrintJobTableTable(attachedDatabase, alias);
  }
}

class PrintJobTableData extends DataClass
    implements Insertable<PrintJobTableData> {
  final int id;
  final String uuid;
  final String targetPrinterAddress;
  final String targetPrinterType;
  final Uint8List bytes;
  final String status;
  final DateTime createdAt;
  final int retryCount;
  const PrintJobTableData(
      {required this.id,
      required this.uuid,
      required this.targetPrinterAddress,
      required this.targetPrinterType,
      required this.bytes,
      required this.status,
      required this.createdAt,
      required this.retryCount});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    map['target_printer_address'] = Variable<String>(targetPrinterAddress);
    map['target_printer_type'] = Variable<String>(targetPrinterType);
    map['bytes'] = Variable<Uint8List>(bytes);
    map['status'] = Variable<String>(status);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['retry_count'] = Variable<int>(retryCount);
    return map;
  }

  PrintJobTableCompanion toCompanion(bool nullToAbsent) {
    return PrintJobTableCompanion(
      id: Value(id),
      uuid: Value(uuid),
      targetPrinterAddress: Value(targetPrinterAddress),
      targetPrinterType: Value(targetPrinterType),
      bytes: Value(bytes),
      status: Value(status),
      createdAt: Value(createdAt),
      retryCount: Value(retryCount),
    );
  }

  factory PrintJobTableData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return PrintJobTableData(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      targetPrinterAddress:
          serializer.fromJson<String>(json['targetPrinterAddress']),
      targetPrinterType: serializer.fromJson<String>(json['targetPrinterType']),
      bytes: serializer.fromJson<Uint8List>(json['bytes']),
      status: serializer.fromJson<String>(json['status']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      retryCount: serializer.fromJson<int>(json['retryCount']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'targetPrinterAddress': serializer.toJson<String>(targetPrinterAddress),
      'targetPrinterType': serializer.toJson<String>(targetPrinterType),
      'bytes': serializer.toJson<Uint8List>(bytes),
      'status': serializer.toJson<String>(status),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'retryCount': serializer.toJson<int>(retryCount),
    };
  }

  PrintJobTableData copyWith(
          {int? id,
          String? uuid,
          String? targetPrinterAddress,
          String? targetPrinterType,
          Uint8List? bytes,
          String? status,
          DateTime? createdAt,
          int? retryCount}) =>
      PrintJobTableData(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        targetPrinterAddress: targetPrinterAddress ?? this.targetPrinterAddress,
        targetPrinterType: targetPrinterType ?? this.targetPrinterType,
        bytes: bytes ?? this.bytes,
        status: status ?? this.status,
        createdAt: createdAt ?? this.createdAt,
        retryCount: retryCount ?? this.retryCount,
      );
  PrintJobTableData copyWithCompanion(PrintJobTableCompanion data) {
    return PrintJobTableData(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      targetPrinterAddress: data.targetPrinterAddress.present
          ? data.targetPrinterAddress.value
          : this.targetPrinterAddress,
      targetPrinterType: data.targetPrinterType.present
          ? data.targetPrinterType.value
          : this.targetPrinterType,
      bytes: data.bytes.present ? data.bytes.value : this.bytes,
      status: data.status.present ? data.status.value : this.status,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      retryCount:
          data.retryCount.present ? data.retryCount.value : this.retryCount,
    );
  }

  @override
  String toString() {
    return (StringBuffer('PrintJobTableData(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('targetPrinterAddress: $targetPrinterAddress, ')
          ..write('targetPrinterType: $targetPrinterType, ')
          ..write('bytes: $bytes, ')
          ..write('status: $status, ')
          ..write('createdAt: $createdAt, ')
          ..write('retryCount: $retryCount')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      uuid,
      targetPrinterAddress,
      targetPrinterType,
      $driftBlobEquality.hash(bytes),
      status,
      createdAt,
      retryCount);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is PrintJobTableData &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.targetPrinterAddress == this.targetPrinterAddress &&
          other.targetPrinterType == this.targetPrinterType &&
          $driftBlobEquality.equals(other.bytes, this.bytes) &&
          other.status == this.status &&
          other.createdAt == this.createdAt &&
          other.retryCount == this.retryCount);
}

class PrintJobTableCompanion extends UpdateCompanion<PrintJobTableData> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String> targetPrinterAddress;
  final Value<String> targetPrinterType;
  final Value<Uint8List> bytes;
  final Value<String> status;
  final Value<DateTime> createdAt;
  final Value<int> retryCount;
  const PrintJobTableCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.targetPrinterAddress = const Value.absent(),
    this.targetPrinterType = const Value.absent(),
    this.bytes = const Value.absent(),
    this.status = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.retryCount = const Value.absent(),
  });
  PrintJobTableCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    required String targetPrinterAddress,
    required String targetPrinterType,
    required Uint8List bytes,
    this.status = const Value.absent(),
    required DateTime createdAt,
    this.retryCount = const Value.absent(),
  })  : uuid = Value(uuid),
        targetPrinterAddress = Value(targetPrinterAddress),
        targetPrinterType = Value(targetPrinterType),
        bytes = Value(bytes),
        createdAt = Value(createdAt);
  static Insertable<PrintJobTableData> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? targetPrinterAddress,
    Expression<String>? targetPrinterType,
    Expression<Uint8List>? bytes,
    Expression<String>? status,
    Expression<DateTime>? createdAt,
    Expression<int>? retryCount,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (targetPrinterAddress != null)
        'target_printer_address': targetPrinterAddress,
      if (targetPrinterType != null) 'target_printer_type': targetPrinterType,
      if (bytes != null) 'bytes': bytes,
      if (status != null) 'status': status,
      if (createdAt != null) 'created_at': createdAt,
      if (retryCount != null) 'retry_count': retryCount,
    });
  }

  PrintJobTableCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String>? targetPrinterAddress,
      Value<String>? targetPrinterType,
      Value<Uint8List>? bytes,
      Value<String>? status,
      Value<DateTime>? createdAt,
      Value<int>? retryCount}) {
    return PrintJobTableCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      targetPrinterAddress: targetPrinterAddress ?? this.targetPrinterAddress,
      targetPrinterType: targetPrinterType ?? this.targetPrinterType,
      bytes: bytes ?? this.bytes,
      status: status ?? this.status,
      createdAt: createdAt ?? this.createdAt,
      retryCount: retryCount ?? this.retryCount,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (targetPrinterAddress.present) {
      map['target_printer_address'] =
          Variable<String>(targetPrinterAddress.value);
    }
    if (targetPrinterType.present) {
      map['target_printer_type'] = Variable<String>(targetPrinterType.value);
    }
    if (bytes.present) {
      map['bytes'] = Variable<Uint8List>(bytes.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (retryCount.present) {
      map['retry_count'] = Variable<int>(retryCount.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('PrintJobTableCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('targetPrinterAddress: $targetPrinterAddress, ')
          ..write('targetPrinterType: $targetPrinterType, ')
          ..write('bytes: $bytes, ')
          ..write('status: $status, ')
          ..write('createdAt: $createdAt, ')
          ..write('retryCount: $retryCount')
          ..write(')'))
        .toString();
  }
}

abstract class _$AppDatabase extends GeneratedDatabase {
  _$AppDatabase(QueryExecutor e) : super(e);
  $AppDatabaseManager get managers => $AppDatabaseManager(this);
  late final $ZoneTableTable zoneTable = $ZoneTableTable(this);
  late final $TenantConfigTableTable tenantConfigTable =
      $TenantConfigTableTable(this);
  late final $RestaurantTableTable restaurantTable =
      $RestaurantTableTable(this);
  late final $ReservationTableTable reservationTable =
      $ReservationTableTable(this);
  late final $EmployeeTableTable employeeTable = $EmployeeTableTable(this);
  late final $CategoryTableTable categoryTable = $CategoryTableTable(this);
  late final $ProductTableTable productTable = $ProductTableTable(this);
  late final $ModifierGroupTableTable modifierGroupTable =
      $ModifierGroupTableTable(this);
  late final $ModifierItemTableTable modifierItemTable =
      $ModifierItemTableTable(this);
  late final $ProductModifierLinkTableTable productModifierLinkTable =
      $ProductModifierLinkTableTable(this);
  late final $IngredientTableTable ingredientTable =
      $IngredientTableTable(this);
  late final $RecipeTableTable recipeTable = $RecipeTableTable(this);
  late final $CustomerTableTable customerTable = $CustomerTableTable(this);
  late final $OrderTableTable orderTable = $OrderTableTable(this);
  late final $OrderItemTableTable orderItemTable = $OrderItemTableTable(this);
  late final $InventoryLedgerTableTable inventoryLedgerTable =
      $InventoryLedgerTableTable(this);
  late final $InventoryCacheTableTable inventoryCacheTable =
      $InventoryCacheTableTable(this);
  late final $LocalStocksTableTable localStocksTable =
      $LocalStocksTableTable(this);
  late final $SupplierTableTable supplierTable = $SupplierTableTable(this);
  late final $ProductSupplierTableTable productSupplierTable =
      $ProductSupplierTableTable(this);
  late final $PurchaseOrderTableTable purchaseOrderTable =
      $PurchaseOrderTableTable(this);
  late final $PurchaseOrderItemTableTable purchaseOrderItemTable =
      $PurchaseOrderItemTableTable(this);
  late final $ShiftSessionTableTable shiftSessionTable =
      $ShiftSessionTableTable(this);
  late final $SyncQueueTable syncQueue = $SyncQueueTable(this);
  late final $CashTransactionTableTable cashTransactionTable =
      $CashTransactionTableTable(this);
  late final $WasteTableTable wasteTable = $WasteTableTable(this);
  late final $MarketingCampaignTableTable marketingCampaignTable =
      $MarketingCampaignTableTable(this);
  late final $CampaignRunHistoryTableTable campaignRunHistoryTable =
      $CampaignRunHistoryTableTable(this);
  late final $DeliveryChannelTableTable deliveryChannelTable =
      $DeliveryChannelTableTable(this);
  late final $DeliveryOrderMetadataTableTable deliveryOrderMetadataTable =
      $DeliveryOrderMetadataTableTable(this);
  late final $CashDrawerTableTable cashDrawerTable =
      $CashDrawerTableTable(this);
  late final $CashEventTableTable cashEventTable = $CashEventTableTable(this);
  late final $CustomerNoteTableTable customerNoteTable =
      $CustomerNoteTableTable(this);
  late final $CustomerTagTableTable customerTagTable =
      $CustomerTagTableTable(this);
  late final $PaymentTransactionTableTable paymentTransactionTable =
      $PaymentTransactionTableTable(this);
  late final $StockCountTableTable stockCountTable =
      $StockCountTableTable(this);
  late final $StockCountItemTableTable stockCountItemTable =
      $StockCountItemTableTable(this);
  late final $WarehouseTableTable warehouseTable = $WarehouseTableTable(this);
  late final $StockLevelTableTable stockLevelTable =
      $StockLevelTableTable(this);
  late final $BatchTableTable batchTable = $BatchTableTable(this);
  late final $StockAlertTableTable stockAlertTable =
      $StockAlertTableTable(this);
  late final $StockTransferTableTable stockTransferTable =
      $StockTransferTableTable(this);
  late final $StockTransferItemTableTable stockTransferItemTable =
      $StockTransferItemTableTable(this);
  late final $StockAlertConfigTableTable stockAlertConfigTable =
      $StockAlertConfigTableTable(this);
  late final $StockMovementTableTable stockMovementTable =
      $StockMovementTableTable(this);
  late final $TimeEntryTableTable timeEntryTable = $TimeEntryTableTable(this);
  late final $ScheduledShiftTableTable scheduledShiftTable =
      $ScheduledShiftTableTable(this);
  late final $EmployeeExtendedTableTable employeeExtendedTable =
      $EmployeeExtendedTableTable(this);
  late final $GiftCardTableTable giftCardTable = $GiftCardTableTable(this);
  late final $GiftCardTransactionTableTable giftCardTransactionTable =
      $GiftCardTransactionTableTable(this);
  late final $LoyaltyProgramTableTable loyaltyProgramTable =
      $LoyaltyProgramTableTable(this);
  late final $LoyaltyMemberTableTable loyaltyMemberTable =
      $LoyaltyMemberTableTable(this);
  late final $LoyaltyTransactionTableTable loyaltyTransactionTable =
      $LoyaltyTransactionTableTable(this);
  late final $LoyaltyRewardTableTable loyaltyRewardTable =
      $LoyaltyRewardTableTable(this);
  late final $TipTableTable tipTable = $TipTableTable(this);
  late final $TipPoolConfigTableTable tipPoolConfigTable =
      $TipPoolConfigTableTable(this);
  late final $TipDistributionTableTable tipDistributionTable =
      $TipDistributionTableTable(this);
  late final $SplitBillTableTable splitBillTable = $SplitBillTableTable(this);
  late final $GuestBillTableTable guestBillTable = $GuestBillTableTable(this);
  late final $SplitBillItemTableTable splitBillItemTable =
      $SplitBillItemTableTable(this);
  late final $DiscountTableTable discountTable = $DiscountTableTable(this);
  late final $AppliedDiscountTableTable appliedDiscountTable =
      $AppliedDiscountTableTable(this);
  late final $WaitlistTableTable waitlistTable = $WaitlistTableTable(this);
  late final $StaffAlertTableTable staffAlertTable =
      $StaffAlertTableTable(this);
  late final $KitchenTicketTableTable kitchenTicketTable =
      $KitchenTicketTableTable(this);
  late final $KitchenItemTableTable kitchenItemTable =
      $KitchenItemTableTable(this);
  late final $CustomerFeedbackTableTable customerFeedbackTable =
      $CustomerFeedbackTableTable(this);
  late final $AuditLogTableTable auditLogTable = $AuditLogTableTable(this);
  late final $PrintJobTableTable printJobTable = $PrintJobTableTable(this);
  @override
  Iterable<TableInfo<Table, Object?>> get allTables =>
      allSchemaEntities.whereType<TableInfo<Table, Object?>>();
  @override
  List<DatabaseSchemaEntity> get allSchemaEntities => [
        zoneTable,
        tenantConfigTable,
        restaurantTable,
        reservationTable,
        employeeTable,
        categoryTable,
        productTable,
        modifierGroupTable,
        modifierItemTable,
        productModifierLinkTable,
        ingredientTable,
        recipeTable,
        customerTable,
        orderTable,
        orderItemTable,
        inventoryLedgerTable,
        inventoryCacheTable,
        localStocksTable,
        supplierTable,
        productSupplierTable,
        purchaseOrderTable,
        purchaseOrderItemTable,
        shiftSessionTable,
        syncQueue,
        cashTransactionTable,
        wasteTable,
        marketingCampaignTable,
        campaignRunHistoryTable,
        deliveryChannelTable,
        deliveryOrderMetadataTable,
        cashDrawerTable,
        cashEventTable,
        customerNoteTable,
        customerTagTable,
        paymentTransactionTable,
        stockCountTable,
        stockCountItemTable,
        warehouseTable,
        stockLevelTable,
        batchTable,
        stockAlertTable,
        stockTransferTable,
        stockTransferItemTable,
        stockAlertConfigTable,
        stockMovementTable,
        timeEntryTable,
        scheduledShiftTable,
        employeeExtendedTable,
        giftCardTable,
        giftCardTransactionTable,
        loyaltyProgramTable,
        loyaltyMemberTable,
        loyaltyTransactionTable,
        loyaltyRewardTable,
        tipTable,
        tipPoolConfigTable,
        tipDistributionTable,
        splitBillTable,
        guestBillTable,
        splitBillItemTable,
        discountTable,
        appliedDiscountTable,
        waitlistTable,
        staffAlertTable,
        kitchenTicketTable,
        kitchenItemTable,
        customerFeedbackTable,
        auditLogTable,
        printJobTable
      ];
  @override
  StreamQueryUpdateRules get streamUpdateRules => const StreamQueryUpdateRules(
        [
          WritePropagation(
            on: TableUpdateQuery.onTableName('modifier_group_table',
                limitUpdateKind: UpdateKind.delete),
            result: [
              TableUpdate('modifier_item_table', kind: UpdateKind.delete),
            ],
          ),
          WritePropagation(
            on: TableUpdateQuery.onTableName('product_table',
                limitUpdateKind: UpdateKind.delete),
            result: [
              TableUpdate('product_modifier_link_table',
                  kind: UpdateKind.delete),
            ],
          ),
          WritePropagation(
            on: TableUpdateQuery.onTableName('modifier_group_table',
                limitUpdateKind: UpdateKind.delete),
            result: [
              TableUpdate('product_modifier_link_table',
                  kind: UpdateKind.delete),
            ],
          ),
          WritePropagation(
            on: TableUpdateQuery.onTableName('product_table',
                limitUpdateKind: UpdateKind.delete),
            result: [
              TableUpdate('recipe_table', kind: UpdateKind.delete),
            ],
          ),
          WritePropagation(
            on: TableUpdateQuery.onTableName('ingredient_table',
                limitUpdateKind: UpdateKind.delete),
            result: [
              TableUpdate('recipe_table', kind: UpdateKind.delete),
            ],
          ),
          WritePropagation(
            on: TableUpdateQuery.onTableName('order_table',
                limitUpdateKind: UpdateKind.delete),
            result: [
              TableUpdate('order_item_table', kind: UpdateKind.delete),
            ],
          ),
          WritePropagation(
            on: TableUpdateQuery.onTableName('product_table',
                limitUpdateKind: UpdateKind.delete),
            result: [
              TableUpdate('local_stocks_table', kind: UpdateKind.delete),
            ],
          ),
          WritePropagation(
            on: TableUpdateQuery.onTableName('product_table',
                limitUpdateKind: UpdateKind.delete),
            result: [
              TableUpdate('product_supplier_table', kind: UpdateKind.delete),
            ],
          ),
          WritePropagation(
            on: TableUpdateQuery.onTableName('supplier_table',
                limitUpdateKind: UpdateKind.delete),
            result: [
              TableUpdate('product_supplier_table', kind: UpdateKind.delete),
            ],
          ),
          WritePropagation(
            on: TableUpdateQuery.onTableName('supplier_table',
                limitUpdateKind: UpdateKind.delete),
            result: [
              TableUpdate('purchase_order_table', kind: UpdateKind.delete),
            ],
          ),
          WritePropagation(
            on: TableUpdateQuery.onTableName('purchase_order_table',
                limitUpdateKind: UpdateKind.delete),
            result: [
              TableUpdate('purchase_order_item_table', kind: UpdateKind.delete),
            ],
          ),
          WritePropagation(
            on: TableUpdateQuery.onTableName('product_table',
                limitUpdateKind: UpdateKind.delete),
            result: [
              TableUpdate('purchase_order_item_table', kind: UpdateKind.delete),
            ],
          ),
          WritePropagation(
            on: TableUpdateQuery.onTableName('ingredient_table',
                limitUpdateKind: UpdateKind.delete),
            result: [
              TableUpdate('purchase_order_item_table', kind: UpdateKind.delete),
            ],
          ),
          WritePropagation(
            on: TableUpdateQuery.onTableName('order_table',
                limitUpdateKind: UpdateKind.delete),
            result: [
              TableUpdate('delivery_order_metadata_table',
                  kind: UpdateKind.delete),
            ],
          ),
          WritePropagation(
            on: TableUpdateQuery.onTableName('order_table',
                limitUpdateKind: UpdateKind.delete),
            result: [
              TableUpdate('payment_transaction_table', kind: UpdateKind.delete),
            ],
          ),
          WritePropagation(
            on: TableUpdateQuery.onTableName('stock_count_table',
                limitUpdateKind: UpdateKind.delete),
            result: [
              TableUpdate('stock_count_item_table', kind: UpdateKind.delete),
            ],
          ),
          WritePropagation(
            on: TableUpdateQuery.onTableName('kitchen_ticket_table',
                limitUpdateKind: UpdateKind.delete),
            result: [
              TableUpdate('kitchen_item_table', kind: UpdateKind.delete),
            ],
          ),
        ],
      );
}

typedef $$ZoneTableTableCreateCompanionBuilder = ZoneTableCompanion Function({
  Value<int> id,
  required String uuid,
  required String name,
  Value<double> width,
  Value<double> height,
  required DateTime updatedAt,
  Value<bool> isDeleted,
});
typedef $$ZoneTableTableUpdateCompanionBuilder = ZoneTableCompanion Function({
  Value<int> id,
  Value<String> uuid,
  Value<String> name,
  Value<double> width,
  Value<double> height,
  Value<DateTime> updatedAt,
  Value<bool> isDeleted,
});

final class $$ZoneTableTableReferences
    extends BaseReferences<_$AppDatabase, $ZoneTableTable, ZoneTableData> {
  $$ZoneTableTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$RestaurantTableTable, List<RestaurantTableData>>
      _restaurantTableRefsTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.restaurantTable,
              aliasName: $_aliasNameGenerator(
                  db.zoneTable.uuid, db.restaurantTable.zoneUuid));

  $$RestaurantTableTableProcessedTableManager get restaurantTableRefs {
    final manager =
        $$RestaurantTableTableTableManager($_db, $_db.restaurantTable).filter(
            (f) => f.zoneUuid.uuid.sqlEquals($_itemColumn<String>('uuid')!));

    final cache =
        $_typedResult.readTableOrNull(_restaurantTableRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $$ZoneTableTableFilterComposer
    extends Composer<_$AppDatabase, $ZoneTableTable> {
  $$ZoneTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get width => $composableBuilder(
      column: $table.width, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get height => $composableBuilder(
      column: $table.height, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnFilters(column));

  Expression<bool> restaurantTableRefs(
      Expression<bool> Function($$RestaurantTableTableFilterComposer f) f) {
    final $$RestaurantTableTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.uuid,
        referencedTable: $db.restaurantTable,
        getReferencedColumn: (t) => t.zoneUuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$RestaurantTableTableFilterComposer(
              $db: $db,
              $table: $db.restaurantTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$ZoneTableTableOrderingComposer
    extends Composer<_$AppDatabase, $ZoneTableTable> {
  $$ZoneTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get width => $composableBuilder(
      column: $table.width, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get height => $composableBuilder(
      column: $table.height, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnOrderings(column));
}

class $$ZoneTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $ZoneTableTable> {
  $$ZoneTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<double> get width =>
      $composableBuilder(column: $table.width, builder: (column) => column);

  GeneratedColumn<double> get height =>
      $composableBuilder(column: $table.height, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<bool> get isDeleted =>
      $composableBuilder(column: $table.isDeleted, builder: (column) => column);

  Expression<T> restaurantTableRefs<T extends Object>(
      Expression<T> Function($$RestaurantTableTableAnnotationComposer a) f) {
    final $$RestaurantTableTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.uuid,
        referencedTable: $db.restaurantTable,
        getReferencedColumn: (t) => t.zoneUuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$RestaurantTableTableAnnotationComposer(
              $db: $db,
              $table: $db.restaurantTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$ZoneTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $ZoneTableTable,
    ZoneTableData,
    $$ZoneTableTableFilterComposer,
    $$ZoneTableTableOrderingComposer,
    $$ZoneTableTableAnnotationComposer,
    $$ZoneTableTableCreateCompanionBuilder,
    $$ZoneTableTableUpdateCompanionBuilder,
    (ZoneTableData, $$ZoneTableTableReferences),
    ZoneTableData,
    PrefetchHooks Function({bool restaurantTableRefs})> {
  $$ZoneTableTableTableManager(_$AppDatabase db, $ZoneTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ZoneTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ZoneTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ZoneTableTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String> name = const Value.absent(),
            Value<double> width = const Value.absent(),
            Value<double> height = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
            Value<bool> isDeleted = const Value.absent(),
          }) =>
              ZoneTableCompanion(
            id: id,
            uuid: uuid,
            name: name,
            width: width,
            height: height,
            updatedAt: updatedAt,
            isDeleted: isDeleted,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            required String name,
            Value<double> width = const Value.absent(),
            Value<double> height = const Value.absent(),
            required DateTime updatedAt,
            Value<bool> isDeleted = const Value.absent(),
          }) =>
              ZoneTableCompanion.insert(
            id: id,
            uuid: uuid,
            name: name,
            width: width,
            height: height,
            updatedAt: updatedAt,
            isDeleted: isDeleted,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$ZoneTableTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: ({restaurantTableRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (restaurantTableRefs) db.restaurantTable
              ],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (restaurantTableRefs)
                    await $_getPrefetchedData<ZoneTableData, $ZoneTableTable,
                            RestaurantTableData>(
                        currentTable: table,
                        referencedTable: $$ZoneTableTableReferences
                            ._restaurantTableRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$ZoneTableTableReferences(db, table, p0)
                                .restaurantTableRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.zoneUuid == item.uuid),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $$ZoneTableTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $ZoneTableTable,
    ZoneTableData,
    $$ZoneTableTableFilterComposer,
    $$ZoneTableTableOrderingComposer,
    $$ZoneTableTableAnnotationComposer,
    $$ZoneTableTableCreateCompanionBuilder,
    $$ZoneTableTableUpdateCompanionBuilder,
    (ZoneTableData, $$ZoneTableTableReferences),
    ZoneTableData,
    PrefetchHooks Function({bool restaurantTableRefs})>;
typedef $$TenantConfigTableTableCreateCompanionBuilder
    = TenantConfigTableCompanion Function({
  Value<int> id,
  required String tenantId,
  required String outletName,
  required String address,
  required String currencySymbol,
  required int tier,
  Value<DateTime?> subscriptionExpiry,
  required bool isAdsEnabled,
  Value<String?> managerPinHash,
  required DateTime updatedAt,
});
typedef $$TenantConfigTableTableUpdateCompanionBuilder
    = TenantConfigTableCompanion Function({
  Value<int> id,
  Value<String> tenantId,
  Value<String> outletName,
  Value<String> address,
  Value<String> currencySymbol,
  Value<int> tier,
  Value<DateTime?> subscriptionExpiry,
  Value<bool> isAdsEnabled,
  Value<String?> managerPinHash,
  Value<DateTime> updatedAt,
});

class $$TenantConfigTableTableFilterComposer
    extends Composer<_$AppDatabase, $TenantConfigTableTable> {
  $$TenantConfigTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get tenantId => $composableBuilder(
      column: $table.tenantId, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get outletName => $composableBuilder(
      column: $table.outletName, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get address => $composableBuilder(
      column: $table.address, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get currencySymbol => $composableBuilder(
      column: $table.currencySymbol,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get tier => $composableBuilder(
      column: $table.tier, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get subscriptionExpiry => $composableBuilder(
      column: $table.subscriptionExpiry,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isAdsEnabled => $composableBuilder(
      column: $table.isAdsEnabled, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get managerPinHash => $composableBuilder(
      column: $table.managerPinHash,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));
}

class $$TenantConfigTableTableOrderingComposer
    extends Composer<_$AppDatabase, $TenantConfigTableTable> {
  $$TenantConfigTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get tenantId => $composableBuilder(
      column: $table.tenantId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get outletName => $composableBuilder(
      column: $table.outletName, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get address => $composableBuilder(
      column: $table.address, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get currencySymbol => $composableBuilder(
      column: $table.currencySymbol,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get tier => $composableBuilder(
      column: $table.tier, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get subscriptionExpiry => $composableBuilder(
      column: $table.subscriptionExpiry,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isAdsEnabled => $composableBuilder(
      column: $table.isAdsEnabled,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get managerPinHash => $composableBuilder(
      column: $table.managerPinHash,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));
}

class $$TenantConfigTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $TenantConfigTableTable> {
  $$TenantConfigTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get tenantId =>
      $composableBuilder(column: $table.tenantId, builder: (column) => column);

  GeneratedColumn<String> get outletName => $composableBuilder(
      column: $table.outletName, builder: (column) => column);

  GeneratedColumn<String> get address =>
      $composableBuilder(column: $table.address, builder: (column) => column);

  GeneratedColumn<String> get currencySymbol => $composableBuilder(
      column: $table.currencySymbol, builder: (column) => column);

  GeneratedColumn<int> get tier =>
      $composableBuilder(column: $table.tier, builder: (column) => column);

  GeneratedColumn<DateTime> get subscriptionExpiry => $composableBuilder(
      column: $table.subscriptionExpiry, builder: (column) => column);

  GeneratedColumn<bool> get isAdsEnabled => $composableBuilder(
      column: $table.isAdsEnabled, builder: (column) => column);

  GeneratedColumn<String> get managerPinHash => $composableBuilder(
      column: $table.managerPinHash, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$TenantConfigTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $TenantConfigTableTable,
    TenantConfigTableData,
    $$TenantConfigTableTableFilterComposer,
    $$TenantConfigTableTableOrderingComposer,
    $$TenantConfigTableTableAnnotationComposer,
    $$TenantConfigTableTableCreateCompanionBuilder,
    $$TenantConfigTableTableUpdateCompanionBuilder,
    (
      TenantConfigTableData,
      BaseReferences<_$AppDatabase, $TenantConfigTableTable,
          TenantConfigTableData>
    ),
    TenantConfigTableData,
    PrefetchHooks Function()> {
  $$TenantConfigTableTableTableManager(
      _$AppDatabase db, $TenantConfigTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$TenantConfigTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$TenantConfigTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$TenantConfigTableTableAnnotationComposer(
                  $db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> tenantId = const Value.absent(),
            Value<String> outletName = const Value.absent(),
            Value<String> address = const Value.absent(),
            Value<String> currencySymbol = const Value.absent(),
            Value<int> tier = const Value.absent(),
            Value<DateTime?> subscriptionExpiry = const Value.absent(),
            Value<bool> isAdsEnabled = const Value.absent(),
            Value<String?> managerPinHash = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
          }) =>
              TenantConfigTableCompanion(
            id: id,
            tenantId: tenantId,
            outletName: outletName,
            address: address,
            currencySymbol: currencySymbol,
            tier: tier,
            subscriptionExpiry: subscriptionExpiry,
            isAdsEnabled: isAdsEnabled,
            managerPinHash: managerPinHash,
            updatedAt: updatedAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String tenantId,
            required String outletName,
            required String address,
            required String currencySymbol,
            required int tier,
            Value<DateTime?> subscriptionExpiry = const Value.absent(),
            required bool isAdsEnabled,
            Value<String?> managerPinHash = const Value.absent(),
            required DateTime updatedAt,
          }) =>
              TenantConfigTableCompanion.insert(
            id: id,
            tenantId: tenantId,
            outletName: outletName,
            address: address,
            currencySymbol: currencySymbol,
            tier: tier,
            subscriptionExpiry: subscriptionExpiry,
            isAdsEnabled: isAdsEnabled,
            managerPinHash: managerPinHash,
            updatedAt: updatedAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$TenantConfigTableTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $TenantConfigTableTable,
    TenantConfigTableData,
    $$TenantConfigTableTableFilterComposer,
    $$TenantConfigTableTableOrderingComposer,
    $$TenantConfigTableTableAnnotationComposer,
    $$TenantConfigTableTableCreateCompanionBuilder,
    $$TenantConfigTableTableUpdateCompanionBuilder,
    (
      TenantConfigTableData,
      BaseReferences<_$AppDatabase, $TenantConfigTableTable,
          TenantConfigTableData>
    ),
    TenantConfigTableData,
    PrefetchHooks Function()>;
typedef $$RestaurantTableTableCreateCompanionBuilder = RestaurantTableCompanion
    Function({
  Value<int> id,
  required String uuid,
  required String name,
  Value<int> capacity,
  Value<double> x,
  Value<double> y,
  Value<double> width,
  Value<double> height,
  Value<double> rotation,
  Value<String> shape,
  Value<String?> zoneUuid,
  Value<bool> isOccupied,
  Value<String?> currentOrderUuid,
  Value<String?> currentSessionToken,
  Value<String?> qrCodeUrl,
  Value<String> sessionStatus,
  required DateTime updatedAt,
  Value<bool> isDeleted,
  Value<int> version,
});
typedef $$RestaurantTableTableUpdateCompanionBuilder = RestaurantTableCompanion
    Function({
  Value<int> id,
  Value<String> uuid,
  Value<String> name,
  Value<int> capacity,
  Value<double> x,
  Value<double> y,
  Value<double> width,
  Value<double> height,
  Value<double> rotation,
  Value<String> shape,
  Value<String?> zoneUuid,
  Value<bool> isOccupied,
  Value<String?> currentOrderUuid,
  Value<String?> currentSessionToken,
  Value<String?> qrCodeUrl,
  Value<String> sessionStatus,
  Value<DateTime> updatedAt,
  Value<bool> isDeleted,
  Value<int> version,
});

final class $$RestaurantTableTableReferences extends BaseReferences<
    _$AppDatabase, $RestaurantTableTable, RestaurantTableData> {
  $$RestaurantTableTableReferences(
      super.$_db, super.$_table, super.$_typedResult);

  static $ZoneTableTable _zoneUuidTable(_$AppDatabase db) =>
      db.zoneTable.createAlias(
          $_aliasNameGenerator(db.restaurantTable.zoneUuid, db.zoneTable.uuid));

  $$ZoneTableTableProcessedTableManager? get zoneUuid {
    final $_column = $_itemColumn<String>('zone_uuid');
    if ($_column == null) return null;
    final manager = $$ZoneTableTableTableManager($_db, $_db.zoneTable)
        .filter((f) => f.uuid.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_zoneUuidTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }
}

class $$RestaurantTableTableFilterComposer
    extends Composer<_$AppDatabase, $RestaurantTableTable> {
  $$RestaurantTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get capacity => $composableBuilder(
      column: $table.capacity, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get x => $composableBuilder(
      column: $table.x, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get y => $composableBuilder(
      column: $table.y, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get width => $composableBuilder(
      column: $table.width, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get height => $composableBuilder(
      column: $table.height, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get rotation => $composableBuilder(
      column: $table.rotation, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get shape => $composableBuilder(
      column: $table.shape, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isOccupied => $composableBuilder(
      column: $table.isOccupied, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get currentOrderUuid => $composableBuilder(
      column: $table.currentOrderUuid,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get currentSessionToken => $composableBuilder(
      column: $table.currentSessionToken,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get qrCodeUrl => $composableBuilder(
      column: $table.qrCodeUrl, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get sessionStatus => $composableBuilder(
      column: $table.sessionStatus, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get version => $composableBuilder(
      column: $table.version, builder: (column) => ColumnFilters(column));

  $$ZoneTableTableFilterComposer get zoneUuid {
    final $$ZoneTableTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.zoneUuid,
        referencedTable: $db.zoneTable,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ZoneTableTableFilterComposer(
              $db: $db,
              $table: $db.zoneTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$RestaurantTableTableOrderingComposer
    extends Composer<_$AppDatabase, $RestaurantTableTable> {
  $$RestaurantTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get capacity => $composableBuilder(
      column: $table.capacity, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get x => $composableBuilder(
      column: $table.x, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get y => $composableBuilder(
      column: $table.y, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get width => $composableBuilder(
      column: $table.width, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get height => $composableBuilder(
      column: $table.height, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get rotation => $composableBuilder(
      column: $table.rotation, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get shape => $composableBuilder(
      column: $table.shape, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isOccupied => $composableBuilder(
      column: $table.isOccupied, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get currentOrderUuid => $composableBuilder(
      column: $table.currentOrderUuid,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get currentSessionToken => $composableBuilder(
      column: $table.currentSessionToken,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get qrCodeUrl => $composableBuilder(
      column: $table.qrCodeUrl, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get sessionStatus => $composableBuilder(
      column: $table.sessionStatus,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get version => $composableBuilder(
      column: $table.version, builder: (column) => ColumnOrderings(column));

  $$ZoneTableTableOrderingComposer get zoneUuid {
    final $$ZoneTableTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.zoneUuid,
        referencedTable: $db.zoneTable,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ZoneTableTableOrderingComposer(
              $db: $db,
              $table: $db.zoneTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$RestaurantTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $RestaurantTableTable> {
  $$RestaurantTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<int> get capacity =>
      $composableBuilder(column: $table.capacity, builder: (column) => column);

  GeneratedColumn<double> get x =>
      $composableBuilder(column: $table.x, builder: (column) => column);

  GeneratedColumn<double> get y =>
      $composableBuilder(column: $table.y, builder: (column) => column);

  GeneratedColumn<double> get width =>
      $composableBuilder(column: $table.width, builder: (column) => column);

  GeneratedColumn<double> get height =>
      $composableBuilder(column: $table.height, builder: (column) => column);

  GeneratedColumn<double> get rotation =>
      $composableBuilder(column: $table.rotation, builder: (column) => column);

  GeneratedColumn<String> get shape =>
      $composableBuilder(column: $table.shape, builder: (column) => column);

  GeneratedColumn<bool> get isOccupied => $composableBuilder(
      column: $table.isOccupied, builder: (column) => column);

  GeneratedColumn<String> get currentOrderUuid => $composableBuilder(
      column: $table.currentOrderUuid, builder: (column) => column);

  GeneratedColumn<String> get currentSessionToken => $composableBuilder(
      column: $table.currentSessionToken, builder: (column) => column);

  GeneratedColumn<String> get qrCodeUrl =>
      $composableBuilder(column: $table.qrCodeUrl, builder: (column) => column);

  GeneratedColumn<String> get sessionStatus => $composableBuilder(
      column: $table.sessionStatus, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<bool> get isDeleted =>
      $composableBuilder(column: $table.isDeleted, builder: (column) => column);

  GeneratedColumn<int> get version =>
      $composableBuilder(column: $table.version, builder: (column) => column);

  $$ZoneTableTableAnnotationComposer get zoneUuid {
    final $$ZoneTableTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.zoneUuid,
        referencedTable: $db.zoneTable,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ZoneTableTableAnnotationComposer(
              $db: $db,
              $table: $db.zoneTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$RestaurantTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $RestaurantTableTable,
    RestaurantTableData,
    $$RestaurantTableTableFilterComposer,
    $$RestaurantTableTableOrderingComposer,
    $$RestaurantTableTableAnnotationComposer,
    $$RestaurantTableTableCreateCompanionBuilder,
    $$RestaurantTableTableUpdateCompanionBuilder,
    (RestaurantTableData, $$RestaurantTableTableReferences),
    RestaurantTableData,
    PrefetchHooks Function({bool zoneUuid})> {
  $$RestaurantTableTableTableManager(
      _$AppDatabase db, $RestaurantTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$RestaurantTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$RestaurantTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$RestaurantTableTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String> name = const Value.absent(),
            Value<int> capacity = const Value.absent(),
            Value<double> x = const Value.absent(),
            Value<double> y = const Value.absent(),
            Value<double> width = const Value.absent(),
            Value<double> height = const Value.absent(),
            Value<double> rotation = const Value.absent(),
            Value<String> shape = const Value.absent(),
            Value<String?> zoneUuid = const Value.absent(),
            Value<bool> isOccupied = const Value.absent(),
            Value<String?> currentOrderUuid = const Value.absent(),
            Value<String?> currentSessionToken = const Value.absent(),
            Value<String?> qrCodeUrl = const Value.absent(),
            Value<String> sessionStatus = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
            Value<bool> isDeleted = const Value.absent(),
            Value<int> version = const Value.absent(),
          }) =>
              RestaurantTableCompanion(
            id: id,
            uuid: uuid,
            name: name,
            capacity: capacity,
            x: x,
            y: y,
            width: width,
            height: height,
            rotation: rotation,
            shape: shape,
            zoneUuid: zoneUuid,
            isOccupied: isOccupied,
            currentOrderUuid: currentOrderUuid,
            currentSessionToken: currentSessionToken,
            qrCodeUrl: qrCodeUrl,
            sessionStatus: sessionStatus,
            updatedAt: updatedAt,
            isDeleted: isDeleted,
            version: version,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            required String name,
            Value<int> capacity = const Value.absent(),
            Value<double> x = const Value.absent(),
            Value<double> y = const Value.absent(),
            Value<double> width = const Value.absent(),
            Value<double> height = const Value.absent(),
            Value<double> rotation = const Value.absent(),
            Value<String> shape = const Value.absent(),
            Value<String?> zoneUuid = const Value.absent(),
            Value<bool> isOccupied = const Value.absent(),
            Value<String?> currentOrderUuid = const Value.absent(),
            Value<String?> currentSessionToken = const Value.absent(),
            Value<String?> qrCodeUrl = const Value.absent(),
            Value<String> sessionStatus = const Value.absent(),
            required DateTime updatedAt,
            Value<bool> isDeleted = const Value.absent(),
            Value<int> version = const Value.absent(),
          }) =>
              RestaurantTableCompanion.insert(
            id: id,
            uuid: uuid,
            name: name,
            capacity: capacity,
            x: x,
            y: y,
            width: width,
            height: height,
            rotation: rotation,
            shape: shape,
            zoneUuid: zoneUuid,
            isOccupied: isOccupied,
            currentOrderUuid: currentOrderUuid,
            currentSessionToken: currentSessionToken,
            qrCodeUrl: qrCodeUrl,
            sessionStatus: sessionStatus,
            updatedAt: updatedAt,
            isDeleted: isDeleted,
            version: version,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$RestaurantTableTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: ({zoneUuid = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (zoneUuid) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.zoneUuid,
                    referencedTable:
                        $$RestaurantTableTableReferences._zoneUuidTable(db),
                    referencedColumn: $$RestaurantTableTableReferences
                        ._zoneUuidTable(db)
                        .uuid,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ));
}

typedef $$RestaurantTableTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $RestaurantTableTable,
    RestaurantTableData,
    $$RestaurantTableTableFilterComposer,
    $$RestaurantTableTableOrderingComposer,
    $$RestaurantTableTableAnnotationComposer,
    $$RestaurantTableTableCreateCompanionBuilder,
    $$RestaurantTableTableUpdateCompanionBuilder,
    (RestaurantTableData, $$RestaurantTableTableReferences),
    RestaurantTableData,
    PrefetchHooks Function({bool zoneUuid})>;
typedef $$ReservationTableTableCreateCompanionBuilder
    = ReservationTableCompanion Function({
  Value<int> id,
  required String uuid,
  required String customerName,
  Value<String?> phone,
  required int pax,
  required DateTime reservationTime,
  Value<String?> tableUuid,
  Value<String> status,
  Value<String?> note,
  required DateTime createdAt,
  required DateTime updatedAt,
});
typedef $$ReservationTableTableUpdateCompanionBuilder
    = ReservationTableCompanion Function({
  Value<int> id,
  Value<String> uuid,
  Value<String> customerName,
  Value<String?> phone,
  Value<int> pax,
  Value<DateTime> reservationTime,
  Value<String?> tableUuid,
  Value<String> status,
  Value<String?> note,
  Value<DateTime> createdAt,
  Value<DateTime> updatedAt,
});

class $$ReservationTableTableFilterComposer
    extends Composer<_$AppDatabase, $ReservationTableTable> {
  $$ReservationTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get customerName => $composableBuilder(
      column: $table.customerName, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get phone => $composableBuilder(
      column: $table.phone, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get pax => $composableBuilder(
      column: $table.pax, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get reservationTime => $composableBuilder(
      column: $table.reservationTime,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get tableUuid => $composableBuilder(
      column: $table.tableUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get note => $composableBuilder(
      column: $table.note, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));
}

class $$ReservationTableTableOrderingComposer
    extends Composer<_$AppDatabase, $ReservationTableTable> {
  $$ReservationTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get customerName => $composableBuilder(
      column: $table.customerName,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get phone => $composableBuilder(
      column: $table.phone, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get pax => $composableBuilder(
      column: $table.pax, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get reservationTime => $composableBuilder(
      column: $table.reservationTime,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get tableUuid => $composableBuilder(
      column: $table.tableUuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get note => $composableBuilder(
      column: $table.note, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));
}

class $$ReservationTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $ReservationTableTable> {
  $$ReservationTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get customerName => $composableBuilder(
      column: $table.customerName, builder: (column) => column);

  GeneratedColumn<String> get phone =>
      $composableBuilder(column: $table.phone, builder: (column) => column);

  GeneratedColumn<int> get pax =>
      $composableBuilder(column: $table.pax, builder: (column) => column);

  GeneratedColumn<DateTime> get reservationTime => $composableBuilder(
      column: $table.reservationTime, builder: (column) => column);

  GeneratedColumn<String> get tableUuid =>
      $composableBuilder(column: $table.tableUuid, builder: (column) => column);

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<String> get note =>
      $composableBuilder(column: $table.note, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$ReservationTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $ReservationTableTable,
    ReservationTableData,
    $$ReservationTableTableFilterComposer,
    $$ReservationTableTableOrderingComposer,
    $$ReservationTableTableAnnotationComposer,
    $$ReservationTableTableCreateCompanionBuilder,
    $$ReservationTableTableUpdateCompanionBuilder,
    (
      ReservationTableData,
      BaseReferences<_$AppDatabase, $ReservationTableTable,
          ReservationTableData>
    ),
    ReservationTableData,
    PrefetchHooks Function()> {
  $$ReservationTableTableTableManager(
      _$AppDatabase db, $ReservationTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ReservationTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ReservationTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ReservationTableTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String> customerName = const Value.absent(),
            Value<String?> phone = const Value.absent(),
            Value<int> pax = const Value.absent(),
            Value<DateTime> reservationTime = const Value.absent(),
            Value<String?> tableUuid = const Value.absent(),
            Value<String> status = const Value.absent(),
            Value<String?> note = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
          }) =>
              ReservationTableCompanion(
            id: id,
            uuid: uuid,
            customerName: customerName,
            phone: phone,
            pax: pax,
            reservationTime: reservationTime,
            tableUuid: tableUuid,
            status: status,
            note: note,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            required String customerName,
            Value<String?> phone = const Value.absent(),
            required int pax,
            required DateTime reservationTime,
            Value<String?> tableUuid = const Value.absent(),
            Value<String> status = const Value.absent(),
            Value<String?> note = const Value.absent(),
            required DateTime createdAt,
            required DateTime updatedAt,
          }) =>
              ReservationTableCompanion.insert(
            id: id,
            uuid: uuid,
            customerName: customerName,
            phone: phone,
            pax: pax,
            reservationTime: reservationTime,
            tableUuid: tableUuid,
            status: status,
            note: note,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$ReservationTableTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $ReservationTableTable,
    ReservationTableData,
    $$ReservationTableTableFilterComposer,
    $$ReservationTableTableOrderingComposer,
    $$ReservationTableTableAnnotationComposer,
    $$ReservationTableTableCreateCompanionBuilder,
    $$ReservationTableTableUpdateCompanionBuilder,
    (
      ReservationTableData,
      BaseReferences<_$AppDatabase, $ReservationTableTable,
          ReservationTableData>
    ),
    ReservationTableData,
    PrefetchHooks Function()>;
typedef $$EmployeeTableTableCreateCompanionBuilder = EmployeeTableCompanion
    Function({
  Value<int> id,
  required String uuid,
  required String name,
  required String pin,
  required String role,
  Value<bool> isActive,
  required DateTime createdAt,
  Value<DateTime?> updatedAt,
});
typedef $$EmployeeTableTableUpdateCompanionBuilder = EmployeeTableCompanion
    Function({
  Value<int> id,
  Value<String> uuid,
  Value<String> name,
  Value<String> pin,
  Value<String> role,
  Value<bool> isActive,
  Value<DateTime> createdAt,
  Value<DateTime?> updatedAt,
});

class $$EmployeeTableTableFilterComposer
    extends Composer<_$AppDatabase, $EmployeeTableTable> {
  $$EmployeeTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get pin => $composableBuilder(
      column: $table.pin, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get role => $composableBuilder(
      column: $table.role, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isActive => $composableBuilder(
      column: $table.isActive, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));
}

class $$EmployeeTableTableOrderingComposer
    extends Composer<_$AppDatabase, $EmployeeTableTable> {
  $$EmployeeTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get pin => $composableBuilder(
      column: $table.pin, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get role => $composableBuilder(
      column: $table.role, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isActive => $composableBuilder(
      column: $table.isActive, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));
}

class $$EmployeeTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $EmployeeTableTable> {
  $$EmployeeTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get pin =>
      $composableBuilder(column: $table.pin, builder: (column) => column);

  GeneratedColumn<String> get role =>
      $composableBuilder(column: $table.role, builder: (column) => column);

  GeneratedColumn<bool> get isActive =>
      $composableBuilder(column: $table.isActive, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$EmployeeTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $EmployeeTableTable,
    EmployeeTableData,
    $$EmployeeTableTableFilterComposer,
    $$EmployeeTableTableOrderingComposer,
    $$EmployeeTableTableAnnotationComposer,
    $$EmployeeTableTableCreateCompanionBuilder,
    $$EmployeeTableTableUpdateCompanionBuilder,
    (
      EmployeeTableData,
      BaseReferences<_$AppDatabase, $EmployeeTableTable, EmployeeTableData>
    ),
    EmployeeTableData,
    PrefetchHooks Function()> {
  $$EmployeeTableTableTableManager(_$AppDatabase db, $EmployeeTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$EmployeeTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$EmployeeTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$EmployeeTableTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String> name = const Value.absent(),
            Value<String> pin = const Value.absent(),
            Value<String> role = const Value.absent(),
            Value<bool> isActive = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<DateTime?> updatedAt = const Value.absent(),
          }) =>
              EmployeeTableCompanion(
            id: id,
            uuid: uuid,
            name: name,
            pin: pin,
            role: role,
            isActive: isActive,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            required String name,
            required String pin,
            required String role,
            Value<bool> isActive = const Value.absent(),
            required DateTime createdAt,
            Value<DateTime?> updatedAt = const Value.absent(),
          }) =>
              EmployeeTableCompanion.insert(
            id: id,
            uuid: uuid,
            name: name,
            pin: pin,
            role: role,
            isActive: isActive,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$EmployeeTableTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $EmployeeTableTable,
    EmployeeTableData,
    $$EmployeeTableTableFilterComposer,
    $$EmployeeTableTableOrderingComposer,
    $$EmployeeTableTableAnnotationComposer,
    $$EmployeeTableTableCreateCompanionBuilder,
    $$EmployeeTableTableUpdateCompanionBuilder,
    (
      EmployeeTableData,
      BaseReferences<_$AppDatabase, $EmployeeTableTable, EmployeeTableData>
    ),
    EmployeeTableData,
    PrefetchHooks Function()>;
typedef $$CategoryTableTableCreateCompanionBuilder = CategoryTableCompanion
    Function({
  Value<int> id,
  required String uuid,
  required String name,
  Value<String?> colorHex,
  required DateTime createdAt,
  required DateTime updatedAt,
  Value<bool> isDeleted,
});
typedef $$CategoryTableTableUpdateCompanionBuilder = CategoryTableCompanion
    Function({
  Value<int> id,
  Value<String> uuid,
  Value<String> name,
  Value<String?> colorHex,
  Value<DateTime> createdAt,
  Value<DateTime> updatedAt,
  Value<bool> isDeleted,
});

class $$CategoryTableTableFilterComposer
    extends Composer<_$AppDatabase, $CategoryTableTable> {
  $$CategoryTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get colorHex => $composableBuilder(
      column: $table.colorHex, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnFilters(column));
}

class $$CategoryTableTableOrderingComposer
    extends Composer<_$AppDatabase, $CategoryTableTable> {
  $$CategoryTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get colorHex => $composableBuilder(
      column: $table.colorHex, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnOrderings(column));
}

class $$CategoryTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $CategoryTableTable> {
  $$CategoryTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get colorHex =>
      $composableBuilder(column: $table.colorHex, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<bool> get isDeleted =>
      $composableBuilder(column: $table.isDeleted, builder: (column) => column);
}

class $$CategoryTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $CategoryTableTable,
    CategoryTableData,
    $$CategoryTableTableFilterComposer,
    $$CategoryTableTableOrderingComposer,
    $$CategoryTableTableAnnotationComposer,
    $$CategoryTableTableCreateCompanionBuilder,
    $$CategoryTableTableUpdateCompanionBuilder,
    (
      CategoryTableData,
      BaseReferences<_$AppDatabase, $CategoryTableTable, CategoryTableData>
    ),
    CategoryTableData,
    PrefetchHooks Function()> {
  $$CategoryTableTableTableManager(_$AppDatabase db, $CategoryTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$CategoryTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$CategoryTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$CategoryTableTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String> name = const Value.absent(),
            Value<String?> colorHex = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
            Value<bool> isDeleted = const Value.absent(),
          }) =>
              CategoryTableCompanion(
            id: id,
            uuid: uuid,
            name: name,
            colorHex: colorHex,
            createdAt: createdAt,
            updatedAt: updatedAt,
            isDeleted: isDeleted,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            required String name,
            Value<String?> colorHex = const Value.absent(),
            required DateTime createdAt,
            required DateTime updatedAt,
            Value<bool> isDeleted = const Value.absent(),
          }) =>
              CategoryTableCompanion.insert(
            id: id,
            uuid: uuid,
            name: name,
            colorHex: colorHex,
            createdAt: createdAt,
            updatedAt: updatedAt,
            isDeleted: isDeleted,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$CategoryTableTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $CategoryTableTable,
    CategoryTableData,
    $$CategoryTableTableFilterComposer,
    $$CategoryTableTableOrderingComposer,
    $$CategoryTableTableAnnotationComposer,
    $$CategoryTableTableCreateCompanionBuilder,
    $$CategoryTableTableUpdateCompanionBuilder,
    (
      CategoryTableData,
      BaseReferences<_$AppDatabase, $CategoryTableTable, CategoryTableData>
    ),
    CategoryTableData,
    PrefetchHooks Function()>;
typedef $$ProductTableTableCreateCompanionBuilder = ProductTableCompanion
    Function({
  Value<int> id,
  required String uuid,
  required String name,
  Value<String?> sku,
  Value<String?> barcode,
  required double price,
  Value<double?> costPrice,
  required String categoryId,
  required bool trackStock,
  required bool isService,
  Value<double> totalSpent,
  Value<DateTime?> lastVisitAt,
  Value<String?> colorHex,
  Value<String?> imageUrl,
  Value<String> printerCategory,
  required DateTime updatedAt,
  Value<bool> isSynced,
  Value<int> version,
  Value<bool> isDeleted,
  Value<String?> outletId,
  Value<bool> isComposite,
});
typedef $$ProductTableTableUpdateCompanionBuilder = ProductTableCompanion
    Function({
  Value<int> id,
  Value<String> uuid,
  Value<String> name,
  Value<String?> sku,
  Value<String?> barcode,
  Value<double> price,
  Value<double?> costPrice,
  Value<String> categoryId,
  Value<bool> trackStock,
  Value<bool> isService,
  Value<double> totalSpent,
  Value<DateTime?> lastVisitAt,
  Value<String?> colorHex,
  Value<String?> imageUrl,
  Value<String> printerCategory,
  Value<DateTime> updatedAt,
  Value<bool> isSynced,
  Value<int> version,
  Value<bool> isDeleted,
  Value<String?> outletId,
  Value<bool> isComposite,
});

final class $$ProductTableTableReferences extends BaseReferences<_$AppDatabase,
    $ProductTableTable, ProductTableData> {
  $$ProductTableTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$ProductModifierLinkTableTable,
      List<ProductModifierLinkTableData>> _productModifierLinkTableRefsTable(
          _$AppDatabase db) =>
      MultiTypedResultKey.fromTable(db.productModifierLinkTable,
          aliasName: $_aliasNameGenerator(
              db.productTable.uuid, db.productModifierLinkTable.productUuid));

  $$ProductModifierLinkTableTableProcessedTableManager
      get productModifierLinkTableRefs {
    final manager = $$ProductModifierLinkTableTableTableManager(
            $_db, $_db.productModifierLinkTable)
        .filter(
            (f) => f.productUuid.uuid.sqlEquals($_itemColumn<String>('uuid')!));

    final cache =
        $_typedResult.readTableOrNull(_productModifierLinkTableRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$RecipeTableTable, List<RecipeTableData>>
      _recipeTableRefsTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.recipeTable,
              aliasName: $_aliasNameGenerator(
                  db.productTable.uuid, db.recipeTable.productUuid));

  $$RecipeTableTableProcessedTableManager get recipeTableRefs {
    final manager = $$RecipeTableTableTableManager($_db, $_db.recipeTable)
        .filter(
            (f) => f.productUuid.uuid.sqlEquals($_itemColumn<String>('uuid')!));

    final cache = $_typedResult.readTableOrNull(_recipeTableRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$LocalStocksTableTable, List<LocalStocksTableData>>
      _localStocksTableRefsTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.localStocksTable,
              aliasName: $_aliasNameGenerator(
                  db.productTable.uuid, db.localStocksTable.productUuid));

  $$LocalStocksTableTableProcessedTableManager get localStocksTableRefs {
    final manager =
        $$LocalStocksTableTableTableManager($_db, $_db.localStocksTable).filter(
            (f) => f.productUuid.uuid.sqlEquals($_itemColumn<String>('uuid')!));

    final cache =
        $_typedResult.readTableOrNull(_localStocksTableRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$ProductSupplierTableTable,
      List<ProductSupplierTableData>> _productSupplierTableRefsTable(
          _$AppDatabase db) =>
      MultiTypedResultKey.fromTable(db.productSupplierTable,
          aliasName: $_aliasNameGenerator(
              db.productTable.uuid, db.productSupplierTable.productUuid));

  $$ProductSupplierTableTableProcessedTableManager
      get productSupplierTableRefs {
    final manager = $$ProductSupplierTableTableTableManager(
            $_db, $_db.productSupplierTable)
        .filter(
            (f) => f.productUuid.uuid.sqlEquals($_itemColumn<String>('uuid')!));

    final cache =
        $_typedResult.readTableOrNull(_productSupplierTableRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$PurchaseOrderItemTableTable,
      List<PurchaseOrderItemTableData>> _purchaseOrderItemTableRefsTable(
          _$AppDatabase db) =>
      MultiTypedResultKey.fromTable(db.purchaseOrderItemTable,
          aliasName: $_aliasNameGenerator(
              db.productTable.uuid, db.purchaseOrderItemTable.productUuid));

  $$PurchaseOrderItemTableTableProcessedTableManager
      get purchaseOrderItemTableRefs {
    final manager = $$PurchaseOrderItemTableTableTableManager(
            $_db, $_db.purchaseOrderItemTable)
        .filter(
            (f) => f.productUuid.uuid.sqlEquals($_itemColumn<String>('uuid')!));

    final cache =
        $_typedResult.readTableOrNull(_purchaseOrderItemTableRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $$ProductTableTableFilterComposer
    extends Composer<_$AppDatabase, $ProductTableTable> {
  $$ProductTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get sku => $composableBuilder(
      column: $table.sku, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get barcode => $composableBuilder(
      column: $table.barcode, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get price => $composableBuilder(
      column: $table.price, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get costPrice => $composableBuilder(
      column: $table.costPrice, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get categoryId => $composableBuilder(
      column: $table.categoryId, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get trackStock => $composableBuilder(
      column: $table.trackStock, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isService => $composableBuilder(
      column: $table.isService, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get totalSpent => $composableBuilder(
      column: $table.totalSpent, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get lastVisitAt => $composableBuilder(
      column: $table.lastVisitAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get colorHex => $composableBuilder(
      column: $table.colorHex, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get imageUrl => $composableBuilder(
      column: $table.imageUrl, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get printerCategory => $composableBuilder(
      column: $table.printerCategory,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isSynced => $composableBuilder(
      column: $table.isSynced, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get version => $composableBuilder(
      column: $table.version, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get outletId => $composableBuilder(
      column: $table.outletId, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isComposite => $composableBuilder(
      column: $table.isComposite, builder: (column) => ColumnFilters(column));

  Expression<bool> productModifierLinkTableRefs(
      Expression<bool> Function($$ProductModifierLinkTableTableFilterComposer f)
          f) {
    final $$ProductModifierLinkTableTableFilterComposer composer =
        $composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.uuid,
            referencedTable: $db.productModifierLinkTable,
            getReferencedColumn: (t) => t.productUuid,
            builder: (joinBuilder,
                    {$addJoinBuilderToRootComposer,
                    $removeJoinBuilderFromRootComposer}) =>
                $$ProductModifierLinkTableTableFilterComposer(
                  $db: $db,
                  $table: $db.productModifierLinkTable,
                  $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                  joinBuilder: joinBuilder,
                  $removeJoinBuilderFromRootComposer:
                      $removeJoinBuilderFromRootComposer,
                ));
    return f(composer);
  }

  Expression<bool> recipeTableRefs(
      Expression<bool> Function($$RecipeTableTableFilterComposer f) f) {
    final $$RecipeTableTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.uuid,
        referencedTable: $db.recipeTable,
        getReferencedColumn: (t) => t.productUuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$RecipeTableTableFilterComposer(
              $db: $db,
              $table: $db.recipeTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> localStocksTableRefs(
      Expression<bool> Function($$LocalStocksTableTableFilterComposer f) f) {
    final $$LocalStocksTableTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.uuid,
        referencedTable: $db.localStocksTable,
        getReferencedColumn: (t) => t.productUuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalStocksTableTableFilterComposer(
              $db: $db,
              $table: $db.localStocksTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> productSupplierTableRefs(
      Expression<bool> Function($$ProductSupplierTableTableFilterComposer f)
          f) {
    final $$ProductSupplierTableTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.uuid,
        referencedTable: $db.productSupplierTable,
        getReferencedColumn: (t) => t.productUuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ProductSupplierTableTableFilterComposer(
              $db: $db,
              $table: $db.productSupplierTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> purchaseOrderItemTableRefs(
      Expression<bool> Function($$PurchaseOrderItemTableTableFilterComposer f)
          f) {
    final $$PurchaseOrderItemTableTableFilterComposer composer =
        $composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.uuid,
            referencedTable: $db.purchaseOrderItemTable,
            getReferencedColumn: (t) => t.productUuid,
            builder: (joinBuilder,
                    {$addJoinBuilderToRootComposer,
                    $removeJoinBuilderFromRootComposer}) =>
                $$PurchaseOrderItemTableTableFilterComposer(
                  $db: $db,
                  $table: $db.purchaseOrderItemTable,
                  $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                  joinBuilder: joinBuilder,
                  $removeJoinBuilderFromRootComposer:
                      $removeJoinBuilderFromRootComposer,
                ));
    return f(composer);
  }
}

class $$ProductTableTableOrderingComposer
    extends Composer<_$AppDatabase, $ProductTableTable> {
  $$ProductTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get sku => $composableBuilder(
      column: $table.sku, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get barcode => $composableBuilder(
      column: $table.barcode, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get price => $composableBuilder(
      column: $table.price, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get costPrice => $composableBuilder(
      column: $table.costPrice, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get categoryId => $composableBuilder(
      column: $table.categoryId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get trackStock => $composableBuilder(
      column: $table.trackStock, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isService => $composableBuilder(
      column: $table.isService, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get totalSpent => $composableBuilder(
      column: $table.totalSpent, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get lastVisitAt => $composableBuilder(
      column: $table.lastVisitAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get colorHex => $composableBuilder(
      column: $table.colorHex, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get imageUrl => $composableBuilder(
      column: $table.imageUrl, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get printerCategory => $composableBuilder(
      column: $table.printerCategory,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isSynced => $composableBuilder(
      column: $table.isSynced, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get version => $composableBuilder(
      column: $table.version, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get outletId => $composableBuilder(
      column: $table.outletId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isComposite => $composableBuilder(
      column: $table.isComposite, builder: (column) => ColumnOrderings(column));
}

class $$ProductTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $ProductTableTable> {
  $$ProductTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get sku =>
      $composableBuilder(column: $table.sku, builder: (column) => column);

  GeneratedColumn<String> get barcode =>
      $composableBuilder(column: $table.barcode, builder: (column) => column);

  GeneratedColumn<double> get price =>
      $composableBuilder(column: $table.price, builder: (column) => column);

  GeneratedColumn<double> get costPrice =>
      $composableBuilder(column: $table.costPrice, builder: (column) => column);

  GeneratedColumn<String> get categoryId => $composableBuilder(
      column: $table.categoryId, builder: (column) => column);

  GeneratedColumn<bool> get trackStock => $composableBuilder(
      column: $table.trackStock, builder: (column) => column);

  GeneratedColumn<bool> get isService =>
      $composableBuilder(column: $table.isService, builder: (column) => column);

  GeneratedColumn<double> get totalSpent => $composableBuilder(
      column: $table.totalSpent, builder: (column) => column);

  GeneratedColumn<DateTime> get lastVisitAt => $composableBuilder(
      column: $table.lastVisitAt, builder: (column) => column);

  GeneratedColumn<String> get colorHex =>
      $composableBuilder(column: $table.colorHex, builder: (column) => column);

  GeneratedColumn<String> get imageUrl =>
      $composableBuilder(column: $table.imageUrl, builder: (column) => column);

  GeneratedColumn<String> get printerCategory => $composableBuilder(
      column: $table.printerCategory, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<bool> get isSynced =>
      $composableBuilder(column: $table.isSynced, builder: (column) => column);

  GeneratedColumn<int> get version =>
      $composableBuilder(column: $table.version, builder: (column) => column);

  GeneratedColumn<bool> get isDeleted =>
      $composableBuilder(column: $table.isDeleted, builder: (column) => column);

  GeneratedColumn<String> get outletId =>
      $composableBuilder(column: $table.outletId, builder: (column) => column);

  GeneratedColumn<bool> get isComposite => $composableBuilder(
      column: $table.isComposite, builder: (column) => column);

  Expression<T> productModifierLinkTableRefs<T extends Object>(
      Expression<T> Function(
              $$ProductModifierLinkTableTableAnnotationComposer a)
          f) {
    final $$ProductModifierLinkTableTableAnnotationComposer composer =
        $composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.uuid,
            referencedTable: $db.productModifierLinkTable,
            getReferencedColumn: (t) => t.productUuid,
            builder: (joinBuilder,
                    {$addJoinBuilderToRootComposer,
                    $removeJoinBuilderFromRootComposer}) =>
                $$ProductModifierLinkTableTableAnnotationComposer(
                  $db: $db,
                  $table: $db.productModifierLinkTable,
                  $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                  joinBuilder: joinBuilder,
                  $removeJoinBuilderFromRootComposer:
                      $removeJoinBuilderFromRootComposer,
                ));
    return f(composer);
  }

  Expression<T> recipeTableRefs<T extends Object>(
      Expression<T> Function($$RecipeTableTableAnnotationComposer a) f) {
    final $$RecipeTableTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.uuid,
        referencedTable: $db.recipeTable,
        getReferencedColumn: (t) => t.productUuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$RecipeTableTableAnnotationComposer(
              $db: $db,
              $table: $db.recipeTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> localStocksTableRefs<T extends Object>(
      Expression<T> Function($$LocalStocksTableTableAnnotationComposer a) f) {
    final $$LocalStocksTableTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.uuid,
        referencedTable: $db.localStocksTable,
        getReferencedColumn: (t) => t.productUuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalStocksTableTableAnnotationComposer(
              $db: $db,
              $table: $db.localStocksTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> productSupplierTableRefs<T extends Object>(
      Expression<T> Function($$ProductSupplierTableTableAnnotationComposer a)
          f) {
    final $$ProductSupplierTableTableAnnotationComposer composer =
        $composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.uuid,
            referencedTable: $db.productSupplierTable,
            getReferencedColumn: (t) => t.productUuid,
            builder: (joinBuilder,
                    {$addJoinBuilderToRootComposer,
                    $removeJoinBuilderFromRootComposer}) =>
                $$ProductSupplierTableTableAnnotationComposer(
                  $db: $db,
                  $table: $db.productSupplierTable,
                  $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                  joinBuilder: joinBuilder,
                  $removeJoinBuilderFromRootComposer:
                      $removeJoinBuilderFromRootComposer,
                ));
    return f(composer);
  }

  Expression<T> purchaseOrderItemTableRefs<T extends Object>(
      Expression<T> Function($$PurchaseOrderItemTableTableAnnotationComposer a)
          f) {
    final $$PurchaseOrderItemTableTableAnnotationComposer composer =
        $composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.uuid,
            referencedTable: $db.purchaseOrderItemTable,
            getReferencedColumn: (t) => t.productUuid,
            builder: (joinBuilder,
                    {$addJoinBuilderToRootComposer,
                    $removeJoinBuilderFromRootComposer}) =>
                $$PurchaseOrderItemTableTableAnnotationComposer(
                  $db: $db,
                  $table: $db.purchaseOrderItemTable,
                  $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                  joinBuilder: joinBuilder,
                  $removeJoinBuilderFromRootComposer:
                      $removeJoinBuilderFromRootComposer,
                ));
    return f(composer);
  }
}

class $$ProductTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $ProductTableTable,
    ProductTableData,
    $$ProductTableTableFilterComposer,
    $$ProductTableTableOrderingComposer,
    $$ProductTableTableAnnotationComposer,
    $$ProductTableTableCreateCompanionBuilder,
    $$ProductTableTableUpdateCompanionBuilder,
    (ProductTableData, $$ProductTableTableReferences),
    ProductTableData,
    PrefetchHooks Function(
        {bool productModifierLinkTableRefs,
        bool recipeTableRefs,
        bool localStocksTableRefs,
        bool productSupplierTableRefs,
        bool purchaseOrderItemTableRefs})> {
  $$ProductTableTableTableManager(_$AppDatabase db, $ProductTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ProductTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ProductTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ProductTableTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String> name = const Value.absent(),
            Value<String?> sku = const Value.absent(),
            Value<String?> barcode = const Value.absent(),
            Value<double> price = const Value.absent(),
            Value<double?> costPrice = const Value.absent(),
            Value<String> categoryId = const Value.absent(),
            Value<bool> trackStock = const Value.absent(),
            Value<bool> isService = const Value.absent(),
            Value<double> totalSpent = const Value.absent(),
            Value<DateTime?> lastVisitAt = const Value.absent(),
            Value<String?> colorHex = const Value.absent(),
            Value<String?> imageUrl = const Value.absent(),
            Value<String> printerCategory = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
            Value<bool> isSynced = const Value.absent(),
            Value<int> version = const Value.absent(),
            Value<bool> isDeleted = const Value.absent(),
            Value<String?> outletId = const Value.absent(),
            Value<bool> isComposite = const Value.absent(),
          }) =>
              ProductTableCompanion(
            id: id,
            uuid: uuid,
            name: name,
            sku: sku,
            barcode: barcode,
            price: price,
            costPrice: costPrice,
            categoryId: categoryId,
            trackStock: trackStock,
            isService: isService,
            totalSpent: totalSpent,
            lastVisitAt: lastVisitAt,
            colorHex: colorHex,
            imageUrl: imageUrl,
            printerCategory: printerCategory,
            updatedAt: updatedAt,
            isSynced: isSynced,
            version: version,
            isDeleted: isDeleted,
            outletId: outletId,
            isComposite: isComposite,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            required String name,
            Value<String?> sku = const Value.absent(),
            Value<String?> barcode = const Value.absent(),
            required double price,
            Value<double?> costPrice = const Value.absent(),
            required String categoryId,
            required bool trackStock,
            required bool isService,
            Value<double> totalSpent = const Value.absent(),
            Value<DateTime?> lastVisitAt = const Value.absent(),
            Value<String?> colorHex = const Value.absent(),
            Value<String?> imageUrl = const Value.absent(),
            Value<String> printerCategory = const Value.absent(),
            required DateTime updatedAt,
            Value<bool> isSynced = const Value.absent(),
            Value<int> version = const Value.absent(),
            Value<bool> isDeleted = const Value.absent(),
            Value<String?> outletId = const Value.absent(),
            Value<bool> isComposite = const Value.absent(),
          }) =>
              ProductTableCompanion.insert(
            id: id,
            uuid: uuid,
            name: name,
            sku: sku,
            barcode: barcode,
            price: price,
            costPrice: costPrice,
            categoryId: categoryId,
            trackStock: trackStock,
            isService: isService,
            totalSpent: totalSpent,
            lastVisitAt: lastVisitAt,
            colorHex: colorHex,
            imageUrl: imageUrl,
            printerCategory: printerCategory,
            updatedAt: updatedAt,
            isSynced: isSynced,
            version: version,
            isDeleted: isDeleted,
            outletId: outletId,
            isComposite: isComposite,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$ProductTableTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: (
              {productModifierLinkTableRefs = false,
              recipeTableRefs = false,
              localStocksTableRefs = false,
              productSupplierTableRefs = false,
              purchaseOrderItemTableRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (productModifierLinkTableRefs) db.productModifierLinkTable,
                if (recipeTableRefs) db.recipeTable,
                if (localStocksTableRefs) db.localStocksTable,
                if (productSupplierTableRefs) db.productSupplierTable,
                if (purchaseOrderItemTableRefs) db.purchaseOrderItemTable
              ],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (productModifierLinkTableRefs)
                    await $_getPrefetchedData<ProductTableData,
                            $ProductTableTable, ProductModifierLinkTableData>(
                        currentTable: table,
                        referencedTable: $$ProductTableTableReferences
                            ._productModifierLinkTableRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$ProductTableTableReferences(db, table, p0)
                                .productModifierLinkTableRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.productUuid == item.uuid),
                        typedResults: items),
                  if (recipeTableRefs)
                    await $_getPrefetchedData<ProductTableData,
                            $ProductTableTable, RecipeTableData>(
                        currentTable: table,
                        referencedTable: $$ProductTableTableReferences
                            ._recipeTableRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$ProductTableTableReferences(db, table, p0)
                                .recipeTableRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.productUuid == item.uuid),
                        typedResults: items),
                  if (localStocksTableRefs)
                    await $_getPrefetchedData<ProductTableData,
                            $ProductTableTable, LocalStocksTableData>(
                        currentTable: table,
                        referencedTable: $$ProductTableTableReferences
                            ._localStocksTableRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$ProductTableTableReferences(db, table, p0)
                                .localStocksTableRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.productUuid == item.uuid),
                        typedResults: items),
                  if (productSupplierTableRefs)
                    await $_getPrefetchedData<ProductTableData,
                            $ProductTableTable, ProductSupplierTableData>(
                        currentTable: table,
                        referencedTable: $$ProductTableTableReferences
                            ._productSupplierTableRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$ProductTableTableReferences(db, table, p0)
                                .productSupplierTableRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.productUuid == item.uuid),
                        typedResults: items),
                  if (purchaseOrderItemTableRefs)
                    await $_getPrefetchedData<ProductTableData,
                            $ProductTableTable, PurchaseOrderItemTableData>(
                        currentTable: table,
                        referencedTable: $$ProductTableTableReferences
                            ._purchaseOrderItemTableRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$ProductTableTableReferences(db, table, p0)
                                .purchaseOrderItemTableRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.productUuid == item.uuid),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $$ProductTableTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $ProductTableTable,
    ProductTableData,
    $$ProductTableTableFilterComposer,
    $$ProductTableTableOrderingComposer,
    $$ProductTableTableAnnotationComposer,
    $$ProductTableTableCreateCompanionBuilder,
    $$ProductTableTableUpdateCompanionBuilder,
    (ProductTableData, $$ProductTableTableReferences),
    ProductTableData,
    PrefetchHooks Function(
        {bool productModifierLinkTableRefs,
        bool recipeTableRefs,
        bool localStocksTableRefs,
        bool productSupplierTableRefs,
        bool purchaseOrderItemTableRefs})>;
typedef $$ModifierGroupTableTableCreateCompanionBuilder
    = ModifierGroupTableCompanion Function({
  Value<int> id,
  required String uuid,
  required String name,
  Value<bool> allowMultiSelect,
  Value<int> minSelection,
  Value<int?> maxSelection,
  required DateTime updatedAt,
  Value<bool> isDeleted,
});
typedef $$ModifierGroupTableTableUpdateCompanionBuilder
    = ModifierGroupTableCompanion Function({
  Value<int> id,
  Value<String> uuid,
  Value<String> name,
  Value<bool> allowMultiSelect,
  Value<int> minSelection,
  Value<int?> maxSelection,
  Value<DateTime> updatedAt,
  Value<bool> isDeleted,
});

final class $$ModifierGroupTableTableReferences extends BaseReferences<
    _$AppDatabase, $ModifierGroupTableTable, ModifierGroupTableData> {
  $$ModifierGroupTableTableReferences(
      super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$ModifierItemTableTable,
      List<ModifierItemTableData>> _modifierItemTableRefsTable(
          _$AppDatabase db) =>
      MultiTypedResultKey.fromTable(db.modifierItemTable,
          aliasName: $_aliasNameGenerator(
              db.modifierGroupTable.uuid, db.modifierItemTable.groupUuid));

  $$ModifierItemTableTableProcessedTableManager get modifierItemTableRefs {
    final manager = $$ModifierItemTableTableTableManager(
            $_db, $_db.modifierItemTable)
        .filter(
            (f) => f.groupUuid.uuid.sqlEquals($_itemColumn<String>('uuid')!));

    final cache =
        $_typedResult.readTableOrNull(_modifierItemTableRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$ProductModifierLinkTableTable,
      List<ProductModifierLinkTableData>> _productModifierLinkTableRefsTable(
          _$AppDatabase db) =>
      MultiTypedResultKey.fromTable(db.productModifierLinkTable,
          aliasName: $_aliasNameGenerator(db.modifierGroupTable.uuid,
              db.productModifierLinkTable.modifierGroupUuid));

  $$ProductModifierLinkTableTableProcessedTableManager
      get productModifierLinkTableRefs {
    final manager = $$ProductModifierLinkTableTableTableManager(
            $_db, $_db.productModifierLinkTable)
        .filter((f) =>
            f.modifierGroupUuid.uuid.sqlEquals($_itemColumn<String>('uuid')!));

    final cache =
        $_typedResult.readTableOrNull(_productModifierLinkTableRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $$ModifierGroupTableTableFilterComposer
    extends Composer<_$AppDatabase, $ModifierGroupTableTable> {
  $$ModifierGroupTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get allowMultiSelect => $composableBuilder(
      column: $table.allowMultiSelect,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get minSelection => $composableBuilder(
      column: $table.minSelection, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get maxSelection => $composableBuilder(
      column: $table.maxSelection, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnFilters(column));

  Expression<bool> modifierItemTableRefs(
      Expression<bool> Function($$ModifierItemTableTableFilterComposer f) f) {
    final $$ModifierItemTableTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.uuid,
        referencedTable: $db.modifierItemTable,
        getReferencedColumn: (t) => t.groupUuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ModifierItemTableTableFilterComposer(
              $db: $db,
              $table: $db.modifierItemTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> productModifierLinkTableRefs(
      Expression<bool> Function($$ProductModifierLinkTableTableFilterComposer f)
          f) {
    final $$ProductModifierLinkTableTableFilterComposer composer =
        $composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.uuid,
            referencedTable: $db.productModifierLinkTable,
            getReferencedColumn: (t) => t.modifierGroupUuid,
            builder: (joinBuilder,
                    {$addJoinBuilderToRootComposer,
                    $removeJoinBuilderFromRootComposer}) =>
                $$ProductModifierLinkTableTableFilterComposer(
                  $db: $db,
                  $table: $db.productModifierLinkTable,
                  $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                  joinBuilder: joinBuilder,
                  $removeJoinBuilderFromRootComposer:
                      $removeJoinBuilderFromRootComposer,
                ));
    return f(composer);
  }
}

class $$ModifierGroupTableTableOrderingComposer
    extends Composer<_$AppDatabase, $ModifierGroupTableTable> {
  $$ModifierGroupTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get allowMultiSelect => $composableBuilder(
      column: $table.allowMultiSelect,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get minSelection => $composableBuilder(
      column: $table.minSelection,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get maxSelection => $composableBuilder(
      column: $table.maxSelection,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnOrderings(column));
}

class $$ModifierGroupTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $ModifierGroupTableTable> {
  $$ModifierGroupTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<bool> get allowMultiSelect => $composableBuilder(
      column: $table.allowMultiSelect, builder: (column) => column);

  GeneratedColumn<int> get minSelection => $composableBuilder(
      column: $table.minSelection, builder: (column) => column);

  GeneratedColumn<int> get maxSelection => $composableBuilder(
      column: $table.maxSelection, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<bool> get isDeleted =>
      $composableBuilder(column: $table.isDeleted, builder: (column) => column);

  Expression<T> modifierItemTableRefs<T extends Object>(
      Expression<T> Function($$ModifierItemTableTableAnnotationComposer a) f) {
    final $$ModifierItemTableTableAnnotationComposer composer =
        $composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.uuid,
            referencedTable: $db.modifierItemTable,
            getReferencedColumn: (t) => t.groupUuid,
            builder: (joinBuilder,
                    {$addJoinBuilderToRootComposer,
                    $removeJoinBuilderFromRootComposer}) =>
                $$ModifierItemTableTableAnnotationComposer(
                  $db: $db,
                  $table: $db.modifierItemTable,
                  $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                  joinBuilder: joinBuilder,
                  $removeJoinBuilderFromRootComposer:
                      $removeJoinBuilderFromRootComposer,
                ));
    return f(composer);
  }

  Expression<T> productModifierLinkTableRefs<T extends Object>(
      Expression<T> Function(
              $$ProductModifierLinkTableTableAnnotationComposer a)
          f) {
    final $$ProductModifierLinkTableTableAnnotationComposer composer =
        $composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.uuid,
            referencedTable: $db.productModifierLinkTable,
            getReferencedColumn: (t) => t.modifierGroupUuid,
            builder: (joinBuilder,
                    {$addJoinBuilderToRootComposer,
                    $removeJoinBuilderFromRootComposer}) =>
                $$ProductModifierLinkTableTableAnnotationComposer(
                  $db: $db,
                  $table: $db.productModifierLinkTable,
                  $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                  joinBuilder: joinBuilder,
                  $removeJoinBuilderFromRootComposer:
                      $removeJoinBuilderFromRootComposer,
                ));
    return f(composer);
  }
}

class $$ModifierGroupTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $ModifierGroupTableTable,
    ModifierGroupTableData,
    $$ModifierGroupTableTableFilterComposer,
    $$ModifierGroupTableTableOrderingComposer,
    $$ModifierGroupTableTableAnnotationComposer,
    $$ModifierGroupTableTableCreateCompanionBuilder,
    $$ModifierGroupTableTableUpdateCompanionBuilder,
    (ModifierGroupTableData, $$ModifierGroupTableTableReferences),
    ModifierGroupTableData,
    PrefetchHooks Function(
        {bool modifierItemTableRefs, bool productModifierLinkTableRefs})> {
  $$ModifierGroupTableTableTableManager(
      _$AppDatabase db, $ModifierGroupTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ModifierGroupTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ModifierGroupTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ModifierGroupTableTableAnnotationComposer(
                  $db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String> name = const Value.absent(),
            Value<bool> allowMultiSelect = const Value.absent(),
            Value<int> minSelection = const Value.absent(),
            Value<int?> maxSelection = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
            Value<bool> isDeleted = const Value.absent(),
          }) =>
              ModifierGroupTableCompanion(
            id: id,
            uuid: uuid,
            name: name,
            allowMultiSelect: allowMultiSelect,
            minSelection: minSelection,
            maxSelection: maxSelection,
            updatedAt: updatedAt,
            isDeleted: isDeleted,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            required String name,
            Value<bool> allowMultiSelect = const Value.absent(),
            Value<int> minSelection = const Value.absent(),
            Value<int?> maxSelection = const Value.absent(),
            required DateTime updatedAt,
            Value<bool> isDeleted = const Value.absent(),
          }) =>
              ModifierGroupTableCompanion.insert(
            id: id,
            uuid: uuid,
            name: name,
            allowMultiSelect: allowMultiSelect,
            minSelection: minSelection,
            maxSelection: maxSelection,
            updatedAt: updatedAt,
            isDeleted: isDeleted,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$ModifierGroupTableTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: (
              {modifierItemTableRefs = false,
              productModifierLinkTableRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (modifierItemTableRefs) db.modifierItemTable,
                if (productModifierLinkTableRefs) db.productModifierLinkTable
              ],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (modifierItemTableRefs)
                    await $_getPrefetchedData<ModifierGroupTableData,
                            $ModifierGroupTableTable, ModifierItemTableData>(
                        currentTable: table,
                        referencedTable: $$ModifierGroupTableTableReferences
                            ._modifierItemTableRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$ModifierGroupTableTableReferences(db, table, p0)
                                .modifierItemTableRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.groupUuid == item.uuid),
                        typedResults: items),
                  if (productModifierLinkTableRefs)
                    await $_getPrefetchedData<
                            ModifierGroupTableData,
                            $ModifierGroupTableTable,
                            ProductModifierLinkTableData>(
                        currentTable: table,
                        referencedTable: $$ModifierGroupTableTableReferences
                            ._productModifierLinkTableRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$ModifierGroupTableTableReferences(db, table, p0)
                                .productModifierLinkTableRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.modifierGroupUuid == item.uuid),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $$ModifierGroupTableTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $ModifierGroupTableTable,
    ModifierGroupTableData,
    $$ModifierGroupTableTableFilterComposer,
    $$ModifierGroupTableTableOrderingComposer,
    $$ModifierGroupTableTableAnnotationComposer,
    $$ModifierGroupTableTableCreateCompanionBuilder,
    $$ModifierGroupTableTableUpdateCompanionBuilder,
    (ModifierGroupTableData, $$ModifierGroupTableTableReferences),
    ModifierGroupTableData,
    PrefetchHooks Function(
        {bool modifierItemTableRefs, bool productModifierLinkTableRefs})>;
typedef $$ModifierItemTableTableCreateCompanionBuilder
    = ModifierItemTableCompanion Function({
  Value<int> id,
  required String uuid,
  required String groupUuid,
  required String name,
  Value<double> priceDelta,
  required DateTime updatedAt,
  Value<bool> isDeleted,
});
typedef $$ModifierItemTableTableUpdateCompanionBuilder
    = ModifierItemTableCompanion Function({
  Value<int> id,
  Value<String> uuid,
  Value<String> groupUuid,
  Value<String> name,
  Value<double> priceDelta,
  Value<DateTime> updatedAt,
  Value<bool> isDeleted,
});

final class $$ModifierItemTableTableReferences extends BaseReferences<
    _$AppDatabase, $ModifierItemTableTable, ModifierItemTableData> {
  $$ModifierItemTableTableReferences(
      super.$_db, super.$_table, super.$_typedResult);

  static $ModifierGroupTableTable _groupUuidTable(_$AppDatabase db) =>
      db.modifierGroupTable.createAlias($_aliasNameGenerator(
          db.modifierItemTable.groupUuid, db.modifierGroupTable.uuid));

  $$ModifierGroupTableTableProcessedTableManager get groupUuid {
    final $_column = $_itemColumn<String>('group_uuid')!;

    final manager =
        $$ModifierGroupTableTableTableManager($_db, $_db.modifierGroupTable)
            .filter((f) => f.uuid.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_groupUuidTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }
}

class $$ModifierItemTableTableFilterComposer
    extends Composer<_$AppDatabase, $ModifierItemTableTable> {
  $$ModifierItemTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get priceDelta => $composableBuilder(
      column: $table.priceDelta, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnFilters(column));

  $$ModifierGroupTableTableFilterComposer get groupUuid {
    final $$ModifierGroupTableTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.groupUuid,
        referencedTable: $db.modifierGroupTable,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ModifierGroupTableTableFilterComposer(
              $db: $db,
              $table: $db.modifierGroupTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$ModifierItemTableTableOrderingComposer
    extends Composer<_$AppDatabase, $ModifierItemTableTable> {
  $$ModifierItemTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get priceDelta => $composableBuilder(
      column: $table.priceDelta, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnOrderings(column));

  $$ModifierGroupTableTableOrderingComposer get groupUuid {
    final $$ModifierGroupTableTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.groupUuid,
        referencedTable: $db.modifierGroupTable,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ModifierGroupTableTableOrderingComposer(
              $db: $db,
              $table: $db.modifierGroupTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$ModifierItemTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $ModifierItemTableTable> {
  $$ModifierItemTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<double> get priceDelta => $composableBuilder(
      column: $table.priceDelta, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<bool> get isDeleted =>
      $composableBuilder(column: $table.isDeleted, builder: (column) => column);

  $$ModifierGroupTableTableAnnotationComposer get groupUuid {
    final $$ModifierGroupTableTableAnnotationComposer composer =
        $composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.groupUuid,
            referencedTable: $db.modifierGroupTable,
            getReferencedColumn: (t) => t.uuid,
            builder: (joinBuilder,
                    {$addJoinBuilderToRootComposer,
                    $removeJoinBuilderFromRootComposer}) =>
                $$ModifierGroupTableTableAnnotationComposer(
                  $db: $db,
                  $table: $db.modifierGroupTable,
                  $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                  joinBuilder: joinBuilder,
                  $removeJoinBuilderFromRootComposer:
                      $removeJoinBuilderFromRootComposer,
                ));
    return composer;
  }
}

class $$ModifierItemTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $ModifierItemTableTable,
    ModifierItemTableData,
    $$ModifierItemTableTableFilterComposer,
    $$ModifierItemTableTableOrderingComposer,
    $$ModifierItemTableTableAnnotationComposer,
    $$ModifierItemTableTableCreateCompanionBuilder,
    $$ModifierItemTableTableUpdateCompanionBuilder,
    (ModifierItemTableData, $$ModifierItemTableTableReferences),
    ModifierItemTableData,
    PrefetchHooks Function({bool groupUuid})> {
  $$ModifierItemTableTableTableManager(
      _$AppDatabase db, $ModifierItemTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ModifierItemTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ModifierItemTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ModifierItemTableTableAnnotationComposer(
                  $db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String> groupUuid = const Value.absent(),
            Value<String> name = const Value.absent(),
            Value<double> priceDelta = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
            Value<bool> isDeleted = const Value.absent(),
          }) =>
              ModifierItemTableCompanion(
            id: id,
            uuid: uuid,
            groupUuid: groupUuid,
            name: name,
            priceDelta: priceDelta,
            updatedAt: updatedAt,
            isDeleted: isDeleted,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            required String groupUuid,
            required String name,
            Value<double> priceDelta = const Value.absent(),
            required DateTime updatedAt,
            Value<bool> isDeleted = const Value.absent(),
          }) =>
              ModifierItemTableCompanion.insert(
            id: id,
            uuid: uuid,
            groupUuid: groupUuid,
            name: name,
            priceDelta: priceDelta,
            updatedAt: updatedAt,
            isDeleted: isDeleted,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$ModifierItemTableTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: ({groupUuid = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (groupUuid) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.groupUuid,
                    referencedTable:
                        $$ModifierItemTableTableReferences._groupUuidTable(db),
                    referencedColumn: $$ModifierItemTableTableReferences
                        ._groupUuidTable(db)
                        .uuid,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ));
}

typedef $$ModifierItemTableTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $ModifierItemTableTable,
    ModifierItemTableData,
    $$ModifierItemTableTableFilterComposer,
    $$ModifierItemTableTableOrderingComposer,
    $$ModifierItemTableTableAnnotationComposer,
    $$ModifierItemTableTableCreateCompanionBuilder,
    $$ModifierItemTableTableUpdateCompanionBuilder,
    (ModifierItemTableData, $$ModifierItemTableTableReferences),
    ModifierItemTableData,
    PrefetchHooks Function({bool groupUuid})>;
typedef $$ProductModifierLinkTableTableCreateCompanionBuilder
    = ProductModifierLinkTableCompanion Function({
  Value<int> id,
  required String productUuid,
  required String modifierGroupUuid,
  Value<int> sortOrder,
});
typedef $$ProductModifierLinkTableTableUpdateCompanionBuilder
    = ProductModifierLinkTableCompanion Function({
  Value<int> id,
  Value<String> productUuid,
  Value<String> modifierGroupUuid,
  Value<int> sortOrder,
});

final class $$ProductModifierLinkTableTableReferences extends BaseReferences<
    _$AppDatabase,
    $ProductModifierLinkTableTable,
    ProductModifierLinkTableData> {
  $$ProductModifierLinkTableTableReferences(
      super.$_db, super.$_table, super.$_typedResult);

  static $ProductTableTable _productUuidTable(_$AppDatabase db) =>
      db.productTable.createAlias($_aliasNameGenerator(
          db.productModifierLinkTable.productUuid, db.productTable.uuid));

  $$ProductTableTableProcessedTableManager get productUuid {
    final $_column = $_itemColumn<String>('product_uuid')!;

    final manager = $$ProductTableTableTableManager($_db, $_db.productTable)
        .filter((f) => f.uuid.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_productUuidTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static $ModifierGroupTableTable _modifierGroupUuidTable(_$AppDatabase db) =>
      db.modifierGroupTable.createAlias($_aliasNameGenerator(
          db.productModifierLinkTable.modifierGroupUuid,
          db.modifierGroupTable.uuid));

  $$ModifierGroupTableTableProcessedTableManager get modifierGroupUuid {
    final $_column = $_itemColumn<String>('modifier_group_uuid')!;

    final manager =
        $$ModifierGroupTableTableTableManager($_db, $_db.modifierGroupTable)
            .filter((f) => f.uuid.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_modifierGroupUuidTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }
}

class $$ProductModifierLinkTableTableFilterComposer
    extends Composer<_$AppDatabase, $ProductModifierLinkTableTable> {
  $$ProductModifierLinkTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get sortOrder => $composableBuilder(
      column: $table.sortOrder, builder: (column) => ColumnFilters(column));

  $$ProductTableTableFilterComposer get productUuid {
    final $$ProductTableTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.productUuid,
        referencedTable: $db.productTable,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ProductTableTableFilterComposer(
              $db: $db,
              $table: $db.productTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$ModifierGroupTableTableFilterComposer get modifierGroupUuid {
    final $$ModifierGroupTableTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.modifierGroupUuid,
        referencedTable: $db.modifierGroupTable,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ModifierGroupTableTableFilterComposer(
              $db: $db,
              $table: $db.modifierGroupTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$ProductModifierLinkTableTableOrderingComposer
    extends Composer<_$AppDatabase, $ProductModifierLinkTableTable> {
  $$ProductModifierLinkTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get sortOrder => $composableBuilder(
      column: $table.sortOrder, builder: (column) => ColumnOrderings(column));

  $$ProductTableTableOrderingComposer get productUuid {
    final $$ProductTableTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.productUuid,
        referencedTable: $db.productTable,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ProductTableTableOrderingComposer(
              $db: $db,
              $table: $db.productTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$ModifierGroupTableTableOrderingComposer get modifierGroupUuid {
    final $$ModifierGroupTableTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.modifierGroupUuid,
        referencedTable: $db.modifierGroupTable,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ModifierGroupTableTableOrderingComposer(
              $db: $db,
              $table: $db.modifierGroupTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$ProductModifierLinkTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $ProductModifierLinkTableTable> {
  $$ProductModifierLinkTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<int> get sortOrder =>
      $composableBuilder(column: $table.sortOrder, builder: (column) => column);

  $$ProductTableTableAnnotationComposer get productUuid {
    final $$ProductTableTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.productUuid,
        referencedTable: $db.productTable,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ProductTableTableAnnotationComposer(
              $db: $db,
              $table: $db.productTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$ModifierGroupTableTableAnnotationComposer get modifierGroupUuid {
    final $$ModifierGroupTableTableAnnotationComposer composer =
        $composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.modifierGroupUuid,
            referencedTable: $db.modifierGroupTable,
            getReferencedColumn: (t) => t.uuid,
            builder: (joinBuilder,
                    {$addJoinBuilderToRootComposer,
                    $removeJoinBuilderFromRootComposer}) =>
                $$ModifierGroupTableTableAnnotationComposer(
                  $db: $db,
                  $table: $db.modifierGroupTable,
                  $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                  joinBuilder: joinBuilder,
                  $removeJoinBuilderFromRootComposer:
                      $removeJoinBuilderFromRootComposer,
                ));
    return composer;
  }
}

class $$ProductModifierLinkTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $ProductModifierLinkTableTable,
    ProductModifierLinkTableData,
    $$ProductModifierLinkTableTableFilterComposer,
    $$ProductModifierLinkTableTableOrderingComposer,
    $$ProductModifierLinkTableTableAnnotationComposer,
    $$ProductModifierLinkTableTableCreateCompanionBuilder,
    $$ProductModifierLinkTableTableUpdateCompanionBuilder,
    (ProductModifierLinkTableData, $$ProductModifierLinkTableTableReferences),
    ProductModifierLinkTableData,
    PrefetchHooks Function({bool productUuid, bool modifierGroupUuid})> {
  $$ProductModifierLinkTableTableTableManager(
      _$AppDatabase db, $ProductModifierLinkTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ProductModifierLinkTableTableFilterComposer(
                  $db: db, $table: table),
          createOrderingComposer: () =>
              $$ProductModifierLinkTableTableOrderingComposer(
                  $db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ProductModifierLinkTableTableAnnotationComposer(
                  $db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> productUuid = const Value.absent(),
            Value<String> modifierGroupUuid = const Value.absent(),
            Value<int> sortOrder = const Value.absent(),
          }) =>
              ProductModifierLinkTableCompanion(
            id: id,
            productUuid: productUuid,
            modifierGroupUuid: modifierGroupUuid,
            sortOrder: sortOrder,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String productUuid,
            required String modifierGroupUuid,
            Value<int> sortOrder = const Value.absent(),
          }) =>
              ProductModifierLinkTableCompanion.insert(
            id: id,
            productUuid: productUuid,
            modifierGroupUuid: modifierGroupUuid,
            sortOrder: sortOrder,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$ProductModifierLinkTableTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: (
              {productUuid = false, modifierGroupUuid = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (productUuid) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.productUuid,
                    referencedTable: $$ProductModifierLinkTableTableReferences
                        ._productUuidTable(db),
                    referencedColumn: $$ProductModifierLinkTableTableReferences
                        ._productUuidTable(db)
                        .uuid,
                  ) as T;
                }
                if (modifierGroupUuid) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.modifierGroupUuid,
                    referencedTable: $$ProductModifierLinkTableTableReferences
                        ._modifierGroupUuidTable(db),
                    referencedColumn: $$ProductModifierLinkTableTableReferences
                        ._modifierGroupUuidTable(db)
                        .uuid,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ));
}

typedef $$ProductModifierLinkTableTableProcessedTableManager
    = ProcessedTableManager<
        _$AppDatabase,
        $ProductModifierLinkTableTable,
        ProductModifierLinkTableData,
        $$ProductModifierLinkTableTableFilterComposer,
        $$ProductModifierLinkTableTableOrderingComposer,
        $$ProductModifierLinkTableTableAnnotationComposer,
        $$ProductModifierLinkTableTableCreateCompanionBuilder,
        $$ProductModifierLinkTableTableUpdateCompanionBuilder,
        (
          ProductModifierLinkTableData,
          $$ProductModifierLinkTableTableReferences
        ),
        ProductModifierLinkTableData,
        PrefetchHooks Function({bool productUuid, bool modifierGroupUuid})>;
typedef $$IngredientTableTableCreateCompanionBuilder = IngredientTableCompanion
    Function({
  Value<int> id,
  required String uuid,
  required String name,
  required String unit,
  Value<double> currentStock,
  Value<double> costPerUnit,
  required DateTime updatedAt,
  Value<bool> isDeleted,
});
typedef $$IngredientTableTableUpdateCompanionBuilder = IngredientTableCompanion
    Function({
  Value<int> id,
  Value<String> uuid,
  Value<String> name,
  Value<String> unit,
  Value<double> currentStock,
  Value<double> costPerUnit,
  Value<DateTime> updatedAt,
  Value<bool> isDeleted,
});

final class $$IngredientTableTableReferences extends BaseReferences<
    _$AppDatabase, $IngredientTableTable, IngredientTableData> {
  $$IngredientTableTableReferences(
      super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$RecipeTableTable, List<RecipeTableData>>
      _recipeTableRefsTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.recipeTable,
              aliasName: $_aliasNameGenerator(
                  db.ingredientTable.uuid, db.recipeTable.ingredientUuid));

  $$RecipeTableTableProcessedTableManager get recipeTableRefs {
    final manager = $$RecipeTableTableTableManager($_db, $_db.recipeTable)
        .filter((f) =>
            f.ingredientUuid.uuid.sqlEquals($_itemColumn<String>('uuid')!));

    final cache = $_typedResult.readTableOrNull(_recipeTableRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$PurchaseOrderItemTableTable,
      List<PurchaseOrderItemTableData>> _purchaseOrderItemTableRefsTable(
          _$AppDatabase db) =>
      MultiTypedResultKey.fromTable(db.purchaseOrderItemTable,
          aliasName: $_aliasNameGenerator(db.ingredientTable.uuid,
              db.purchaseOrderItemTable.ingredientUuid));

  $$PurchaseOrderItemTableTableProcessedTableManager
      get purchaseOrderItemTableRefs {
    final manager = $$PurchaseOrderItemTableTableTableManager(
            $_db, $_db.purchaseOrderItemTable)
        .filter((f) =>
            f.ingredientUuid.uuid.sqlEquals($_itemColumn<String>('uuid')!));

    final cache =
        $_typedResult.readTableOrNull(_purchaseOrderItemTableRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $$IngredientTableTableFilterComposer
    extends Composer<_$AppDatabase, $IngredientTableTable> {
  $$IngredientTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get unit => $composableBuilder(
      column: $table.unit, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get currentStock => $composableBuilder(
      column: $table.currentStock, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get costPerUnit => $composableBuilder(
      column: $table.costPerUnit, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnFilters(column));

  Expression<bool> recipeTableRefs(
      Expression<bool> Function($$RecipeTableTableFilterComposer f) f) {
    final $$RecipeTableTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.uuid,
        referencedTable: $db.recipeTable,
        getReferencedColumn: (t) => t.ingredientUuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$RecipeTableTableFilterComposer(
              $db: $db,
              $table: $db.recipeTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> purchaseOrderItemTableRefs(
      Expression<bool> Function($$PurchaseOrderItemTableTableFilterComposer f)
          f) {
    final $$PurchaseOrderItemTableTableFilterComposer composer =
        $composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.uuid,
            referencedTable: $db.purchaseOrderItemTable,
            getReferencedColumn: (t) => t.ingredientUuid,
            builder: (joinBuilder,
                    {$addJoinBuilderToRootComposer,
                    $removeJoinBuilderFromRootComposer}) =>
                $$PurchaseOrderItemTableTableFilterComposer(
                  $db: $db,
                  $table: $db.purchaseOrderItemTable,
                  $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                  joinBuilder: joinBuilder,
                  $removeJoinBuilderFromRootComposer:
                      $removeJoinBuilderFromRootComposer,
                ));
    return f(composer);
  }
}

class $$IngredientTableTableOrderingComposer
    extends Composer<_$AppDatabase, $IngredientTableTable> {
  $$IngredientTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get unit => $composableBuilder(
      column: $table.unit, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get currentStock => $composableBuilder(
      column: $table.currentStock,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get costPerUnit => $composableBuilder(
      column: $table.costPerUnit, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnOrderings(column));
}

class $$IngredientTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $IngredientTableTable> {
  $$IngredientTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get unit =>
      $composableBuilder(column: $table.unit, builder: (column) => column);

  GeneratedColumn<double> get currentStock => $composableBuilder(
      column: $table.currentStock, builder: (column) => column);

  GeneratedColumn<double> get costPerUnit => $composableBuilder(
      column: $table.costPerUnit, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<bool> get isDeleted =>
      $composableBuilder(column: $table.isDeleted, builder: (column) => column);

  Expression<T> recipeTableRefs<T extends Object>(
      Expression<T> Function($$RecipeTableTableAnnotationComposer a) f) {
    final $$RecipeTableTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.uuid,
        referencedTable: $db.recipeTable,
        getReferencedColumn: (t) => t.ingredientUuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$RecipeTableTableAnnotationComposer(
              $db: $db,
              $table: $db.recipeTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> purchaseOrderItemTableRefs<T extends Object>(
      Expression<T> Function($$PurchaseOrderItemTableTableAnnotationComposer a)
          f) {
    final $$PurchaseOrderItemTableTableAnnotationComposer composer =
        $composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.uuid,
            referencedTable: $db.purchaseOrderItemTable,
            getReferencedColumn: (t) => t.ingredientUuid,
            builder: (joinBuilder,
                    {$addJoinBuilderToRootComposer,
                    $removeJoinBuilderFromRootComposer}) =>
                $$PurchaseOrderItemTableTableAnnotationComposer(
                  $db: $db,
                  $table: $db.purchaseOrderItemTable,
                  $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                  joinBuilder: joinBuilder,
                  $removeJoinBuilderFromRootComposer:
                      $removeJoinBuilderFromRootComposer,
                ));
    return f(composer);
  }
}

class $$IngredientTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $IngredientTableTable,
    IngredientTableData,
    $$IngredientTableTableFilterComposer,
    $$IngredientTableTableOrderingComposer,
    $$IngredientTableTableAnnotationComposer,
    $$IngredientTableTableCreateCompanionBuilder,
    $$IngredientTableTableUpdateCompanionBuilder,
    (IngredientTableData, $$IngredientTableTableReferences),
    IngredientTableData,
    PrefetchHooks Function(
        {bool recipeTableRefs, bool purchaseOrderItemTableRefs})> {
  $$IngredientTableTableTableManager(
      _$AppDatabase db, $IngredientTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$IngredientTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$IngredientTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$IngredientTableTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String> name = const Value.absent(),
            Value<String> unit = const Value.absent(),
            Value<double> currentStock = const Value.absent(),
            Value<double> costPerUnit = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
            Value<bool> isDeleted = const Value.absent(),
          }) =>
              IngredientTableCompanion(
            id: id,
            uuid: uuid,
            name: name,
            unit: unit,
            currentStock: currentStock,
            costPerUnit: costPerUnit,
            updatedAt: updatedAt,
            isDeleted: isDeleted,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            required String name,
            required String unit,
            Value<double> currentStock = const Value.absent(),
            Value<double> costPerUnit = const Value.absent(),
            required DateTime updatedAt,
            Value<bool> isDeleted = const Value.absent(),
          }) =>
              IngredientTableCompanion.insert(
            id: id,
            uuid: uuid,
            name: name,
            unit: unit,
            currentStock: currentStock,
            costPerUnit: costPerUnit,
            updatedAt: updatedAt,
            isDeleted: isDeleted,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$IngredientTableTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: (
              {recipeTableRefs = false, purchaseOrderItemTableRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (recipeTableRefs) db.recipeTable,
                if (purchaseOrderItemTableRefs) db.purchaseOrderItemTable
              ],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (recipeTableRefs)
                    await $_getPrefetchedData<IngredientTableData,
                            $IngredientTableTable, RecipeTableData>(
                        currentTable: table,
                        referencedTable: $$IngredientTableTableReferences
                            ._recipeTableRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$IngredientTableTableReferences(db, table, p0)
                                .recipeTableRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.ingredientUuid == item.uuid),
                        typedResults: items),
                  if (purchaseOrderItemTableRefs)
                    await $_getPrefetchedData<IngredientTableData,
                            $IngredientTableTable, PurchaseOrderItemTableData>(
                        currentTable: table,
                        referencedTable: $$IngredientTableTableReferences
                            ._purchaseOrderItemTableRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$IngredientTableTableReferences(db, table, p0)
                                .purchaseOrderItemTableRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.ingredientUuid == item.uuid),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $$IngredientTableTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $IngredientTableTable,
    IngredientTableData,
    $$IngredientTableTableFilterComposer,
    $$IngredientTableTableOrderingComposer,
    $$IngredientTableTableAnnotationComposer,
    $$IngredientTableTableCreateCompanionBuilder,
    $$IngredientTableTableUpdateCompanionBuilder,
    (IngredientTableData, $$IngredientTableTableReferences),
    IngredientTableData,
    PrefetchHooks Function(
        {bool recipeTableRefs, bool purchaseOrderItemTableRefs})>;
typedef $$RecipeTableTableCreateCompanionBuilder = RecipeTableCompanion
    Function({
  Value<int> id,
  required String productUuid,
  required String ingredientUuid,
  required double quantityRequired,
});
typedef $$RecipeTableTableUpdateCompanionBuilder = RecipeTableCompanion
    Function({
  Value<int> id,
  Value<String> productUuid,
  Value<String> ingredientUuid,
  Value<double> quantityRequired,
});

final class $$RecipeTableTableReferences
    extends BaseReferences<_$AppDatabase, $RecipeTableTable, RecipeTableData> {
  $$RecipeTableTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $ProductTableTable _productUuidTable(_$AppDatabase db) =>
      db.productTable.createAlias($_aliasNameGenerator(
          db.recipeTable.productUuid, db.productTable.uuid));

  $$ProductTableTableProcessedTableManager get productUuid {
    final $_column = $_itemColumn<String>('product_uuid')!;

    final manager = $$ProductTableTableTableManager($_db, $_db.productTable)
        .filter((f) => f.uuid.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_productUuidTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static $IngredientTableTable _ingredientUuidTable(_$AppDatabase db) =>
      db.ingredientTable.createAlias($_aliasNameGenerator(
          db.recipeTable.ingredientUuid, db.ingredientTable.uuid));

  $$IngredientTableTableProcessedTableManager get ingredientUuid {
    final $_column = $_itemColumn<String>('ingredient_uuid')!;

    final manager =
        $$IngredientTableTableTableManager($_db, $_db.ingredientTable)
            .filter((f) => f.uuid.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_ingredientUuidTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }
}

class $$RecipeTableTableFilterComposer
    extends Composer<_$AppDatabase, $RecipeTableTable> {
  $$RecipeTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get quantityRequired => $composableBuilder(
      column: $table.quantityRequired,
      builder: (column) => ColumnFilters(column));

  $$ProductTableTableFilterComposer get productUuid {
    final $$ProductTableTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.productUuid,
        referencedTable: $db.productTable,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ProductTableTableFilterComposer(
              $db: $db,
              $table: $db.productTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$IngredientTableTableFilterComposer get ingredientUuid {
    final $$IngredientTableTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.ingredientUuid,
        referencedTable: $db.ingredientTable,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$IngredientTableTableFilterComposer(
              $db: $db,
              $table: $db.ingredientTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$RecipeTableTableOrderingComposer
    extends Composer<_$AppDatabase, $RecipeTableTable> {
  $$RecipeTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get quantityRequired => $composableBuilder(
      column: $table.quantityRequired,
      builder: (column) => ColumnOrderings(column));

  $$ProductTableTableOrderingComposer get productUuid {
    final $$ProductTableTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.productUuid,
        referencedTable: $db.productTable,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ProductTableTableOrderingComposer(
              $db: $db,
              $table: $db.productTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$IngredientTableTableOrderingComposer get ingredientUuid {
    final $$IngredientTableTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.ingredientUuid,
        referencedTable: $db.ingredientTable,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$IngredientTableTableOrderingComposer(
              $db: $db,
              $table: $db.ingredientTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$RecipeTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $RecipeTableTable> {
  $$RecipeTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<double> get quantityRequired => $composableBuilder(
      column: $table.quantityRequired, builder: (column) => column);

  $$ProductTableTableAnnotationComposer get productUuid {
    final $$ProductTableTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.productUuid,
        referencedTable: $db.productTable,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ProductTableTableAnnotationComposer(
              $db: $db,
              $table: $db.productTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$IngredientTableTableAnnotationComposer get ingredientUuid {
    final $$IngredientTableTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.ingredientUuid,
        referencedTable: $db.ingredientTable,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$IngredientTableTableAnnotationComposer(
              $db: $db,
              $table: $db.ingredientTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$RecipeTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $RecipeTableTable,
    RecipeTableData,
    $$RecipeTableTableFilterComposer,
    $$RecipeTableTableOrderingComposer,
    $$RecipeTableTableAnnotationComposer,
    $$RecipeTableTableCreateCompanionBuilder,
    $$RecipeTableTableUpdateCompanionBuilder,
    (RecipeTableData, $$RecipeTableTableReferences),
    RecipeTableData,
    PrefetchHooks Function({bool productUuid, bool ingredientUuid})> {
  $$RecipeTableTableTableManager(_$AppDatabase db, $RecipeTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$RecipeTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$RecipeTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$RecipeTableTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> productUuid = const Value.absent(),
            Value<String> ingredientUuid = const Value.absent(),
            Value<double> quantityRequired = const Value.absent(),
          }) =>
              RecipeTableCompanion(
            id: id,
            productUuid: productUuid,
            ingredientUuid: ingredientUuid,
            quantityRequired: quantityRequired,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String productUuid,
            required String ingredientUuid,
            required double quantityRequired,
          }) =>
              RecipeTableCompanion.insert(
            id: id,
            productUuid: productUuid,
            ingredientUuid: ingredientUuid,
            quantityRequired: quantityRequired,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$RecipeTableTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: (
              {productUuid = false, ingredientUuid = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (productUuid) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.productUuid,
                    referencedTable:
                        $$RecipeTableTableReferences._productUuidTable(db),
                    referencedColumn:
                        $$RecipeTableTableReferences._productUuidTable(db).uuid,
                  ) as T;
                }
                if (ingredientUuid) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.ingredientUuid,
                    referencedTable:
                        $$RecipeTableTableReferences._ingredientUuidTable(db),
                    referencedColumn: $$RecipeTableTableReferences
                        ._ingredientUuidTable(db)
                        .uuid,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ));
}

typedef $$RecipeTableTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $RecipeTableTable,
    RecipeTableData,
    $$RecipeTableTableFilterComposer,
    $$RecipeTableTableOrderingComposer,
    $$RecipeTableTableAnnotationComposer,
    $$RecipeTableTableCreateCompanionBuilder,
    $$RecipeTableTableUpdateCompanionBuilder,
    (RecipeTableData, $$RecipeTableTableReferences),
    RecipeTableData,
    PrefetchHooks Function({bool productUuid, bool ingredientUuid})>;
typedef $$CustomerTableTableCreateCompanionBuilder = CustomerTableCompanion
    Function({
  Value<int> id,
  required String uuid,
  required String name,
  Value<String?> phone,
  Value<String?> email,
  Value<double> totalPoints,
  Value<DateTime?> lastVisitAt,
  required DateTime updatedAt,
  Value<bool> isSynced,
  Value<int> version,
  Value<bool> isDeleted,
});
typedef $$CustomerTableTableUpdateCompanionBuilder = CustomerTableCompanion
    Function({
  Value<int> id,
  Value<String> uuid,
  Value<String> name,
  Value<String?> phone,
  Value<String?> email,
  Value<double> totalPoints,
  Value<DateTime?> lastVisitAt,
  Value<DateTime> updatedAt,
  Value<bool> isSynced,
  Value<int> version,
  Value<bool> isDeleted,
});

final class $$CustomerTableTableReferences extends BaseReferences<_$AppDatabase,
    $CustomerTableTable, CustomerTableData> {
  $$CustomerTableTableReferences(
      super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$CustomerFeedbackTableTable,
      List<CustomerFeedbackTableData>> _customerFeedbackTableRefsTable(
          _$AppDatabase db) =>
      MultiTypedResultKey.fromTable(db.customerFeedbackTable,
          aliasName: $_aliasNameGenerator(
              db.customerTable.uuid, db.customerFeedbackTable.customerUuid));

  $$CustomerFeedbackTableTableProcessedTableManager
      get customerFeedbackTableRefs {
    final manager = $$CustomerFeedbackTableTableTableManager(
            $_db, $_db.customerFeedbackTable)
        .filter((f) =>
            f.customerUuid.uuid.sqlEquals($_itemColumn<String>('uuid')!));

    final cache =
        $_typedResult.readTableOrNull(_customerFeedbackTableRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $$CustomerTableTableFilterComposer
    extends Composer<_$AppDatabase, $CustomerTableTable> {
  $$CustomerTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get phone => $composableBuilder(
      column: $table.phone, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get email => $composableBuilder(
      column: $table.email, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get totalPoints => $composableBuilder(
      column: $table.totalPoints, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get lastVisitAt => $composableBuilder(
      column: $table.lastVisitAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isSynced => $composableBuilder(
      column: $table.isSynced, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get version => $composableBuilder(
      column: $table.version, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnFilters(column));

  Expression<bool> customerFeedbackTableRefs(
      Expression<bool> Function($$CustomerFeedbackTableTableFilterComposer f)
          f) {
    final $$CustomerFeedbackTableTableFilterComposer composer =
        $composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.uuid,
            referencedTable: $db.customerFeedbackTable,
            getReferencedColumn: (t) => t.customerUuid,
            builder: (joinBuilder,
                    {$addJoinBuilderToRootComposer,
                    $removeJoinBuilderFromRootComposer}) =>
                $$CustomerFeedbackTableTableFilterComposer(
                  $db: $db,
                  $table: $db.customerFeedbackTable,
                  $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                  joinBuilder: joinBuilder,
                  $removeJoinBuilderFromRootComposer:
                      $removeJoinBuilderFromRootComposer,
                ));
    return f(composer);
  }
}

class $$CustomerTableTableOrderingComposer
    extends Composer<_$AppDatabase, $CustomerTableTable> {
  $$CustomerTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get phone => $composableBuilder(
      column: $table.phone, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get email => $composableBuilder(
      column: $table.email, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get totalPoints => $composableBuilder(
      column: $table.totalPoints, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get lastVisitAt => $composableBuilder(
      column: $table.lastVisitAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isSynced => $composableBuilder(
      column: $table.isSynced, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get version => $composableBuilder(
      column: $table.version, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnOrderings(column));
}

class $$CustomerTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $CustomerTableTable> {
  $$CustomerTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get phone =>
      $composableBuilder(column: $table.phone, builder: (column) => column);

  GeneratedColumn<String> get email =>
      $composableBuilder(column: $table.email, builder: (column) => column);

  GeneratedColumn<double> get totalPoints => $composableBuilder(
      column: $table.totalPoints, builder: (column) => column);

  GeneratedColumn<DateTime> get lastVisitAt => $composableBuilder(
      column: $table.lastVisitAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<bool> get isSynced =>
      $composableBuilder(column: $table.isSynced, builder: (column) => column);

  GeneratedColumn<int> get version =>
      $composableBuilder(column: $table.version, builder: (column) => column);

  GeneratedColumn<bool> get isDeleted =>
      $composableBuilder(column: $table.isDeleted, builder: (column) => column);

  Expression<T> customerFeedbackTableRefs<T extends Object>(
      Expression<T> Function($$CustomerFeedbackTableTableAnnotationComposer a)
          f) {
    final $$CustomerFeedbackTableTableAnnotationComposer composer =
        $composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.uuid,
            referencedTable: $db.customerFeedbackTable,
            getReferencedColumn: (t) => t.customerUuid,
            builder: (joinBuilder,
                    {$addJoinBuilderToRootComposer,
                    $removeJoinBuilderFromRootComposer}) =>
                $$CustomerFeedbackTableTableAnnotationComposer(
                  $db: $db,
                  $table: $db.customerFeedbackTable,
                  $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                  joinBuilder: joinBuilder,
                  $removeJoinBuilderFromRootComposer:
                      $removeJoinBuilderFromRootComposer,
                ));
    return f(composer);
  }
}

class $$CustomerTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $CustomerTableTable,
    CustomerTableData,
    $$CustomerTableTableFilterComposer,
    $$CustomerTableTableOrderingComposer,
    $$CustomerTableTableAnnotationComposer,
    $$CustomerTableTableCreateCompanionBuilder,
    $$CustomerTableTableUpdateCompanionBuilder,
    (CustomerTableData, $$CustomerTableTableReferences),
    CustomerTableData,
    PrefetchHooks Function({bool customerFeedbackTableRefs})> {
  $$CustomerTableTableTableManager(_$AppDatabase db, $CustomerTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$CustomerTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$CustomerTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$CustomerTableTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String> name = const Value.absent(),
            Value<String?> phone = const Value.absent(),
            Value<String?> email = const Value.absent(),
            Value<double> totalPoints = const Value.absent(),
            Value<DateTime?> lastVisitAt = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
            Value<bool> isSynced = const Value.absent(),
            Value<int> version = const Value.absent(),
            Value<bool> isDeleted = const Value.absent(),
          }) =>
              CustomerTableCompanion(
            id: id,
            uuid: uuid,
            name: name,
            phone: phone,
            email: email,
            totalPoints: totalPoints,
            lastVisitAt: lastVisitAt,
            updatedAt: updatedAt,
            isSynced: isSynced,
            version: version,
            isDeleted: isDeleted,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            required String name,
            Value<String?> phone = const Value.absent(),
            Value<String?> email = const Value.absent(),
            Value<double> totalPoints = const Value.absent(),
            Value<DateTime?> lastVisitAt = const Value.absent(),
            required DateTime updatedAt,
            Value<bool> isSynced = const Value.absent(),
            Value<int> version = const Value.absent(),
            Value<bool> isDeleted = const Value.absent(),
          }) =>
              CustomerTableCompanion.insert(
            id: id,
            uuid: uuid,
            name: name,
            phone: phone,
            email: email,
            totalPoints: totalPoints,
            lastVisitAt: lastVisitAt,
            updatedAt: updatedAt,
            isSynced: isSynced,
            version: version,
            isDeleted: isDeleted,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$CustomerTableTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: ({customerFeedbackTableRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (customerFeedbackTableRefs) db.customerFeedbackTable
              ],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (customerFeedbackTableRefs)
                    await $_getPrefetchedData<CustomerTableData,
                            $CustomerTableTable, CustomerFeedbackTableData>(
                        currentTable: table,
                        referencedTable: $$CustomerTableTableReferences
                            ._customerFeedbackTableRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$CustomerTableTableReferences(db, table, p0)
                                .customerFeedbackTableRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.customerUuid == item.uuid),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $$CustomerTableTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $CustomerTableTable,
    CustomerTableData,
    $$CustomerTableTableFilterComposer,
    $$CustomerTableTableOrderingComposer,
    $$CustomerTableTableAnnotationComposer,
    $$CustomerTableTableCreateCompanionBuilder,
    $$CustomerTableTableUpdateCompanionBuilder,
    (CustomerTableData, $$CustomerTableTableReferences),
    CustomerTableData,
    PrefetchHooks Function({bool customerFeedbackTableRefs})>;
typedef $$OrderTableTableCreateCompanionBuilder = OrderTableCompanion Function({
  Value<int> id,
  required String uuid,
  required String orderNumber,
  Value<String?> shiftUuid,
  Value<String?> customerUuid,
  Value<String?> tenantId,
  Value<String?> outletId,
  Value<String> status,
  Value<String> paymentStatus,
  required DateTime transactionDate,
  required double subtotal,
  required double discountTotal,
  required double taxTotal,
  required double grandTotal,
  Value<String?> paymentMethod,
  Value<double?> tenderedAmount,
  Value<double?> changeAmount,
  Value<DateTime> updatedAt,
  Value<bool> isSynced,
  Value<int> version,
  Value<int> syncAttempts,
  Value<bool> isFulfilled,
});
typedef $$OrderTableTableUpdateCompanionBuilder = OrderTableCompanion Function({
  Value<int> id,
  Value<String> uuid,
  Value<String> orderNumber,
  Value<String?> shiftUuid,
  Value<String?> customerUuid,
  Value<String?> tenantId,
  Value<String?> outletId,
  Value<String> status,
  Value<String> paymentStatus,
  Value<DateTime> transactionDate,
  Value<double> subtotal,
  Value<double> discountTotal,
  Value<double> taxTotal,
  Value<double> grandTotal,
  Value<String?> paymentMethod,
  Value<double?> tenderedAmount,
  Value<double?> changeAmount,
  Value<DateTime> updatedAt,
  Value<bool> isSynced,
  Value<int> version,
  Value<int> syncAttempts,
  Value<bool> isFulfilled,
});

final class $$OrderTableTableReferences
    extends BaseReferences<_$AppDatabase, $OrderTableTable, OrderTableData> {
  $$OrderTableTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$OrderItemTableTable, List<OrderItemTableData>>
      _orderItemTableRefsTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.orderItemTable,
              aliasName: $_aliasNameGenerator(
                  db.orderTable.uuid, db.orderItemTable.orderUuid));

  $$OrderItemTableTableProcessedTableManager get orderItemTableRefs {
    final manager = $$OrderItemTableTableTableManager($_db, $_db.orderItemTable)
        .filter(
            (f) => f.orderUuid.uuid.sqlEquals($_itemColumn<String>('uuid')!));

    final cache = $_typedResult.readTableOrNull(_orderItemTableRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$DeliveryOrderMetadataTableTable,
          List<DeliveryOrderMetadataTableData>>
      _deliveryOrderMetadataTableRefsTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.deliveryOrderMetadataTable,
              aliasName: $_aliasNameGenerator(
                  db.orderTable.uuid, db.deliveryOrderMetadataTable.orderUuid));

  $$DeliveryOrderMetadataTableTableProcessedTableManager
      get deliveryOrderMetadataTableRefs {
    final manager = $$DeliveryOrderMetadataTableTableTableManager(
            $_db, $_db.deliveryOrderMetadataTable)
        .filter(
            (f) => f.orderUuid.uuid.sqlEquals($_itemColumn<String>('uuid')!));

    final cache = $_typedResult
        .readTableOrNull(_deliveryOrderMetadataTableRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$PaymentTransactionTableTable,
      List<PaymentTransactionTableData>> _paymentTransactionTableRefsTable(
          _$AppDatabase db) =>
      MultiTypedResultKey.fromTable(db.paymentTransactionTable,
          aliasName: $_aliasNameGenerator(
              db.orderTable.uuid, db.paymentTransactionTable.orderUuid));

  $$PaymentTransactionTableTableProcessedTableManager
      get paymentTransactionTableRefs {
    final manager = $$PaymentTransactionTableTableTableManager(
            $_db, $_db.paymentTransactionTable)
        .filter(
            (f) => f.orderUuid.uuid.sqlEquals($_itemColumn<String>('uuid')!));

    final cache =
        $_typedResult.readTableOrNull(_paymentTransactionTableRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$CustomerFeedbackTableTable,
      List<CustomerFeedbackTableData>> _customerFeedbackTableRefsTable(
          _$AppDatabase db) =>
      MultiTypedResultKey.fromTable(db.customerFeedbackTable,
          aliasName: $_aliasNameGenerator(
              db.orderTable.uuid, db.customerFeedbackTable.orderUuid));

  $$CustomerFeedbackTableTableProcessedTableManager
      get customerFeedbackTableRefs {
    final manager = $$CustomerFeedbackTableTableTableManager(
            $_db, $_db.customerFeedbackTable)
        .filter(
            (f) => f.orderUuid.uuid.sqlEquals($_itemColumn<String>('uuid')!));

    final cache =
        $_typedResult.readTableOrNull(_customerFeedbackTableRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $$OrderTableTableFilterComposer
    extends Composer<_$AppDatabase, $OrderTableTable> {
  $$OrderTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get orderNumber => $composableBuilder(
      column: $table.orderNumber, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get shiftUuid => $composableBuilder(
      column: $table.shiftUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get customerUuid => $composableBuilder(
      column: $table.customerUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get tenantId => $composableBuilder(
      column: $table.tenantId, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get outletId => $composableBuilder(
      column: $table.outletId, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get paymentStatus => $composableBuilder(
      column: $table.paymentStatus, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get transactionDate => $composableBuilder(
      column: $table.transactionDate,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get subtotal => $composableBuilder(
      column: $table.subtotal, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get discountTotal => $composableBuilder(
      column: $table.discountTotal, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get taxTotal => $composableBuilder(
      column: $table.taxTotal, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get grandTotal => $composableBuilder(
      column: $table.grandTotal, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get paymentMethod => $composableBuilder(
      column: $table.paymentMethod, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get tenderedAmount => $composableBuilder(
      column: $table.tenderedAmount,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get changeAmount => $composableBuilder(
      column: $table.changeAmount, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isSynced => $composableBuilder(
      column: $table.isSynced, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get version => $composableBuilder(
      column: $table.version, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get syncAttempts => $composableBuilder(
      column: $table.syncAttempts, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isFulfilled => $composableBuilder(
      column: $table.isFulfilled, builder: (column) => ColumnFilters(column));

  Expression<bool> orderItemTableRefs(
      Expression<bool> Function($$OrderItemTableTableFilterComposer f) f) {
    final $$OrderItemTableTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.uuid,
        referencedTable: $db.orderItemTable,
        getReferencedColumn: (t) => t.orderUuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$OrderItemTableTableFilterComposer(
              $db: $db,
              $table: $db.orderItemTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> deliveryOrderMetadataTableRefs(
      Expression<bool> Function(
              $$DeliveryOrderMetadataTableTableFilterComposer f)
          f) {
    final $$DeliveryOrderMetadataTableTableFilterComposer composer =
        $composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.uuid,
            referencedTable: $db.deliveryOrderMetadataTable,
            getReferencedColumn: (t) => t.orderUuid,
            builder: (joinBuilder,
                    {$addJoinBuilderToRootComposer,
                    $removeJoinBuilderFromRootComposer}) =>
                $$DeliveryOrderMetadataTableTableFilterComposer(
                  $db: $db,
                  $table: $db.deliveryOrderMetadataTable,
                  $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                  joinBuilder: joinBuilder,
                  $removeJoinBuilderFromRootComposer:
                      $removeJoinBuilderFromRootComposer,
                ));
    return f(composer);
  }

  Expression<bool> paymentTransactionTableRefs(
      Expression<bool> Function($$PaymentTransactionTableTableFilterComposer f)
          f) {
    final $$PaymentTransactionTableTableFilterComposer composer =
        $composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.uuid,
            referencedTable: $db.paymentTransactionTable,
            getReferencedColumn: (t) => t.orderUuid,
            builder: (joinBuilder,
                    {$addJoinBuilderToRootComposer,
                    $removeJoinBuilderFromRootComposer}) =>
                $$PaymentTransactionTableTableFilterComposer(
                  $db: $db,
                  $table: $db.paymentTransactionTable,
                  $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                  joinBuilder: joinBuilder,
                  $removeJoinBuilderFromRootComposer:
                      $removeJoinBuilderFromRootComposer,
                ));
    return f(composer);
  }

  Expression<bool> customerFeedbackTableRefs(
      Expression<bool> Function($$CustomerFeedbackTableTableFilterComposer f)
          f) {
    final $$CustomerFeedbackTableTableFilterComposer composer =
        $composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.uuid,
            referencedTable: $db.customerFeedbackTable,
            getReferencedColumn: (t) => t.orderUuid,
            builder: (joinBuilder,
                    {$addJoinBuilderToRootComposer,
                    $removeJoinBuilderFromRootComposer}) =>
                $$CustomerFeedbackTableTableFilterComposer(
                  $db: $db,
                  $table: $db.customerFeedbackTable,
                  $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                  joinBuilder: joinBuilder,
                  $removeJoinBuilderFromRootComposer:
                      $removeJoinBuilderFromRootComposer,
                ));
    return f(composer);
  }
}

class $$OrderTableTableOrderingComposer
    extends Composer<_$AppDatabase, $OrderTableTable> {
  $$OrderTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get orderNumber => $composableBuilder(
      column: $table.orderNumber, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get shiftUuid => $composableBuilder(
      column: $table.shiftUuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get customerUuid => $composableBuilder(
      column: $table.customerUuid,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get tenantId => $composableBuilder(
      column: $table.tenantId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get outletId => $composableBuilder(
      column: $table.outletId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get paymentStatus => $composableBuilder(
      column: $table.paymentStatus,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get transactionDate => $composableBuilder(
      column: $table.transactionDate,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get subtotal => $composableBuilder(
      column: $table.subtotal, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get discountTotal => $composableBuilder(
      column: $table.discountTotal,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get taxTotal => $composableBuilder(
      column: $table.taxTotal, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get grandTotal => $composableBuilder(
      column: $table.grandTotal, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get paymentMethod => $composableBuilder(
      column: $table.paymentMethod,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get tenderedAmount => $composableBuilder(
      column: $table.tenderedAmount,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get changeAmount => $composableBuilder(
      column: $table.changeAmount,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isSynced => $composableBuilder(
      column: $table.isSynced, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get version => $composableBuilder(
      column: $table.version, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get syncAttempts => $composableBuilder(
      column: $table.syncAttempts,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isFulfilled => $composableBuilder(
      column: $table.isFulfilled, builder: (column) => ColumnOrderings(column));
}

class $$OrderTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $OrderTableTable> {
  $$OrderTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get orderNumber => $composableBuilder(
      column: $table.orderNumber, builder: (column) => column);

  GeneratedColumn<String> get shiftUuid =>
      $composableBuilder(column: $table.shiftUuid, builder: (column) => column);

  GeneratedColumn<String> get customerUuid => $composableBuilder(
      column: $table.customerUuid, builder: (column) => column);

  GeneratedColumn<String> get tenantId =>
      $composableBuilder(column: $table.tenantId, builder: (column) => column);

  GeneratedColumn<String> get outletId =>
      $composableBuilder(column: $table.outletId, builder: (column) => column);

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<String> get paymentStatus => $composableBuilder(
      column: $table.paymentStatus, builder: (column) => column);

  GeneratedColumn<DateTime> get transactionDate => $composableBuilder(
      column: $table.transactionDate, builder: (column) => column);

  GeneratedColumn<double> get subtotal =>
      $composableBuilder(column: $table.subtotal, builder: (column) => column);

  GeneratedColumn<double> get discountTotal => $composableBuilder(
      column: $table.discountTotal, builder: (column) => column);

  GeneratedColumn<double> get taxTotal =>
      $composableBuilder(column: $table.taxTotal, builder: (column) => column);

  GeneratedColumn<double> get grandTotal => $composableBuilder(
      column: $table.grandTotal, builder: (column) => column);

  GeneratedColumn<String> get paymentMethod => $composableBuilder(
      column: $table.paymentMethod, builder: (column) => column);

  GeneratedColumn<double> get tenderedAmount => $composableBuilder(
      column: $table.tenderedAmount, builder: (column) => column);

  GeneratedColumn<double> get changeAmount => $composableBuilder(
      column: $table.changeAmount, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<bool> get isSynced =>
      $composableBuilder(column: $table.isSynced, builder: (column) => column);

  GeneratedColumn<int> get version =>
      $composableBuilder(column: $table.version, builder: (column) => column);

  GeneratedColumn<int> get syncAttempts => $composableBuilder(
      column: $table.syncAttempts, builder: (column) => column);

  GeneratedColumn<bool> get isFulfilled => $composableBuilder(
      column: $table.isFulfilled, builder: (column) => column);

  Expression<T> orderItemTableRefs<T extends Object>(
      Expression<T> Function($$OrderItemTableTableAnnotationComposer a) f) {
    final $$OrderItemTableTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.uuid,
        referencedTable: $db.orderItemTable,
        getReferencedColumn: (t) => t.orderUuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$OrderItemTableTableAnnotationComposer(
              $db: $db,
              $table: $db.orderItemTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> deliveryOrderMetadataTableRefs<T extends Object>(
      Expression<T> Function(
              $$DeliveryOrderMetadataTableTableAnnotationComposer a)
          f) {
    final $$DeliveryOrderMetadataTableTableAnnotationComposer composer =
        $composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.uuid,
            referencedTable: $db.deliveryOrderMetadataTable,
            getReferencedColumn: (t) => t.orderUuid,
            builder: (joinBuilder,
                    {$addJoinBuilderToRootComposer,
                    $removeJoinBuilderFromRootComposer}) =>
                $$DeliveryOrderMetadataTableTableAnnotationComposer(
                  $db: $db,
                  $table: $db.deliveryOrderMetadataTable,
                  $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                  joinBuilder: joinBuilder,
                  $removeJoinBuilderFromRootComposer:
                      $removeJoinBuilderFromRootComposer,
                ));
    return f(composer);
  }

  Expression<T> paymentTransactionTableRefs<T extends Object>(
      Expression<T> Function($$PaymentTransactionTableTableAnnotationComposer a)
          f) {
    final $$PaymentTransactionTableTableAnnotationComposer composer =
        $composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.uuid,
            referencedTable: $db.paymentTransactionTable,
            getReferencedColumn: (t) => t.orderUuid,
            builder: (joinBuilder,
                    {$addJoinBuilderToRootComposer,
                    $removeJoinBuilderFromRootComposer}) =>
                $$PaymentTransactionTableTableAnnotationComposer(
                  $db: $db,
                  $table: $db.paymentTransactionTable,
                  $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                  joinBuilder: joinBuilder,
                  $removeJoinBuilderFromRootComposer:
                      $removeJoinBuilderFromRootComposer,
                ));
    return f(composer);
  }

  Expression<T> customerFeedbackTableRefs<T extends Object>(
      Expression<T> Function($$CustomerFeedbackTableTableAnnotationComposer a)
          f) {
    final $$CustomerFeedbackTableTableAnnotationComposer composer =
        $composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.uuid,
            referencedTable: $db.customerFeedbackTable,
            getReferencedColumn: (t) => t.orderUuid,
            builder: (joinBuilder,
                    {$addJoinBuilderToRootComposer,
                    $removeJoinBuilderFromRootComposer}) =>
                $$CustomerFeedbackTableTableAnnotationComposer(
                  $db: $db,
                  $table: $db.customerFeedbackTable,
                  $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                  joinBuilder: joinBuilder,
                  $removeJoinBuilderFromRootComposer:
                      $removeJoinBuilderFromRootComposer,
                ));
    return f(composer);
  }
}

class $$OrderTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $OrderTableTable,
    OrderTableData,
    $$OrderTableTableFilterComposer,
    $$OrderTableTableOrderingComposer,
    $$OrderTableTableAnnotationComposer,
    $$OrderTableTableCreateCompanionBuilder,
    $$OrderTableTableUpdateCompanionBuilder,
    (OrderTableData, $$OrderTableTableReferences),
    OrderTableData,
    PrefetchHooks Function(
        {bool orderItemTableRefs,
        bool deliveryOrderMetadataTableRefs,
        bool paymentTransactionTableRefs,
        bool customerFeedbackTableRefs})> {
  $$OrderTableTableTableManager(_$AppDatabase db, $OrderTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$OrderTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$OrderTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$OrderTableTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String> orderNumber = const Value.absent(),
            Value<String?> shiftUuid = const Value.absent(),
            Value<String?> customerUuid = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<String?> outletId = const Value.absent(),
            Value<String> status = const Value.absent(),
            Value<String> paymentStatus = const Value.absent(),
            Value<DateTime> transactionDate = const Value.absent(),
            Value<double> subtotal = const Value.absent(),
            Value<double> discountTotal = const Value.absent(),
            Value<double> taxTotal = const Value.absent(),
            Value<double> grandTotal = const Value.absent(),
            Value<String?> paymentMethod = const Value.absent(),
            Value<double?> tenderedAmount = const Value.absent(),
            Value<double?> changeAmount = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
            Value<bool> isSynced = const Value.absent(),
            Value<int> version = const Value.absent(),
            Value<int> syncAttempts = const Value.absent(),
            Value<bool> isFulfilled = const Value.absent(),
          }) =>
              OrderTableCompanion(
            id: id,
            uuid: uuid,
            orderNumber: orderNumber,
            shiftUuid: shiftUuid,
            customerUuid: customerUuid,
            tenantId: tenantId,
            outletId: outletId,
            status: status,
            paymentStatus: paymentStatus,
            transactionDate: transactionDate,
            subtotal: subtotal,
            discountTotal: discountTotal,
            taxTotal: taxTotal,
            grandTotal: grandTotal,
            paymentMethod: paymentMethod,
            tenderedAmount: tenderedAmount,
            changeAmount: changeAmount,
            updatedAt: updatedAt,
            isSynced: isSynced,
            version: version,
            syncAttempts: syncAttempts,
            isFulfilled: isFulfilled,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            required String orderNumber,
            Value<String?> shiftUuid = const Value.absent(),
            Value<String?> customerUuid = const Value.absent(),
            Value<String?> tenantId = const Value.absent(),
            Value<String?> outletId = const Value.absent(),
            Value<String> status = const Value.absent(),
            Value<String> paymentStatus = const Value.absent(),
            required DateTime transactionDate,
            required double subtotal,
            required double discountTotal,
            required double taxTotal,
            required double grandTotal,
            Value<String?> paymentMethod = const Value.absent(),
            Value<double?> tenderedAmount = const Value.absent(),
            Value<double?> changeAmount = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
            Value<bool> isSynced = const Value.absent(),
            Value<int> version = const Value.absent(),
            Value<int> syncAttempts = const Value.absent(),
            Value<bool> isFulfilled = const Value.absent(),
          }) =>
              OrderTableCompanion.insert(
            id: id,
            uuid: uuid,
            orderNumber: orderNumber,
            shiftUuid: shiftUuid,
            customerUuid: customerUuid,
            tenantId: tenantId,
            outletId: outletId,
            status: status,
            paymentStatus: paymentStatus,
            transactionDate: transactionDate,
            subtotal: subtotal,
            discountTotal: discountTotal,
            taxTotal: taxTotal,
            grandTotal: grandTotal,
            paymentMethod: paymentMethod,
            tenderedAmount: tenderedAmount,
            changeAmount: changeAmount,
            updatedAt: updatedAt,
            isSynced: isSynced,
            version: version,
            syncAttempts: syncAttempts,
            isFulfilled: isFulfilled,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$OrderTableTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: (
              {orderItemTableRefs = false,
              deliveryOrderMetadataTableRefs = false,
              paymentTransactionTableRefs = false,
              customerFeedbackTableRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (orderItemTableRefs) db.orderItemTable,
                if (deliveryOrderMetadataTableRefs)
                  db.deliveryOrderMetadataTable,
                if (paymentTransactionTableRefs) db.paymentTransactionTable,
                if (customerFeedbackTableRefs) db.customerFeedbackTable
              ],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (orderItemTableRefs)
                    await $_getPrefetchedData<OrderTableData, $OrderTableTable,
                            OrderItemTableData>(
                        currentTable: table,
                        referencedTable: $$OrderTableTableReferences
                            ._orderItemTableRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$OrderTableTableReferences(db, table, p0)
                                .orderItemTableRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.orderUuid == item.uuid),
                        typedResults: items),
                  if (deliveryOrderMetadataTableRefs)
                    await $_getPrefetchedData<OrderTableData, $OrderTableTable,
                            DeliveryOrderMetadataTableData>(
                        currentTable: table,
                        referencedTable: $$OrderTableTableReferences
                            ._deliveryOrderMetadataTableRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$OrderTableTableReferences(db, table, p0)
                                .deliveryOrderMetadataTableRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.orderUuid == item.uuid),
                        typedResults: items),
                  if (paymentTransactionTableRefs)
                    await $_getPrefetchedData<OrderTableData, $OrderTableTable,
                            PaymentTransactionTableData>(
                        currentTable: table,
                        referencedTable: $$OrderTableTableReferences
                            ._paymentTransactionTableRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$OrderTableTableReferences(db, table, p0)
                                .paymentTransactionTableRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.orderUuid == item.uuid),
                        typedResults: items),
                  if (customerFeedbackTableRefs)
                    await $_getPrefetchedData<OrderTableData, $OrderTableTable,
                            CustomerFeedbackTableData>(
                        currentTable: table,
                        referencedTable: $$OrderTableTableReferences
                            ._customerFeedbackTableRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$OrderTableTableReferences(db, table, p0)
                                .customerFeedbackTableRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.orderUuid == item.uuid),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $$OrderTableTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $OrderTableTable,
    OrderTableData,
    $$OrderTableTableFilterComposer,
    $$OrderTableTableOrderingComposer,
    $$OrderTableTableAnnotationComposer,
    $$OrderTableTableCreateCompanionBuilder,
    $$OrderTableTableUpdateCompanionBuilder,
    (OrderTableData, $$OrderTableTableReferences),
    OrderTableData,
    PrefetchHooks Function(
        {bool orderItemTableRefs,
        bool deliveryOrderMetadataTableRefs,
        bool paymentTransactionTableRefs,
        bool customerFeedbackTableRefs})>;
typedef $$OrderItemTableTableCreateCompanionBuilder = OrderItemTableCompanion
    Function({
  Value<int> id,
  required String orderUuid,
  required String productUuid,
  required String name,
  required double price,
  required double quantity,
  Value<double> paidQty,
  Value<String?> note,
  Value<String?> modifiersJson,
  required double total,
  Value<DateTime> updatedAt,
});
typedef $$OrderItemTableTableUpdateCompanionBuilder = OrderItemTableCompanion
    Function({
  Value<int> id,
  Value<String> orderUuid,
  Value<String> productUuid,
  Value<String> name,
  Value<double> price,
  Value<double> quantity,
  Value<double> paidQty,
  Value<String?> note,
  Value<String?> modifiersJson,
  Value<double> total,
  Value<DateTime> updatedAt,
});

final class $$OrderItemTableTableReferences extends BaseReferences<
    _$AppDatabase, $OrderItemTableTable, OrderItemTableData> {
  $$OrderItemTableTableReferences(
      super.$_db, super.$_table, super.$_typedResult);

  static $OrderTableTable _orderUuidTable(_$AppDatabase db) =>
      db.orderTable.createAlias($_aliasNameGenerator(
          db.orderItemTable.orderUuid, db.orderTable.uuid));

  $$OrderTableTableProcessedTableManager get orderUuid {
    final $_column = $_itemColumn<String>('order_uuid')!;

    final manager = $$OrderTableTableTableManager($_db, $_db.orderTable)
        .filter((f) => f.uuid.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_orderUuidTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }
}

class $$OrderItemTableTableFilterComposer
    extends Composer<_$AppDatabase, $OrderItemTableTable> {
  $$OrderItemTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get productUuid => $composableBuilder(
      column: $table.productUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get price => $composableBuilder(
      column: $table.price, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get quantity => $composableBuilder(
      column: $table.quantity, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get paidQty => $composableBuilder(
      column: $table.paidQty, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get note => $composableBuilder(
      column: $table.note, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get modifiersJson => $composableBuilder(
      column: $table.modifiersJson, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get total => $composableBuilder(
      column: $table.total, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));

  $$OrderTableTableFilterComposer get orderUuid {
    final $$OrderTableTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.orderUuid,
        referencedTable: $db.orderTable,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$OrderTableTableFilterComposer(
              $db: $db,
              $table: $db.orderTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$OrderItemTableTableOrderingComposer
    extends Composer<_$AppDatabase, $OrderItemTableTable> {
  $$OrderItemTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get productUuid => $composableBuilder(
      column: $table.productUuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get price => $composableBuilder(
      column: $table.price, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get quantity => $composableBuilder(
      column: $table.quantity, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get paidQty => $composableBuilder(
      column: $table.paidQty, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get note => $composableBuilder(
      column: $table.note, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get modifiersJson => $composableBuilder(
      column: $table.modifiersJson,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get total => $composableBuilder(
      column: $table.total, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));

  $$OrderTableTableOrderingComposer get orderUuid {
    final $$OrderTableTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.orderUuid,
        referencedTable: $db.orderTable,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$OrderTableTableOrderingComposer(
              $db: $db,
              $table: $db.orderTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$OrderItemTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $OrderItemTableTable> {
  $$OrderItemTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get productUuid => $composableBuilder(
      column: $table.productUuid, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<double> get price =>
      $composableBuilder(column: $table.price, builder: (column) => column);

  GeneratedColumn<double> get quantity =>
      $composableBuilder(column: $table.quantity, builder: (column) => column);

  GeneratedColumn<double> get paidQty =>
      $composableBuilder(column: $table.paidQty, builder: (column) => column);

  GeneratedColumn<String> get note =>
      $composableBuilder(column: $table.note, builder: (column) => column);

  GeneratedColumn<String> get modifiersJson => $composableBuilder(
      column: $table.modifiersJson, builder: (column) => column);

  GeneratedColumn<double> get total =>
      $composableBuilder(column: $table.total, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $$OrderTableTableAnnotationComposer get orderUuid {
    final $$OrderTableTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.orderUuid,
        referencedTable: $db.orderTable,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$OrderTableTableAnnotationComposer(
              $db: $db,
              $table: $db.orderTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$OrderItemTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $OrderItemTableTable,
    OrderItemTableData,
    $$OrderItemTableTableFilterComposer,
    $$OrderItemTableTableOrderingComposer,
    $$OrderItemTableTableAnnotationComposer,
    $$OrderItemTableTableCreateCompanionBuilder,
    $$OrderItemTableTableUpdateCompanionBuilder,
    (OrderItemTableData, $$OrderItemTableTableReferences),
    OrderItemTableData,
    PrefetchHooks Function({bool orderUuid})> {
  $$OrderItemTableTableTableManager(
      _$AppDatabase db, $OrderItemTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$OrderItemTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$OrderItemTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$OrderItemTableTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> orderUuid = const Value.absent(),
            Value<String> productUuid = const Value.absent(),
            Value<String> name = const Value.absent(),
            Value<double> price = const Value.absent(),
            Value<double> quantity = const Value.absent(),
            Value<double> paidQty = const Value.absent(),
            Value<String?> note = const Value.absent(),
            Value<String?> modifiersJson = const Value.absent(),
            Value<double> total = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
          }) =>
              OrderItemTableCompanion(
            id: id,
            orderUuid: orderUuid,
            productUuid: productUuid,
            name: name,
            price: price,
            quantity: quantity,
            paidQty: paidQty,
            note: note,
            modifiersJson: modifiersJson,
            total: total,
            updatedAt: updatedAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String orderUuid,
            required String productUuid,
            required String name,
            required double price,
            required double quantity,
            Value<double> paidQty = const Value.absent(),
            Value<String?> note = const Value.absent(),
            Value<String?> modifiersJson = const Value.absent(),
            required double total,
            Value<DateTime> updatedAt = const Value.absent(),
          }) =>
              OrderItemTableCompanion.insert(
            id: id,
            orderUuid: orderUuid,
            productUuid: productUuid,
            name: name,
            price: price,
            quantity: quantity,
            paidQty: paidQty,
            note: note,
            modifiersJson: modifiersJson,
            total: total,
            updatedAt: updatedAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$OrderItemTableTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: ({orderUuid = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (orderUuid) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.orderUuid,
                    referencedTable:
                        $$OrderItemTableTableReferences._orderUuidTable(db),
                    referencedColumn: $$OrderItemTableTableReferences
                        ._orderUuidTable(db)
                        .uuid,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ));
}

typedef $$OrderItemTableTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $OrderItemTableTable,
    OrderItemTableData,
    $$OrderItemTableTableFilterComposer,
    $$OrderItemTableTableOrderingComposer,
    $$OrderItemTableTableAnnotationComposer,
    $$OrderItemTableTableCreateCompanionBuilder,
    $$OrderItemTableTableUpdateCompanionBuilder,
    (OrderItemTableData, $$OrderItemTableTableReferences),
    OrderItemTableData,
    PrefetchHooks Function({bool orderUuid})>;
typedef $$InventoryLedgerTableTableCreateCompanionBuilder
    = InventoryLedgerTableCompanion Function({
  Value<int> id,
  required String productUuid,
  required double quantityChange,
  required String referenceId,
  required String type,
  required DateTime timestamp,
  Value<bool> isSynced,
});
typedef $$InventoryLedgerTableTableUpdateCompanionBuilder
    = InventoryLedgerTableCompanion Function({
  Value<int> id,
  Value<String> productUuid,
  Value<double> quantityChange,
  Value<String> referenceId,
  Value<String> type,
  Value<DateTime> timestamp,
  Value<bool> isSynced,
});

class $$InventoryLedgerTableTableFilterComposer
    extends Composer<_$AppDatabase, $InventoryLedgerTableTable> {
  $$InventoryLedgerTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get productUuid => $composableBuilder(
      column: $table.productUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get quantityChange => $composableBuilder(
      column: $table.quantityChange,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get referenceId => $composableBuilder(
      column: $table.referenceId, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get type => $composableBuilder(
      column: $table.type, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get timestamp => $composableBuilder(
      column: $table.timestamp, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isSynced => $composableBuilder(
      column: $table.isSynced, builder: (column) => ColumnFilters(column));
}

class $$InventoryLedgerTableTableOrderingComposer
    extends Composer<_$AppDatabase, $InventoryLedgerTableTable> {
  $$InventoryLedgerTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get productUuid => $composableBuilder(
      column: $table.productUuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get quantityChange => $composableBuilder(
      column: $table.quantityChange,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get referenceId => $composableBuilder(
      column: $table.referenceId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get type => $composableBuilder(
      column: $table.type, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get timestamp => $composableBuilder(
      column: $table.timestamp, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isSynced => $composableBuilder(
      column: $table.isSynced, builder: (column) => ColumnOrderings(column));
}

class $$InventoryLedgerTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $InventoryLedgerTableTable> {
  $$InventoryLedgerTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get productUuid => $composableBuilder(
      column: $table.productUuid, builder: (column) => column);

  GeneratedColumn<double> get quantityChange => $composableBuilder(
      column: $table.quantityChange, builder: (column) => column);

  GeneratedColumn<String> get referenceId => $composableBuilder(
      column: $table.referenceId, builder: (column) => column);

  GeneratedColumn<String> get type =>
      $composableBuilder(column: $table.type, builder: (column) => column);

  GeneratedColumn<DateTime> get timestamp =>
      $composableBuilder(column: $table.timestamp, builder: (column) => column);

  GeneratedColumn<bool> get isSynced =>
      $composableBuilder(column: $table.isSynced, builder: (column) => column);
}

class $$InventoryLedgerTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $InventoryLedgerTableTable,
    InventoryLedgerTableData,
    $$InventoryLedgerTableTableFilterComposer,
    $$InventoryLedgerTableTableOrderingComposer,
    $$InventoryLedgerTableTableAnnotationComposer,
    $$InventoryLedgerTableTableCreateCompanionBuilder,
    $$InventoryLedgerTableTableUpdateCompanionBuilder,
    (
      InventoryLedgerTableData,
      BaseReferences<_$AppDatabase, $InventoryLedgerTableTable,
          InventoryLedgerTableData>
    ),
    InventoryLedgerTableData,
    PrefetchHooks Function()> {
  $$InventoryLedgerTableTableTableManager(
      _$AppDatabase db, $InventoryLedgerTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$InventoryLedgerTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$InventoryLedgerTableTableOrderingComposer(
                  $db: db, $table: table),
          createComputedFieldComposer: () =>
              $$InventoryLedgerTableTableAnnotationComposer(
                  $db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> productUuid = const Value.absent(),
            Value<double> quantityChange = const Value.absent(),
            Value<String> referenceId = const Value.absent(),
            Value<String> type = const Value.absent(),
            Value<DateTime> timestamp = const Value.absent(),
            Value<bool> isSynced = const Value.absent(),
          }) =>
              InventoryLedgerTableCompanion(
            id: id,
            productUuid: productUuid,
            quantityChange: quantityChange,
            referenceId: referenceId,
            type: type,
            timestamp: timestamp,
            isSynced: isSynced,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String productUuid,
            required double quantityChange,
            required String referenceId,
            required String type,
            required DateTime timestamp,
            Value<bool> isSynced = const Value.absent(),
          }) =>
              InventoryLedgerTableCompanion.insert(
            id: id,
            productUuid: productUuid,
            quantityChange: quantityChange,
            referenceId: referenceId,
            type: type,
            timestamp: timestamp,
            isSynced: isSynced,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$InventoryLedgerTableTableProcessedTableManager
    = ProcessedTableManager<
        _$AppDatabase,
        $InventoryLedgerTableTable,
        InventoryLedgerTableData,
        $$InventoryLedgerTableTableFilterComposer,
        $$InventoryLedgerTableTableOrderingComposer,
        $$InventoryLedgerTableTableAnnotationComposer,
        $$InventoryLedgerTableTableCreateCompanionBuilder,
        $$InventoryLedgerTableTableUpdateCompanionBuilder,
        (
          InventoryLedgerTableData,
          BaseReferences<_$AppDatabase, $InventoryLedgerTableTable,
              InventoryLedgerTableData>
        ),
        InventoryLedgerTableData,
        PrefetchHooks Function()>;
typedef $$InventoryCacheTableTableCreateCompanionBuilder
    = InventoryCacheTableCompanion Function({
  Value<int> id,
  required String productUuid,
  required double serverQuantity,
  required DateTime lastSyncedAt,
});
typedef $$InventoryCacheTableTableUpdateCompanionBuilder
    = InventoryCacheTableCompanion Function({
  Value<int> id,
  Value<String> productUuid,
  Value<double> serverQuantity,
  Value<DateTime> lastSyncedAt,
});

class $$InventoryCacheTableTableFilterComposer
    extends Composer<_$AppDatabase, $InventoryCacheTableTable> {
  $$InventoryCacheTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get productUuid => $composableBuilder(
      column: $table.productUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get serverQuantity => $composableBuilder(
      column: $table.serverQuantity,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get lastSyncedAt => $composableBuilder(
      column: $table.lastSyncedAt, builder: (column) => ColumnFilters(column));
}

class $$InventoryCacheTableTableOrderingComposer
    extends Composer<_$AppDatabase, $InventoryCacheTableTable> {
  $$InventoryCacheTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get productUuid => $composableBuilder(
      column: $table.productUuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get serverQuantity => $composableBuilder(
      column: $table.serverQuantity,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get lastSyncedAt => $composableBuilder(
      column: $table.lastSyncedAt,
      builder: (column) => ColumnOrderings(column));
}

class $$InventoryCacheTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $InventoryCacheTableTable> {
  $$InventoryCacheTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get productUuid => $composableBuilder(
      column: $table.productUuid, builder: (column) => column);

  GeneratedColumn<double> get serverQuantity => $composableBuilder(
      column: $table.serverQuantity, builder: (column) => column);

  GeneratedColumn<DateTime> get lastSyncedAt => $composableBuilder(
      column: $table.lastSyncedAt, builder: (column) => column);
}

class $$InventoryCacheTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $InventoryCacheTableTable,
    InventoryCacheTableData,
    $$InventoryCacheTableTableFilterComposer,
    $$InventoryCacheTableTableOrderingComposer,
    $$InventoryCacheTableTableAnnotationComposer,
    $$InventoryCacheTableTableCreateCompanionBuilder,
    $$InventoryCacheTableTableUpdateCompanionBuilder,
    (
      InventoryCacheTableData,
      BaseReferences<_$AppDatabase, $InventoryCacheTableTable,
          InventoryCacheTableData>
    ),
    InventoryCacheTableData,
    PrefetchHooks Function()> {
  $$InventoryCacheTableTableTableManager(
      _$AppDatabase db, $InventoryCacheTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$InventoryCacheTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$InventoryCacheTableTableOrderingComposer(
                  $db: db, $table: table),
          createComputedFieldComposer: () =>
              $$InventoryCacheTableTableAnnotationComposer(
                  $db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> productUuid = const Value.absent(),
            Value<double> serverQuantity = const Value.absent(),
            Value<DateTime> lastSyncedAt = const Value.absent(),
          }) =>
              InventoryCacheTableCompanion(
            id: id,
            productUuid: productUuid,
            serverQuantity: serverQuantity,
            lastSyncedAt: lastSyncedAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String productUuid,
            required double serverQuantity,
            required DateTime lastSyncedAt,
          }) =>
              InventoryCacheTableCompanion.insert(
            id: id,
            productUuid: productUuid,
            serverQuantity: serverQuantity,
            lastSyncedAt: lastSyncedAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$InventoryCacheTableTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $InventoryCacheTableTable,
    InventoryCacheTableData,
    $$InventoryCacheTableTableFilterComposer,
    $$InventoryCacheTableTableOrderingComposer,
    $$InventoryCacheTableTableAnnotationComposer,
    $$InventoryCacheTableTableCreateCompanionBuilder,
    $$InventoryCacheTableTableUpdateCompanionBuilder,
    (
      InventoryCacheTableData,
      BaseReferences<_$AppDatabase, $InventoryCacheTableTable,
          InventoryCacheTableData>
    ),
    InventoryCacheTableData,
    PrefetchHooks Function()>;
typedef $$LocalStocksTableTableCreateCompanionBuilder
    = LocalStocksTableCompanion Function({
  Value<int> id,
  required String productUuid,
  required String warehouseUuid,
  Value<double> quantity,
  required DateTime updatedAt,
  Value<int> version,
});
typedef $$LocalStocksTableTableUpdateCompanionBuilder
    = LocalStocksTableCompanion Function({
  Value<int> id,
  Value<String> productUuid,
  Value<String> warehouseUuid,
  Value<double> quantity,
  Value<DateTime> updatedAt,
  Value<int> version,
});

final class $$LocalStocksTableTableReferences extends BaseReferences<
    _$AppDatabase, $LocalStocksTableTable, LocalStocksTableData> {
  $$LocalStocksTableTableReferences(
      super.$_db, super.$_table, super.$_typedResult);

  static $ProductTableTable _productUuidTable(_$AppDatabase db) =>
      db.productTable.createAlias($_aliasNameGenerator(
          db.localStocksTable.productUuid, db.productTable.uuid));

  $$ProductTableTableProcessedTableManager get productUuid {
    final $_column = $_itemColumn<String>('product_uuid')!;

    final manager = $$ProductTableTableTableManager($_db, $_db.productTable)
        .filter((f) => f.uuid.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_productUuidTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }
}

class $$LocalStocksTableTableFilterComposer
    extends Composer<_$AppDatabase, $LocalStocksTableTable> {
  $$LocalStocksTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get warehouseUuid => $composableBuilder(
      column: $table.warehouseUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get quantity => $composableBuilder(
      column: $table.quantity, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get version => $composableBuilder(
      column: $table.version, builder: (column) => ColumnFilters(column));

  $$ProductTableTableFilterComposer get productUuid {
    final $$ProductTableTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.productUuid,
        referencedTable: $db.productTable,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ProductTableTableFilterComposer(
              $db: $db,
              $table: $db.productTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$LocalStocksTableTableOrderingComposer
    extends Composer<_$AppDatabase, $LocalStocksTableTable> {
  $$LocalStocksTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get warehouseUuid => $composableBuilder(
      column: $table.warehouseUuid,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get quantity => $composableBuilder(
      column: $table.quantity, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get version => $composableBuilder(
      column: $table.version, builder: (column) => ColumnOrderings(column));

  $$ProductTableTableOrderingComposer get productUuid {
    final $$ProductTableTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.productUuid,
        referencedTable: $db.productTable,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ProductTableTableOrderingComposer(
              $db: $db,
              $table: $db.productTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$LocalStocksTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $LocalStocksTableTable> {
  $$LocalStocksTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get warehouseUuid => $composableBuilder(
      column: $table.warehouseUuid, builder: (column) => column);

  GeneratedColumn<double> get quantity =>
      $composableBuilder(column: $table.quantity, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<int> get version =>
      $composableBuilder(column: $table.version, builder: (column) => column);

  $$ProductTableTableAnnotationComposer get productUuid {
    final $$ProductTableTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.productUuid,
        referencedTable: $db.productTable,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ProductTableTableAnnotationComposer(
              $db: $db,
              $table: $db.productTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$LocalStocksTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $LocalStocksTableTable,
    LocalStocksTableData,
    $$LocalStocksTableTableFilterComposer,
    $$LocalStocksTableTableOrderingComposer,
    $$LocalStocksTableTableAnnotationComposer,
    $$LocalStocksTableTableCreateCompanionBuilder,
    $$LocalStocksTableTableUpdateCompanionBuilder,
    (LocalStocksTableData, $$LocalStocksTableTableReferences),
    LocalStocksTableData,
    PrefetchHooks Function({bool productUuid})> {
  $$LocalStocksTableTableTableManager(
      _$AppDatabase db, $LocalStocksTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$LocalStocksTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$LocalStocksTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$LocalStocksTableTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> productUuid = const Value.absent(),
            Value<String> warehouseUuid = const Value.absent(),
            Value<double> quantity = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
            Value<int> version = const Value.absent(),
          }) =>
              LocalStocksTableCompanion(
            id: id,
            productUuid: productUuid,
            warehouseUuid: warehouseUuid,
            quantity: quantity,
            updatedAt: updatedAt,
            version: version,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String productUuid,
            required String warehouseUuid,
            Value<double> quantity = const Value.absent(),
            required DateTime updatedAt,
            Value<int> version = const Value.absent(),
          }) =>
              LocalStocksTableCompanion.insert(
            id: id,
            productUuid: productUuid,
            warehouseUuid: warehouseUuid,
            quantity: quantity,
            updatedAt: updatedAt,
            version: version,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$LocalStocksTableTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: ({productUuid = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (productUuid) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.productUuid,
                    referencedTable:
                        $$LocalStocksTableTableReferences._productUuidTable(db),
                    referencedColumn: $$LocalStocksTableTableReferences
                        ._productUuidTable(db)
                        .uuid,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ));
}

typedef $$LocalStocksTableTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $LocalStocksTableTable,
    LocalStocksTableData,
    $$LocalStocksTableTableFilterComposer,
    $$LocalStocksTableTableOrderingComposer,
    $$LocalStocksTableTableAnnotationComposer,
    $$LocalStocksTableTableCreateCompanionBuilder,
    $$LocalStocksTableTableUpdateCompanionBuilder,
    (LocalStocksTableData, $$LocalStocksTableTableReferences),
    LocalStocksTableData,
    PrefetchHooks Function({bool productUuid})>;
typedef $$SupplierTableTableCreateCompanionBuilder = SupplierTableCompanion
    Function({
  Value<int> id,
  required String uuid,
  required String name,
  Value<String?> email,
  Value<String?> phone,
  Value<String?> address,
  Value<int> leadTimeDays,
  required DateTime updatedAt,
});
typedef $$SupplierTableTableUpdateCompanionBuilder = SupplierTableCompanion
    Function({
  Value<int> id,
  Value<String> uuid,
  Value<String> name,
  Value<String?> email,
  Value<String?> phone,
  Value<String?> address,
  Value<int> leadTimeDays,
  Value<DateTime> updatedAt,
});

final class $$SupplierTableTableReferences extends BaseReferences<_$AppDatabase,
    $SupplierTableTable, SupplierTableData> {
  $$SupplierTableTableReferences(
      super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$ProductSupplierTableTable,
      List<ProductSupplierTableData>> _productSupplierTableRefsTable(
          _$AppDatabase db) =>
      MultiTypedResultKey.fromTable(db.productSupplierTable,
          aliasName: $_aliasNameGenerator(
              db.supplierTable.uuid, db.productSupplierTable.supplierUuid));

  $$ProductSupplierTableTableProcessedTableManager
      get productSupplierTableRefs {
    final manager =
        $$ProductSupplierTableTableTableManager($_db, $_db.productSupplierTable)
            .filter((f) =>
                f.supplierUuid.uuid.sqlEquals($_itemColumn<String>('uuid')!));

    final cache =
        $_typedResult.readTableOrNull(_productSupplierTableRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$PurchaseOrderTableTable,
      List<PurchaseOrderTableData>> _purchaseOrderTableRefsTable(
          _$AppDatabase db) =>
      MultiTypedResultKey.fromTable(db.purchaseOrderTable,
          aliasName: $_aliasNameGenerator(
              db.supplierTable.uuid, db.purchaseOrderTable.supplierUuid));

  $$PurchaseOrderTableTableProcessedTableManager get purchaseOrderTableRefs {
    final manager =
        $$PurchaseOrderTableTableTableManager($_db, $_db.purchaseOrderTable)
            .filter((f) =>
                f.supplierUuid.uuid.sqlEquals($_itemColumn<String>('uuid')!));

    final cache =
        $_typedResult.readTableOrNull(_purchaseOrderTableRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $$SupplierTableTableFilterComposer
    extends Composer<_$AppDatabase, $SupplierTableTable> {
  $$SupplierTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get email => $composableBuilder(
      column: $table.email, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get phone => $composableBuilder(
      column: $table.phone, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get address => $composableBuilder(
      column: $table.address, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get leadTimeDays => $composableBuilder(
      column: $table.leadTimeDays, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));

  Expression<bool> productSupplierTableRefs(
      Expression<bool> Function($$ProductSupplierTableTableFilterComposer f)
          f) {
    final $$ProductSupplierTableTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.uuid,
        referencedTable: $db.productSupplierTable,
        getReferencedColumn: (t) => t.supplierUuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ProductSupplierTableTableFilterComposer(
              $db: $db,
              $table: $db.productSupplierTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> purchaseOrderTableRefs(
      Expression<bool> Function($$PurchaseOrderTableTableFilterComposer f) f) {
    final $$PurchaseOrderTableTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.uuid,
        referencedTable: $db.purchaseOrderTable,
        getReferencedColumn: (t) => t.supplierUuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$PurchaseOrderTableTableFilterComposer(
              $db: $db,
              $table: $db.purchaseOrderTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$SupplierTableTableOrderingComposer
    extends Composer<_$AppDatabase, $SupplierTableTable> {
  $$SupplierTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get email => $composableBuilder(
      column: $table.email, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get phone => $composableBuilder(
      column: $table.phone, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get address => $composableBuilder(
      column: $table.address, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get leadTimeDays => $composableBuilder(
      column: $table.leadTimeDays,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));
}

class $$SupplierTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $SupplierTableTable> {
  $$SupplierTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get email =>
      $composableBuilder(column: $table.email, builder: (column) => column);

  GeneratedColumn<String> get phone =>
      $composableBuilder(column: $table.phone, builder: (column) => column);

  GeneratedColumn<String> get address =>
      $composableBuilder(column: $table.address, builder: (column) => column);

  GeneratedColumn<int> get leadTimeDays => $composableBuilder(
      column: $table.leadTimeDays, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  Expression<T> productSupplierTableRefs<T extends Object>(
      Expression<T> Function($$ProductSupplierTableTableAnnotationComposer a)
          f) {
    final $$ProductSupplierTableTableAnnotationComposer composer =
        $composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.uuid,
            referencedTable: $db.productSupplierTable,
            getReferencedColumn: (t) => t.supplierUuid,
            builder: (joinBuilder,
                    {$addJoinBuilderToRootComposer,
                    $removeJoinBuilderFromRootComposer}) =>
                $$ProductSupplierTableTableAnnotationComposer(
                  $db: $db,
                  $table: $db.productSupplierTable,
                  $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                  joinBuilder: joinBuilder,
                  $removeJoinBuilderFromRootComposer:
                      $removeJoinBuilderFromRootComposer,
                ));
    return f(composer);
  }

  Expression<T> purchaseOrderTableRefs<T extends Object>(
      Expression<T> Function($$PurchaseOrderTableTableAnnotationComposer a) f) {
    final $$PurchaseOrderTableTableAnnotationComposer composer =
        $composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.uuid,
            referencedTable: $db.purchaseOrderTable,
            getReferencedColumn: (t) => t.supplierUuid,
            builder: (joinBuilder,
                    {$addJoinBuilderToRootComposer,
                    $removeJoinBuilderFromRootComposer}) =>
                $$PurchaseOrderTableTableAnnotationComposer(
                  $db: $db,
                  $table: $db.purchaseOrderTable,
                  $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                  joinBuilder: joinBuilder,
                  $removeJoinBuilderFromRootComposer:
                      $removeJoinBuilderFromRootComposer,
                ));
    return f(composer);
  }
}

class $$SupplierTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $SupplierTableTable,
    SupplierTableData,
    $$SupplierTableTableFilterComposer,
    $$SupplierTableTableOrderingComposer,
    $$SupplierTableTableAnnotationComposer,
    $$SupplierTableTableCreateCompanionBuilder,
    $$SupplierTableTableUpdateCompanionBuilder,
    (SupplierTableData, $$SupplierTableTableReferences),
    SupplierTableData,
    PrefetchHooks Function(
        {bool productSupplierTableRefs, bool purchaseOrderTableRefs})> {
  $$SupplierTableTableTableManager(_$AppDatabase db, $SupplierTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$SupplierTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$SupplierTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$SupplierTableTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String> name = const Value.absent(),
            Value<String?> email = const Value.absent(),
            Value<String?> phone = const Value.absent(),
            Value<String?> address = const Value.absent(),
            Value<int> leadTimeDays = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
          }) =>
              SupplierTableCompanion(
            id: id,
            uuid: uuid,
            name: name,
            email: email,
            phone: phone,
            address: address,
            leadTimeDays: leadTimeDays,
            updatedAt: updatedAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            required String name,
            Value<String?> email = const Value.absent(),
            Value<String?> phone = const Value.absent(),
            Value<String?> address = const Value.absent(),
            Value<int> leadTimeDays = const Value.absent(),
            required DateTime updatedAt,
          }) =>
              SupplierTableCompanion.insert(
            id: id,
            uuid: uuid,
            name: name,
            email: email,
            phone: phone,
            address: address,
            leadTimeDays: leadTimeDays,
            updatedAt: updatedAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$SupplierTableTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: (
              {productSupplierTableRefs = false,
              purchaseOrderTableRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (productSupplierTableRefs) db.productSupplierTable,
                if (purchaseOrderTableRefs) db.purchaseOrderTable
              ],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (productSupplierTableRefs)
                    await $_getPrefetchedData<SupplierTableData,
                            $SupplierTableTable, ProductSupplierTableData>(
                        currentTable: table,
                        referencedTable: $$SupplierTableTableReferences
                            ._productSupplierTableRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$SupplierTableTableReferences(db, table, p0)
                                .productSupplierTableRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.supplierUuid == item.uuid),
                        typedResults: items),
                  if (purchaseOrderTableRefs)
                    await $_getPrefetchedData<SupplierTableData,
                            $SupplierTableTable, PurchaseOrderTableData>(
                        currentTable: table,
                        referencedTable: $$SupplierTableTableReferences
                            ._purchaseOrderTableRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$SupplierTableTableReferences(db, table, p0)
                                .purchaseOrderTableRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.supplierUuid == item.uuid),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $$SupplierTableTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $SupplierTableTable,
    SupplierTableData,
    $$SupplierTableTableFilterComposer,
    $$SupplierTableTableOrderingComposer,
    $$SupplierTableTableAnnotationComposer,
    $$SupplierTableTableCreateCompanionBuilder,
    $$SupplierTableTableUpdateCompanionBuilder,
    (SupplierTableData, $$SupplierTableTableReferences),
    SupplierTableData,
    PrefetchHooks Function(
        {bool productSupplierTableRefs, bool purchaseOrderTableRefs})>;
typedef $$ProductSupplierTableTableCreateCompanionBuilder
    = ProductSupplierTableCompanion Function({
  Value<int> id,
  required String productUuid,
  required String supplierUuid,
  Value<double> costPrice,
  Value<int> leadTimeDays,
  Value<double> minOrderQty,
});
typedef $$ProductSupplierTableTableUpdateCompanionBuilder
    = ProductSupplierTableCompanion Function({
  Value<int> id,
  Value<String> productUuid,
  Value<String> supplierUuid,
  Value<double> costPrice,
  Value<int> leadTimeDays,
  Value<double> minOrderQty,
});

final class $$ProductSupplierTableTableReferences extends BaseReferences<
    _$AppDatabase, $ProductSupplierTableTable, ProductSupplierTableData> {
  $$ProductSupplierTableTableReferences(
      super.$_db, super.$_table, super.$_typedResult);

  static $ProductTableTable _productUuidTable(_$AppDatabase db) =>
      db.productTable.createAlias($_aliasNameGenerator(
          db.productSupplierTable.productUuid, db.productTable.uuid));

  $$ProductTableTableProcessedTableManager get productUuid {
    final $_column = $_itemColumn<String>('product_uuid')!;

    final manager = $$ProductTableTableTableManager($_db, $_db.productTable)
        .filter((f) => f.uuid.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_productUuidTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static $SupplierTableTable _supplierUuidTable(_$AppDatabase db) =>
      db.supplierTable.createAlias($_aliasNameGenerator(
          db.productSupplierTable.supplierUuid, db.supplierTable.uuid));

  $$SupplierTableTableProcessedTableManager get supplierUuid {
    final $_column = $_itemColumn<String>('supplier_uuid')!;

    final manager = $$SupplierTableTableTableManager($_db, $_db.supplierTable)
        .filter((f) => f.uuid.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_supplierUuidTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }
}

class $$ProductSupplierTableTableFilterComposer
    extends Composer<_$AppDatabase, $ProductSupplierTableTable> {
  $$ProductSupplierTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get costPrice => $composableBuilder(
      column: $table.costPrice, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get leadTimeDays => $composableBuilder(
      column: $table.leadTimeDays, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get minOrderQty => $composableBuilder(
      column: $table.minOrderQty, builder: (column) => ColumnFilters(column));

  $$ProductTableTableFilterComposer get productUuid {
    final $$ProductTableTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.productUuid,
        referencedTable: $db.productTable,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ProductTableTableFilterComposer(
              $db: $db,
              $table: $db.productTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$SupplierTableTableFilterComposer get supplierUuid {
    final $$SupplierTableTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.supplierUuid,
        referencedTable: $db.supplierTable,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$SupplierTableTableFilterComposer(
              $db: $db,
              $table: $db.supplierTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$ProductSupplierTableTableOrderingComposer
    extends Composer<_$AppDatabase, $ProductSupplierTableTable> {
  $$ProductSupplierTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get costPrice => $composableBuilder(
      column: $table.costPrice, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get leadTimeDays => $composableBuilder(
      column: $table.leadTimeDays,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get minOrderQty => $composableBuilder(
      column: $table.minOrderQty, builder: (column) => ColumnOrderings(column));

  $$ProductTableTableOrderingComposer get productUuid {
    final $$ProductTableTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.productUuid,
        referencedTable: $db.productTable,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ProductTableTableOrderingComposer(
              $db: $db,
              $table: $db.productTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$SupplierTableTableOrderingComposer get supplierUuid {
    final $$SupplierTableTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.supplierUuid,
        referencedTable: $db.supplierTable,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$SupplierTableTableOrderingComposer(
              $db: $db,
              $table: $db.supplierTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$ProductSupplierTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $ProductSupplierTableTable> {
  $$ProductSupplierTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<double> get costPrice =>
      $composableBuilder(column: $table.costPrice, builder: (column) => column);

  GeneratedColumn<int> get leadTimeDays => $composableBuilder(
      column: $table.leadTimeDays, builder: (column) => column);

  GeneratedColumn<double> get minOrderQty => $composableBuilder(
      column: $table.minOrderQty, builder: (column) => column);

  $$ProductTableTableAnnotationComposer get productUuid {
    final $$ProductTableTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.productUuid,
        referencedTable: $db.productTable,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ProductTableTableAnnotationComposer(
              $db: $db,
              $table: $db.productTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$SupplierTableTableAnnotationComposer get supplierUuid {
    final $$SupplierTableTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.supplierUuid,
        referencedTable: $db.supplierTable,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$SupplierTableTableAnnotationComposer(
              $db: $db,
              $table: $db.supplierTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$ProductSupplierTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $ProductSupplierTableTable,
    ProductSupplierTableData,
    $$ProductSupplierTableTableFilterComposer,
    $$ProductSupplierTableTableOrderingComposer,
    $$ProductSupplierTableTableAnnotationComposer,
    $$ProductSupplierTableTableCreateCompanionBuilder,
    $$ProductSupplierTableTableUpdateCompanionBuilder,
    (ProductSupplierTableData, $$ProductSupplierTableTableReferences),
    ProductSupplierTableData,
    PrefetchHooks Function({bool productUuid, bool supplierUuid})> {
  $$ProductSupplierTableTableTableManager(
      _$AppDatabase db, $ProductSupplierTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ProductSupplierTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ProductSupplierTableTableOrderingComposer(
                  $db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ProductSupplierTableTableAnnotationComposer(
                  $db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> productUuid = const Value.absent(),
            Value<String> supplierUuid = const Value.absent(),
            Value<double> costPrice = const Value.absent(),
            Value<int> leadTimeDays = const Value.absent(),
            Value<double> minOrderQty = const Value.absent(),
          }) =>
              ProductSupplierTableCompanion(
            id: id,
            productUuid: productUuid,
            supplierUuid: supplierUuid,
            costPrice: costPrice,
            leadTimeDays: leadTimeDays,
            minOrderQty: minOrderQty,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String productUuid,
            required String supplierUuid,
            Value<double> costPrice = const Value.absent(),
            Value<int> leadTimeDays = const Value.absent(),
            Value<double> minOrderQty = const Value.absent(),
          }) =>
              ProductSupplierTableCompanion.insert(
            id: id,
            productUuid: productUuid,
            supplierUuid: supplierUuid,
            costPrice: costPrice,
            leadTimeDays: leadTimeDays,
            minOrderQty: minOrderQty,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$ProductSupplierTableTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: ({productUuid = false, supplierUuid = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (productUuid) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.productUuid,
                    referencedTable: $$ProductSupplierTableTableReferences
                        ._productUuidTable(db),
                    referencedColumn: $$ProductSupplierTableTableReferences
                        ._productUuidTable(db)
                        .uuid,
                  ) as T;
                }
                if (supplierUuid) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.supplierUuid,
                    referencedTable: $$ProductSupplierTableTableReferences
                        ._supplierUuidTable(db),
                    referencedColumn: $$ProductSupplierTableTableReferences
                        ._supplierUuidTable(db)
                        .uuid,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ));
}

typedef $$ProductSupplierTableTableProcessedTableManager
    = ProcessedTableManager<
        _$AppDatabase,
        $ProductSupplierTableTable,
        ProductSupplierTableData,
        $$ProductSupplierTableTableFilterComposer,
        $$ProductSupplierTableTableOrderingComposer,
        $$ProductSupplierTableTableAnnotationComposer,
        $$ProductSupplierTableTableCreateCompanionBuilder,
        $$ProductSupplierTableTableUpdateCompanionBuilder,
        (ProductSupplierTableData, $$ProductSupplierTableTableReferences),
        ProductSupplierTableData,
        PrefetchHooks Function({bool productUuid, bool supplierUuid})>;
typedef $$PurchaseOrderTableTableCreateCompanionBuilder
    = PurchaseOrderTableCompanion Function({
  Value<int> id,
  required String uuid,
  required String supplierUuid,
  required String targetWarehouseUuid,
  Value<String> status,
  Value<String?> referenceNumber,
  Value<String?> notes,
  Value<double> totalCost,
  required DateTime createdAt,
  required DateTime updatedAt,
  Value<bool> isSynced,
});
typedef $$PurchaseOrderTableTableUpdateCompanionBuilder
    = PurchaseOrderTableCompanion Function({
  Value<int> id,
  Value<String> uuid,
  Value<String> supplierUuid,
  Value<String> targetWarehouseUuid,
  Value<String> status,
  Value<String?> referenceNumber,
  Value<String?> notes,
  Value<double> totalCost,
  Value<DateTime> createdAt,
  Value<DateTime> updatedAt,
  Value<bool> isSynced,
});

final class $$PurchaseOrderTableTableReferences extends BaseReferences<
    _$AppDatabase, $PurchaseOrderTableTable, PurchaseOrderTableData> {
  $$PurchaseOrderTableTableReferences(
      super.$_db, super.$_table, super.$_typedResult);

  static $SupplierTableTable _supplierUuidTable(_$AppDatabase db) =>
      db.supplierTable.createAlias($_aliasNameGenerator(
          db.purchaseOrderTable.supplierUuid, db.supplierTable.uuid));

  $$SupplierTableTableProcessedTableManager get supplierUuid {
    final $_column = $_itemColumn<String>('supplier_uuid')!;

    final manager = $$SupplierTableTableTableManager($_db, $_db.supplierTable)
        .filter((f) => f.uuid.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_supplierUuidTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static MultiTypedResultKey<$PurchaseOrderItemTableTable,
      List<PurchaseOrderItemTableData>> _purchaseOrderItemTableRefsTable(
          _$AppDatabase db) =>
      MultiTypedResultKey.fromTable(db.purchaseOrderItemTable,
          aliasName: $_aliasNameGenerator(
              db.purchaseOrderTable.uuid, db.purchaseOrderItemTable.poUuid));

  $$PurchaseOrderItemTableTableProcessedTableManager
      get purchaseOrderItemTableRefs {
    final manager = $$PurchaseOrderItemTableTableTableManager(
            $_db, $_db.purchaseOrderItemTable)
        .filter((f) => f.poUuid.uuid.sqlEquals($_itemColumn<String>('uuid')!));

    final cache =
        $_typedResult.readTableOrNull(_purchaseOrderItemTableRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $$PurchaseOrderTableTableFilterComposer
    extends Composer<_$AppDatabase, $PurchaseOrderTableTable> {
  $$PurchaseOrderTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get targetWarehouseUuid => $composableBuilder(
      column: $table.targetWarehouseUuid,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get referenceNumber => $composableBuilder(
      column: $table.referenceNumber,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get notes => $composableBuilder(
      column: $table.notes, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get totalCost => $composableBuilder(
      column: $table.totalCost, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isSynced => $composableBuilder(
      column: $table.isSynced, builder: (column) => ColumnFilters(column));

  $$SupplierTableTableFilterComposer get supplierUuid {
    final $$SupplierTableTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.supplierUuid,
        referencedTable: $db.supplierTable,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$SupplierTableTableFilterComposer(
              $db: $db,
              $table: $db.supplierTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<bool> purchaseOrderItemTableRefs(
      Expression<bool> Function($$PurchaseOrderItemTableTableFilterComposer f)
          f) {
    final $$PurchaseOrderItemTableTableFilterComposer composer =
        $composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.uuid,
            referencedTable: $db.purchaseOrderItemTable,
            getReferencedColumn: (t) => t.poUuid,
            builder: (joinBuilder,
                    {$addJoinBuilderToRootComposer,
                    $removeJoinBuilderFromRootComposer}) =>
                $$PurchaseOrderItemTableTableFilterComposer(
                  $db: $db,
                  $table: $db.purchaseOrderItemTable,
                  $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                  joinBuilder: joinBuilder,
                  $removeJoinBuilderFromRootComposer:
                      $removeJoinBuilderFromRootComposer,
                ));
    return f(composer);
  }
}

class $$PurchaseOrderTableTableOrderingComposer
    extends Composer<_$AppDatabase, $PurchaseOrderTableTable> {
  $$PurchaseOrderTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get targetWarehouseUuid => $composableBuilder(
      column: $table.targetWarehouseUuid,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get referenceNumber => $composableBuilder(
      column: $table.referenceNumber,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get notes => $composableBuilder(
      column: $table.notes, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get totalCost => $composableBuilder(
      column: $table.totalCost, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isSynced => $composableBuilder(
      column: $table.isSynced, builder: (column) => ColumnOrderings(column));

  $$SupplierTableTableOrderingComposer get supplierUuid {
    final $$SupplierTableTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.supplierUuid,
        referencedTable: $db.supplierTable,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$SupplierTableTableOrderingComposer(
              $db: $db,
              $table: $db.supplierTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$PurchaseOrderTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $PurchaseOrderTableTable> {
  $$PurchaseOrderTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get targetWarehouseUuid => $composableBuilder(
      column: $table.targetWarehouseUuid, builder: (column) => column);

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<String> get referenceNumber => $composableBuilder(
      column: $table.referenceNumber, builder: (column) => column);

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<double> get totalCost =>
      $composableBuilder(column: $table.totalCost, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<bool> get isSynced =>
      $composableBuilder(column: $table.isSynced, builder: (column) => column);

  $$SupplierTableTableAnnotationComposer get supplierUuid {
    final $$SupplierTableTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.supplierUuid,
        referencedTable: $db.supplierTable,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$SupplierTableTableAnnotationComposer(
              $db: $db,
              $table: $db.supplierTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<T> purchaseOrderItemTableRefs<T extends Object>(
      Expression<T> Function($$PurchaseOrderItemTableTableAnnotationComposer a)
          f) {
    final $$PurchaseOrderItemTableTableAnnotationComposer composer =
        $composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.uuid,
            referencedTable: $db.purchaseOrderItemTable,
            getReferencedColumn: (t) => t.poUuid,
            builder: (joinBuilder,
                    {$addJoinBuilderToRootComposer,
                    $removeJoinBuilderFromRootComposer}) =>
                $$PurchaseOrderItemTableTableAnnotationComposer(
                  $db: $db,
                  $table: $db.purchaseOrderItemTable,
                  $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                  joinBuilder: joinBuilder,
                  $removeJoinBuilderFromRootComposer:
                      $removeJoinBuilderFromRootComposer,
                ));
    return f(composer);
  }
}

class $$PurchaseOrderTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $PurchaseOrderTableTable,
    PurchaseOrderTableData,
    $$PurchaseOrderTableTableFilterComposer,
    $$PurchaseOrderTableTableOrderingComposer,
    $$PurchaseOrderTableTableAnnotationComposer,
    $$PurchaseOrderTableTableCreateCompanionBuilder,
    $$PurchaseOrderTableTableUpdateCompanionBuilder,
    (PurchaseOrderTableData, $$PurchaseOrderTableTableReferences),
    PurchaseOrderTableData,
    PrefetchHooks Function(
        {bool supplierUuid, bool purchaseOrderItemTableRefs})> {
  $$PurchaseOrderTableTableTableManager(
      _$AppDatabase db, $PurchaseOrderTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$PurchaseOrderTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$PurchaseOrderTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$PurchaseOrderTableTableAnnotationComposer(
                  $db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String> supplierUuid = const Value.absent(),
            Value<String> targetWarehouseUuid = const Value.absent(),
            Value<String> status = const Value.absent(),
            Value<String?> referenceNumber = const Value.absent(),
            Value<String?> notes = const Value.absent(),
            Value<double> totalCost = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
            Value<bool> isSynced = const Value.absent(),
          }) =>
              PurchaseOrderTableCompanion(
            id: id,
            uuid: uuid,
            supplierUuid: supplierUuid,
            targetWarehouseUuid: targetWarehouseUuid,
            status: status,
            referenceNumber: referenceNumber,
            notes: notes,
            totalCost: totalCost,
            createdAt: createdAt,
            updatedAt: updatedAt,
            isSynced: isSynced,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            required String supplierUuid,
            required String targetWarehouseUuid,
            Value<String> status = const Value.absent(),
            Value<String?> referenceNumber = const Value.absent(),
            Value<String?> notes = const Value.absent(),
            Value<double> totalCost = const Value.absent(),
            required DateTime createdAt,
            required DateTime updatedAt,
            Value<bool> isSynced = const Value.absent(),
          }) =>
              PurchaseOrderTableCompanion.insert(
            id: id,
            uuid: uuid,
            supplierUuid: supplierUuid,
            targetWarehouseUuid: targetWarehouseUuid,
            status: status,
            referenceNumber: referenceNumber,
            notes: notes,
            totalCost: totalCost,
            createdAt: createdAt,
            updatedAt: updatedAt,
            isSynced: isSynced,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$PurchaseOrderTableTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: (
              {supplierUuid = false, purchaseOrderItemTableRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (purchaseOrderItemTableRefs) db.purchaseOrderItemTable
              ],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (supplierUuid) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.supplierUuid,
                    referencedTable: $$PurchaseOrderTableTableReferences
                        ._supplierUuidTable(db),
                    referencedColumn: $$PurchaseOrderTableTableReferences
                        ._supplierUuidTable(db)
                        .uuid,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [
                  if (purchaseOrderItemTableRefs)
                    await $_getPrefetchedData<
                            PurchaseOrderTableData,
                            $PurchaseOrderTableTable,
                            PurchaseOrderItemTableData>(
                        currentTable: table,
                        referencedTable: $$PurchaseOrderTableTableReferences
                            ._purchaseOrderItemTableRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$PurchaseOrderTableTableReferences(db, table, p0)
                                .purchaseOrderItemTableRefs,
                        referencedItemsForCurrentItem: (item,
                                referencedItems) =>
                            referencedItems.where((e) => e.poUuid == item.uuid),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $$PurchaseOrderTableTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $PurchaseOrderTableTable,
    PurchaseOrderTableData,
    $$PurchaseOrderTableTableFilterComposer,
    $$PurchaseOrderTableTableOrderingComposer,
    $$PurchaseOrderTableTableAnnotationComposer,
    $$PurchaseOrderTableTableCreateCompanionBuilder,
    $$PurchaseOrderTableTableUpdateCompanionBuilder,
    (PurchaseOrderTableData, $$PurchaseOrderTableTableReferences),
    PurchaseOrderTableData,
    PrefetchHooks Function(
        {bool supplierUuid, bool purchaseOrderItemTableRefs})>;
typedef $$PurchaseOrderItemTableTableCreateCompanionBuilder
    = PurchaseOrderItemTableCompanion Function({
  Value<int> id,
  required String poUuid,
  Value<String?> productUuid,
  Value<String?> ingredientUuid,
  required double quantityOrdered,
  Value<double> quantityReceived,
  required double unitCost,
});
typedef $$PurchaseOrderItemTableTableUpdateCompanionBuilder
    = PurchaseOrderItemTableCompanion Function({
  Value<int> id,
  Value<String> poUuid,
  Value<String?> productUuid,
  Value<String?> ingredientUuid,
  Value<double> quantityOrdered,
  Value<double> quantityReceived,
  Value<double> unitCost,
});

final class $$PurchaseOrderItemTableTableReferences extends BaseReferences<
    _$AppDatabase, $PurchaseOrderItemTableTable, PurchaseOrderItemTableData> {
  $$PurchaseOrderItemTableTableReferences(
      super.$_db, super.$_table, super.$_typedResult);

  static $PurchaseOrderTableTable _poUuidTable(_$AppDatabase db) =>
      db.purchaseOrderTable.createAlias($_aliasNameGenerator(
          db.purchaseOrderItemTable.poUuid, db.purchaseOrderTable.uuid));

  $$PurchaseOrderTableTableProcessedTableManager get poUuid {
    final $_column = $_itemColumn<String>('po_uuid')!;

    final manager =
        $$PurchaseOrderTableTableTableManager($_db, $_db.purchaseOrderTable)
            .filter((f) => f.uuid.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_poUuidTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static $ProductTableTable _productUuidTable(_$AppDatabase db) =>
      db.productTable.createAlias($_aliasNameGenerator(
          db.purchaseOrderItemTable.productUuid, db.productTable.uuid));

  $$ProductTableTableProcessedTableManager? get productUuid {
    final $_column = $_itemColumn<String>('product_uuid');
    if ($_column == null) return null;
    final manager = $$ProductTableTableTableManager($_db, $_db.productTable)
        .filter((f) => f.uuid.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_productUuidTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static $IngredientTableTable _ingredientUuidTable(_$AppDatabase db) =>
      db.ingredientTable.createAlias($_aliasNameGenerator(
          db.purchaseOrderItemTable.ingredientUuid, db.ingredientTable.uuid));

  $$IngredientTableTableProcessedTableManager? get ingredientUuid {
    final $_column = $_itemColumn<String>('ingredient_uuid');
    if ($_column == null) return null;
    final manager =
        $$IngredientTableTableTableManager($_db, $_db.ingredientTable)
            .filter((f) => f.uuid.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_ingredientUuidTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }
}

class $$PurchaseOrderItemTableTableFilterComposer
    extends Composer<_$AppDatabase, $PurchaseOrderItemTableTable> {
  $$PurchaseOrderItemTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get quantityOrdered => $composableBuilder(
      column: $table.quantityOrdered,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get quantityReceived => $composableBuilder(
      column: $table.quantityReceived,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get unitCost => $composableBuilder(
      column: $table.unitCost, builder: (column) => ColumnFilters(column));

  $$PurchaseOrderTableTableFilterComposer get poUuid {
    final $$PurchaseOrderTableTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.poUuid,
        referencedTable: $db.purchaseOrderTable,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$PurchaseOrderTableTableFilterComposer(
              $db: $db,
              $table: $db.purchaseOrderTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$ProductTableTableFilterComposer get productUuid {
    final $$ProductTableTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.productUuid,
        referencedTable: $db.productTable,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ProductTableTableFilterComposer(
              $db: $db,
              $table: $db.productTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$IngredientTableTableFilterComposer get ingredientUuid {
    final $$IngredientTableTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.ingredientUuid,
        referencedTable: $db.ingredientTable,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$IngredientTableTableFilterComposer(
              $db: $db,
              $table: $db.ingredientTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$PurchaseOrderItemTableTableOrderingComposer
    extends Composer<_$AppDatabase, $PurchaseOrderItemTableTable> {
  $$PurchaseOrderItemTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get quantityOrdered => $composableBuilder(
      column: $table.quantityOrdered,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get quantityReceived => $composableBuilder(
      column: $table.quantityReceived,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get unitCost => $composableBuilder(
      column: $table.unitCost, builder: (column) => ColumnOrderings(column));

  $$PurchaseOrderTableTableOrderingComposer get poUuid {
    final $$PurchaseOrderTableTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.poUuid,
        referencedTable: $db.purchaseOrderTable,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$PurchaseOrderTableTableOrderingComposer(
              $db: $db,
              $table: $db.purchaseOrderTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$ProductTableTableOrderingComposer get productUuid {
    final $$ProductTableTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.productUuid,
        referencedTable: $db.productTable,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ProductTableTableOrderingComposer(
              $db: $db,
              $table: $db.productTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$IngredientTableTableOrderingComposer get ingredientUuid {
    final $$IngredientTableTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.ingredientUuid,
        referencedTable: $db.ingredientTable,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$IngredientTableTableOrderingComposer(
              $db: $db,
              $table: $db.ingredientTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$PurchaseOrderItemTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $PurchaseOrderItemTableTable> {
  $$PurchaseOrderItemTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<double> get quantityOrdered => $composableBuilder(
      column: $table.quantityOrdered, builder: (column) => column);

  GeneratedColumn<double> get quantityReceived => $composableBuilder(
      column: $table.quantityReceived, builder: (column) => column);

  GeneratedColumn<double> get unitCost =>
      $composableBuilder(column: $table.unitCost, builder: (column) => column);

  $$PurchaseOrderTableTableAnnotationComposer get poUuid {
    final $$PurchaseOrderTableTableAnnotationComposer composer =
        $composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.poUuid,
            referencedTable: $db.purchaseOrderTable,
            getReferencedColumn: (t) => t.uuid,
            builder: (joinBuilder,
                    {$addJoinBuilderToRootComposer,
                    $removeJoinBuilderFromRootComposer}) =>
                $$PurchaseOrderTableTableAnnotationComposer(
                  $db: $db,
                  $table: $db.purchaseOrderTable,
                  $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                  joinBuilder: joinBuilder,
                  $removeJoinBuilderFromRootComposer:
                      $removeJoinBuilderFromRootComposer,
                ));
    return composer;
  }

  $$ProductTableTableAnnotationComposer get productUuid {
    final $$ProductTableTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.productUuid,
        referencedTable: $db.productTable,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ProductTableTableAnnotationComposer(
              $db: $db,
              $table: $db.productTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$IngredientTableTableAnnotationComposer get ingredientUuid {
    final $$IngredientTableTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.ingredientUuid,
        referencedTable: $db.ingredientTable,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$IngredientTableTableAnnotationComposer(
              $db: $db,
              $table: $db.ingredientTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$PurchaseOrderItemTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $PurchaseOrderItemTableTable,
    PurchaseOrderItemTableData,
    $$PurchaseOrderItemTableTableFilterComposer,
    $$PurchaseOrderItemTableTableOrderingComposer,
    $$PurchaseOrderItemTableTableAnnotationComposer,
    $$PurchaseOrderItemTableTableCreateCompanionBuilder,
    $$PurchaseOrderItemTableTableUpdateCompanionBuilder,
    (PurchaseOrderItemTableData, $$PurchaseOrderItemTableTableReferences),
    PurchaseOrderItemTableData,
    PrefetchHooks Function(
        {bool poUuid, bool productUuid, bool ingredientUuid})> {
  $$PurchaseOrderItemTableTableTableManager(
      _$AppDatabase db, $PurchaseOrderItemTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$PurchaseOrderItemTableTableFilterComposer(
                  $db: db, $table: table),
          createOrderingComposer: () =>
              $$PurchaseOrderItemTableTableOrderingComposer(
                  $db: db, $table: table),
          createComputedFieldComposer: () =>
              $$PurchaseOrderItemTableTableAnnotationComposer(
                  $db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> poUuid = const Value.absent(),
            Value<String?> productUuid = const Value.absent(),
            Value<String?> ingredientUuid = const Value.absent(),
            Value<double> quantityOrdered = const Value.absent(),
            Value<double> quantityReceived = const Value.absent(),
            Value<double> unitCost = const Value.absent(),
          }) =>
              PurchaseOrderItemTableCompanion(
            id: id,
            poUuid: poUuid,
            productUuid: productUuid,
            ingredientUuid: ingredientUuid,
            quantityOrdered: quantityOrdered,
            quantityReceived: quantityReceived,
            unitCost: unitCost,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String poUuid,
            Value<String?> productUuid = const Value.absent(),
            Value<String?> ingredientUuid = const Value.absent(),
            required double quantityOrdered,
            Value<double> quantityReceived = const Value.absent(),
            required double unitCost,
          }) =>
              PurchaseOrderItemTableCompanion.insert(
            id: id,
            poUuid: poUuid,
            productUuid: productUuid,
            ingredientUuid: ingredientUuid,
            quantityOrdered: quantityOrdered,
            quantityReceived: quantityReceived,
            unitCost: unitCost,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$PurchaseOrderItemTableTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: (
              {poUuid = false, productUuid = false, ingredientUuid = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (poUuid) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.poUuid,
                    referencedTable: $$PurchaseOrderItemTableTableReferences
                        ._poUuidTable(db),
                    referencedColumn: $$PurchaseOrderItemTableTableReferences
                        ._poUuidTable(db)
                        .uuid,
                  ) as T;
                }
                if (productUuid) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.productUuid,
                    referencedTable: $$PurchaseOrderItemTableTableReferences
                        ._productUuidTable(db),
                    referencedColumn: $$PurchaseOrderItemTableTableReferences
                        ._productUuidTable(db)
                        .uuid,
                  ) as T;
                }
                if (ingredientUuid) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.ingredientUuid,
                    referencedTable: $$PurchaseOrderItemTableTableReferences
                        ._ingredientUuidTable(db),
                    referencedColumn: $$PurchaseOrderItemTableTableReferences
                        ._ingredientUuidTable(db)
                        .uuid,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ));
}

typedef $$PurchaseOrderItemTableTableProcessedTableManager
    = ProcessedTableManager<
        _$AppDatabase,
        $PurchaseOrderItemTableTable,
        PurchaseOrderItemTableData,
        $$PurchaseOrderItemTableTableFilterComposer,
        $$PurchaseOrderItemTableTableOrderingComposer,
        $$PurchaseOrderItemTableTableAnnotationComposer,
        $$PurchaseOrderItemTableTableCreateCompanionBuilder,
        $$PurchaseOrderItemTableTableUpdateCompanionBuilder,
        (PurchaseOrderItemTableData, $$PurchaseOrderItemTableTableReferences),
        PurchaseOrderItemTableData,
        PrefetchHooks Function(
            {bool poUuid, bool productUuid, bool ingredientUuid})>;
typedef $$ShiftSessionTableTableCreateCompanionBuilder
    = ShiftSessionTableCompanion Function({
  Value<int> id,
  required String uuid,
  required String staffId,
  required String staffName,
  Value<String?> outletId,
  required DateTime startShift,
  Value<DateTime?> endShift,
  required double startCash,
  required double expectedCash,
  required double actualCash,
  required double difference,
  Value<String?> varianceReason,
  Value<bool> isClosed,
  Value<bool> isSynced,
});
typedef $$ShiftSessionTableTableUpdateCompanionBuilder
    = ShiftSessionTableCompanion Function({
  Value<int> id,
  Value<String> uuid,
  Value<String> staffId,
  Value<String> staffName,
  Value<String?> outletId,
  Value<DateTime> startShift,
  Value<DateTime?> endShift,
  Value<double> startCash,
  Value<double> expectedCash,
  Value<double> actualCash,
  Value<double> difference,
  Value<String?> varianceReason,
  Value<bool> isClosed,
  Value<bool> isSynced,
});

class $$ShiftSessionTableTableFilterComposer
    extends Composer<_$AppDatabase, $ShiftSessionTableTable> {
  $$ShiftSessionTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get staffId => $composableBuilder(
      column: $table.staffId, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get staffName => $composableBuilder(
      column: $table.staffName, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get outletId => $composableBuilder(
      column: $table.outletId, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get startShift => $composableBuilder(
      column: $table.startShift, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get endShift => $composableBuilder(
      column: $table.endShift, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get startCash => $composableBuilder(
      column: $table.startCash, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get expectedCash => $composableBuilder(
      column: $table.expectedCash, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get actualCash => $composableBuilder(
      column: $table.actualCash, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get difference => $composableBuilder(
      column: $table.difference, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get varianceReason => $composableBuilder(
      column: $table.varianceReason,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isClosed => $composableBuilder(
      column: $table.isClosed, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isSynced => $composableBuilder(
      column: $table.isSynced, builder: (column) => ColumnFilters(column));
}

class $$ShiftSessionTableTableOrderingComposer
    extends Composer<_$AppDatabase, $ShiftSessionTableTable> {
  $$ShiftSessionTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get staffId => $composableBuilder(
      column: $table.staffId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get staffName => $composableBuilder(
      column: $table.staffName, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get outletId => $composableBuilder(
      column: $table.outletId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get startShift => $composableBuilder(
      column: $table.startShift, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get endShift => $composableBuilder(
      column: $table.endShift, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get startCash => $composableBuilder(
      column: $table.startCash, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get expectedCash => $composableBuilder(
      column: $table.expectedCash,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get actualCash => $composableBuilder(
      column: $table.actualCash, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get difference => $composableBuilder(
      column: $table.difference, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get varianceReason => $composableBuilder(
      column: $table.varianceReason,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isClosed => $composableBuilder(
      column: $table.isClosed, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isSynced => $composableBuilder(
      column: $table.isSynced, builder: (column) => ColumnOrderings(column));
}

class $$ShiftSessionTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $ShiftSessionTableTable> {
  $$ShiftSessionTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get staffId =>
      $composableBuilder(column: $table.staffId, builder: (column) => column);

  GeneratedColumn<String> get staffName =>
      $composableBuilder(column: $table.staffName, builder: (column) => column);

  GeneratedColumn<String> get outletId =>
      $composableBuilder(column: $table.outletId, builder: (column) => column);

  GeneratedColumn<DateTime> get startShift => $composableBuilder(
      column: $table.startShift, builder: (column) => column);

  GeneratedColumn<DateTime> get endShift =>
      $composableBuilder(column: $table.endShift, builder: (column) => column);

  GeneratedColumn<double> get startCash =>
      $composableBuilder(column: $table.startCash, builder: (column) => column);

  GeneratedColumn<double> get expectedCash => $composableBuilder(
      column: $table.expectedCash, builder: (column) => column);

  GeneratedColumn<double> get actualCash => $composableBuilder(
      column: $table.actualCash, builder: (column) => column);

  GeneratedColumn<double> get difference => $composableBuilder(
      column: $table.difference, builder: (column) => column);

  GeneratedColumn<String> get varianceReason => $composableBuilder(
      column: $table.varianceReason, builder: (column) => column);

  GeneratedColumn<bool> get isClosed =>
      $composableBuilder(column: $table.isClosed, builder: (column) => column);

  GeneratedColumn<bool> get isSynced =>
      $composableBuilder(column: $table.isSynced, builder: (column) => column);
}

class $$ShiftSessionTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $ShiftSessionTableTable,
    ShiftSessionTableData,
    $$ShiftSessionTableTableFilterComposer,
    $$ShiftSessionTableTableOrderingComposer,
    $$ShiftSessionTableTableAnnotationComposer,
    $$ShiftSessionTableTableCreateCompanionBuilder,
    $$ShiftSessionTableTableUpdateCompanionBuilder,
    (
      ShiftSessionTableData,
      BaseReferences<_$AppDatabase, $ShiftSessionTableTable,
          ShiftSessionTableData>
    ),
    ShiftSessionTableData,
    PrefetchHooks Function()> {
  $$ShiftSessionTableTableTableManager(
      _$AppDatabase db, $ShiftSessionTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ShiftSessionTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ShiftSessionTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ShiftSessionTableTableAnnotationComposer(
                  $db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String> staffId = const Value.absent(),
            Value<String> staffName = const Value.absent(),
            Value<String?> outletId = const Value.absent(),
            Value<DateTime> startShift = const Value.absent(),
            Value<DateTime?> endShift = const Value.absent(),
            Value<double> startCash = const Value.absent(),
            Value<double> expectedCash = const Value.absent(),
            Value<double> actualCash = const Value.absent(),
            Value<double> difference = const Value.absent(),
            Value<String?> varianceReason = const Value.absent(),
            Value<bool> isClosed = const Value.absent(),
            Value<bool> isSynced = const Value.absent(),
          }) =>
              ShiftSessionTableCompanion(
            id: id,
            uuid: uuid,
            staffId: staffId,
            staffName: staffName,
            outletId: outletId,
            startShift: startShift,
            endShift: endShift,
            startCash: startCash,
            expectedCash: expectedCash,
            actualCash: actualCash,
            difference: difference,
            varianceReason: varianceReason,
            isClosed: isClosed,
            isSynced: isSynced,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            required String staffId,
            required String staffName,
            Value<String?> outletId = const Value.absent(),
            required DateTime startShift,
            Value<DateTime?> endShift = const Value.absent(),
            required double startCash,
            required double expectedCash,
            required double actualCash,
            required double difference,
            Value<String?> varianceReason = const Value.absent(),
            Value<bool> isClosed = const Value.absent(),
            Value<bool> isSynced = const Value.absent(),
          }) =>
              ShiftSessionTableCompanion.insert(
            id: id,
            uuid: uuid,
            staffId: staffId,
            staffName: staffName,
            outletId: outletId,
            startShift: startShift,
            endShift: endShift,
            startCash: startCash,
            expectedCash: expectedCash,
            actualCash: actualCash,
            difference: difference,
            varianceReason: varianceReason,
            isClosed: isClosed,
            isSynced: isSynced,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$ShiftSessionTableTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $ShiftSessionTableTable,
    ShiftSessionTableData,
    $$ShiftSessionTableTableFilterComposer,
    $$ShiftSessionTableTableOrderingComposer,
    $$ShiftSessionTableTableAnnotationComposer,
    $$ShiftSessionTableTableCreateCompanionBuilder,
    $$ShiftSessionTableTableUpdateCompanionBuilder,
    (
      ShiftSessionTableData,
      BaseReferences<_$AppDatabase, $ShiftSessionTableTable,
          ShiftSessionTableData>
    ),
    ShiftSessionTableData,
    PrefetchHooks Function()>;
typedef $$SyncQueueTableCreateCompanionBuilder = SyncQueueCompanion Function({
  Value<int> id,
  required String actionType,
  required String payloadJson,
  required String idempotencyKey,
  required DateTime createdAt,
  Value<String> status,
  Value<int> retryCount,
  Value<DateTime?> nextRetryAt,
});
typedef $$SyncQueueTableUpdateCompanionBuilder = SyncQueueCompanion Function({
  Value<int> id,
  Value<String> actionType,
  Value<String> payloadJson,
  Value<String> idempotencyKey,
  Value<DateTime> createdAt,
  Value<String> status,
  Value<int> retryCount,
  Value<DateTime?> nextRetryAt,
});

class $$SyncQueueTableFilterComposer
    extends Composer<_$AppDatabase, $SyncQueueTable> {
  $$SyncQueueTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get actionType => $composableBuilder(
      column: $table.actionType, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get payloadJson => $composableBuilder(
      column: $table.payloadJson, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get idempotencyKey => $composableBuilder(
      column: $table.idempotencyKey,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get retryCount => $composableBuilder(
      column: $table.retryCount, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get nextRetryAt => $composableBuilder(
      column: $table.nextRetryAt, builder: (column) => ColumnFilters(column));
}

class $$SyncQueueTableOrderingComposer
    extends Composer<_$AppDatabase, $SyncQueueTable> {
  $$SyncQueueTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get actionType => $composableBuilder(
      column: $table.actionType, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get payloadJson => $composableBuilder(
      column: $table.payloadJson, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get idempotencyKey => $composableBuilder(
      column: $table.idempotencyKey,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get retryCount => $composableBuilder(
      column: $table.retryCount, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get nextRetryAt => $composableBuilder(
      column: $table.nextRetryAt, builder: (column) => ColumnOrderings(column));
}

class $$SyncQueueTableAnnotationComposer
    extends Composer<_$AppDatabase, $SyncQueueTable> {
  $$SyncQueueTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get actionType => $composableBuilder(
      column: $table.actionType, builder: (column) => column);

  GeneratedColumn<String> get payloadJson => $composableBuilder(
      column: $table.payloadJson, builder: (column) => column);

  GeneratedColumn<String> get idempotencyKey => $composableBuilder(
      column: $table.idempotencyKey, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<int> get retryCount => $composableBuilder(
      column: $table.retryCount, builder: (column) => column);

  GeneratedColumn<DateTime> get nextRetryAt => $composableBuilder(
      column: $table.nextRetryAt, builder: (column) => column);
}

class $$SyncQueueTableTableManager extends RootTableManager<
    _$AppDatabase,
    $SyncQueueTable,
    SyncQueueData,
    $$SyncQueueTableFilterComposer,
    $$SyncQueueTableOrderingComposer,
    $$SyncQueueTableAnnotationComposer,
    $$SyncQueueTableCreateCompanionBuilder,
    $$SyncQueueTableUpdateCompanionBuilder,
    (
      SyncQueueData,
      BaseReferences<_$AppDatabase, $SyncQueueTable, SyncQueueData>
    ),
    SyncQueueData,
    PrefetchHooks Function()> {
  $$SyncQueueTableTableManager(_$AppDatabase db, $SyncQueueTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$SyncQueueTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$SyncQueueTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$SyncQueueTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> actionType = const Value.absent(),
            Value<String> payloadJson = const Value.absent(),
            Value<String> idempotencyKey = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<String> status = const Value.absent(),
            Value<int> retryCount = const Value.absent(),
            Value<DateTime?> nextRetryAt = const Value.absent(),
          }) =>
              SyncQueueCompanion(
            id: id,
            actionType: actionType,
            payloadJson: payloadJson,
            idempotencyKey: idempotencyKey,
            createdAt: createdAt,
            status: status,
            retryCount: retryCount,
            nextRetryAt: nextRetryAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String actionType,
            required String payloadJson,
            required String idempotencyKey,
            required DateTime createdAt,
            Value<String> status = const Value.absent(),
            Value<int> retryCount = const Value.absent(),
            Value<DateTime?> nextRetryAt = const Value.absent(),
          }) =>
              SyncQueueCompanion.insert(
            id: id,
            actionType: actionType,
            payloadJson: payloadJson,
            idempotencyKey: idempotencyKey,
            createdAt: createdAt,
            status: status,
            retryCount: retryCount,
            nextRetryAt: nextRetryAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$SyncQueueTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $SyncQueueTable,
    SyncQueueData,
    $$SyncQueueTableFilterComposer,
    $$SyncQueueTableOrderingComposer,
    $$SyncQueueTableAnnotationComposer,
    $$SyncQueueTableCreateCompanionBuilder,
    $$SyncQueueTableUpdateCompanionBuilder,
    (
      SyncQueueData,
      BaseReferences<_$AppDatabase, $SyncQueueTable, SyncQueueData>
    ),
    SyncQueueData,
    PrefetchHooks Function()>;
typedef $$CashTransactionTableTableCreateCompanionBuilder
    = CashTransactionTableCompanion Function({
  Value<int> id,
  required String uuid,
  Value<String?> shiftUuid,
  required String type,
  required double amount,
  Value<String?> reason,
  required DateTime createdAt,
  Value<bool> isSynced,
});
typedef $$CashTransactionTableTableUpdateCompanionBuilder
    = CashTransactionTableCompanion Function({
  Value<int> id,
  Value<String> uuid,
  Value<String?> shiftUuid,
  Value<String> type,
  Value<double> amount,
  Value<String?> reason,
  Value<DateTime> createdAt,
  Value<bool> isSynced,
});

class $$CashTransactionTableTableFilterComposer
    extends Composer<_$AppDatabase, $CashTransactionTableTable> {
  $$CashTransactionTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get shiftUuid => $composableBuilder(
      column: $table.shiftUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get type => $composableBuilder(
      column: $table.type, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get amount => $composableBuilder(
      column: $table.amount, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get reason => $composableBuilder(
      column: $table.reason, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isSynced => $composableBuilder(
      column: $table.isSynced, builder: (column) => ColumnFilters(column));
}

class $$CashTransactionTableTableOrderingComposer
    extends Composer<_$AppDatabase, $CashTransactionTableTable> {
  $$CashTransactionTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get shiftUuid => $composableBuilder(
      column: $table.shiftUuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get type => $composableBuilder(
      column: $table.type, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get amount => $composableBuilder(
      column: $table.amount, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get reason => $composableBuilder(
      column: $table.reason, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isSynced => $composableBuilder(
      column: $table.isSynced, builder: (column) => ColumnOrderings(column));
}

class $$CashTransactionTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $CashTransactionTableTable> {
  $$CashTransactionTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get shiftUuid =>
      $composableBuilder(column: $table.shiftUuid, builder: (column) => column);

  GeneratedColumn<String> get type =>
      $composableBuilder(column: $table.type, builder: (column) => column);

  GeneratedColumn<double> get amount =>
      $composableBuilder(column: $table.amount, builder: (column) => column);

  GeneratedColumn<String> get reason =>
      $composableBuilder(column: $table.reason, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<bool> get isSynced =>
      $composableBuilder(column: $table.isSynced, builder: (column) => column);
}

class $$CashTransactionTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $CashTransactionTableTable,
    CashTransactionTableData,
    $$CashTransactionTableTableFilterComposer,
    $$CashTransactionTableTableOrderingComposer,
    $$CashTransactionTableTableAnnotationComposer,
    $$CashTransactionTableTableCreateCompanionBuilder,
    $$CashTransactionTableTableUpdateCompanionBuilder,
    (
      CashTransactionTableData,
      BaseReferences<_$AppDatabase, $CashTransactionTableTable,
          CashTransactionTableData>
    ),
    CashTransactionTableData,
    PrefetchHooks Function()> {
  $$CashTransactionTableTableTableManager(
      _$AppDatabase db, $CashTransactionTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$CashTransactionTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$CashTransactionTableTableOrderingComposer(
                  $db: db, $table: table),
          createComputedFieldComposer: () =>
              $$CashTransactionTableTableAnnotationComposer(
                  $db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String?> shiftUuid = const Value.absent(),
            Value<String> type = const Value.absent(),
            Value<double> amount = const Value.absent(),
            Value<String?> reason = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<bool> isSynced = const Value.absent(),
          }) =>
              CashTransactionTableCompanion(
            id: id,
            uuid: uuid,
            shiftUuid: shiftUuid,
            type: type,
            amount: amount,
            reason: reason,
            createdAt: createdAt,
            isSynced: isSynced,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            Value<String?> shiftUuid = const Value.absent(),
            required String type,
            required double amount,
            Value<String?> reason = const Value.absent(),
            required DateTime createdAt,
            Value<bool> isSynced = const Value.absent(),
          }) =>
              CashTransactionTableCompanion.insert(
            id: id,
            uuid: uuid,
            shiftUuid: shiftUuid,
            type: type,
            amount: amount,
            reason: reason,
            createdAt: createdAt,
            isSynced: isSynced,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$CashTransactionTableTableProcessedTableManager
    = ProcessedTableManager<
        _$AppDatabase,
        $CashTransactionTableTable,
        CashTransactionTableData,
        $$CashTransactionTableTableFilterComposer,
        $$CashTransactionTableTableOrderingComposer,
        $$CashTransactionTableTableAnnotationComposer,
        $$CashTransactionTableTableCreateCompanionBuilder,
        $$CashTransactionTableTableUpdateCompanionBuilder,
        (
          CashTransactionTableData,
          BaseReferences<_$AppDatabase, $CashTransactionTableTable,
              CashTransactionTableData>
        ),
        CashTransactionTableData,
        PrefetchHooks Function()>;
typedef $$WasteTableTableCreateCompanionBuilder = WasteTableCompanion Function({
  Value<int> id,
  required String uuid,
  required String itemUuid,
  required String itemType,
  required double quantity,
  required String reason,
  Value<String?> note,
  required double costLoss,
  required String staffUuid,
  required String warehouseUuid,
  required DateTime recordedAt,
  Value<bool> isSynced,
});
typedef $$WasteTableTableUpdateCompanionBuilder = WasteTableCompanion Function({
  Value<int> id,
  Value<String> uuid,
  Value<String> itemUuid,
  Value<String> itemType,
  Value<double> quantity,
  Value<String> reason,
  Value<String?> note,
  Value<double> costLoss,
  Value<String> staffUuid,
  Value<String> warehouseUuid,
  Value<DateTime> recordedAt,
  Value<bool> isSynced,
});

class $$WasteTableTableFilterComposer
    extends Composer<_$AppDatabase, $WasteTableTable> {
  $$WasteTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get itemUuid => $composableBuilder(
      column: $table.itemUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get itemType => $composableBuilder(
      column: $table.itemType, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get quantity => $composableBuilder(
      column: $table.quantity, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get reason => $composableBuilder(
      column: $table.reason, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get note => $composableBuilder(
      column: $table.note, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get costLoss => $composableBuilder(
      column: $table.costLoss, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get staffUuid => $composableBuilder(
      column: $table.staffUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get warehouseUuid => $composableBuilder(
      column: $table.warehouseUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get recordedAt => $composableBuilder(
      column: $table.recordedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isSynced => $composableBuilder(
      column: $table.isSynced, builder: (column) => ColumnFilters(column));
}

class $$WasteTableTableOrderingComposer
    extends Composer<_$AppDatabase, $WasteTableTable> {
  $$WasteTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get itemUuid => $composableBuilder(
      column: $table.itemUuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get itemType => $composableBuilder(
      column: $table.itemType, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get quantity => $composableBuilder(
      column: $table.quantity, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get reason => $composableBuilder(
      column: $table.reason, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get note => $composableBuilder(
      column: $table.note, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get costLoss => $composableBuilder(
      column: $table.costLoss, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get staffUuid => $composableBuilder(
      column: $table.staffUuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get warehouseUuid => $composableBuilder(
      column: $table.warehouseUuid,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get recordedAt => $composableBuilder(
      column: $table.recordedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isSynced => $composableBuilder(
      column: $table.isSynced, builder: (column) => ColumnOrderings(column));
}

class $$WasteTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $WasteTableTable> {
  $$WasteTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get itemUuid =>
      $composableBuilder(column: $table.itemUuid, builder: (column) => column);

  GeneratedColumn<String> get itemType =>
      $composableBuilder(column: $table.itemType, builder: (column) => column);

  GeneratedColumn<double> get quantity =>
      $composableBuilder(column: $table.quantity, builder: (column) => column);

  GeneratedColumn<String> get reason =>
      $composableBuilder(column: $table.reason, builder: (column) => column);

  GeneratedColumn<String> get note =>
      $composableBuilder(column: $table.note, builder: (column) => column);

  GeneratedColumn<double> get costLoss =>
      $composableBuilder(column: $table.costLoss, builder: (column) => column);

  GeneratedColumn<String> get staffUuid =>
      $composableBuilder(column: $table.staffUuid, builder: (column) => column);

  GeneratedColumn<String> get warehouseUuid => $composableBuilder(
      column: $table.warehouseUuid, builder: (column) => column);

  GeneratedColumn<DateTime> get recordedAt => $composableBuilder(
      column: $table.recordedAt, builder: (column) => column);

  GeneratedColumn<bool> get isSynced =>
      $composableBuilder(column: $table.isSynced, builder: (column) => column);
}

class $$WasteTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $WasteTableTable,
    WasteTableData,
    $$WasteTableTableFilterComposer,
    $$WasteTableTableOrderingComposer,
    $$WasteTableTableAnnotationComposer,
    $$WasteTableTableCreateCompanionBuilder,
    $$WasteTableTableUpdateCompanionBuilder,
    (
      WasteTableData,
      BaseReferences<_$AppDatabase, $WasteTableTable, WasteTableData>
    ),
    WasteTableData,
    PrefetchHooks Function()> {
  $$WasteTableTableTableManager(_$AppDatabase db, $WasteTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$WasteTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$WasteTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$WasteTableTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String> itemUuid = const Value.absent(),
            Value<String> itemType = const Value.absent(),
            Value<double> quantity = const Value.absent(),
            Value<String> reason = const Value.absent(),
            Value<String?> note = const Value.absent(),
            Value<double> costLoss = const Value.absent(),
            Value<String> staffUuid = const Value.absent(),
            Value<String> warehouseUuid = const Value.absent(),
            Value<DateTime> recordedAt = const Value.absent(),
            Value<bool> isSynced = const Value.absent(),
          }) =>
              WasteTableCompanion(
            id: id,
            uuid: uuid,
            itemUuid: itemUuid,
            itemType: itemType,
            quantity: quantity,
            reason: reason,
            note: note,
            costLoss: costLoss,
            staffUuid: staffUuid,
            warehouseUuid: warehouseUuid,
            recordedAt: recordedAt,
            isSynced: isSynced,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            required String itemUuid,
            required String itemType,
            required double quantity,
            required String reason,
            Value<String?> note = const Value.absent(),
            required double costLoss,
            required String staffUuid,
            required String warehouseUuid,
            required DateTime recordedAt,
            Value<bool> isSynced = const Value.absent(),
          }) =>
              WasteTableCompanion.insert(
            id: id,
            uuid: uuid,
            itemUuid: itemUuid,
            itemType: itemType,
            quantity: quantity,
            reason: reason,
            note: note,
            costLoss: costLoss,
            staffUuid: staffUuid,
            warehouseUuid: warehouseUuid,
            recordedAt: recordedAt,
            isSynced: isSynced,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$WasteTableTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $WasteTableTable,
    WasteTableData,
    $$WasteTableTableFilterComposer,
    $$WasteTableTableOrderingComposer,
    $$WasteTableTableAnnotationComposer,
    $$WasteTableTableCreateCompanionBuilder,
    $$WasteTableTableUpdateCompanionBuilder,
    (
      WasteTableData,
      BaseReferences<_$AppDatabase, $WasteTableTable, WasteTableData>
    ),
    WasteTableData,
    PrefetchHooks Function()>;
typedef $$MarketingCampaignTableTableCreateCompanionBuilder
    = MarketingCampaignTableCompanion Function({
  Value<int> id,
  required String uuid,
  required String name,
  required String channel,
  required String triggerType,
  Value<String?> triggerValue,
  required String content,
  Value<bool> isActive,
  required DateTime createdAt,
  Value<DateTime?> updatedAt,
});
typedef $$MarketingCampaignTableTableUpdateCompanionBuilder
    = MarketingCampaignTableCompanion Function({
  Value<int> id,
  Value<String> uuid,
  Value<String> name,
  Value<String> channel,
  Value<String> triggerType,
  Value<String?> triggerValue,
  Value<String> content,
  Value<bool> isActive,
  Value<DateTime> createdAt,
  Value<DateTime?> updatedAt,
});

class $$MarketingCampaignTableTableFilterComposer
    extends Composer<_$AppDatabase, $MarketingCampaignTableTable> {
  $$MarketingCampaignTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get channel => $composableBuilder(
      column: $table.channel, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get triggerType => $composableBuilder(
      column: $table.triggerType, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get triggerValue => $composableBuilder(
      column: $table.triggerValue, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get content => $composableBuilder(
      column: $table.content, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isActive => $composableBuilder(
      column: $table.isActive, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));
}

class $$MarketingCampaignTableTableOrderingComposer
    extends Composer<_$AppDatabase, $MarketingCampaignTableTable> {
  $$MarketingCampaignTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get channel => $composableBuilder(
      column: $table.channel, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get triggerType => $composableBuilder(
      column: $table.triggerType, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get triggerValue => $composableBuilder(
      column: $table.triggerValue,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get content => $composableBuilder(
      column: $table.content, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isActive => $composableBuilder(
      column: $table.isActive, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));
}

class $$MarketingCampaignTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $MarketingCampaignTableTable> {
  $$MarketingCampaignTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get channel =>
      $composableBuilder(column: $table.channel, builder: (column) => column);

  GeneratedColumn<String> get triggerType => $composableBuilder(
      column: $table.triggerType, builder: (column) => column);

  GeneratedColumn<String> get triggerValue => $composableBuilder(
      column: $table.triggerValue, builder: (column) => column);

  GeneratedColumn<String> get content =>
      $composableBuilder(column: $table.content, builder: (column) => column);

  GeneratedColumn<bool> get isActive =>
      $composableBuilder(column: $table.isActive, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$MarketingCampaignTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $MarketingCampaignTableTable,
    MarketingCampaignTableData,
    $$MarketingCampaignTableTableFilterComposer,
    $$MarketingCampaignTableTableOrderingComposer,
    $$MarketingCampaignTableTableAnnotationComposer,
    $$MarketingCampaignTableTableCreateCompanionBuilder,
    $$MarketingCampaignTableTableUpdateCompanionBuilder,
    (
      MarketingCampaignTableData,
      BaseReferences<_$AppDatabase, $MarketingCampaignTableTable,
          MarketingCampaignTableData>
    ),
    MarketingCampaignTableData,
    PrefetchHooks Function()> {
  $$MarketingCampaignTableTableTableManager(
      _$AppDatabase db, $MarketingCampaignTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$MarketingCampaignTableTableFilterComposer(
                  $db: db, $table: table),
          createOrderingComposer: () =>
              $$MarketingCampaignTableTableOrderingComposer(
                  $db: db, $table: table),
          createComputedFieldComposer: () =>
              $$MarketingCampaignTableTableAnnotationComposer(
                  $db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String> name = const Value.absent(),
            Value<String> channel = const Value.absent(),
            Value<String> triggerType = const Value.absent(),
            Value<String?> triggerValue = const Value.absent(),
            Value<String> content = const Value.absent(),
            Value<bool> isActive = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<DateTime?> updatedAt = const Value.absent(),
          }) =>
              MarketingCampaignTableCompanion(
            id: id,
            uuid: uuid,
            name: name,
            channel: channel,
            triggerType: triggerType,
            triggerValue: triggerValue,
            content: content,
            isActive: isActive,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            required String name,
            required String channel,
            required String triggerType,
            Value<String?> triggerValue = const Value.absent(),
            required String content,
            Value<bool> isActive = const Value.absent(),
            required DateTime createdAt,
            Value<DateTime?> updatedAt = const Value.absent(),
          }) =>
              MarketingCampaignTableCompanion.insert(
            id: id,
            uuid: uuid,
            name: name,
            channel: channel,
            triggerType: triggerType,
            triggerValue: triggerValue,
            content: content,
            isActive: isActive,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$MarketingCampaignTableTableProcessedTableManager
    = ProcessedTableManager<
        _$AppDatabase,
        $MarketingCampaignTableTable,
        MarketingCampaignTableData,
        $$MarketingCampaignTableTableFilterComposer,
        $$MarketingCampaignTableTableOrderingComposer,
        $$MarketingCampaignTableTableAnnotationComposer,
        $$MarketingCampaignTableTableCreateCompanionBuilder,
        $$MarketingCampaignTableTableUpdateCompanionBuilder,
        (
          MarketingCampaignTableData,
          BaseReferences<_$AppDatabase, $MarketingCampaignTableTable,
              MarketingCampaignTableData>
        ),
        MarketingCampaignTableData,
        PrefetchHooks Function()>;
typedef $$CampaignRunHistoryTableTableCreateCompanionBuilder
    = CampaignRunHistoryTableCompanion Function({
  Value<int> id,
  required String uuid,
  required String campaignUuid,
  required String customerUuid,
  required String status,
  required DateTime sentAt,
  Value<String?> errorMessage,
});
typedef $$CampaignRunHistoryTableTableUpdateCompanionBuilder
    = CampaignRunHistoryTableCompanion Function({
  Value<int> id,
  Value<String> uuid,
  Value<String> campaignUuid,
  Value<String> customerUuid,
  Value<String> status,
  Value<DateTime> sentAt,
  Value<String?> errorMessage,
});

class $$CampaignRunHistoryTableTableFilterComposer
    extends Composer<_$AppDatabase, $CampaignRunHistoryTableTable> {
  $$CampaignRunHistoryTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get campaignUuid => $composableBuilder(
      column: $table.campaignUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get customerUuid => $composableBuilder(
      column: $table.customerUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get sentAt => $composableBuilder(
      column: $table.sentAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get errorMessage => $composableBuilder(
      column: $table.errorMessage, builder: (column) => ColumnFilters(column));
}

class $$CampaignRunHistoryTableTableOrderingComposer
    extends Composer<_$AppDatabase, $CampaignRunHistoryTableTable> {
  $$CampaignRunHistoryTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get campaignUuid => $composableBuilder(
      column: $table.campaignUuid,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get customerUuid => $composableBuilder(
      column: $table.customerUuid,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get sentAt => $composableBuilder(
      column: $table.sentAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get errorMessage => $composableBuilder(
      column: $table.errorMessage,
      builder: (column) => ColumnOrderings(column));
}

class $$CampaignRunHistoryTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $CampaignRunHistoryTableTable> {
  $$CampaignRunHistoryTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get campaignUuid => $composableBuilder(
      column: $table.campaignUuid, builder: (column) => column);

  GeneratedColumn<String> get customerUuid => $composableBuilder(
      column: $table.customerUuid, builder: (column) => column);

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<DateTime> get sentAt =>
      $composableBuilder(column: $table.sentAt, builder: (column) => column);

  GeneratedColumn<String> get errorMessage => $composableBuilder(
      column: $table.errorMessage, builder: (column) => column);
}

class $$CampaignRunHistoryTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $CampaignRunHistoryTableTable,
    CampaignRunHistoryTableData,
    $$CampaignRunHistoryTableTableFilterComposer,
    $$CampaignRunHistoryTableTableOrderingComposer,
    $$CampaignRunHistoryTableTableAnnotationComposer,
    $$CampaignRunHistoryTableTableCreateCompanionBuilder,
    $$CampaignRunHistoryTableTableUpdateCompanionBuilder,
    (
      CampaignRunHistoryTableData,
      BaseReferences<_$AppDatabase, $CampaignRunHistoryTableTable,
          CampaignRunHistoryTableData>
    ),
    CampaignRunHistoryTableData,
    PrefetchHooks Function()> {
  $$CampaignRunHistoryTableTableTableManager(
      _$AppDatabase db, $CampaignRunHistoryTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$CampaignRunHistoryTableTableFilterComposer(
                  $db: db, $table: table),
          createOrderingComposer: () =>
              $$CampaignRunHistoryTableTableOrderingComposer(
                  $db: db, $table: table),
          createComputedFieldComposer: () =>
              $$CampaignRunHistoryTableTableAnnotationComposer(
                  $db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String> campaignUuid = const Value.absent(),
            Value<String> customerUuid = const Value.absent(),
            Value<String> status = const Value.absent(),
            Value<DateTime> sentAt = const Value.absent(),
            Value<String?> errorMessage = const Value.absent(),
          }) =>
              CampaignRunHistoryTableCompanion(
            id: id,
            uuid: uuid,
            campaignUuid: campaignUuid,
            customerUuid: customerUuid,
            status: status,
            sentAt: sentAt,
            errorMessage: errorMessage,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            required String campaignUuid,
            required String customerUuid,
            required String status,
            required DateTime sentAt,
            Value<String?> errorMessage = const Value.absent(),
          }) =>
              CampaignRunHistoryTableCompanion.insert(
            id: id,
            uuid: uuid,
            campaignUuid: campaignUuid,
            customerUuid: customerUuid,
            status: status,
            sentAt: sentAt,
            errorMessage: errorMessage,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$CampaignRunHistoryTableTableProcessedTableManager
    = ProcessedTableManager<
        _$AppDatabase,
        $CampaignRunHistoryTableTable,
        CampaignRunHistoryTableData,
        $$CampaignRunHistoryTableTableFilterComposer,
        $$CampaignRunHistoryTableTableOrderingComposer,
        $$CampaignRunHistoryTableTableAnnotationComposer,
        $$CampaignRunHistoryTableTableCreateCompanionBuilder,
        $$CampaignRunHistoryTableTableUpdateCompanionBuilder,
        (
          CampaignRunHistoryTableData,
          BaseReferences<_$AppDatabase, $CampaignRunHistoryTableTable,
              CampaignRunHistoryTableData>
        ),
        CampaignRunHistoryTableData,
        PrefetchHooks Function()>;
typedef $$DeliveryChannelTableTableCreateCompanionBuilder
    = DeliveryChannelTableCompanion Function({
  required String id,
  required String provider,
  Value<bool> isActive,
  Value<bool> autoAcceptOrders,
  Value<double> surchargePercent,
  Value<DateTime?> lastSyncedAt,
  Value<int> rowid,
});
typedef $$DeliveryChannelTableTableUpdateCompanionBuilder
    = DeliveryChannelTableCompanion Function({
  Value<String> id,
  Value<String> provider,
  Value<bool> isActive,
  Value<bool> autoAcceptOrders,
  Value<double> surchargePercent,
  Value<DateTime?> lastSyncedAt,
  Value<int> rowid,
});

class $$DeliveryChannelTableTableFilterComposer
    extends Composer<_$AppDatabase, $DeliveryChannelTableTable> {
  $$DeliveryChannelTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get provider => $composableBuilder(
      column: $table.provider, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isActive => $composableBuilder(
      column: $table.isActive, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get autoAcceptOrders => $composableBuilder(
      column: $table.autoAcceptOrders,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get surchargePercent => $composableBuilder(
      column: $table.surchargePercent,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get lastSyncedAt => $composableBuilder(
      column: $table.lastSyncedAt, builder: (column) => ColumnFilters(column));
}

class $$DeliveryChannelTableTableOrderingComposer
    extends Composer<_$AppDatabase, $DeliveryChannelTableTable> {
  $$DeliveryChannelTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get provider => $composableBuilder(
      column: $table.provider, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isActive => $composableBuilder(
      column: $table.isActive, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get autoAcceptOrders => $composableBuilder(
      column: $table.autoAcceptOrders,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get surchargePercent => $composableBuilder(
      column: $table.surchargePercent,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get lastSyncedAt => $composableBuilder(
      column: $table.lastSyncedAt,
      builder: (column) => ColumnOrderings(column));
}

class $$DeliveryChannelTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $DeliveryChannelTableTable> {
  $$DeliveryChannelTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get provider =>
      $composableBuilder(column: $table.provider, builder: (column) => column);

  GeneratedColumn<bool> get isActive =>
      $composableBuilder(column: $table.isActive, builder: (column) => column);

  GeneratedColumn<bool> get autoAcceptOrders => $composableBuilder(
      column: $table.autoAcceptOrders, builder: (column) => column);

  GeneratedColumn<double> get surchargePercent => $composableBuilder(
      column: $table.surchargePercent, builder: (column) => column);

  GeneratedColumn<DateTime> get lastSyncedAt => $composableBuilder(
      column: $table.lastSyncedAt, builder: (column) => column);
}

class $$DeliveryChannelTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $DeliveryChannelTableTable,
    DeliveryChannelTableData,
    $$DeliveryChannelTableTableFilterComposer,
    $$DeliveryChannelTableTableOrderingComposer,
    $$DeliveryChannelTableTableAnnotationComposer,
    $$DeliveryChannelTableTableCreateCompanionBuilder,
    $$DeliveryChannelTableTableUpdateCompanionBuilder,
    (
      DeliveryChannelTableData,
      BaseReferences<_$AppDatabase, $DeliveryChannelTableTable,
          DeliveryChannelTableData>
    ),
    DeliveryChannelTableData,
    PrefetchHooks Function()> {
  $$DeliveryChannelTableTableTableManager(
      _$AppDatabase db, $DeliveryChannelTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$DeliveryChannelTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$DeliveryChannelTableTableOrderingComposer(
                  $db: db, $table: table),
          createComputedFieldComposer: () =>
              $$DeliveryChannelTableTableAnnotationComposer(
                  $db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> id = const Value.absent(),
            Value<String> provider = const Value.absent(),
            Value<bool> isActive = const Value.absent(),
            Value<bool> autoAcceptOrders = const Value.absent(),
            Value<double> surchargePercent = const Value.absent(),
            Value<DateTime?> lastSyncedAt = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              DeliveryChannelTableCompanion(
            id: id,
            provider: provider,
            isActive: isActive,
            autoAcceptOrders: autoAcceptOrders,
            surchargePercent: surchargePercent,
            lastSyncedAt: lastSyncedAt,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String id,
            required String provider,
            Value<bool> isActive = const Value.absent(),
            Value<bool> autoAcceptOrders = const Value.absent(),
            Value<double> surchargePercent = const Value.absent(),
            Value<DateTime?> lastSyncedAt = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              DeliveryChannelTableCompanion.insert(
            id: id,
            provider: provider,
            isActive: isActive,
            autoAcceptOrders: autoAcceptOrders,
            surchargePercent: surchargePercent,
            lastSyncedAt: lastSyncedAt,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$DeliveryChannelTableTableProcessedTableManager
    = ProcessedTableManager<
        _$AppDatabase,
        $DeliveryChannelTableTable,
        DeliveryChannelTableData,
        $$DeliveryChannelTableTableFilterComposer,
        $$DeliveryChannelTableTableOrderingComposer,
        $$DeliveryChannelTableTableAnnotationComposer,
        $$DeliveryChannelTableTableCreateCompanionBuilder,
        $$DeliveryChannelTableTableUpdateCompanionBuilder,
        (
          DeliveryChannelTableData,
          BaseReferences<_$AppDatabase, $DeliveryChannelTableTable,
              DeliveryChannelTableData>
        ),
        DeliveryChannelTableData,
        PrefetchHooks Function()>;
typedef $$DeliveryOrderMetadataTableTableCreateCompanionBuilder
    = DeliveryOrderMetadataTableCompanion Function({
  Value<int> id,
  required String orderUuid,
  required String provider,
  required String externalOrderId,
  Value<String?> driverName,
  Value<String?> driverPhone,
  Value<String?> driverPlate,
  Value<DateTime?> pickupTime,
  Value<String> deliveryStatus,
});
typedef $$DeliveryOrderMetadataTableTableUpdateCompanionBuilder
    = DeliveryOrderMetadataTableCompanion Function({
  Value<int> id,
  Value<String> orderUuid,
  Value<String> provider,
  Value<String> externalOrderId,
  Value<String?> driverName,
  Value<String?> driverPhone,
  Value<String?> driverPlate,
  Value<DateTime?> pickupTime,
  Value<String> deliveryStatus,
});

final class $$DeliveryOrderMetadataTableTableReferences extends BaseReferences<
    _$AppDatabase,
    $DeliveryOrderMetadataTableTable,
    DeliveryOrderMetadataTableData> {
  $$DeliveryOrderMetadataTableTableReferences(
      super.$_db, super.$_table, super.$_typedResult);

  static $OrderTableTable _orderUuidTable(_$AppDatabase db) =>
      db.orderTable.createAlias($_aliasNameGenerator(
          db.deliveryOrderMetadataTable.orderUuid, db.orderTable.uuid));

  $$OrderTableTableProcessedTableManager get orderUuid {
    final $_column = $_itemColumn<String>('order_uuid')!;

    final manager = $$OrderTableTableTableManager($_db, $_db.orderTable)
        .filter((f) => f.uuid.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_orderUuidTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }
}

class $$DeliveryOrderMetadataTableTableFilterComposer
    extends Composer<_$AppDatabase, $DeliveryOrderMetadataTableTable> {
  $$DeliveryOrderMetadataTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get provider => $composableBuilder(
      column: $table.provider, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get externalOrderId => $composableBuilder(
      column: $table.externalOrderId,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get driverName => $composableBuilder(
      column: $table.driverName, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get driverPhone => $composableBuilder(
      column: $table.driverPhone, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get driverPlate => $composableBuilder(
      column: $table.driverPlate, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get pickupTime => $composableBuilder(
      column: $table.pickupTime, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get deliveryStatus => $composableBuilder(
      column: $table.deliveryStatus,
      builder: (column) => ColumnFilters(column));

  $$OrderTableTableFilterComposer get orderUuid {
    final $$OrderTableTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.orderUuid,
        referencedTable: $db.orderTable,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$OrderTableTableFilterComposer(
              $db: $db,
              $table: $db.orderTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$DeliveryOrderMetadataTableTableOrderingComposer
    extends Composer<_$AppDatabase, $DeliveryOrderMetadataTableTable> {
  $$DeliveryOrderMetadataTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get provider => $composableBuilder(
      column: $table.provider, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get externalOrderId => $composableBuilder(
      column: $table.externalOrderId,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get driverName => $composableBuilder(
      column: $table.driverName, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get driverPhone => $composableBuilder(
      column: $table.driverPhone, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get driverPlate => $composableBuilder(
      column: $table.driverPlate, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get pickupTime => $composableBuilder(
      column: $table.pickupTime, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get deliveryStatus => $composableBuilder(
      column: $table.deliveryStatus,
      builder: (column) => ColumnOrderings(column));

  $$OrderTableTableOrderingComposer get orderUuid {
    final $$OrderTableTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.orderUuid,
        referencedTable: $db.orderTable,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$OrderTableTableOrderingComposer(
              $db: $db,
              $table: $db.orderTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$DeliveryOrderMetadataTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $DeliveryOrderMetadataTableTable> {
  $$DeliveryOrderMetadataTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get provider =>
      $composableBuilder(column: $table.provider, builder: (column) => column);

  GeneratedColumn<String> get externalOrderId => $composableBuilder(
      column: $table.externalOrderId, builder: (column) => column);

  GeneratedColumn<String> get driverName => $composableBuilder(
      column: $table.driverName, builder: (column) => column);

  GeneratedColumn<String> get driverPhone => $composableBuilder(
      column: $table.driverPhone, builder: (column) => column);

  GeneratedColumn<String> get driverPlate => $composableBuilder(
      column: $table.driverPlate, builder: (column) => column);

  GeneratedColumn<DateTime> get pickupTime => $composableBuilder(
      column: $table.pickupTime, builder: (column) => column);

  GeneratedColumn<String> get deliveryStatus => $composableBuilder(
      column: $table.deliveryStatus, builder: (column) => column);

  $$OrderTableTableAnnotationComposer get orderUuid {
    final $$OrderTableTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.orderUuid,
        referencedTable: $db.orderTable,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$OrderTableTableAnnotationComposer(
              $db: $db,
              $table: $db.orderTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$DeliveryOrderMetadataTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $DeliveryOrderMetadataTableTable,
    DeliveryOrderMetadataTableData,
    $$DeliveryOrderMetadataTableTableFilterComposer,
    $$DeliveryOrderMetadataTableTableOrderingComposer,
    $$DeliveryOrderMetadataTableTableAnnotationComposer,
    $$DeliveryOrderMetadataTableTableCreateCompanionBuilder,
    $$DeliveryOrderMetadataTableTableUpdateCompanionBuilder,
    (
      DeliveryOrderMetadataTableData,
      $$DeliveryOrderMetadataTableTableReferences
    ),
    DeliveryOrderMetadataTableData,
    PrefetchHooks Function({bool orderUuid})> {
  $$DeliveryOrderMetadataTableTableTableManager(
      _$AppDatabase db, $DeliveryOrderMetadataTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$DeliveryOrderMetadataTableTableFilterComposer(
                  $db: db, $table: table),
          createOrderingComposer: () =>
              $$DeliveryOrderMetadataTableTableOrderingComposer(
                  $db: db, $table: table),
          createComputedFieldComposer: () =>
              $$DeliveryOrderMetadataTableTableAnnotationComposer(
                  $db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> orderUuid = const Value.absent(),
            Value<String> provider = const Value.absent(),
            Value<String> externalOrderId = const Value.absent(),
            Value<String?> driverName = const Value.absent(),
            Value<String?> driverPhone = const Value.absent(),
            Value<String?> driverPlate = const Value.absent(),
            Value<DateTime?> pickupTime = const Value.absent(),
            Value<String> deliveryStatus = const Value.absent(),
          }) =>
              DeliveryOrderMetadataTableCompanion(
            id: id,
            orderUuid: orderUuid,
            provider: provider,
            externalOrderId: externalOrderId,
            driverName: driverName,
            driverPhone: driverPhone,
            driverPlate: driverPlate,
            pickupTime: pickupTime,
            deliveryStatus: deliveryStatus,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String orderUuid,
            required String provider,
            required String externalOrderId,
            Value<String?> driverName = const Value.absent(),
            Value<String?> driverPhone = const Value.absent(),
            Value<String?> driverPlate = const Value.absent(),
            Value<DateTime?> pickupTime = const Value.absent(),
            Value<String> deliveryStatus = const Value.absent(),
          }) =>
              DeliveryOrderMetadataTableCompanion.insert(
            id: id,
            orderUuid: orderUuid,
            provider: provider,
            externalOrderId: externalOrderId,
            driverName: driverName,
            driverPhone: driverPhone,
            driverPlate: driverPlate,
            pickupTime: pickupTime,
            deliveryStatus: deliveryStatus,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$DeliveryOrderMetadataTableTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: ({orderUuid = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (orderUuid) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.orderUuid,
                    referencedTable: $$DeliveryOrderMetadataTableTableReferences
                        ._orderUuidTable(db),
                    referencedColumn:
                        $$DeliveryOrderMetadataTableTableReferences
                            ._orderUuidTable(db)
                            .uuid,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ));
}

typedef $$DeliveryOrderMetadataTableTableProcessedTableManager
    = ProcessedTableManager<
        _$AppDatabase,
        $DeliveryOrderMetadataTableTable,
        DeliveryOrderMetadataTableData,
        $$DeliveryOrderMetadataTableTableFilterComposer,
        $$DeliveryOrderMetadataTableTableOrderingComposer,
        $$DeliveryOrderMetadataTableTableAnnotationComposer,
        $$DeliveryOrderMetadataTableTableCreateCompanionBuilder,
        $$DeliveryOrderMetadataTableTableUpdateCompanionBuilder,
        (
          DeliveryOrderMetadataTableData,
          $$DeliveryOrderMetadataTableTableReferences
        ),
        DeliveryOrderMetadataTableData,
        PrefetchHooks Function({bool orderUuid})>;
typedef $$CashDrawerTableTableCreateCompanionBuilder = CashDrawerTableCompanion
    Function({
  Value<int> id,
  required String uuid,
  required String shiftUuid,
  required String employeeUuid,
  required String employeeName,
  required double startingBalance,
  required double currentBalance,
  required double expectedBalance,
  Value<String> state,
  required DateTime openedAt,
  Value<DateTime?> closedAt,
  Value<double?> closingBalance,
  Value<double?> variance,
});
typedef $$CashDrawerTableTableUpdateCompanionBuilder = CashDrawerTableCompanion
    Function({
  Value<int> id,
  Value<String> uuid,
  Value<String> shiftUuid,
  Value<String> employeeUuid,
  Value<String> employeeName,
  Value<double> startingBalance,
  Value<double> currentBalance,
  Value<double> expectedBalance,
  Value<String> state,
  Value<DateTime> openedAt,
  Value<DateTime?> closedAt,
  Value<double?> closingBalance,
  Value<double?> variance,
});

class $$CashDrawerTableTableFilterComposer
    extends Composer<_$AppDatabase, $CashDrawerTableTable> {
  $$CashDrawerTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get shiftUuid => $composableBuilder(
      column: $table.shiftUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get employeeUuid => $composableBuilder(
      column: $table.employeeUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get employeeName => $composableBuilder(
      column: $table.employeeName, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get startingBalance => $composableBuilder(
      column: $table.startingBalance,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get currentBalance => $composableBuilder(
      column: $table.currentBalance,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get expectedBalance => $composableBuilder(
      column: $table.expectedBalance,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get state => $composableBuilder(
      column: $table.state, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get openedAt => $composableBuilder(
      column: $table.openedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get closedAt => $composableBuilder(
      column: $table.closedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get closingBalance => $composableBuilder(
      column: $table.closingBalance,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get variance => $composableBuilder(
      column: $table.variance, builder: (column) => ColumnFilters(column));
}

class $$CashDrawerTableTableOrderingComposer
    extends Composer<_$AppDatabase, $CashDrawerTableTable> {
  $$CashDrawerTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get shiftUuid => $composableBuilder(
      column: $table.shiftUuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get employeeUuid => $composableBuilder(
      column: $table.employeeUuid,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get employeeName => $composableBuilder(
      column: $table.employeeName,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get startingBalance => $composableBuilder(
      column: $table.startingBalance,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get currentBalance => $composableBuilder(
      column: $table.currentBalance,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get expectedBalance => $composableBuilder(
      column: $table.expectedBalance,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get state => $composableBuilder(
      column: $table.state, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get openedAt => $composableBuilder(
      column: $table.openedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get closedAt => $composableBuilder(
      column: $table.closedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get closingBalance => $composableBuilder(
      column: $table.closingBalance,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get variance => $composableBuilder(
      column: $table.variance, builder: (column) => ColumnOrderings(column));
}

class $$CashDrawerTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $CashDrawerTableTable> {
  $$CashDrawerTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get shiftUuid =>
      $composableBuilder(column: $table.shiftUuid, builder: (column) => column);

  GeneratedColumn<String> get employeeUuid => $composableBuilder(
      column: $table.employeeUuid, builder: (column) => column);

  GeneratedColumn<String> get employeeName => $composableBuilder(
      column: $table.employeeName, builder: (column) => column);

  GeneratedColumn<double> get startingBalance => $composableBuilder(
      column: $table.startingBalance, builder: (column) => column);

  GeneratedColumn<double> get currentBalance => $composableBuilder(
      column: $table.currentBalance, builder: (column) => column);

  GeneratedColumn<double> get expectedBalance => $composableBuilder(
      column: $table.expectedBalance, builder: (column) => column);

  GeneratedColumn<String> get state =>
      $composableBuilder(column: $table.state, builder: (column) => column);

  GeneratedColumn<DateTime> get openedAt =>
      $composableBuilder(column: $table.openedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get closedAt =>
      $composableBuilder(column: $table.closedAt, builder: (column) => column);

  GeneratedColumn<double> get closingBalance => $composableBuilder(
      column: $table.closingBalance, builder: (column) => column);

  GeneratedColumn<double> get variance =>
      $composableBuilder(column: $table.variance, builder: (column) => column);
}

class $$CashDrawerTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $CashDrawerTableTable,
    CashDrawerTableData,
    $$CashDrawerTableTableFilterComposer,
    $$CashDrawerTableTableOrderingComposer,
    $$CashDrawerTableTableAnnotationComposer,
    $$CashDrawerTableTableCreateCompanionBuilder,
    $$CashDrawerTableTableUpdateCompanionBuilder,
    (
      CashDrawerTableData,
      BaseReferences<_$AppDatabase, $CashDrawerTableTable, CashDrawerTableData>
    ),
    CashDrawerTableData,
    PrefetchHooks Function()> {
  $$CashDrawerTableTableTableManager(
      _$AppDatabase db, $CashDrawerTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$CashDrawerTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$CashDrawerTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$CashDrawerTableTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String> shiftUuid = const Value.absent(),
            Value<String> employeeUuid = const Value.absent(),
            Value<String> employeeName = const Value.absent(),
            Value<double> startingBalance = const Value.absent(),
            Value<double> currentBalance = const Value.absent(),
            Value<double> expectedBalance = const Value.absent(),
            Value<String> state = const Value.absent(),
            Value<DateTime> openedAt = const Value.absent(),
            Value<DateTime?> closedAt = const Value.absent(),
            Value<double?> closingBalance = const Value.absent(),
            Value<double?> variance = const Value.absent(),
          }) =>
              CashDrawerTableCompanion(
            id: id,
            uuid: uuid,
            shiftUuid: shiftUuid,
            employeeUuid: employeeUuid,
            employeeName: employeeName,
            startingBalance: startingBalance,
            currentBalance: currentBalance,
            expectedBalance: expectedBalance,
            state: state,
            openedAt: openedAt,
            closedAt: closedAt,
            closingBalance: closingBalance,
            variance: variance,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            required String shiftUuid,
            required String employeeUuid,
            required String employeeName,
            required double startingBalance,
            required double currentBalance,
            required double expectedBalance,
            Value<String> state = const Value.absent(),
            required DateTime openedAt,
            Value<DateTime?> closedAt = const Value.absent(),
            Value<double?> closingBalance = const Value.absent(),
            Value<double?> variance = const Value.absent(),
          }) =>
              CashDrawerTableCompanion.insert(
            id: id,
            uuid: uuid,
            shiftUuid: shiftUuid,
            employeeUuid: employeeUuid,
            employeeName: employeeName,
            startingBalance: startingBalance,
            currentBalance: currentBalance,
            expectedBalance: expectedBalance,
            state: state,
            openedAt: openedAt,
            closedAt: closedAt,
            closingBalance: closingBalance,
            variance: variance,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$CashDrawerTableTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $CashDrawerTableTable,
    CashDrawerTableData,
    $$CashDrawerTableTableFilterComposer,
    $$CashDrawerTableTableOrderingComposer,
    $$CashDrawerTableTableAnnotationComposer,
    $$CashDrawerTableTableCreateCompanionBuilder,
    $$CashDrawerTableTableUpdateCompanionBuilder,
    (
      CashDrawerTableData,
      BaseReferences<_$AppDatabase, $CashDrawerTableTable, CashDrawerTableData>
    ),
    CashDrawerTableData,
    PrefetchHooks Function()>;
typedef $$CashEventTableTableCreateCompanionBuilder = CashEventTableCompanion
    Function({
  Value<int> id,
  required String uuid,
  required String drawerUuid,
  required String type,
  required double amount,
  required String reason,
  Value<String?> comment,
  Value<String?> performedBy,
  Value<String?> orderUuid,
  required DateTime timestamp,
});
typedef $$CashEventTableTableUpdateCompanionBuilder = CashEventTableCompanion
    Function({
  Value<int> id,
  Value<String> uuid,
  Value<String> drawerUuid,
  Value<String> type,
  Value<double> amount,
  Value<String> reason,
  Value<String?> comment,
  Value<String?> performedBy,
  Value<String?> orderUuid,
  Value<DateTime> timestamp,
});

class $$CashEventTableTableFilterComposer
    extends Composer<_$AppDatabase, $CashEventTableTable> {
  $$CashEventTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get drawerUuid => $composableBuilder(
      column: $table.drawerUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get type => $composableBuilder(
      column: $table.type, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get amount => $composableBuilder(
      column: $table.amount, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get reason => $composableBuilder(
      column: $table.reason, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get comment => $composableBuilder(
      column: $table.comment, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get performedBy => $composableBuilder(
      column: $table.performedBy, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get orderUuid => $composableBuilder(
      column: $table.orderUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get timestamp => $composableBuilder(
      column: $table.timestamp, builder: (column) => ColumnFilters(column));
}

class $$CashEventTableTableOrderingComposer
    extends Composer<_$AppDatabase, $CashEventTableTable> {
  $$CashEventTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get drawerUuid => $composableBuilder(
      column: $table.drawerUuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get type => $composableBuilder(
      column: $table.type, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get amount => $composableBuilder(
      column: $table.amount, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get reason => $composableBuilder(
      column: $table.reason, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get comment => $composableBuilder(
      column: $table.comment, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get performedBy => $composableBuilder(
      column: $table.performedBy, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get orderUuid => $composableBuilder(
      column: $table.orderUuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get timestamp => $composableBuilder(
      column: $table.timestamp, builder: (column) => ColumnOrderings(column));
}

class $$CashEventTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $CashEventTableTable> {
  $$CashEventTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get drawerUuid => $composableBuilder(
      column: $table.drawerUuid, builder: (column) => column);

  GeneratedColumn<String> get type =>
      $composableBuilder(column: $table.type, builder: (column) => column);

  GeneratedColumn<double> get amount =>
      $composableBuilder(column: $table.amount, builder: (column) => column);

  GeneratedColumn<String> get reason =>
      $composableBuilder(column: $table.reason, builder: (column) => column);

  GeneratedColumn<String> get comment =>
      $composableBuilder(column: $table.comment, builder: (column) => column);

  GeneratedColumn<String> get performedBy => $composableBuilder(
      column: $table.performedBy, builder: (column) => column);

  GeneratedColumn<String> get orderUuid =>
      $composableBuilder(column: $table.orderUuid, builder: (column) => column);

  GeneratedColumn<DateTime> get timestamp =>
      $composableBuilder(column: $table.timestamp, builder: (column) => column);
}

class $$CashEventTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $CashEventTableTable,
    CashEventTableData,
    $$CashEventTableTableFilterComposer,
    $$CashEventTableTableOrderingComposer,
    $$CashEventTableTableAnnotationComposer,
    $$CashEventTableTableCreateCompanionBuilder,
    $$CashEventTableTableUpdateCompanionBuilder,
    (
      CashEventTableData,
      BaseReferences<_$AppDatabase, $CashEventTableTable, CashEventTableData>
    ),
    CashEventTableData,
    PrefetchHooks Function()> {
  $$CashEventTableTableTableManager(
      _$AppDatabase db, $CashEventTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$CashEventTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$CashEventTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$CashEventTableTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String> drawerUuid = const Value.absent(),
            Value<String> type = const Value.absent(),
            Value<double> amount = const Value.absent(),
            Value<String> reason = const Value.absent(),
            Value<String?> comment = const Value.absent(),
            Value<String?> performedBy = const Value.absent(),
            Value<String?> orderUuid = const Value.absent(),
            Value<DateTime> timestamp = const Value.absent(),
          }) =>
              CashEventTableCompanion(
            id: id,
            uuid: uuid,
            drawerUuid: drawerUuid,
            type: type,
            amount: amount,
            reason: reason,
            comment: comment,
            performedBy: performedBy,
            orderUuid: orderUuid,
            timestamp: timestamp,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            required String drawerUuid,
            required String type,
            required double amount,
            required String reason,
            Value<String?> comment = const Value.absent(),
            Value<String?> performedBy = const Value.absent(),
            Value<String?> orderUuid = const Value.absent(),
            required DateTime timestamp,
          }) =>
              CashEventTableCompanion.insert(
            id: id,
            uuid: uuid,
            drawerUuid: drawerUuid,
            type: type,
            amount: amount,
            reason: reason,
            comment: comment,
            performedBy: performedBy,
            orderUuid: orderUuid,
            timestamp: timestamp,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$CashEventTableTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $CashEventTableTable,
    CashEventTableData,
    $$CashEventTableTableFilterComposer,
    $$CashEventTableTableOrderingComposer,
    $$CashEventTableTableAnnotationComposer,
    $$CashEventTableTableCreateCompanionBuilder,
    $$CashEventTableTableUpdateCompanionBuilder,
    (
      CashEventTableData,
      BaseReferences<_$AppDatabase, $CashEventTableTable, CashEventTableData>
    ),
    CashEventTableData,
    PrefetchHooks Function()>;
typedef $$CustomerNoteTableTableCreateCompanionBuilder
    = CustomerNoteTableCompanion Function({
  Value<int> id,
  required String uuid,
  required String customerUuid,
  required String content,
  required String createdBy,
  required DateTime createdAt,
  Value<bool> isCritical,
});
typedef $$CustomerNoteTableTableUpdateCompanionBuilder
    = CustomerNoteTableCompanion Function({
  Value<int> id,
  Value<String> uuid,
  Value<String> customerUuid,
  Value<String> content,
  Value<String> createdBy,
  Value<DateTime> createdAt,
  Value<bool> isCritical,
});

class $$CustomerNoteTableTableFilterComposer
    extends Composer<_$AppDatabase, $CustomerNoteTableTable> {
  $$CustomerNoteTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get customerUuid => $composableBuilder(
      column: $table.customerUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get content => $composableBuilder(
      column: $table.content, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get createdBy => $composableBuilder(
      column: $table.createdBy, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isCritical => $composableBuilder(
      column: $table.isCritical, builder: (column) => ColumnFilters(column));
}

class $$CustomerNoteTableTableOrderingComposer
    extends Composer<_$AppDatabase, $CustomerNoteTableTable> {
  $$CustomerNoteTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get customerUuid => $composableBuilder(
      column: $table.customerUuid,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get content => $composableBuilder(
      column: $table.content, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get createdBy => $composableBuilder(
      column: $table.createdBy, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isCritical => $composableBuilder(
      column: $table.isCritical, builder: (column) => ColumnOrderings(column));
}

class $$CustomerNoteTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $CustomerNoteTableTable> {
  $$CustomerNoteTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get customerUuid => $composableBuilder(
      column: $table.customerUuid, builder: (column) => column);

  GeneratedColumn<String> get content =>
      $composableBuilder(column: $table.content, builder: (column) => column);

  GeneratedColumn<String> get createdBy =>
      $composableBuilder(column: $table.createdBy, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<bool> get isCritical => $composableBuilder(
      column: $table.isCritical, builder: (column) => column);
}

class $$CustomerNoteTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $CustomerNoteTableTable,
    CustomerNoteTableData,
    $$CustomerNoteTableTableFilterComposer,
    $$CustomerNoteTableTableOrderingComposer,
    $$CustomerNoteTableTableAnnotationComposer,
    $$CustomerNoteTableTableCreateCompanionBuilder,
    $$CustomerNoteTableTableUpdateCompanionBuilder,
    (
      CustomerNoteTableData,
      BaseReferences<_$AppDatabase, $CustomerNoteTableTable,
          CustomerNoteTableData>
    ),
    CustomerNoteTableData,
    PrefetchHooks Function()> {
  $$CustomerNoteTableTableTableManager(
      _$AppDatabase db, $CustomerNoteTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$CustomerNoteTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$CustomerNoteTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$CustomerNoteTableTableAnnotationComposer(
                  $db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String> customerUuid = const Value.absent(),
            Value<String> content = const Value.absent(),
            Value<String> createdBy = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<bool> isCritical = const Value.absent(),
          }) =>
              CustomerNoteTableCompanion(
            id: id,
            uuid: uuid,
            customerUuid: customerUuid,
            content: content,
            createdBy: createdBy,
            createdAt: createdAt,
            isCritical: isCritical,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            required String customerUuid,
            required String content,
            required String createdBy,
            required DateTime createdAt,
            Value<bool> isCritical = const Value.absent(),
          }) =>
              CustomerNoteTableCompanion.insert(
            id: id,
            uuid: uuid,
            customerUuid: customerUuid,
            content: content,
            createdBy: createdBy,
            createdAt: createdAt,
            isCritical: isCritical,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$CustomerNoteTableTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $CustomerNoteTableTable,
    CustomerNoteTableData,
    $$CustomerNoteTableTableFilterComposer,
    $$CustomerNoteTableTableOrderingComposer,
    $$CustomerNoteTableTableAnnotationComposer,
    $$CustomerNoteTableTableCreateCompanionBuilder,
    $$CustomerNoteTableTableUpdateCompanionBuilder,
    (
      CustomerNoteTableData,
      BaseReferences<_$AppDatabase, $CustomerNoteTableTable,
          CustomerNoteTableData>
    ),
    CustomerNoteTableData,
    PrefetchHooks Function()>;
typedef $$CustomerTagTableTableCreateCompanionBuilder
    = CustomerTagTableCompanion Function({
  Value<int> id,
  required String customerUuid,
  required String tag,
});
typedef $$CustomerTagTableTableUpdateCompanionBuilder
    = CustomerTagTableCompanion Function({
  Value<int> id,
  Value<String> customerUuid,
  Value<String> tag,
});

class $$CustomerTagTableTableFilterComposer
    extends Composer<_$AppDatabase, $CustomerTagTableTable> {
  $$CustomerTagTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get customerUuid => $composableBuilder(
      column: $table.customerUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get tag => $composableBuilder(
      column: $table.tag, builder: (column) => ColumnFilters(column));
}

class $$CustomerTagTableTableOrderingComposer
    extends Composer<_$AppDatabase, $CustomerTagTableTable> {
  $$CustomerTagTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get customerUuid => $composableBuilder(
      column: $table.customerUuid,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get tag => $composableBuilder(
      column: $table.tag, builder: (column) => ColumnOrderings(column));
}

class $$CustomerTagTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $CustomerTagTableTable> {
  $$CustomerTagTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get customerUuid => $composableBuilder(
      column: $table.customerUuid, builder: (column) => column);

  GeneratedColumn<String> get tag =>
      $composableBuilder(column: $table.tag, builder: (column) => column);
}

class $$CustomerTagTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $CustomerTagTableTable,
    CustomerTagTableData,
    $$CustomerTagTableTableFilterComposer,
    $$CustomerTagTableTableOrderingComposer,
    $$CustomerTagTableTableAnnotationComposer,
    $$CustomerTagTableTableCreateCompanionBuilder,
    $$CustomerTagTableTableUpdateCompanionBuilder,
    (
      CustomerTagTableData,
      BaseReferences<_$AppDatabase, $CustomerTagTableTable,
          CustomerTagTableData>
    ),
    CustomerTagTableData,
    PrefetchHooks Function()> {
  $$CustomerTagTableTableTableManager(
      _$AppDatabase db, $CustomerTagTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$CustomerTagTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$CustomerTagTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$CustomerTagTableTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> customerUuid = const Value.absent(),
            Value<String> tag = const Value.absent(),
          }) =>
              CustomerTagTableCompanion(
            id: id,
            customerUuid: customerUuid,
            tag: tag,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String customerUuid,
            required String tag,
          }) =>
              CustomerTagTableCompanion.insert(
            id: id,
            customerUuid: customerUuid,
            tag: tag,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$CustomerTagTableTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $CustomerTagTableTable,
    CustomerTagTableData,
    $$CustomerTagTableTableFilterComposer,
    $$CustomerTagTableTableOrderingComposer,
    $$CustomerTagTableTableAnnotationComposer,
    $$CustomerTagTableTableCreateCompanionBuilder,
    $$CustomerTagTableTableUpdateCompanionBuilder,
    (
      CustomerTagTableData,
      BaseReferences<_$AppDatabase, $CustomerTagTableTable,
          CustomerTagTableData>
    ),
    CustomerTagTableData,
    PrefetchHooks Function()>;
typedef $$PaymentTransactionTableTableCreateCompanionBuilder
    = PaymentTransactionTableCompanion Function({
  Value<int> id,
  required String uuid,
  required String orderUuid,
  required String method,
  required double amount,
  Value<double?> tendered,
  Value<double?> change,
  Value<String> status,
  Value<String?> referenceId,
  Value<String?> note,
  required DateTime createdAt,
  Value<String?> createdBy,
  Value<bool> isSynced,
});
typedef $$PaymentTransactionTableTableUpdateCompanionBuilder
    = PaymentTransactionTableCompanion Function({
  Value<int> id,
  Value<String> uuid,
  Value<String> orderUuid,
  Value<String> method,
  Value<double> amount,
  Value<double?> tendered,
  Value<double?> change,
  Value<String> status,
  Value<String?> referenceId,
  Value<String?> note,
  Value<DateTime> createdAt,
  Value<String?> createdBy,
  Value<bool> isSynced,
});

final class $$PaymentTransactionTableTableReferences extends BaseReferences<
    _$AppDatabase, $PaymentTransactionTableTable, PaymentTransactionTableData> {
  $$PaymentTransactionTableTableReferences(
      super.$_db, super.$_table, super.$_typedResult);

  static $OrderTableTable _orderUuidTable(_$AppDatabase db) =>
      db.orderTable.createAlias($_aliasNameGenerator(
          db.paymentTransactionTable.orderUuid, db.orderTable.uuid));

  $$OrderTableTableProcessedTableManager get orderUuid {
    final $_column = $_itemColumn<String>('order_uuid')!;

    final manager = $$OrderTableTableTableManager($_db, $_db.orderTable)
        .filter((f) => f.uuid.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_orderUuidTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }
}

class $$PaymentTransactionTableTableFilterComposer
    extends Composer<_$AppDatabase, $PaymentTransactionTableTable> {
  $$PaymentTransactionTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get method => $composableBuilder(
      column: $table.method, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get amount => $composableBuilder(
      column: $table.amount, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get tendered => $composableBuilder(
      column: $table.tendered, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get change => $composableBuilder(
      column: $table.change, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get referenceId => $composableBuilder(
      column: $table.referenceId, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get note => $composableBuilder(
      column: $table.note, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get createdBy => $composableBuilder(
      column: $table.createdBy, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isSynced => $composableBuilder(
      column: $table.isSynced, builder: (column) => ColumnFilters(column));

  $$OrderTableTableFilterComposer get orderUuid {
    final $$OrderTableTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.orderUuid,
        referencedTable: $db.orderTable,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$OrderTableTableFilterComposer(
              $db: $db,
              $table: $db.orderTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$PaymentTransactionTableTableOrderingComposer
    extends Composer<_$AppDatabase, $PaymentTransactionTableTable> {
  $$PaymentTransactionTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get method => $composableBuilder(
      column: $table.method, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get amount => $composableBuilder(
      column: $table.amount, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get tendered => $composableBuilder(
      column: $table.tendered, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get change => $composableBuilder(
      column: $table.change, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get referenceId => $composableBuilder(
      column: $table.referenceId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get note => $composableBuilder(
      column: $table.note, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get createdBy => $composableBuilder(
      column: $table.createdBy, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isSynced => $composableBuilder(
      column: $table.isSynced, builder: (column) => ColumnOrderings(column));

  $$OrderTableTableOrderingComposer get orderUuid {
    final $$OrderTableTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.orderUuid,
        referencedTable: $db.orderTable,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$OrderTableTableOrderingComposer(
              $db: $db,
              $table: $db.orderTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$PaymentTransactionTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $PaymentTransactionTableTable> {
  $$PaymentTransactionTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get method =>
      $composableBuilder(column: $table.method, builder: (column) => column);

  GeneratedColumn<double> get amount =>
      $composableBuilder(column: $table.amount, builder: (column) => column);

  GeneratedColumn<double> get tendered =>
      $composableBuilder(column: $table.tendered, builder: (column) => column);

  GeneratedColumn<double> get change =>
      $composableBuilder(column: $table.change, builder: (column) => column);

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<String> get referenceId => $composableBuilder(
      column: $table.referenceId, builder: (column) => column);

  GeneratedColumn<String> get note =>
      $composableBuilder(column: $table.note, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<String> get createdBy =>
      $composableBuilder(column: $table.createdBy, builder: (column) => column);

  GeneratedColumn<bool> get isSynced =>
      $composableBuilder(column: $table.isSynced, builder: (column) => column);

  $$OrderTableTableAnnotationComposer get orderUuid {
    final $$OrderTableTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.orderUuid,
        referencedTable: $db.orderTable,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$OrderTableTableAnnotationComposer(
              $db: $db,
              $table: $db.orderTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$PaymentTransactionTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $PaymentTransactionTableTable,
    PaymentTransactionTableData,
    $$PaymentTransactionTableTableFilterComposer,
    $$PaymentTransactionTableTableOrderingComposer,
    $$PaymentTransactionTableTableAnnotationComposer,
    $$PaymentTransactionTableTableCreateCompanionBuilder,
    $$PaymentTransactionTableTableUpdateCompanionBuilder,
    (PaymentTransactionTableData, $$PaymentTransactionTableTableReferences),
    PaymentTransactionTableData,
    PrefetchHooks Function({bool orderUuid})> {
  $$PaymentTransactionTableTableTableManager(
      _$AppDatabase db, $PaymentTransactionTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$PaymentTransactionTableTableFilterComposer(
                  $db: db, $table: table),
          createOrderingComposer: () =>
              $$PaymentTransactionTableTableOrderingComposer(
                  $db: db, $table: table),
          createComputedFieldComposer: () =>
              $$PaymentTransactionTableTableAnnotationComposer(
                  $db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String> orderUuid = const Value.absent(),
            Value<String> method = const Value.absent(),
            Value<double> amount = const Value.absent(),
            Value<double?> tendered = const Value.absent(),
            Value<double?> change = const Value.absent(),
            Value<String> status = const Value.absent(),
            Value<String?> referenceId = const Value.absent(),
            Value<String?> note = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<String?> createdBy = const Value.absent(),
            Value<bool> isSynced = const Value.absent(),
          }) =>
              PaymentTransactionTableCompanion(
            id: id,
            uuid: uuid,
            orderUuid: orderUuid,
            method: method,
            amount: amount,
            tendered: tendered,
            change: change,
            status: status,
            referenceId: referenceId,
            note: note,
            createdAt: createdAt,
            createdBy: createdBy,
            isSynced: isSynced,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            required String orderUuid,
            required String method,
            required double amount,
            Value<double?> tendered = const Value.absent(),
            Value<double?> change = const Value.absent(),
            Value<String> status = const Value.absent(),
            Value<String?> referenceId = const Value.absent(),
            Value<String?> note = const Value.absent(),
            required DateTime createdAt,
            Value<String?> createdBy = const Value.absent(),
            Value<bool> isSynced = const Value.absent(),
          }) =>
              PaymentTransactionTableCompanion.insert(
            id: id,
            uuid: uuid,
            orderUuid: orderUuid,
            method: method,
            amount: amount,
            tendered: tendered,
            change: change,
            status: status,
            referenceId: referenceId,
            note: note,
            createdAt: createdAt,
            createdBy: createdBy,
            isSynced: isSynced,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$PaymentTransactionTableTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: ({orderUuid = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (orderUuid) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.orderUuid,
                    referencedTable: $$PaymentTransactionTableTableReferences
                        ._orderUuidTable(db),
                    referencedColumn: $$PaymentTransactionTableTableReferences
                        ._orderUuidTable(db)
                        .uuid,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ));
}

typedef $$PaymentTransactionTableTableProcessedTableManager
    = ProcessedTableManager<
        _$AppDatabase,
        $PaymentTransactionTableTable,
        PaymentTransactionTableData,
        $$PaymentTransactionTableTableFilterComposer,
        $$PaymentTransactionTableTableOrderingComposer,
        $$PaymentTransactionTableTableAnnotationComposer,
        $$PaymentTransactionTableTableCreateCompanionBuilder,
        $$PaymentTransactionTableTableUpdateCompanionBuilder,
        (PaymentTransactionTableData, $$PaymentTransactionTableTableReferences),
        PaymentTransactionTableData,
        PrefetchHooks Function({bool orderUuid})>;
typedef $$StockCountTableTableCreateCompanionBuilder = StockCountTableCompanion
    Function({
  Value<int> id,
  required String uuid,
  required String warehouseUuid,
  Value<String> status,
  required DateTime startedAt,
  Value<DateTime?> completedAt,
  required String conductedBy,
});
typedef $$StockCountTableTableUpdateCompanionBuilder = StockCountTableCompanion
    Function({
  Value<int> id,
  Value<String> uuid,
  Value<String> warehouseUuid,
  Value<String> status,
  Value<DateTime> startedAt,
  Value<DateTime?> completedAt,
  Value<String> conductedBy,
});

final class $$StockCountTableTableReferences extends BaseReferences<
    _$AppDatabase, $StockCountTableTable, StockCountTableData> {
  $$StockCountTableTableReferences(
      super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$StockCountItemTableTable,
      List<StockCountItemTableData>> _stockCountItemTableRefsTable(
          _$AppDatabase db) =>
      MultiTypedResultKey.fromTable(db.stockCountItemTable,
          aliasName: $_aliasNameGenerator(
              db.stockCountTable.uuid, db.stockCountItemTable.countUuid));

  $$StockCountItemTableTableProcessedTableManager get stockCountItemTableRefs {
    final manager = $$StockCountItemTableTableTableManager(
            $_db, $_db.stockCountItemTable)
        .filter(
            (f) => f.countUuid.uuid.sqlEquals($_itemColumn<String>('uuid')!));

    final cache =
        $_typedResult.readTableOrNull(_stockCountItemTableRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $$StockCountTableTableFilterComposer
    extends Composer<_$AppDatabase, $StockCountTableTable> {
  $$StockCountTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get warehouseUuid => $composableBuilder(
      column: $table.warehouseUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get startedAt => $composableBuilder(
      column: $table.startedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get completedAt => $composableBuilder(
      column: $table.completedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get conductedBy => $composableBuilder(
      column: $table.conductedBy, builder: (column) => ColumnFilters(column));

  Expression<bool> stockCountItemTableRefs(
      Expression<bool> Function($$StockCountItemTableTableFilterComposer f) f) {
    final $$StockCountItemTableTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.uuid,
        referencedTable: $db.stockCountItemTable,
        getReferencedColumn: (t) => t.countUuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$StockCountItemTableTableFilterComposer(
              $db: $db,
              $table: $db.stockCountItemTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$StockCountTableTableOrderingComposer
    extends Composer<_$AppDatabase, $StockCountTableTable> {
  $$StockCountTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get warehouseUuid => $composableBuilder(
      column: $table.warehouseUuid,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get startedAt => $composableBuilder(
      column: $table.startedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get completedAt => $composableBuilder(
      column: $table.completedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get conductedBy => $composableBuilder(
      column: $table.conductedBy, builder: (column) => ColumnOrderings(column));
}

class $$StockCountTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $StockCountTableTable> {
  $$StockCountTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get warehouseUuid => $composableBuilder(
      column: $table.warehouseUuid, builder: (column) => column);

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<DateTime> get startedAt =>
      $composableBuilder(column: $table.startedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get completedAt => $composableBuilder(
      column: $table.completedAt, builder: (column) => column);

  GeneratedColumn<String> get conductedBy => $composableBuilder(
      column: $table.conductedBy, builder: (column) => column);

  Expression<T> stockCountItemTableRefs<T extends Object>(
      Expression<T> Function($$StockCountItemTableTableAnnotationComposer a)
          f) {
    final $$StockCountItemTableTableAnnotationComposer composer =
        $composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.uuid,
            referencedTable: $db.stockCountItemTable,
            getReferencedColumn: (t) => t.countUuid,
            builder: (joinBuilder,
                    {$addJoinBuilderToRootComposer,
                    $removeJoinBuilderFromRootComposer}) =>
                $$StockCountItemTableTableAnnotationComposer(
                  $db: $db,
                  $table: $db.stockCountItemTable,
                  $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                  joinBuilder: joinBuilder,
                  $removeJoinBuilderFromRootComposer:
                      $removeJoinBuilderFromRootComposer,
                ));
    return f(composer);
  }
}

class $$StockCountTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $StockCountTableTable,
    StockCountTableData,
    $$StockCountTableTableFilterComposer,
    $$StockCountTableTableOrderingComposer,
    $$StockCountTableTableAnnotationComposer,
    $$StockCountTableTableCreateCompanionBuilder,
    $$StockCountTableTableUpdateCompanionBuilder,
    (StockCountTableData, $$StockCountTableTableReferences),
    StockCountTableData,
    PrefetchHooks Function({bool stockCountItemTableRefs})> {
  $$StockCountTableTableTableManager(
      _$AppDatabase db, $StockCountTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$StockCountTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$StockCountTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$StockCountTableTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String> warehouseUuid = const Value.absent(),
            Value<String> status = const Value.absent(),
            Value<DateTime> startedAt = const Value.absent(),
            Value<DateTime?> completedAt = const Value.absent(),
            Value<String> conductedBy = const Value.absent(),
          }) =>
              StockCountTableCompanion(
            id: id,
            uuid: uuid,
            warehouseUuid: warehouseUuid,
            status: status,
            startedAt: startedAt,
            completedAt: completedAt,
            conductedBy: conductedBy,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            required String warehouseUuid,
            Value<String> status = const Value.absent(),
            required DateTime startedAt,
            Value<DateTime?> completedAt = const Value.absent(),
            required String conductedBy,
          }) =>
              StockCountTableCompanion.insert(
            id: id,
            uuid: uuid,
            warehouseUuid: warehouseUuid,
            status: status,
            startedAt: startedAt,
            completedAt: completedAt,
            conductedBy: conductedBy,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$StockCountTableTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: ({stockCountItemTableRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (stockCountItemTableRefs) db.stockCountItemTable
              ],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (stockCountItemTableRefs)
                    await $_getPrefetchedData<StockCountTableData,
                            $StockCountTableTable, StockCountItemTableData>(
                        currentTable: table,
                        referencedTable: $$StockCountTableTableReferences
                            ._stockCountItemTableRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$StockCountTableTableReferences(db, table, p0)
                                .stockCountItemTableRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.countUuid == item.uuid),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $$StockCountTableTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $StockCountTableTable,
    StockCountTableData,
    $$StockCountTableTableFilterComposer,
    $$StockCountTableTableOrderingComposer,
    $$StockCountTableTableAnnotationComposer,
    $$StockCountTableTableCreateCompanionBuilder,
    $$StockCountTableTableUpdateCompanionBuilder,
    (StockCountTableData, $$StockCountTableTableReferences),
    StockCountTableData,
    PrefetchHooks Function({bool stockCountItemTableRefs})>;
typedef $$StockCountItemTableTableCreateCompanionBuilder
    = StockCountItemTableCompanion Function({
  Value<int> id,
  required String countUuid,
  required String productUuid,
  required double expectedQty,
  required double countedQty,
  required double variance,
});
typedef $$StockCountItemTableTableUpdateCompanionBuilder
    = StockCountItemTableCompanion Function({
  Value<int> id,
  Value<String> countUuid,
  Value<String> productUuid,
  Value<double> expectedQty,
  Value<double> countedQty,
  Value<double> variance,
});

final class $$StockCountItemTableTableReferences extends BaseReferences<
    _$AppDatabase, $StockCountItemTableTable, StockCountItemTableData> {
  $$StockCountItemTableTableReferences(
      super.$_db, super.$_table, super.$_typedResult);

  static $StockCountTableTable _countUuidTable(_$AppDatabase db) =>
      db.stockCountTable.createAlias($_aliasNameGenerator(
          db.stockCountItemTable.countUuid, db.stockCountTable.uuid));

  $$StockCountTableTableProcessedTableManager get countUuid {
    final $_column = $_itemColumn<String>('count_uuid')!;

    final manager =
        $$StockCountTableTableTableManager($_db, $_db.stockCountTable)
            .filter((f) => f.uuid.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_countUuidTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }
}

class $$StockCountItemTableTableFilterComposer
    extends Composer<_$AppDatabase, $StockCountItemTableTable> {
  $$StockCountItemTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get productUuid => $composableBuilder(
      column: $table.productUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get expectedQty => $composableBuilder(
      column: $table.expectedQty, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get countedQty => $composableBuilder(
      column: $table.countedQty, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get variance => $composableBuilder(
      column: $table.variance, builder: (column) => ColumnFilters(column));

  $$StockCountTableTableFilterComposer get countUuid {
    final $$StockCountTableTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.countUuid,
        referencedTable: $db.stockCountTable,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$StockCountTableTableFilterComposer(
              $db: $db,
              $table: $db.stockCountTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$StockCountItemTableTableOrderingComposer
    extends Composer<_$AppDatabase, $StockCountItemTableTable> {
  $$StockCountItemTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get productUuid => $composableBuilder(
      column: $table.productUuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get expectedQty => $composableBuilder(
      column: $table.expectedQty, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get countedQty => $composableBuilder(
      column: $table.countedQty, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get variance => $composableBuilder(
      column: $table.variance, builder: (column) => ColumnOrderings(column));

  $$StockCountTableTableOrderingComposer get countUuid {
    final $$StockCountTableTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.countUuid,
        referencedTable: $db.stockCountTable,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$StockCountTableTableOrderingComposer(
              $db: $db,
              $table: $db.stockCountTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$StockCountItemTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $StockCountItemTableTable> {
  $$StockCountItemTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get productUuid => $composableBuilder(
      column: $table.productUuid, builder: (column) => column);

  GeneratedColumn<double> get expectedQty => $composableBuilder(
      column: $table.expectedQty, builder: (column) => column);

  GeneratedColumn<double> get countedQty => $composableBuilder(
      column: $table.countedQty, builder: (column) => column);

  GeneratedColumn<double> get variance =>
      $composableBuilder(column: $table.variance, builder: (column) => column);

  $$StockCountTableTableAnnotationComposer get countUuid {
    final $$StockCountTableTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.countUuid,
        referencedTable: $db.stockCountTable,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$StockCountTableTableAnnotationComposer(
              $db: $db,
              $table: $db.stockCountTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$StockCountItemTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $StockCountItemTableTable,
    StockCountItemTableData,
    $$StockCountItemTableTableFilterComposer,
    $$StockCountItemTableTableOrderingComposer,
    $$StockCountItemTableTableAnnotationComposer,
    $$StockCountItemTableTableCreateCompanionBuilder,
    $$StockCountItemTableTableUpdateCompanionBuilder,
    (StockCountItemTableData, $$StockCountItemTableTableReferences),
    StockCountItemTableData,
    PrefetchHooks Function({bool countUuid})> {
  $$StockCountItemTableTableTableManager(
      _$AppDatabase db, $StockCountItemTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$StockCountItemTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$StockCountItemTableTableOrderingComposer(
                  $db: db, $table: table),
          createComputedFieldComposer: () =>
              $$StockCountItemTableTableAnnotationComposer(
                  $db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> countUuid = const Value.absent(),
            Value<String> productUuid = const Value.absent(),
            Value<double> expectedQty = const Value.absent(),
            Value<double> countedQty = const Value.absent(),
            Value<double> variance = const Value.absent(),
          }) =>
              StockCountItemTableCompanion(
            id: id,
            countUuid: countUuid,
            productUuid: productUuid,
            expectedQty: expectedQty,
            countedQty: countedQty,
            variance: variance,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String countUuid,
            required String productUuid,
            required double expectedQty,
            required double countedQty,
            required double variance,
          }) =>
              StockCountItemTableCompanion.insert(
            id: id,
            countUuid: countUuid,
            productUuid: productUuid,
            expectedQty: expectedQty,
            countedQty: countedQty,
            variance: variance,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$StockCountItemTableTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: ({countUuid = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (countUuid) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.countUuid,
                    referencedTable: $$StockCountItemTableTableReferences
                        ._countUuidTable(db),
                    referencedColumn: $$StockCountItemTableTableReferences
                        ._countUuidTable(db)
                        .uuid,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ));
}

typedef $$StockCountItemTableTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $StockCountItemTableTable,
    StockCountItemTableData,
    $$StockCountItemTableTableFilterComposer,
    $$StockCountItemTableTableOrderingComposer,
    $$StockCountItemTableTableAnnotationComposer,
    $$StockCountItemTableTableCreateCompanionBuilder,
    $$StockCountItemTableTableUpdateCompanionBuilder,
    (StockCountItemTableData, $$StockCountItemTableTableReferences),
    StockCountItemTableData,
    PrefetchHooks Function({bool countUuid})>;
typedef $$WarehouseTableTableCreateCompanionBuilder = WarehouseTableCompanion
    Function({
  Value<int> id,
  required String uuid,
  required String name,
  required String code,
  Value<String> type,
  Value<String?> address,
  Value<String?> contactPhone,
  Value<bool> isPrimary,
  Value<bool> isActive,
  required DateTime createdAt,
  required DateTime updatedAt,
  Value<bool> isDeleted,
});
typedef $$WarehouseTableTableUpdateCompanionBuilder = WarehouseTableCompanion
    Function({
  Value<int> id,
  Value<String> uuid,
  Value<String> name,
  Value<String> code,
  Value<String> type,
  Value<String?> address,
  Value<String?> contactPhone,
  Value<bool> isPrimary,
  Value<bool> isActive,
  Value<DateTime> createdAt,
  Value<DateTime> updatedAt,
  Value<bool> isDeleted,
});

class $$WarehouseTableTableFilterComposer
    extends Composer<_$AppDatabase, $WarehouseTableTable> {
  $$WarehouseTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get code => $composableBuilder(
      column: $table.code, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get type => $composableBuilder(
      column: $table.type, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get address => $composableBuilder(
      column: $table.address, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get contactPhone => $composableBuilder(
      column: $table.contactPhone, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isPrimary => $composableBuilder(
      column: $table.isPrimary, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isActive => $composableBuilder(
      column: $table.isActive, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnFilters(column));
}

class $$WarehouseTableTableOrderingComposer
    extends Composer<_$AppDatabase, $WarehouseTableTable> {
  $$WarehouseTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get code => $composableBuilder(
      column: $table.code, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get type => $composableBuilder(
      column: $table.type, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get address => $composableBuilder(
      column: $table.address, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get contactPhone => $composableBuilder(
      column: $table.contactPhone,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isPrimary => $composableBuilder(
      column: $table.isPrimary, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isActive => $composableBuilder(
      column: $table.isActive, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnOrderings(column));
}

class $$WarehouseTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $WarehouseTableTable> {
  $$WarehouseTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get code =>
      $composableBuilder(column: $table.code, builder: (column) => column);

  GeneratedColumn<String> get type =>
      $composableBuilder(column: $table.type, builder: (column) => column);

  GeneratedColumn<String> get address =>
      $composableBuilder(column: $table.address, builder: (column) => column);

  GeneratedColumn<String> get contactPhone => $composableBuilder(
      column: $table.contactPhone, builder: (column) => column);

  GeneratedColumn<bool> get isPrimary =>
      $composableBuilder(column: $table.isPrimary, builder: (column) => column);

  GeneratedColumn<bool> get isActive =>
      $composableBuilder(column: $table.isActive, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<bool> get isDeleted =>
      $composableBuilder(column: $table.isDeleted, builder: (column) => column);
}

class $$WarehouseTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $WarehouseTableTable,
    WarehouseTableData,
    $$WarehouseTableTableFilterComposer,
    $$WarehouseTableTableOrderingComposer,
    $$WarehouseTableTableAnnotationComposer,
    $$WarehouseTableTableCreateCompanionBuilder,
    $$WarehouseTableTableUpdateCompanionBuilder,
    (
      WarehouseTableData,
      BaseReferences<_$AppDatabase, $WarehouseTableTable, WarehouseTableData>
    ),
    WarehouseTableData,
    PrefetchHooks Function()> {
  $$WarehouseTableTableTableManager(
      _$AppDatabase db, $WarehouseTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$WarehouseTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$WarehouseTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$WarehouseTableTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String> name = const Value.absent(),
            Value<String> code = const Value.absent(),
            Value<String> type = const Value.absent(),
            Value<String?> address = const Value.absent(),
            Value<String?> contactPhone = const Value.absent(),
            Value<bool> isPrimary = const Value.absent(),
            Value<bool> isActive = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
            Value<bool> isDeleted = const Value.absent(),
          }) =>
              WarehouseTableCompanion(
            id: id,
            uuid: uuid,
            name: name,
            code: code,
            type: type,
            address: address,
            contactPhone: contactPhone,
            isPrimary: isPrimary,
            isActive: isActive,
            createdAt: createdAt,
            updatedAt: updatedAt,
            isDeleted: isDeleted,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            required String name,
            required String code,
            Value<String> type = const Value.absent(),
            Value<String?> address = const Value.absent(),
            Value<String?> contactPhone = const Value.absent(),
            Value<bool> isPrimary = const Value.absent(),
            Value<bool> isActive = const Value.absent(),
            required DateTime createdAt,
            required DateTime updatedAt,
            Value<bool> isDeleted = const Value.absent(),
          }) =>
              WarehouseTableCompanion.insert(
            id: id,
            uuid: uuid,
            name: name,
            code: code,
            type: type,
            address: address,
            contactPhone: contactPhone,
            isPrimary: isPrimary,
            isActive: isActive,
            createdAt: createdAt,
            updatedAt: updatedAt,
            isDeleted: isDeleted,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$WarehouseTableTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $WarehouseTableTable,
    WarehouseTableData,
    $$WarehouseTableTableFilterComposer,
    $$WarehouseTableTableOrderingComposer,
    $$WarehouseTableTableAnnotationComposer,
    $$WarehouseTableTableCreateCompanionBuilder,
    $$WarehouseTableTableUpdateCompanionBuilder,
    (
      WarehouseTableData,
      BaseReferences<_$AppDatabase, $WarehouseTableTable, WarehouseTableData>
    ),
    WarehouseTableData,
    PrefetchHooks Function()>;
typedef $$StockLevelTableTableCreateCompanionBuilder = StockLevelTableCompanion
    Function({
  Value<int> id,
  required String productUuid,
  required String warehouseUuid,
  Value<double> quantity,
  Value<double> reservedQuantity,
  Value<double> availableQuantity,
  Value<double?> reorderPoint,
  Value<double?> reorderQuantity,
  Value<double?> maxStockLevel,
  Value<double> averageCost,
  Value<double> averageDailySales,
  Value<int?> daysOfStock,
  Value<DateTime?> lastCountedAt,
  Value<DateTime?> lastMovementAt,
  required DateTime updatedAt,
});
typedef $$StockLevelTableTableUpdateCompanionBuilder = StockLevelTableCompanion
    Function({
  Value<int> id,
  Value<String> productUuid,
  Value<String> warehouseUuid,
  Value<double> quantity,
  Value<double> reservedQuantity,
  Value<double> availableQuantity,
  Value<double?> reorderPoint,
  Value<double?> reorderQuantity,
  Value<double?> maxStockLevel,
  Value<double> averageCost,
  Value<double> averageDailySales,
  Value<int?> daysOfStock,
  Value<DateTime?> lastCountedAt,
  Value<DateTime?> lastMovementAt,
  Value<DateTime> updatedAt,
});

class $$StockLevelTableTableFilterComposer
    extends Composer<_$AppDatabase, $StockLevelTableTable> {
  $$StockLevelTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get productUuid => $composableBuilder(
      column: $table.productUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get warehouseUuid => $composableBuilder(
      column: $table.warehouseUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get quantity => $composableBuilder(
      column: $table.quantity, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get reservedQuantity => $composableBuilder(
      column: $table.reservedQuantity,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get availableQuantity => $composableBuilder(
      column: $table.availableQuantity,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get reorderPoint => $composableBuilder(
      column: $table.reorderPoint, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get reorderQuantity => $composableBuilder(
      column: $table.reorderQuantity,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get maxStockLevel => $composableBuilder(
      column: $table.maxStockLevel, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get averageCost => $composableBuilder(
      column: $table.averageCost, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get averageDailySales => $composableBuilder(
      column: $table.averageDailySales,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get daysOfStock => $composableBuilder(
      column: $table.daysOfStock, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get lastCountedAt => $composableBuilder(
      column: $table.lastCountedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get lastMovementAt => $composableBuilder(
      column: $table.lastMovementAt,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));
}

class $$StockLevelTableTableOrderingComposer
    extends Composer<_$AppDatabase, $StockLevelTableTable> {
  $$StockLevelTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get productUuid => $composableBuilder(
      column: $table.productUuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get warehouseUuid => $composableBuilder(
      column: $table.warehouseUuid,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get quantity => $composableBuilder(
      column: $table.quantity, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get reservedQuantity => $composableBuilder(
      column: $table.reservedQuantity,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get availableQuantity => $composableBuilder(
      column: $table.availableQuantity,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get reorderPoint => $composableBuilder(
      column: $table.reorderPoint,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get reorderQuantity => $composableBuilder(
      column: $table.reorderQuantity,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get maxStockLevel => $composableBuilder(
      column: $table.maxStockLevel,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get averageCost => $composableBuilder(
      column: $table.averageCost, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get averageDailySales => $composableBuilder(
      column: $table.averageDailySales,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get daysOfStock => $composableBuilder(
      column: $table.daysOfStock, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get lastCountedAt => $composableBuilder(
      column: $table.lastCountedAt,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get lastMovementAt => $composableBuilder(
      column: $table.lastMovementAt,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));
}

class $$StockLevelTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $StockLevelTableTable> {
  $$StockLevelTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get productUuid => $composableBuilder(
      column: $table.productUuid, builder: (column) => column);

  GeneratedColumn<String> get warehouseUuid => $composableBuilder(
      column: $table.warehouseUuid, builder: (column) => column);

  GeneratedColumn<double> get quantity =>
      $composableBuilder(column: $table.quantity, builder: (column) => column);

  GeneratedColumn<double> get reservedQuantity => $composableBuilder(
      column: $table.reservedQuantity, builder: (column) => column);

  GeneratedColumn<double> get availableQuantity => $composableBuilder(
      column: $table.availableQuantity, builder: (column) => column);

  GeneratedColumn<double> get reorderPoint => $composableBuilder(
      column: $table.reorderPoint, builder: (column) => column);

  GeneratedColumn<double> get reorderQuantity => $composableBuilder(
      column: $table.reorderQuantity, builder: (column) => column);

  GeneratedColumn<double> get maxStockLevel => $composableBuilder(
      column: $table.maxStockLevel, builder: (column) => column);

  GeneratedColumn<double> get averageCost => $composableBuilder(
      column: $table.averageCost, builder: (column) => column);

  GeneratedColumn<double> get averageDailySales => $composableBuilder(
      column: $table.averageDailySales, builder: (column) => column);

  GeneratedColumn<int> get daysOfStock => $composableBuilder(
      column: $table.daysOfStock, builder: (column) => column);

  GeneratedColumn<DateTime> get lastCountedAt => $composableBuilder(
      column: $table.lastCountedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get lastMovementAt => $composableBuilder(
      column: $table.lastMovementAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$StockLevelTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $StockLevelTableTable,
    StockLevelTableData,
    $$StockLevelTableTableFilterComposer,
    $$StockLevelTableTableOrderingComposer,
    $$StockLevelTableTableAnnotationComposer,
    $$StockLevelTableTableCreateCompanionBuilder,
    $$StockLevelTableTableUpdateCompanionBuilder,
    (
      StockLevelTableData,
      BaseReferences<_$AppDatabase, $StockLevelTableTable, StockLevelTableData>
    ),
    StockLevelTableData,
    PrefetchHooks Function()> {
  $$StockLevelTableTableTableManager(
      _$AppDatabase db, $StockLevelTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$StockLevelTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$StockLevelTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$StockLevelTableTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> productUuid = const Value.absent(),
            Value<String> warehouseUuid = const Value.absent(),
            Value<double> quantity = const Value.absent(),
            Value<double> reservedQuantity = const Value.absent(),
            Value<double> availableQuantity = const Value.absent(),
            Value<double?> reorderPoint = const Value.absent(),
            Value<double?> reorderQuantity = const Value.absent(),
            Value<double?> maxStockLevel = const Value.absent(),
            Value<double> averageCost = const Value.absent(),
            Value<double> averageDailySales = const Value.absent(),
            Value<int?> daysOfStock = const Value.absent(),
            Value<DateTime?> lastCountedAt = const Value.absent(),
            Value<DateTime?> lastMovementAt = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
          }) =>
              StockLevelTableCompanion(
            id: id,
            productUuid: productUuid,
            warehouseUuid: warehouseUuid,
            quantity: quantity,
            reservedQuantity: reservedQuantity,
            availableQuantity: availableQuantity,
            reorderPoint: reorderPoint,
            reorderQuantity: reorderQuantity,
            maxStockLevel: maxStockLevel,
            averageCost: averageCost,
            averageDailySales: averageDailySales,
            daysOfStock: daysOfStock,
            lastCountedAt: lastCountedAt,
            lastMovementAt: lastMovementAt,
            updatedAt: updatedAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String productUuid,
            required String warehouseUuid,
            Value<double> quantity = const Value.absent(),
            Value<double> reservedQuantity = const Value.absent(),
            Value<double> availableQuantity = const Value.absent(),
            Value<double?> reorderPoint = const Value.absent(),
            Value<double?> reorderQuantity = const Value.absent(),
            Value<double?> maxStockLevel = const Value.absent(),
            Value<double> averageCost = const Value.absent(),
            Value<double> averageDailySales = const Value.absent(),
            Value<int?> daysOfStock = const Value.absent(),
            Value<DateTime?> lastCountedAt = const Value.absent(),
            Value<DateTime?> lastMovementAt = const Value.absent(),
            required DateTime updatedAt,
          }) =>
              StockLevelTableCompanion.insert(
            id: id,
            productUuid: productUuid,
            warehouseUuid: warehouseUuid,
            quantity: quantity,
            reservedQuantity: reservedQuantity,
            availableQuantity: availableQuantity,
            reorderPoint: reorderPoint,
            reorderQuantity: reorderQuantity,
            maxStockLevel: maxStockLevel,
            averageCost: averageCost,
            averageDailySales: averageDailySales,
            daysOfStock: daysOfStock,
            lastCountedAt: lastCountedAt,
            lastMovementAt: lastMovementAt,
            updatedAt: updatedAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$StockLevelTableTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $StockLevelTableTable,
    StockLevelTableData,
    $$StockLevelTableTableFilterComposer,
    $$StockLevelTableTableOrderingComposer,
    $$StockLevelTableTableAnnotationComposer,
    $$StockLevelTableTableCreateCompanionBuilder,
    $$StockLevelTableTableUpdateCompanionBuilder,
    (
      StockLevelTableData,
      BaseReferences<_$AppDatabase, $StockLevelTableTable, StockLevelTableData>
    ),
    StockLevelTableData,
    PrefetchHooks Function()>;
typedef $$BatchTableTableCreateCompanionBuilder = BatchTableCompanion Function({
  Value<int> id,
  required String uuid,
  required String productUuid,
  required String warehouseUuid,
  required String batchNumber,
  Value<String?> supplierUuid,
  Value<String?> poUuid,
  required double initialQuantity,
  required double currentQuantity,
  required double unitCost,
  Value<DateTime?> manufacturedAt,
  Value<DateTime?> expiryDate,
  required DateTime receivedAt,
  Value<String> status,
  Value<String?> notes,
  required DateTime updatedAt,
  Value<bool> isDeleted,
});
typedef $$BatchTableTableUpdateCompanionBuilder = BatchTableCompanion Function({
  Value<int> id,
  Value<String> uuid,
  Value<String> productUuid,
  Value<String> warehouseUuid,
  Value<String> batchNumber,
  Value<String?> supplierUuid,
  Value<String?> poUuid,
  Value<double> initialQuantity,
  Value<double> currentQuantity,
  Value<double> unitCost,
  Value<DateTime?> manufacturedAt,
  Value<DateTime?> expiryDate,
  Value<DateTime> receivedAt,
  Value<String> status,
  Value<String?> notes,
  Value<DateTime> updatedAt,
  Value<bool> isDeleted,
});

class $$BatchTableTableFilterComposer
    extends Composer<_$AppDatabase, $BatchTableTable> {
  $$BatchTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get productUuid => $composableBuilder(
      column: $table.productUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get warehouseUuid => $composableBuilder(
      column: $table.warehouseUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get batchNumber => $composableBuilder(
      column: $table.batchNumber, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get supplierUuid => $composableBuilder(
      column: $table.supplierUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get poUuid => $composableBuilder(
      column: $table.poUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get initialQuantity => $composableBuilder(
      column: $table.initialQuantity,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get currentQuantity => $composableBuilder(
      column: $table.currentQuantity,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get unitCost => $composableBuilder(
      column: $table.unitCost, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get manufacturedAt => $composableBuilder(
      column: $table.manufacturedAt,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get expiryDate => $composableBuilder(
      column: $table.expiryDate, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get receivedAt => $composableBuilder(
      column: $table.receivedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get notes => $composableBuilder(
      column: $table.notes, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnFilters(column));
}

class $$BatchTableTableOrderingComposer
    extends Composer<_$AppDatabase, $BatchTableTable> {
  $$BatchTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get productUuid => $composableBuilder(
      column: $table.productUuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get warehouseUuid => $composableBuilder(
      column: $table.warehouseUuid,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get batchNumber => $composableBuilder(
      column: $table.batchNumber, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get supplierUuid => $composableBuilder(
      column: $table.supplierUuid,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get poUuid => $composableBuilder(
      column: $table.poUuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get initialQuantity => $composableBuilder(
      column: $table.initialQuantity,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get currentQuantity => $composableBuilder(
      column: $table.currentQuantity,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get unitCost => $composableBuilder(
      column: $table.unitCost, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get manufacturedAt => $composableBuilder(
      column: $table.manufacturedAt,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get expiryDate => $composableBuilder(
      column: $table.expiryDate, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get receivedAt => $composableBuilder(
      column: $table.receivedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get notes => $composableBuilder(
      column: $table.notes, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnOrderings(column));
}

class $$BatchTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $BatchTableTable> {
  $$BatchTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get productUuid => $composableBuilder(
      column: $table.productUuid, builder: (column) => column);

  GeneratedColumn<String> get warehouseUuid => $composableBuilder(
      column: $table.warehouseUuid, builder: (column) => column);

  GeneratedColumn<String> get batchNumber => $composableBuilder(
      column: $table.batchNumber, builder: (column) => column);

  GeneratedColumn<String> get supplierUuid => $composableBuilder(
      column: $table.supplierUuid, builder: (column) => column);

  GeneratedColumn<String> get poUuid =>
      $composableBuilder(column: $table.poUuid, builder: (column) => column);

  GeneratedColumn<double> get initialQuantity => $composableBuilder(
      column: $table.initialQuantity, builder: (column) => column);

  GeneratedColumn<double> get currentQuantity => $composableBuilder(
      column: $table.currentQuantity, builder: (column) => column);

  GeneratedColumn<double> get unitCost =>
      $composableBuilder(column: $table.unitCost, builder: (column) => column);

  GeneratedColumn<DateTime> get manufacturedAt => $composableBuilder(
      column: $table.manufacturedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get expiryDate => $composableBuilder(
      column: $table.expiryDate, builder: (column) => column);

  GeneratedColumn<DateTime> get receivedAt => $composableBuilder(
      column: $table.receivedAt, builder: (column) => column);

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<bool> get isDeleted =>
      $composableBuilder(column: $table.isDeleted, builder: (column) => column);
}

class $$BatchTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $BatchTableTable,
    BatchTableData,
    $$BatchTableTableFilterComposer,
    $$BatchTableTableOrderingComposer,
    $$BatchTableTableAnnotationComposer,
    $$BatchTableTableCreateCompanionBuilder,
    $$BatchTableTableUpdateCompanionBuilder,
    (
      BatchTableData,
      BaseReferences<_$AppDatabase, $BatchTableTable, BatchTableData>
    ),
    BatchTableData,
    PrefetchHooks Function()> {
  $$BatchTableTableTableManager(_$AppDatabase db, $BatchTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$BatchTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$BatchTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$BatchTableTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String> productUuid = const Value.absent(),
            Value<String> warehouseUuid = const Value.absent(),
            Value<String> batchNumber = const Value.absent(),
            Value<String?> supplierUuid = const Value.absent(),
            Value<String?> poUuid = const Value.absent(),
            Value<double> initialQuantity = const Value.absent(),
            Value<double> currentQuantity = const Value.absent(),
            Value<double> unitCost = const Value.absent(),
            Value<DateTime?> manufacturedAt = const Value.absent(),
            Value<DateTime?> expiryDate = const Value.absent(),
            Value<DateTime> receivedAt = const Value.absent(),
            Value<String> status = const Value.absent(),
            Value<String?> notes = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
            Value<bool> isDeleted = const Value.absent(),
          }) =>
              BatchTableCompanion(
            id: id,
            uuid: uuid,
            productUuid: productUuid,
            warehouseUuid: warehouseUuid,
            batchNumber: batchNumber,
            supplierUuid: supplierUuid,
            poUuid: poUuid,
            initialQuantity: initialQuantity,
            currentQuantity: currentQuantity,
            unitCost: unitCost,
            manufacturedAt: manufacturedAt,
            expiryDate: expiryDate,
            receivedAt: receivedAt,
            status: status,
            notes: notes,
            updatedAt: updatedAt,
            isDeleted: isDeleted,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            required String productUuid,
            required String warehouseUuid,
            required String batchNumber,
            Value<String?> supplierUuid = const Value.absent(),
            Value<String?> poUuid = const Value.absent(),
            required double initialQuantity,
            required double currentQuantity,
            required double unitCost,
            Value<DateTime?> manufacturedAt = const Value.absent(),
            Value<DateTime?> expiryDate = const Value.absent(),
            required DateTime receivedAt,
            Value<String> status = const Value.absent(),
            Value<String?> notes = const Value.absent(),
            required DateTime updatedAt,
            Value<bool> isDeleted = const Value.absent(),
          }) =>
              BatchTableCompanion.insert(
            id: id,
            uuid: uuid,
            productUuid: productUuid,
            warehouseUuid: warehouseUuid,
            batchNumber: batchNumber,
            supplierUuid: supplierUuid,
            poUuid: poUuid,
            initialQuantity: initialQuantity,
            currentQuantity: currentQuantity,
            unitCost: unitCost,
            manufacturedAt: manufacturedAt,
            expiryDate: expiryDate,
            receivedAt: receivedAt,
            status: status,
            notes: notes,
            updatedAt: updatedAt,
            isDeleted: isDeleted,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$BatchTableTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $BatchTableTable,
    BatchTableData,
    $$BatchTableTableFilterComposer,
    $$BatchTableTableOrderingComposer,
    $$BatchTableTableAnnotationComposer,
    $$BatchTableTableCreateCompanionBuilder,
    $$BatchTableTableUpdateCompanionBuilder,
    (
      BatchTableData,
      BaseReferences<_$AppDatabase, $BatchTableTable, BatchTableData>
    ),
    BatchTableData,
    PrefetchHooks Function()>;
typedef $$StockAlertTableTableCreateCompanionBuilder = StockAlertTableCompanion
    Function({
  Value<int> id,
  required String uuid,
  required String productUuid,
  required String productName,
  Value<String?> warehouseUuid,
  required String alertType,
  Value<String> severity,
  Value<double?> currentValue,
  Value<double?> thresholdValue,
  Value<int?> daysBeforeExpiry,
  required String message,
  Value<bool> isAcknowledged,
  Value<String?> acknowledgedBy,
  Value<DateTime?> acknowledgedAt,
  Value<String?> actionTaken,
  Value<bool> isResolved,
  Value<DateTime?> resolvedAt,
  required DateTime createdAt,
  required DateTime updatedAt,
});
typedef $$StockAlertTableTableUpdateCompanionBuilder = StockAlertTableCompanion
    Function({
  Value<int> id,
  Value<String> uuid,
  Value<String> productUuid,
  Value<String> productName,
  Value<String?> warehouseUuid,
  Value<String> alertType,
  Value<String> severity,
  Value<double?> currentValue,
  Value<double?> thresholdValue,
  Value<int?> daysBeforeExpiry,
  Value<String> message,
  Value<bool> isAcknowledged,
  Value<String?> acknowledgedBy,
  Value<DateTime?> acknowledgedAt,
  Value<String?> actionTaken,
  Value<bool> isResolved,
  Value<DateTime?> resolvedAt,
  Value<DateTime> createdAt,
  Value<DateTime> updatedAt,
});

class $$StockAlertTableTableFilterComposer
    extends Composer<_$AppDatabase, $StockAlertTableTable> {
  $$StockAlertTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get productUuid => $composableBuilder(
      column: $table.productUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get productName => $composableBuilder(
      column: $table.productName, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get warehouseUuid => $composableBuilder(
      column: $table.warehouseUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get alertType => $composableBuilder(
      column: $table.alertType, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get severity => $composableBuilder(
      column: $table.severity, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get currentValue => $composableBuilder(
      column: $table.currentValue, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get thresholdValue => $composableBuilder(
      column: $table.thresholdValue,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get daysBeforeExpiry => $composableBuilder(
      column: $table.daysBeforeExpiry,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get message => $composableBuilder(
      column: $table.message, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isAcknowledged => $composableBuilder(
      column: $table.isAcknowledged,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get acknowledgedBy => $composableBuilder(
      column: $table.acknowledgedBy,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get acknowledgedAt => $composableBuilder(
      column: $table.acknowledgedAt,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get actionTaken => $composableBuilder(
      column: $table.actionTaken, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isResolved => $composableBuilder(
      column: $table.isResolved, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get resolvedAt => $composableBuilder(
      column: $table.resolvedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));
}

class $$StockAlertTableTableOrderingComposer
    extends Composer<_$AppDatabase, $StockAlertTableTable> {
  $$StockAlertTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get productUuid => $composableBuilder(
      column: $table.productUuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get productName => $composableBuilder(
      column: $table.productName, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get warehouseUuid => $composableBuilder(
      column: $table.warehouseUuid,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get alertType => $composableBuilder(
      column: $table.alertType, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get severity => $composableBuilder(
      column: $table.severity, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get currentValue => $composableBuilder(
      column: $table.currentValue,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get thresholdValue => $composableBuilder(
      column: $table.thresholdValue,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get daysBeforeExpiry => $composableBuilder(
      column: $table.daysBeforeExpiry,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get message => $composableBuilder(
      column: $table.message, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isAcknowledged => $composableBuilder(
      column: $table.isAcknowledged,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get acknowledgedBy => $composableBuilder(
      column: $table.acknowledgedBy,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get acknowledgedAt => $composableBuilder(
      column: $table.acknowledgedAt,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get actionTaken => $composableBuilder(
      column: $table.actionTaken, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isResolved => $composableBuilder(
      column: $table.isResolved, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get resolvedAt => $composableBuilder(
      column: $table.resolvedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));
}

class $$StockAlertTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $StockAlertTableTable> {
  $$StockAlertTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get productUuid => $composableBuilder(
      column: $table.productUuid, builder: (column) => column);

  GeneratedColumn<String> get productName => $composableBuilder(
      column: $table.productName, builder: (column) => column);

  GeneratedColumn<String> get warehouseUuid => $composableBuilder(
      column: $table.warehouseUuid, builder: (column) => column);

  GeneratedColumn<String> get alertType =>
      $composableBuilder(column: $table.alertType, builder: (column) => column);

  GeneratedColumn<String> get severity =>
      $composableBuilder(column: $table.severity, builder: (column) => column);

  GeneratedColumn<double> get currentValue => $composableBuilder(
      column: $table.currentValue, builder: (column) => column);

  GeneratedColumn<double> get thresholdValue => $composableBuilder(
      column: $table.thresholdValue, builder: (column) => column);

  GeneratedColumn<int> get daysBeforeExpiry => $composableBuilder(
      column: $table.daysBeforeExpiry, builder: (column) => column);

  GeneratedColumn<String> get message =>
      $composableBuilder(column: $table.message, builder: (column) => column);

  GeneratedColumn<bool> get isAcknowledged => $composableBuilder(
      column: $table.isAcknowledged, builder: (column) => column);

  GeneratedColumn<String> get acknowledgedBy => $composableBuilder(
      column: $table.acknowledgedBy, builder: (column) => column);

  GeneratedColumn<DateTime> get acknowledgedAt => $composableBuilder(
      column: $table.acknowledgedAt, builder: (column) => column);

  GeneratedColumn<String> get actionTaken => $composableBuilder(
      column: $table.actionTaken, builder: (column) => column);

  GeneratedColumn<bool> get isResolved => $composableBuilder(
      column: $table.isResolved, builder: (column) => column);

  GeneratedColumn<DateTime> get resolvedAt => $composableBuilder(
      column: $table.resolvedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$StockAlertTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $StockAlertTableTable,
    StockAlertTableData,
    $$StockAlertTableTableFilterComposer,
    $$StockAlertTableTableOrderingComposer,
    $$StockAlertTableTableAnnotationComposer,
    $$StockAlertTableTableCreateCompanionBuilder,
    $$StockAlertTableTableUpdateCompanionBuilder,
    (
      StockAlertTableData,
      BaseReferences<_$AppDatabase, $StockAlertTableTable, StockAlertTableData>
    ),
    StockAlertTableData,
    PrefetchHooks Function()> {
  $$StockAlertTableTableTableManager(
      _$AppDatabase db, $StockAlertTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$StockAlertTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$StockAlertTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$StockAlertTableTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String> productUuid = const Value.absent(),
            Value<String> productName = const Value.absent(),
            Value<String?> warehouseUuid = const Value.absent(),
            Value<String> alertType = const Value.absent(),
            Value<String> severity = const Value.absent(),
            Value<double?> currentValue = const Value.absent(),
            Value<double?> thresholdValue = const Value.absent(),
            Value<int?> daysBeforeExpiry = const Value.absent(),
            Value<String> message = const Value.absent(),
            Value<bool> isAcknowledged = const Value.absent(),
            Value<String?> acknowledgedBy = const Value.absent(),
            Value<DateTime?> acknowledgedAt = const Value.absent(),
            Value<String?> actionTaken = const Value.absent(),
            Value<bool> isResolved = const Value.absent(),
            Value<DateTime?> resolvedAt = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
          }) =>
              StockAlertTableCompanion(
            id: id,
            uuid: uuid,
            productUuid: productUuid,
            productName: productName,
            warehouseUuid: warehouseUuid,
            alertType: alertType,
            severity: severity,
            currentValue: currentValue,
            thresholdValue: thresholdValue,
            daysBeforeExpiry: daysBeforeExpiry,
            message: message,
            isAcknowledged: isAcknowledged,
            acknowledgedBy: acknowledgedBy,
            acknowledgedAt: acknowledgedAt,
            actionTaken: actionTaken,
            isResolved: isResolved,
            resolvedAt: resolvedAt,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            required String productUuid,
            required String productName,
            Value<String?> warehouseUuid = const Value.absent(),
            required String alertType,
            Value<String> severity = const Value.absent(),
            Value<double?> currentValue = const Value.absent(),
            Value<double?> thresholdValue = const Value.absent(),
            Value<int?> daysBeforeExpiry = const Value.absent(),
            required String message,
            Value<bool> isAcknowledged = const Value.absent(),
            Value<String?> acknowledgedBy = const Value.absent(),
            Value<DateTime?> acknowledgedAt = const Value.absent(),
            Value<String?> actionTaken = const Value.absent(),
            Value<bool> isResolved = const Value.absent(),
            Value<DateTime?> resolvedAt = const Value.absent(),
            required DateTime createdAt,
            required DateTime updatedAt,
          }) =>
              StockAlertTableCompanion.insert(
            id: id,
            uuid: uuid,
            productUuid: productUuid,
            productName: productName,
            warehouseUuid: warehouseUuid,
            alertType: alertType,
            severity: severity,
            currentValue: currentValue,
            thresholdValue: thresholdValue,
            daysBeforeExpiry: daysBeforeExpiry,
            message: message,
            isAcknowledged: isAcknowledged,
            acknowledgedBy: acknowledgedBy,
            acknowledgedAt: acknowledgedAt,
            actionTaken: actionTaken,
            isResolved: isResolved,
            resolvedAt: resolvedAt,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$StockAlertTableTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $StockAlertTableTable,
    StockAlertTableData,
    $$StockAlertTableTableFilterComposer,
    $$StockAlertTableTableOrderingComposer,
    $$StockAlertTableTableAnnotationComposer,
    $$StockAlertTableTableCreateCompanionBuilder,
    $$StockAlertTableTableUpdateCompanionBuilder,
    (
      StockAlertTableData,
      BaseReferences<_$AppDatabase, $StockAlertTableTable, StockAlertTableData>
    ),
    StockAlertTableData,
    PrefetchHooks Function()>;
typedef $$StockTransferTableTableCreateCompanionBuilder
    = StockTransferTableCompanion Function({
  Value<int> id,
  required String uuid,
  required String transferNumber,
  required String sourceWarehouseUuid,
  required String sourceWarehouseName,
  required String targetWarehouseUuid,
  required String targetWarehouseName,
  Value<String> status,
  required String createdBy,
  required String createdByName,
  Value<String?> approvedBy,
  Value<DateTime?> approvedAt,
  Value<String?> notes,
  Value<double> totalValue,
  Value<int> totalItems,
  Value<DateTime?> expectedDeliveryAt,
  Value<DateTime?> shippedAt,
  Value<DateTime?> receivedAt,
  required DateTime createdAt,
  required DateTime updatedAt,
});
typedef $$StockTransferTableTableUpdateCompanionBuilder
    = StockTransferTableCompanion Function({
  Value<int> id,
  Value<String> uuid,
  Value<String> transferNumber,
  Value<String> sourceWarehouseUuid,
  Value<String> sourceWarehouseName,
  Value<String> targetWarehouseUuid,
  Value<String> targetWarehouseName,
  Value<String> status,
  Value<String> createdBy,
  Value<String> createdByName,
  Value<String?> approvedBy,
  Value<DateTime?> approvedAt,
  Value<String?> notes,
  Value<double> totalValue,
  Value<int> totalItems,
  Value<DateTime?> expectedDeliveryAt,
  Value<DateTime?> shippedAt,
  Value<DateTime?> receivedAt,
  Value<DateTime> createdAt,
  Value<DateTime> updatedAt,
});

class $$StockTransferTableTableFilterComposer
    extends Composer<_$AppDatabase, $StockTransferTableTable> {
  $$StockTransferTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get transferNumber => $composableBuilder(
      column: $table.transferNumber,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get sourceWarehouseUuid => $composableBuilder(
      column: $table.sourceWarehouseUuid,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get sourceWarehouseName => $composableBuilder(
      column: $table.sourceWarehouseName,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get targetWarehouseUuid => $composableBuilder(
      column: $table.targetWarehouseUuid,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get targetWarehouseName => $composableBuilder(
      column: $table.targetWarehouseName,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get createdBy => $composableBuilder(
      column: $table.createdBy, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get createdByName => $composableBuilder(
      column: $table.createdByName, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get approvedBy => $composableBuilder(
      column: $table.approvedBy, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get approvedAt => $composableBuilder(
      column: $table.approvedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get notes => $composableBuilder(
      column: $table.notes, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get totalValue => $composableBuilder(
      column: $table.totalValue, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get totalItems => $composableBuilder(
      column: $table.totalItems, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get expectedDeliveryAt => $composableBuilder(
      column: $table.expectedDeliveryAt,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get shippedAt => $composableBuilder(
      column: $table.shippedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get receivedAt => $composableBuilder(
      column: $table.receivedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));
}

class $$StockTransferTableTableOrderingComposer
    extends Composer<_$AppDatabase, $StockTransferTableTable> {
  $$StockTransferTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get transferNumber => $composableBuilder(
      column: $table.transferNumber,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get sourceWarehouseUuid => $composableBuilder(
      column: $table.sourceWarehouseUuid,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get sourceWarehouseName => $composableBuilder(
      column: $table.sourceWarehouseName,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get targetWarehouseUuid => $composableBuilder(
      column: $table.targetWarehouseUuid,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get targetWarehouseName => $composableBuilder(
      column: $table.targetWarehouseName,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get createdBy => $composableBuilder(
      column: $table.createdBy, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get createdByName => $composableBuilder(
      column: $table.createdByName,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get approvedBy => $composableBuilder(
      column: $table.approvedBy, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get approvedAt => $composableBuilder(
      column: $table.approvedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get notes => $composableBuilder(
      column: $table.notes, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get totalValue => $composableBuilder(
      column: $table.totalValue, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get totalItems => $composableBuilder(
      column: $table.totalItems, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get expectedDeliveryAt => $composableBuilder(
      column: $table.expectedDeliveryAt,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get shippedAt => $composableBuilder(
      column: $table.shippedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get receivedAt => $composableBuilder(
      column: $table.receivedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));
}

class $$StockTransferTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $StockTransferTableTable> {
  $$StockTransferTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get transferNumber => $composableBuilder(
      column: $table.transferNumber, builder: (column) => column);

  GeneratedColumn<String> get sourceWarehouseUuid => $composableBuilder(
      column: $table.sourceWarehouseUuid, builder: (column) => column);

  GeneratedColumn<String> get sourceWarehouseName => $composableBuilder(
      column: $table.sourceWarehouseName, builder: (column) => column);

  GeneratedColumn<String> get targetWarehouseUuid => $composableBuilder(
      column: $table.targetWarehouseUuid, builder: (column) => column);

  GeneratedColumn<String> get targetWarehouseName => $composableBuilder(
      column: $table.targetWarehouseName, builder: (column) => column);

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<String> get createdBy =>
      $composableBuilder(column: $table.createdBy, builder: (column) => column);

  GeneratedColumn<String> get createdByName => $composableBuilder(
      column: $table.createdByName, builder: (column) => column);

  GeneratedColumn<String> get approvedBy => $composableBuilder(
      column: $table.approvedBy, builder: (column) => column);

  GeneratedColumn<DateTime> get approvedAt => $composableBuilder(
      column: $table.approvedAt, builder: (column) => column);

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<double> get totalValue => $composableBuilder(
      column: $table.totalValue, builder: (column) => column);

  GeneratedColumn<int> get totalItems => $composableBuilder(
      column: $table.totalItems, builder: (column) => column);

  GeneratedColumn<DateTime> get expectedDeliveryAt => $composableBuilder(
      column: $table.expectedDeliveryAt, builder: (column) => column);

  GeneratedColumn<DateTime> get shippedAt =>
      $composableBuilder(column: $table.shippedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get receivedAt => $composableBuilder(
      column: $table.receivedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$StockTransferTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $StockTransferTableTable,
    StockTransferTableData,
    $$StockTransferTableTableFilterComposer,
    $$StockTransferTableTableOrderingComposer,
    $$StockTransferTableTableAnnotationComposer,
    $$StockTransferTableTableCreateCompanionBuilder,
    $$StockTransferTableTableUpdateCompanionBuilder,
    (
      StockTransferTableData,
      BaseReferences<_$AppDatabase, $StockTransferTableTable,
          StockTransferTableData>
    ),
    StockTransferTableData,
    PrefetchHooks Function()> {
  $$StockTransferTableTableTableManager(
      _$AppDatabase db, $StockTransferTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$StockTransferTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$StockTransferTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$StockTransferTableTableAnnotationComposer(
                  $db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String> transferNumber = const Value.absent(),
            Value<String> sourceWarehouseUuid = const Value.absent(),
            Value<String> sourceWarehouseName = const Value.absent(),
            Value<String> targetWarehouseUuid = const Value.absent(),
            Value<String> targetWarehouseName = const Value.absent(),
            Value<String> status = const Value.absent(),
            Value<String> createdBy = const Value.absent(),
            Value<String> createdByName = const Value.absent(),
            Value<String?> approvedBy = const Value.absent(),
            Value<DateTime?> approvedAt = const Value.absent(),
            Value<String?> notes = const Value.absent(),
            Value<double> totalValue = const Value.absent(),
            Value<int> totalItems = const Value.absent(),
            Value<DateTime?> expectedDeliveryAt = const Value.absent(),
            Value<DateTime?> shippedAt = const Value.absent(),
            Value<DateTime?> receivedAt = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
          }) =>
              StockTransferTableCompanion(
            id: id,
            uuid: uuid,
            transferNumber: transferNumber,
            sourceWarehouseUuid: sourceWarehouseUuid,
            sourceWarehouseName: sourceWarehouseName,
            targetWarehouseUuid: targetWarehouseUuid,
            targetWarehouseName: targetWarehouseName,
            status: status,
            createdBy: createdBy,
            createdByName: createdByName,
            approvedBy: approvedBy,
            approvedAt: approvedAt,
            notes: notes,
            totalValue: totalValue,
            totalItems: totalItems,
            expectedDeliveryAt: expectedDeliveryAt,
            shippedAt: shippedAt,
            receivedAt: receivedAt,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            required String transferNumber,
            required String sourceWarehouseUuid,
            required String sourceWarehouseName,
            required String targetWarehouseUuid,
            required String targetWarehouseName,
            Value<String> status = const Value.absent(),
            required String createdBy,
            required String createdByName,
            Value<String?> approvedBy = const Value.absent(),
            Value<DateTime?> approvedAt = const Value.absent(),
            Value<String?> notes = const Value.absent(),
            Value<double> totalValue = const Value.absent(),
            Value<int> totalItems = const Value.absent(),
            Value<DateTime?> expectedDeliveryAt = const Value.absent(),
            Value<DateTime?> shippedAt = const Value.absent(),
            Value<DateTime?> receivedAt = const Value.absent(),
            required DateTime createdAt,
            required DateTime updatedAt,
          }) =>
              StockTransferTableCompanion.insert(
            id: id,
            uuid: uuid,
            transferNumber: transferNumber,
            sourceWarehouseUuid: sourceWarehouseUuid,
            sourceWarehouseName: sourceWarehouseName,
            targetWarehouseUuid: targetWarehouseUuid,
            targetWarehouseName: targetWarehouseName,
            status: status,
            createdBy: createdBy,
            createdByName: createdByName,
            approvedBy: approvedBy,
            approvedAt: approvedAt,
            notes: notes,
            totalValue: totalValue,
            totalItems: totalItems,
            expectedDeliveryAt: expectedDeliveryAt,
            shippedAt: shippedAt,
            receivedAt: receivedAt,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$StockTransferTableTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $StockTransferTableTable,
    StockTransferTableData,
    $$StockTransferTableTableFilterComposer,
    $$StockTransferTableTableOrderingComposer,
    $$StockTransferTableTableAnnotationComposer,
    $$StockTransferTableTableCreateCompanionBuilder,
    $$StockTransferTableTableUpdateCompanionBuilder,
    (
      StockTransferTableData,
      BaseReferences<_$AppDatabase, $StockTransferTableTable,
          StockTransferTableData>
    ),
    StockTransferTableData,
    PrefetchHooks Function()>;
typedef $$StockTransferItemTableTableCreateCompanionBuilder
    = StockTransferItemTableCompanion Function({
  Value<int> id,
  required String transferUuid,
  required String productUuid,
  required String productName,
  Value<String?> batchUuid,
  required double quantityRequested,
  Value<double> quantityShipped,
  Value<double> quantityReceived,
  required double unitCost,
  Value<String?> notes,
});
typedef $$StockTransferItemTableTableUpdateCompanionBuilder
    = StockTransferItemTableCompanion Function({
  Value<int> id,
  Value<String> transferUuid,
  Value<String> productUuid,
  Value<String> productName,
  Value<String?> batchUuid,
  Value<double> quantityRequested,
  Value<double> quantityShipped,
  Value<double> quantityReceived,
  Value<double> unitCost,
  Value<String?> notes,
});

class $$StockTransferItemTableTableFilterComposer
    extends Composer<_$AppDatabase, $StockTransferItemTableTable> {
  $$StockTransferItemTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get transferUuid => $composableBuilder(
      column: $table.transferUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get productUuid => $composableBuilder(
      column: $table.productUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get productName => $composableBuilder(
      column: $table.productName, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get batchUuid => $composableBuilder(
      column: $table.batchUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get quantityRequested => $composableBuilder(
      column: $table.quantityRequested,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get quantityShipped => $composableBuilder(
      column: $table.quantityShipped,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get quantityReceived => $composableBuilder(
      column: $table.quantityReceived,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get unitCost => $composableBuilder(
      column: $table.unitCost, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get notes => $composableBuilder(
      column: $table.notes, builder: (column) => ColumnFilters(column));
}

class $$StockTransferItemTableTableOrderingComposer
    extends Composer<_$AppDatabase, $StockTransferItemTableTable> {
  $$StockTransferItemTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get transferUuid => $composableBuilder(
      column: $table.transferUuid,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get productUuid => $composableBuilder(
      column: $table.productUuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get productName => $composableBuilder(
      column: $table.productName, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get batchUuid => $composableBuilder(
      column: $table.batchUuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get quantityRequested => $composableBuilder(
      column: $table.quantityRequested,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get quantityShipped => $composableBuilder(
      column: $table.quantityShipped,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get quantityReceived => $composableBuilder(
      column: $table.quantityReceived,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get unitCost => $composableBuilder(
      column: $table.unitCost, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get notes => $composableBuilder(
      column: $table.notes, builder: (column) => ColumnOrderings(column));
}

class $$StockTransferItemTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $StockTransferItemTableTable> {
  $$StockTransferItemTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get transferUuid => $composableBuilder(
      column: $table.transferUuid, builder: (column) => column);

  GeneratedColumn<String> get productUuid => $composableBuilder(
      column: $table.productUuid, builder: (column) => column);

  GeneratedColumn<String> get productName => $composableBuilder(
      column: $table.productName, builder: (column) => column);

  GeneratedColumn<String> get batchUuid =>
      $composableBuilder(column: $table.batchUuid, builder: (column) => column);

  GeneratedColumn<double> get quantityRequested => $composableBuilder(
      column: $table.quantityRequested, builder: (column) => column);

  GeneratedColumn<double> get quantityShipped => $composableBuilder(
      column: $table.quantityShipped, builder: (column) => column);

  GeneratedColumn<double> get quantityReceived => $composableBuilder(
      column: $table.quantityReceived, builder: (column) => column);

  GeneratedColumn<double> get unitCost =>
      $composableBuilder(column: $table.unitCost, builder: (column) => column);

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);
}

class $$StockTransferItemTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $StockTransferItemTableTable,
    StockTransferItemTableData,
    $$StockTransferItemTableTableFilterComposer,
    $$StockTransferItemTableTableOrderingComposer,
    $$StockTransferItemTableTableAnnotationComposer,
    $$StockTransferItemTableTableCreateCompanionBuilder,
    $$StockTransferItemTableTableUpdateCompanionBuilder,
    (
      StockTransferItemTableData,
      BaseReferences<_$AppDatabase, $StockTransferItemTableTable,
          StockTransferItemTableData>
    ),
    StockTransferItemTableData,
    PrefetchHooks Function()> {
  $$StockTransferItemTableTableTableManager(
      _$AppDatabase db, $StockTransferItemTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$StockTransferItemTableTableFilterComposer(
                  $db: db, $table: table),
          createOrderingComposer: () =>
              $$StockTransferItemTableTableOrderingComposer(
                  $db: db, $table: table),
          createComputedFieldComposer: () =>
              $$StockTransferItemTableTableAnnotationComposer(
                  $db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> transferUuid = const Value.absent(),
            Value<String> productUuid = const Value.absent(),
            Value<String> productName = const Value.absent(),
            Value<String?> batchUuid = const Value.absent(),
            Value<double> quantityRequested = const Value.absent(),
            Value<double> quantityShipped = const Value.absent(),
            Value<double> quantityReceived = const Value.absent(),
            Value<double> unitCost = const Value.absent(),
            Value<String?> notes = const Value.absent(),
          }) =>
              StockTransferItemTableCompanion(
            id: id,
            transferUuid: transferUuid,
            productUuid: productUuid,
            productName: productName,
            batchUuid: batchUuid,
            quantityRequested: quantityRequested,
            quantityShipped: quantityShipped,
            quantityReceived: quantityReceived,
            unitCost: unitCost,
            notes: notes,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String transferUuid,
            required String productUuid,
            required String productName,
            Value<String?> batchUuid = const Value.absent(),
            required double quantityRequested,
            Value<double> quantityShipped = const Value.absent(),
            Value<double> quantityReceived = const Value.absent(),
            required double unitCost,
            Value<String?> notes = const Value.absent(),
          }) =>
              StockTransferItemTableCompanion.insert(
            id: id,
            transferUuid: transferUuid,
            productUuid: productUuid,
            productName: productName,
            batchUuid: batchUuid,
            quantityRequested: quantityRequested,
            quantityShipped: quantityShipped,
            quantityReceived: quantityReceived,
            unitCost: unitCost,
            notes: notes,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$StockTransferItemTableTableProcessedTableManager
    = ProcessedTableManager<
        _$AppDatabase,
        $StockTransferItemTableTable,
        StockTransferItemTableData,
        $$StockTransferItemTableTableFilterComposer,
        $$StockTransferItemTableTableOrderingComposer,
        $$StockTransferItemTableTableAnnotationComposer,
        $$StockTransferItemTableTableCreateCompanionBuilder,
        $$StockTransferItemTableTableUpdateCompanionBuilder,
        (
          StockTransferItemTableData,
          BaseReferences<_$AppDatabase, $StockTransferItemTableTable,
              StockTransferItemTableData>
        ),
        StockTransferItemTableData,
        PrefetchHooks Function()>;
typedef $$StockAlertConfigTableTableCreateCompanionBuilder
    = StockAlertConfigTableCompanion Function({
  Value<int> id,
  required String uuid,
  required String productUuid,
  Value<String?> warehouseUuid,
  Value<double?> lowStockThreshold,
  Value<double?> criticalStockThreshold,
  Value<double?> overstockThreshold,
  Value<int> expiryWarningDays,
  Value<bool> lowStockEmailEnabled,
  Value<bool> outOfStockEmailEnabled,
  Value<bool> expiryEmailEnabled,
  required DateTime updatedAt,
});
typedef $$StockAlertConfigTableTableUpdateCompanionBuilder
    = StockAlertConfigTableCompanion Function({
  Value<int> id,
  Value<String> uuid,
  Value<String> productUuid,
  Value<String?> warehouseUuid,
  Value<double?> lowStockThreshold,
  Value<double?> criticalStockThreshold,
  Value<double?> overstockThreshold,
  Value<int> expiryWarningDays,
  Value<bool> lowStockEmailEnabled,
  Value<bool> outOfStockEmailEnabled,
  Value<bool> expiryEmailEnabled,
  Value<DateTime> updatedAt,
});

class $$StockAlertConfigTableTableFilterComposer
    extends Composer<_$AppDatabase, $StockAlertConfigTableTable> {
  $$StockAlertConfigTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get productUuid => $composableBuilder(
      column: $table.productUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get warehouseUuid => $composableBuilder(
      column: $table.warehouseUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get lowStockThreshold => $composableBuilder(
      column: $table.lowStockThreshold,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get criticalStockThreshold => $composableBuilder(
      column: $table.criticalStockThreshold,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get overstockThreshold => $composableBuilder(
      column: $table.overstockThreshold,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get expiryWarningDays => $composableBuilder(
      column: $table.expiryWarningDays,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get lowStockEmailEnabled => $composableBuilder(
      column: $table.lowStockEmailEnabled,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get outOfStockEmailEnabled => $composableBuilder(
      column: $table.outOfStockEmailEnabled,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get expiryEmailEnabled => $composableBuilder(
      column: $table.expiryEmailEnabled,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));
}

class $$StockAlertConfigTableTableOrderingComposer
    extends Composer<_$AppDatabase, $StockAlertConfigTableTable> {
  $$StockAlertConfigTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get productUuid => $composableBuilder(
      column: $table.productUuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get warehouseUuid => $composableBuilder(
      column: $table.warehouseUuid,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get lowStockThreshold => $composableBuilder(
      column: $table.lowStockThreshold,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get criticalStockThreshold => $composableBuilder(
      column: $table.criticalStockThreshold,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get overstockThreshold => $composableBuilder(
      column: $table.overstockThreshold,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get expiryWarningDays => $composableBuilder(
      column: $table.expiryWarningDays,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get lowStockEmailEnabled => $composableBuilder(
      column: $table.lowStockEmailEnabled,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get outOfStockEmailEnabled => $composableBuilder(
      column: $table.outOfStockEmailEnabled,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get expiryEmailEnabled => $composableBuilder(
      column: $table.expiryEmailEnabled,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));
}

class $$StockAlertConfigTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $StockAlertConfigTableTable> {
  $$StockAlertConfigTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get productUuid => $composableBuilder(
      column: $table.productUuid, builder: (column) => column);

  GeneratedColumn<String> get warehouseUuid => $composableBuilder(
      column: $table.warehouseUuid, builder: (column) => column);

  GeneratedColumn<double> get lowStockThreshold => $composableBuilder(
      column: $table.lowStockThreshold, builder: (column) => column);

  GeneratedColumn<double> get criticalStockThreshold => $composableBuilder(
      column: $table.criticalStockThreshold, builder: (column) => column);

  GeneratedColumn<double> get overstockThreshold => $composableBuilder(
      column: $table.overstockThreshold, builder: (column) => column);

  GeneratedColumn<int> get expiryWarningDays => $composableBuilder(
      column: $table.expiryWarningDays, builder: (column) => column);

  GeneratedColumn<bool> get lowStockEmailEnabled => $composableBuilder(
      column: $table.lowStockEmailEnabled, builder: (column) => column);

  GeneratedColumn<bool> get outOfStockEmailEnabled => $composableBuilder(
      column: $table.outOfStockEmailEnabled, builder: (column) => column);

  GeneratedColumn<bool> get expiryEmailEnabled => $composableBuilder(
      column: $table.expiryEmailEnabled, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$StockAlertConfigTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $StockAlertConfigTableTable,
    StockAlertConfigTableData,
    $$StockAlertConfigTableTableFilterComposer,
    $$StockAlertConfigTableTableOrderingComposer,
    $$StockAlertConfigTableTableAnnotationComposer,
    $$StockAlertConfigTableTableCreateCompanionBuilder,
    $$StockAlertConfigTableTableUpdateCompanionBuilder,
    (
      StockAlertConfigTableData,
      BaseReferences<_$AppDatabase, $StockAlertConfigTableTable,
          StockAlertConfigTableData>
    ),
    StockAlertConfigTableData,
    PrefetchHooks Function()> {
  $$StockAlertConfigTableTableTableManager(
      _$AppDatabase db, $StockAlertConfigTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$StockAlertConfigTableTableFilterComposer(
                  $db: db, $table: table),
          createOrderingComposer: () =>
              $$StockAlertConfigTableTableOrderingComposer(
                  $db: db, $table: table),
          createComputedFieldComposer: () =>
              $$StockAlertConfigTableTableAnnotationComposer(
                  $db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String> productUuid = const Value.absent(),
            Value<String?> warehouseUuid = const Value.absent(),
            Value<double?> lowStockThreshold = const Value.absent(),
            Value<double?> criticalStockThreshold = const Value.absent(),
            Value<double?> overstockThreshold = const Value.absent(),
            Value<int> expiryWarningDays = const Value.absent(),
            Value<bool> lowStockEmailEnabled = const Value.absent(),
            Value<bool> outOfStockEmailEnabled = const Value.absent(),
            Value<bool> expiryEmailEnabled = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
          }) =>
              StockAlertConfigTableCompanion(
            id: id,
            uuid: uuid,
            productUuid: productUuid,
            warehouseUuid: warehouseUuid,
            lowStockThreshold: lowStockThreshold,
            criticalStockThreshold: criticalStockThreshold,
            overstockThreshold: overstockThreshold,
            expiryWarningDays: expiryWarningDays,
            lowStockEmailEnabled: lowStockEmailEnabled,
            outOfStockEmailEnabled: outOfStockEmailEnabled,
            expiryEmailEnabled: expiryEmailEnabled,
            updatedAt: updatedAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            required String productUuid,
            Value<String?> warehouseUuid = const Value.absent(),
            Value<double?> lowStockThreshold = const Value.absent(),
            Value<double?> criticalStockThreshold = const Value.absent(),
            Value<double?> overstockThreshold = const Value.absent(),
            Value<int> expiryWarningDays = const Value.absent(),
            Value<bool> lowStockEmailEnabled = const Value.absent(),
            Value<bool> outOfStockEmailEnabled = const Value.absent(),
            Value<bool> expiryEmailEnabled = const Value.absent(),
            required DateTime updatedAt,
          }) =>
              StockAlertConfigTableCompanion.insert(
            id: id,
            uuid: uuid,
            productUuid: productUuid,
            warehouseUuid: warehouseUuid,
            lowStockThreshold: lowStockThreshold,
            criticalStockThreshold: criticalStockThreshold,
            overstockThreshold: overstockThreshold,
            expiryWarningDays: expiryWarningDays,
            lowStockEmailEnabled: lowStockEmailEnabled,
            outOfStockEmailEnabled: outOfStockEmailEnabled,
            expiryEmailEnabled: expiryEmailEnabled,
            updatedAt: updatedAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$StockAlertConfigTableTableProcessedTableManager
    = ProcessedTableManager<
        _$AppDatabase,
        $StockAlertConfigTableTable,
        StockAlertConfigTableData,
        $$StockAlertConfigTableTableFilterComposer,
        $$StockAlertConfigTableTableOrderingComposer,
        $$StockAlertConfigTableTableAnnotationComposer,
        $$StockAlertConfigTableTableCreateCompanionBuilder,
        $$StockAlertConfigTableTableUpdateCompanionBuilder,
        (
          StockAlertConfigTableData,
          BaseReferences<_$AppDatabase, $StockAlertConfigTableTable,
              StockAlertConfigTableData>
        ),
        StockAlertConfigTableData,
        PrefetchHooks Function()>;
typedef $$StockMovementTableTableCreateCompanionBuilder
    = StockMovementTableCompanion Function({
  Value<int> id,
  required String uuid,
  required String productUuid,
  required String productName,
  required String warehouseUuid,
  Value<String?> batchUuid,
  required String movementType,
  required double quantityChange,
  Value<double?> unitCost,
  Value<double?> totalCost,
  Value<String?> referenceType,
  Value<String?> referenceUuid,
  Value<String?> referenceNumber,
  Value<String?> reasonCode,
  Value<String?> notes,
  required String performedBy,
  required String performedByName,
  required double balanceBefore,
  required double balanceAfter,
  required DateTime timestamp,
});
typedef $$StockMovementTableTableUpdateCompanionBuilder
    = StockMovementTableCompanion Function({
  Value<int> id,
  Value<String> uuid,
  Value<String> productUuid,
  Value<String> productName,
  Value<String> warehouseUuid,
  Value<String?> batchUuid,
  Value<String> movementType,
  Value<double> quantityChange,
  Value<double?> unitCost,
  Value<double?> totalCost,
  Value<String?> referenceType,
  Value<String?> referenceUuid,
  Value<String?> referenceNumber,
  Value<String?> reasonCode,
  Value<String?> notes,
  Value<String> performedBy,
  Value<String> performedByName,
  Value<double> balanceBefore,
  Value<double> balanceAfter,
  Value<DateTime> timestamp,
});

class $$StockMovementTableTableFilterComposer
    extends Composer<_$AppDatabase, $StockMovementTableTable> {
  $$StockMovementTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get productUuid => $composableBuilder(
      column: $table.productUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get productName => $composableBuilder(
      column: $table.productName, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get warehouseUuid => $composableBuilder(
      column: $table.warehouseUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get batchUuid => $composableBuilder(
      column: $table.batchUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get movementType => $composableBuilder(
      column: $table.movementType, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get quantityChange => $composableBuilder(
      column: $table.quantityChange,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get unitCost => $composableBuilder(
      column: $table.unitCost, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get totalCost => $composableBuilder(
      column: $table.totalCost, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get referenceType => $composableBuilder(
      column: $table.referenceType, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get referenceUuid => $composableBuilder(
      column: $table.referenceUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get referenceNumber => $composableBuilder(
      column: $table.referenceNumber,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get reasonCode => $composableBuilder(
      column: $table.reasonCode, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get notes => $composableBuilder(
      column: $table.notes, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get performedBy => $composableBuilder(
      column: $table.performedBy, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get performedByName => $composableBuilder(
      column: $table.performedByName,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get balanceBefore => $composableBuilder(
      column: $table.balanceBefore, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get balanceAfter => $composableBuilder(
      column: $table.balanceAfter, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get timestamp => $composableBuilder(
      column: $table.timestamp, builder: (column) => ColumnFilters(column));
}

class $$StockMovementTableTableOrderingComposer
    extends Composer<_$AppDatabase, $StockMovementTableTable> {
  $$StockMovementTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get productUuid => $composableBuilder(
      column: $table.productUuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get productName => $composableBuilder(
      column: $table.productName, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get warehouseUuid => $composableBuilder(
      column: $table.warehouseUuid,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get batchUuid => $composableBuilder(
      column: $table.batchUuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get movementType => $composableBuilder(
      column: $table.movementType,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get quantityChange => $composableBuilder(
      column: $table.quantityChange,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get unitCost => $composableBuilder(
      column: $table.unitCost, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get totalCost => $composableBuilder(
      column: $table.totalCost, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get referenceType => $composableBuilder(
      column: $table.referenceType,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get referenceUuid => $composableBuilder(
      column: $table.referenceUuid,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get referenceNumber => $composableBuilder(
      column: $table.referenceNumber,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get reasonCode => $composableBuilder(
      column: $table.reasonCode, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get notes => $composableBuilder(
      column: $table.notes, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get performedBy => $composableBuilder(
      column: $table.performedBy, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get performedByName => $composableBuilder(
      column: $table.performedByName,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get balanceBefore => $composableBuilder(
      column: $table.balanceBefore,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get balanceAfter => $composableBuilder(
      column: $table.balanceAfter,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get timestamp => $composableBuilder(
      column: $table.timestamp, builder: (column) => ColumnOrderings(column));
}

class $$StockMovementTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $StockMovementTableTable> {
  $$StockMovementTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get productUuid => $composableBuilder(
      column: $table.productUuid, builder: (column) => column);

  GeneratedColumn<String> get productName => $composableBuilder(
      column: $table.productName, builder: (column) => column);

  GeneratedColumn<String> get warehouseUuid => $composableBuilder(
      column: $table.warehouseUuid, builder: (column) => column);

  GeneratedColumn<String> get batchUuid =>
      $composableBuilder(column: $table.batchUuid, builder: (column) => column);

  GeneratedColumn<String> get movementType => $composableBuilder(
      column: $table.movementType, builder: (column) => column);

  GeneratedColumn<double> get quantityChange => $composableBuilder(
      column: $table.quantityChange, builder: (column) => column);

  GeneratedColumn<double> get unitCost =>
      $composableBuilder(column: $table.unitCost, builder: (column) => column);

  GeneratedColumn<double> get totalCost =>
      $composableBuilder(column: $table.totalCost, builder: (column) => column);

  GeneratedColumn<String> get referenceType => $composableBuilder(
      column: $table.referenceType, builder: (column) => column);

  GeneratedColumn<String> get referenceUuid => $composableBuilder(
      column: $table.referenceUuid, builder: (column) => column);

  GeneratedColumn<String> get referenceNumber => $composableBuilder(
      column: $table.referenceNumber, builder: (column) => column);

  GeneratedColumn<String> get reasonCode => $composableBuilder(
      column: $table.reasonCode, builder: (column) => column);

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<String> get performedBy => $composableBuilder(
      column: $table.performedBy, builder: (column) => column);

  GeneratedColumn<String> get performedByName => $composableBuilder(
      column: $table.performedByName, builder: (column) => column);

  GeneratedColumn<double> get balanceBefore => $composableBuilder(
      column: $table.balanceBefore, builder: (column) => column);

  GeneratedColumn<double> get balanceAfter => $composableBuilder(
      column: $table.balanceAfter, builder: (column) => column);

  GeneratedColumn<DateTime> get timestamp =>
      $composableBuilder(column: $table.timestamp, builder: (column) => column);
}

class $$StockMovementTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $StockMovementTableTable,
    StockMovementTableData,
    $$StockMovementTableTableFilterComposer,
    $$StockMovementTableTableOrderingComposer,
    $$StockMovementTableTableAnnotationComposer,
    $$StockMovementTableTableCreateCompanionBuilder,
    $$StockMovementTableTableUpdateCompanionBuilder,
    (
      StockMovementTableData,
      BaseReferences<_$AppDatabase, $StockMovementTableTable,
          StockMovementTableData>
    ),
    StockMovementTableData,
    PrefetchHooks Function()> {
  $$StockMovementTableTableTableManager(
      _$AppDatabase db, $StockMovementTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$StockMovementTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$StockMovementTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$StockMovementTableTableAnnotationComposer(
                  $db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String> productUuid = const Value.absent(),
            Value<String> productName = const Value.absent(),
            Value<String> warehouseUuid = const Value.absent(),
            Value<String?> batchUuid = const Value.absent(),
            Value<String> movementType = const Value.absent(),
            Value<double> quantityChange = const Value.absent(),
            Value<double?> unitCost = const Value.absent(),
            Value<double?> totalCost = const Value.absent(),
            Value<String?> referenceType = const Value.absent(),
            Value<String?> referenceUuid = const Value.absent(),
            Value<String?> referenceNumber = const Value.absent(),
            Value<String?> reasonCode = const Value.absent(),
            Value<String?> notes = const Value.absent(),
            Value<String> performedBy = const Value.absent(),
            Value<String> performedByName = const Value.absent(),
            Value<double> balanceBefore = const Value.absent(),
            Value<double> balanceAfter = const Value.absent(),
            Value<DateTime> timestamp = const Value.absent(),
          }) =>
              StockMovementTableCompanion(
            id: id,
            uuid: uuid,
            productUuid: productUuid,
            productName: productName,
            warehouseUuid: warehouseUuid,
            batchUuid: batchUuid,
            movementType: movementType,
            quantityChange: quantityChange,
            unitCost: unitCost,
            totalCost: totalCost,
            referenceType: referenceType,
            referenceUuid: referenceUuid,
            referenceNumber: referenceNumber,
            reasonCode: reasonCode,
            notes: notes,
            performedBy: performedBy,
            performedByName: performedByName,
            balanceBefore: balanceBefore,
            balanceAfter: balanceAfter,
            timestamp: timestamp,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            required String productUuid,
            required String productName,
            required String warehouseUuid,
            Value<String?> batchUuid = const Value.absent(),
            required String movementType,
            required double quantityChange,
            Value<double?> unitCost = const Value.absent(),
            Value<double?> totalCost = const Value.absent(),
            Value<String?> referenceType = const Value.absent(),
            Value<String?> referenceUuid = const Value.absent(),
            Value<String?> referenceNumber = const Value.absent(),
            Value<String?> reasonCode = const Value.absent(),
            Value<String?> notes = const Value.absent(),
            required String performedBy,
            required String performedByName,
            required double balanceBefore,
            required double balanceAfter,
            required DateTime timestamp,
          }) =>
              StockMovementTableCompanion.insert(
            id: id,
            uuid: uuid,
            productUuid: productUuid,
            productName: productName,
            warehouseUuid: warehouseUuid,
            batchUuid: batchUuid,
            movementType: movementType,
            quantityChange: quantityChange,
            unitCost: unitCost,
            totalCost: totalCost,
            referenceType: referenceType,
            referenceUuid: referenceUuid,
            referenceNumber: referenceNumber,
            reasonCode: reasonCode,
            notes: notes,
            performedBy: performedBy,
            performedByName: performedByName,
            balanceBefore: balanceBefore,
            balanceAfter: balanceAfter,
            timestamp: timestamp,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$StockMovementTableTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $StockMovementTableTable,
    StockMovementTableData,
    $$StockMovementTableTableFilterComposer,
    $$StockMovementTableTableOrderingComposer,
    $$StockMovementTableTableAnnotationComposer,
    $$StockMovementTableTableCreateCompanionBuilder,
    $$StockMovementTableTableUpdateCompanionBuilder,
    (
      StockMovementTableData,
      BaseReferences<_$AppDatabase, $StockMovementTableTable,
          StockMovementTableData>
    ),
    StockMovementTableData,
    PrefetchHooks Function()>;
typedef $$TimeEntryTableTableCreateCompanionBuilder = TimeEntryTableCompanion
    Function({
  Value<int> id,
  required String uuid,
  required String employeeUuid,
  required DateTime clockIn,
  Value<DateTime?> clockOut,
  Value<DateTime?> breakStart,
  Value<DateTime?> breakEnd,
  Value<double> regularHours,
  Value<double> overtimeHours,
  Value<double> breakMinutes,
  Value<double> cashTips,
  Value<double> cardTips,
  Value<String?> shiftUuid,
  Value<String?> notes,
  Value<bool> isApproved,
  Value<String?> approvedBy,
  required DateTime createdAt,
});
typedef $$TimeEntryTableTableUpdateCompanionBuilder = TimeEntryTableCompanion
    Function({
  Value<int> id,
  Value<String> uuid,
  Value<String> employeeUuid,
  Value<DateTime> clockIn,
  Value<DateTime?> clockOut,
  Value<DateTime?> breakStart,
  Value<DateTime?> breakEnd,
  Value<double> regularHours,
  Value<double> overtimeHours,
  Value<double> breakMinutes,
  Value<double> cashTips,
  Value<double> cardTips,
  Value<String?> shiftUuid,
  Value<String?> notes,
  Value<bool> isApproved,
  Value<String?> approvedBy,
  Value<DateTime> createdAt,
});

class $$TimeEntryTableTableFilterComposer
    extends Composer<_$AppDatabase, $TimeEntryTableTable> {
  $$TimeEntryTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get employeeUuid => $composableBuilder(
      column: $table.employeeUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get clockIn => $composableBuilder(
      column: $table.clockIn, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get clockOut => $composableBuilder(
      column: $table.clockOut, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get breakStart => $composableBuilder(
      column: $table.breakStart, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get breakEnd => $composableBuilder(
      column: $table.breakEnd, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get regularHours => $composableBuilder(
      column: $table.regularHours, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get overtimeHours => $composableBuilder(
      column: $table.overtimeHours, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get breakMinutes => $composableBuilder(
      column: $table.breakMinutes, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get cashTips => $composableBuilder(
      column: $table.cashTips, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get cardTips => $composableBuilder(
      column: $table.cardTips, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get shiftUuid => $composableBuilder(
      column: $table.shiftUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get notes => $composableBuilder(
      column: $table.notes, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isApproved => $composableBuilder(
      column: $table.isApproved, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get approvedBy => $composableBuilder(
      column: $table.approvedBy, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));
}

class $$TimeEntryTableTableOrderingComposer
    extends Composer<_$AppDatabase, $TimeEntryTableTable> {
  $$TimeEntryTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get employeeUuid => $composableBuilder(
      column: $table.employeeUuid,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get clockIn => $composableBuilder(
      column: $table.clockIn, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get clockOut => $composableBuilder(
      column: $table.clockOut, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get breakStart => $composableBuilder(
      column: $table.breakStart, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get breakEnd => $composableBuilder(
      column: $table.breakEnd, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get regularHours => $composableBuilder(
      column: $table.regularHours,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get overtimeHours => $composableBuilder(
      column: $table.overtimeHours,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get breakMinutes => $composableBuilder(
      column: $table.breakMinutes,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get cashTips => $composableBuilder(
      column: $table.cashTips, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get cardTips => $composableBuilder(
      column: $table.cardTips, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get shiftUuid => $composableBuilder(
      column: $table.shiftUuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get notes => $composableBuilder(
      column: $table.notes, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isApproved => $composableBuilder(
      column: $table.isApproved, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get approvedBy => $composableBuilder(
      column: $table.approvedBy, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));
}

class $$TimeEntryTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $TimeEntryTableTable> {
  $$TimeEntryTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get employeeUuid => $composableBuilder(
      column: $table.employeeUuid, builder: (column) => column);

  GeneratedColumn<DateTime> get clockIn =>
      $composableBuilder(column: $table.clockIn, builder: (column) => column);

  GeneratedColumn<DateTime> get clockOut =>
      $composableBuilder(column: $table.clockOut, builder: (column) => column);

  GeneratedColumn<DateTime> get breakStart => $composableBuilder(
      column: $table.breakStart, builder: (column) => column);

  GeneratedColumn<DateTime> get breakEnd =>
      $composableBuilder(column: $table.breakEnd, builder: (column) => column);

  GeneratedColumn<double> get regularHours => $composableBuilder(
      column: $table.regularHours, builder: (column) => column);

  GeneratedColumn<double> get overtimeHours => $composableBuilder(
      column: $table.overtimeHours, builder: (column) => column);

  GeneratedColumn<double> get breakMinutes => $composableBuilder(
      column: $table.breakMinutes, builder: (column) => column);

  GeneratedColumn<double> get cashTips =>
      $composableBuilder(column: $table.cashTips, builder: (column) => column);

  GeneratedColumn<double> get cardTips =>
      $composableBuilder(column: $table.cardTips, builder: (column) => column);

  GeneratedColumn<String> get shiftUuid =>
      $composableBuilder(column: $table.shiftUuid, builder: (column) => column);

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<bool> get isApproved => $composableBuilder(
      column: $table.isApproved, builder: (column) => column);

  GeneratedColumn<String> get approvedBy => $composableBuilder(
      column: $table.approvedBy, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);
}

class $$TimeEntryTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $TimeEntryTableTable,
    TimeEntryTableData,
    $$TimeEntryTableTableFilterComposer,
    $$TimeEntryTableTableOrderingComposer,
    $$TimeEntryTableTableAnnotationComposer,
    $$TimeEntryTableTableCreateCompanionBuilder,
    $$TimeEntryTableTableUpdateCompanionBuilder,
    (
      TimeEntryTableData,
      BaseReferences<_$AppDatabase, $TimeEntryTableTable, TimeEntryTableData>
    ),
    TimeEntryTableData,
    PrefetchHooks Function()> {
  $$TimeEntryTableTableTableManager(
      _$AppDatabase db, $TimeEntryTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$TimeEntryTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$TimeEntryTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$TimeEntryTableTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String> employeeUuid = const Value.absent(),
            Value<DateTime> clockIn = const Value.absent(),
            Value<DateTime?> clockOut = const Value.absent(),
            Value<DateTime?> breakStart = const Value.absent(),
            Value<DateTime?> breakEnd = const Value.absent(),
            Value<double> regularHours = const Value.absent(),
            Value<double> overtimeHours = const Value.absent(),
            Value<double> breakMinutes = const Value.absent(),
            Value<double> cashTips = const Value.absent(),
            Value<double> cardTips = const Value.absent(),
            Value<String?> shiftUuid = const Value.absent(),
            Value<String?> notes = const Value.absent(),
            Value<bool> isApproved = const Value.absent(),
            Value<String?> approvedBy = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
          }) =>
              TimeEntryTableCompanion(
            id: id,
            uuid: uuid,
            employeeUuid: employeeUuid,
            clockIn: clockIn,
            clockOut: clockOut,
            breakStart: breakStart,
            breakEnd: breakEnd,
            regularHours: regularHours,
            overtimeHours: overtimeHours,
            breakMinutes: breakMinutes,
            cashTips: cashTips,
            cardTips: cardTips,
            shiftUuid: shiftUuid,
            notes: notes,
            isApproved: isApproved,
            approvedBy: approvedBy,
            createdAt: createdAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            required String employeeUuid,
            required DateTime clockIn,
            Value<DateTime?> clockOut = const Value.absent(),
            Value<DateTime?> breakStart = const Value.absent(),
            Value<DateTime?> breakEnd = const Value.absent(),
            Value<double> regularHours = const Value.absent(),
            Value<double> overtimeHours = const Value.absent(),
            Value<double> breakMinutes = const Value.absent(),
            Value<double> cashTips = const Value.absent(),
            Value<double> cardTips = const Value.absent(),
            Value<String?> shiftUuid = const Value.absent(),
            Value<String?> notes = const Value.absent(),
            Value<bool> isApproved = const Value.absent(),
            Value<String?> approvedBy = const Value.absent(),
            required DateTime createdAt,
          }) =>
              TimeEntryTableCompanion.insert(
            id: id,
            uuid: uuid,
            employeeUuid: employeeUuid,
            clockIn: clockIn,
            clockOut: clockOut,
            breakStart: breakStart,
            breakEnd: breakEnd,
            regularHours: regularHours,
            overtimeHours: overtimeHours,
            breakMinutes: breakMinutes,
            cashTips: cashTips,
            cardTips: cardTips,
            shiftUuid: shiftUuid,
            notes: notes,
            isApproved: isApproved,
            approvedBy: approvedBy,
            createdAt: createdAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$TimeEntryTableTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $TimeEntryTableTable,
    TimeEntryTableData,
    $$TimeEntryTableTableFilterComposer,
    $$TimeEntryTableTableOrderingComposer,
    $$TimeEntryTableTableAnnotationComposer,
    $$TimeEntryTableTableCreateCompanionBuilder,
    $$TimeEntryTableTableUpdateCompanionBuilder,
    (
      TimeEntryTableData,
      BaseReferences<_$AppDatabase, $TimeEntryTableTable, TimeEntryTableData>
    ),
    TimeEntryTableData,
    PrefetchHooks Function()>;
typedef $$ScheduledShiftTableTableCreateCompanionBuilder
    = ScheduledShiftTableCompanion Function({
  Value<int> id,
  required String uuid,
  required String employeeUuid,
  required DateTime date,
  required DateTime startTime,
  required DateTime endTime,
  Value<String?> position,
  Value<String?> notes,
  Value<bool> isPublished,
  Value<bool> isAcknowledged,
  Value<String?> swapRequestedWith,
  Value<bool> isSwapPending,
  required DateTime createdAt,
  required DateTime updatedAt,
});
typedef $$ScheduledShiftTableTableUpdateCompanionBuilder
    = ScheduledShiftTableCompanion Function({
  Value<int> id,
  Value<String> uuid,
  Value<String> employeeUuid,
  Value<DateTime> date,
  Value<DateTime> startTime,
  Value<DateTime> endTime,
  Value<String?> position,
  Value<String?> notes,
  Value<bool> isPublished,
  Value<bool> isAcknowledged,
  Value<String?> swapRequestedWith,
  Value<bool> isSwapPending,
  Value<DateTime> createdAt,
  Value<DateTime> updatedAt,
});

class $$ScheduledShiftTableTableFilterComposer
    extends Composer<_$AppDatabase, $ScheduledShiftTableTable> {
  $$ScheduledShiftTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get employeeUuid => $composableBuilder(
      column: $table.employeeUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get date => $composableBuilder(
      column: $table.date, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get startTime => $composableBuilder(
      column: $table.startTime, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get endTime => $composableBuilder(
      column: $table.endTime, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get position => $composableBuilder(
      column: $table.position, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get notes => $composableBuilder(
      column: $table.notes, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isPublished => $composableBuilder(
      column: $table.isPublished, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isAcknowledged => $composableBuilder(
      column: $table.isAcknowledged,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get swapRequestedWith => $composableBuilder(
      column: $table.swapRequestedWith,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isSwapPending => $composableBuilder(
      column: $table.isSwapPending, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));
}

class $$ScheduledShiftTableTableOrderingComposer
    extends Composer<_$AppDatabase, $ScheduledShiftTableTable> {
  $$ScheduledShiftTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get employeeUuid => $composableBuilder(
      column: $table.employeeUuid,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get date => $composableBuilder(
      column: $table.date, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get startTime => $composableBuilder(
      column: $table.startTime, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get endTime => $composableBuilder(
      column: $table.endTime, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get position => $composableBuilder(
      column: $table.position, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get notes => $composableBuilder(
      column: $table.notes, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isPublished => $composableBuilder(
      column: $table.isPublished, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isAcknowledged => $composableBuilder(
      column: $table.isAcknowledged,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get swapRequestedWith => $composableBuilder(
      column: $table.swapRequestedWith,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isSwapPending => $composableBuilder(
      column: $table.isSwapPending,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));
}

class $$ScheduledShiftTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $ScheduledShiftTableTable> {
  $$ScheduledShiftTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get employeeUuid => $composableBuilder(
      column: $table.employeeUuid, builder: (column) => column);

  GeneratedColumn<DateTime> get date =>
      $composableBuilder(column: $table.date, builder: (column) => column);

  GeneratedColumn<DateTime> get startTime =>
      $composableBuilder(column: $table.startTime, builder: (column) => column);

  GeneratedColumn<DateTime> get endTime =>
      $composableBuilder(column: $table.endTime, builder: (column) => column);

  GeneratedColumn<String> get position =>
      $composableBuilder(column: $table.position, builder: (column) => column);

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<bool> get isPublished => $composableBuilder(
      column: $table.isPublished, builder: (column) => column);

  GeneratedColumn<bool> get isAcknowledged => $composableBuilder(
      column: $table.isAcknowledged, builder: (column) => column);

  GeneratedColumn<String> get swapRequestedWith => $composableBuilder(
      column: $table.swapRequestedWith, builder: (column) => column);

  GeneratedColumn<bool> get isSwapPending => $composableBuilder(
      column: $table.isSwapPending, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$ScheduledShiftTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $ScheduledShiftTableTable,
    ScheduledShiftTableData,
    $$ScheduledShiftTableTableFilterComposer,
    $$ScheduledShiftTableTableOrderingComposer,
    $$ScheduledShiftTableTableAnnotationComposer,
    $$ScheduledShiftTableTableCreateCompanionBuilder,
    $$ScheduledShiftTableTableUpdateCompanionBuilder,
    (
      ScheduledShiftTableData,
      BaseReferences<_$AppDatabase, $ScheduledShiftTableTable,
          ScheduledShiftTableData>
    ),
    ScheduledShiftTableData,
    PrefetchHooks Function()> {
  $$ScheduledShiftTableTableTableManager(
      _$AppDatabase db, $ScheduledShiftTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ScheduledShiftTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ScheduledShiftTableTableOrderingComposer(
                  $db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ScheduledShiftTableTableAnnotationComposer(
                  $db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String> employeeUuid = const Value.absent(),
            Value<DateTime> date = const Value.absent(),
            Value<DateTime> startTime = const Value.absent(),
            Value<DateTime> endTime = const Value.absent(),
            Value<String?> position = const Value.absent(),
            Value<String?> notes = const Value.absent(),
            Value<bool> isPublished = const Value.absent(),
            Value<bool> isAcknowledged = const Value.absent(),
            Value<String?> swapRequestedWith = const Value.absent(),
            Value<bool> isSwapPending = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
          }) =>
              ScheduledShiftTableCompanion(
            id: id,
            uuid: uuid,
            employeeUuid: employeeUuid,
            date: date,
            startTime: startTime,
            endTime: endTime,
            position: position,
            notes: notes,
            isPublished: isPublished,
            isAcknowledged: isAcknowledged,
            swapRequestedWith: swapRequestedWith,
            isSwapPending: isSwapPending,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            required String employeeUuid,
            required DateTime date,
            required DateTime startTime,
            required DateTime endTime,
            Value<String?> position = const Value.absent(),
            Value<String?> notes = const Value.absent(),
            Value<bool> isPublished = const Value.absent(),
            Value<bool> isAcknowledged = const Value.absent(),
            Value<String?> swapRequestedWith = const Value.absent(),
            Value<bool> isSwapPending = const Value.absent(),
            required DateTime createdAt,
            required DateTime updatedAt,
          }) =>
              ScheduledShiftTableCompanion.insert(
            id: id,
            uuid: uuid,
            employeeUuid: employeeUuid,
            date: date,
            startTime: startTime,
            endTime: endTime,
            position: position,
            notes: notes,
            isPublished: isPublished,
            isAcknowledged: isAcknowledged,
            swapRequestedWith: swapRequestedWith,
            isSwapPending: isSwapPending,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$ScheduledShiftTableTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $ScheduledShiftTableTable,
    ScheduledShiftTableData,
    $$ScheduledShiftTableTableFilterComposer,
    $$ScheduledShiftTableTableOrderingComposer,
    $$ScheduledShiftTableTableAnnotationComposer,
    $$ScheduledShiftTableTableCreateCompanionBuilder,
    $$ScheduledShiftTableTableUpdateCompanionBuilder,
    (
      ScheduledShiftTableData,
      BaseReferences<_$AppDatabase, $ScheduledShiftTableTable,
          ScheduledShiftTableData>
    ),
    ScheduledShiftTableData,
    PrefetchHooks Function()>;
typedef $$EmployeeExtendedTableTableCreateCompanionBuilder
    = EmployeeExtendedTableCompanion Function({
  Value<int> id,
  required String employeeUuid,
  Value<double> hourlyRate,
  Value<double> salary,
  Value<String> payType,
  Value<String> employmentStatus,
  Value<String?> phone,
  Value<String?> email,
  Value<String?> avatarUrl,
  Value<DateTime?> hireDate,
  Value<DateTime?> terminationDate,
  Value<String> permissionsJson,
  required DateTime updatedAt,
});
typedef $$EmployeeExtendedTableTableUpdateCompanionBuilder
    = EmployeeExtendedTableCompanion Function({
  Value<int> id,
  Value<String> employeeUuid,
  Value<double> hourlyRate,
  Value<double> salary,
  Value<String> payType,
  Value<String> employmentStatus,
  Value<String?> phone,
  Value<String?> email,
  Value<String?> avatarUrl,
  Value<DateTime?> hireDate,
  Value<DateTime?> terminationDate,
  Value<String> permissionsJson,
  Value<DateTime> updatedAt,
});

class $$EmployeeExtendedTableTableFilterComposer
    extends Composer<_$AppDatabase, $EmployeeExtendedTableTable> {
  $$EmployeeExtendedTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get employeeUuid => $composableBuilder(
      column: $table.employeeUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get hourlyRate => $composableBuilder(
      column: $table.hourlyRate, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get salary => $composableBuilder(
      column: $table.salary, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get payType => $composableBuilder(
      column: $table.payType, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get employmentStatus => $composableBuilder(
      column: $table.employmentStatus,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get phone => $composableBuilder(
      column: $table.phone, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get email => $composableBuilder(
      column: $table.email, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get avatarUrl => $composableBuilder(
      column: $table.avatarUrl, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get hireDate => $composableBuilder(
      column: $table.hireDate, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get terminationDate => $composableBuilder(
      column: $table.terminationDate,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get permissionsJson => $composableBuilder(
      column: $table.permissionsJson,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));
}

class $$EmployeeExtendedTableTableOrderingComposer
    extends Composer<_$AppDatabase, $EmployeeExtendedTableTable> {
  $$EmployeeExtendedTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get employeeUuid => $composableBuilder(
      column: $table.employeeUuid,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get hourlyRate => $composableBuilder(
      column: $table.hourlyRate, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get salary => $composableBuilder(
      column: $table.salary, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get payType => $composableBuilder(
      column: $table.payType, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get employmentStatus => $composableBuilder(
      column: $table.employmentStatus,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get phone => $composableBuilder(
      column: $table.phone, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get email => $composableBuilder(
      column: $table.email, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get avatarUrl => $composableBuilder(
      column: $table.avatarUrl, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get hireDate => $composableBuilder(
      column: $table.hireDate, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get terminationDate => $composableBuilder(
      column: $table.terminationDate,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get permissionsJson => $composableBuilder(
      column: $table.permissionsJson,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));
}

class $$EmployeeExtendedTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $EmployeeExtendedTableTable> {
  $$EmployeeExtendedTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get employeeUuid => $composableBuilder(
      column: $table.employeeUuid, builder: (column) => column);

  GeneratedColumn<double> get hourlyRate => $composableBuilder(
      column: $table.hourlyRate, builder: (column) => column);

  GeneratedColumn<double> get salary =>
      $composableBuilder(column: $table.salary, builder: (column) => column);

  GeneratedColumn<String> get payType =>
      $composableBuilder(column: $table.payType, builder: (column) => column);

  GeneratedColumn<String> get employmentStatus => $composableBuilder(
      column: $table.employmentStatus, builder: (column) => column);

  GeneratedColumn<String> get phone =>
      $composableBuilder(column: $table.phone, builder: (column) => column);

  GeneratedColumn<String> get email =>
      $composableBuilder(column: $table.email, builder: (column) => column);

  GeneratedColumn<String> get avatarUrl =>
      $composableBuilder(column: $table.avatarUrl, builder: (column) => column);

  GeneratedColumn<DateTime> get hireDate =>
      $composableBuilder(column: $table.hireDate, builder: (column) => column);

  GeneratedColumn<DateTime> get terminationDate => $composableBuilder(
      column: $table.terminationDate, builder: (column) => column);

  GeneratedColumn<String> get permissionsJson => $composableBuilder(
      column: $table.permissionsJson, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$EmployeeExtendedTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $EmployeeExtendedTableTable,
    EmployeeExtendedTableData,
    $$EmployeeExtendedTableTableFilterComposer,
    $$EmployeeExtendedTableTableOrderingComposer,
    $$EmployeeExtendedTableTableAnnotationComposer,
    $$EmployeeExtendedTableTableCreateCompanionBuilder,
    $$EmployeeExtendedTableTableUpdateCompanionBuilder,
    (
      EmployeeExtendedTableData,
      BaseReferences<_$AppDatabase, $EmployeeExtendedTableTable,
          EmployeeExtendedTableData>
    ),
    EmployeeExtendedTableData,
    PrefetchHooks Function()> {
  $$EmployeeExtendedTableTableTableManager(
      _$AppDatabase db, $EmployeeExtendedTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$EmployeeExtendedTableTableFilterComposer(
                  $db: db, $table: table),
          createOrderingComposer: () =>
              $$EmployeeExtendedTableTableOrderingComposer(
                  $db: db, $table: table),
          createComputedFieldComposer: () =>
              $$EmployeeExtendedTableTableAnnotationComposer(
                  $db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> employeeUuid = const Value.absent(),
            Value<double> hourlyRate = const Value.absent(),
            Value<double> salary = const Value.absent(),
            Value<String> payType = const Value.absent(),
            Value<String> employmentStatus = const Value.absent(),
            Value<String?> phone = const Value.absent(),
            Value<String?> email = const Value.absent(),
            Value<String?> avatarUrl = const Value.absent(),
            Value<DateTime?> hireDate = const Value.absent(),
            Value<DateTime?> terminationDate = const Value.absent(),
            Value<String> permissionsJson = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
          }) =>
              EmployeeExtendedTableCompanion(
            id: id,
            employeeUuid: employeeUuid,
            hourlyRate: hourlyRate,
            salary: salary,
            payType: payType,
            employmentStatus: employmentStatus,
            phone: phone,
            email: email,
            avatarUrl: avatarUrl,
            hireDate: hireDate,
            terminationDate: terminationDate,
            permissionsJson: permissionsJson,
            updatedAt: updatedAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String employeeUuid,
            Value<double> hourlyRate = const Value.absent(),
            Value<double> salary = const Value.absent(),
            Value<String> payType = const Value.absent(),
            Value<String> employmentStatus = const Value.absent(),
            Value<String?> phone = const Value.absent(),
            Value<String?> email = const Value.absent(),
            Value<String?> avatarUrl = const Value.absent(),
            Value<DateTime?> hireDate = const Value.absent(),
            Value<DateTime?> terminationDate = const Value.absent(),
            Value<String> permissionsJson = const Value.absent(),
            required DateTime updatedAt,
          }) =>
              EmployeeExtendedTableCompanion.insert(
            id: id,
            employeeUuid: employeeUuid,
            hourlyRate: hourlyRate,
            salary: salary,
            payType: payType,
            employmentStatus: employmentStatus,
            phone: phone,
            email: email,
            avatarUrl: avatarUrl,
            hireDate: hireDate,
            terminationDate: terminationDate,
            permissionsJson: permissionsJson,
            updatedAt: updatedAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$EmployeeExtendedTableTableProcessedTableManager
    = ProcessedTableManager<
        _$AppDatabase,
        $EmployeeExtendedTableTable,
        EmployeeExtendedTableData,
        $$EmployeeExtendedTableTableFilterComposer,
        $$EmployeeExtendedTableTableOrderingComposer,
        $$EmployeeExtendedTableTableAnnotationComposer,
        $$EmployeeExtendedTableTableCreateCompanionBuilder,
        $$EmployeeExtendedTableTableUpdateCompanionBuilder,
        (
          EmployeeExtendedTableData,
          BaseReferences<_$AppDatabase, $EmployeeExtendedTableTable,
              EmployeeExtendedTableData>
        ),
        EmployeeExtendedTableData,
        PrefetchHooks Function()>;
typedef $$GiftCardTableTableCreateCompanionBuilder = GiftCardTableCompanion
    Function({
  Value<int> id,
  required String uuid,
  required String cardNumber,
  Value<String?> barcode,
  required double initialValue,
  Value<double> currentBalance,
  Value<String?> customerUuid,
  Value<String?> customerName,
  Value<String?> customerEmail,
  Value<String?> customerPhone,
  Value<String> status,
  required DateTime activatedAt,
  Value<DateTime?> expiresAt,
  Value<DateTime?> lastUsedAt,
  Value<String?> pin,
  Value<String?> activatedByEmployeeUuid,
  Value<String?> activatedByEmployeeName,
  Value<String?> notes,
  required DateTime createdAt,
  required DateTime updatedAt,
});
typedef $$GiftCardTableTableUpdateCompanionBuilder = GiftCardTableCompanion
    Function({
  Value<int> id,
  Value<String> uuid,
  Value<String> cardNumber,
  Value<String?> barcode,
  Value<double> initialValue,
  Value<double> currentBalance,
  Value<String?> customerUuid,
  Value<String?> customerName,
  Value<String?> customerEmail,
  Value<String?> customerPhone,
  Value<String> status,
  Value<DateTime> activatedAt,
  Value<DateTime?> expiresAt,
  Value<DateTime?> lastUsedAt,
  Value<String?> pin,
  Value<String?> activatedByEmployeeUuid,
  Value<String?> activatedByEmployeeName,
  Value<String?> notes,
  Value<DateTime> createdAt,
  Value<DateTime> updatedAt,
});

class $$GiftCardTableTableFilterComposer
    extends Composer<_$AppDatabase, $GiftCardTableTable> {
  $$GiftCardTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get cardNumber => $composableBuilder(
      column: $table.cardNumber, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get barcode => $composableBuilder(
      column: $table.barcode, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get initialValue => $composableBuilder(
      column: $table.initialValue, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get currentBalance => $composableBuilder(
      column: $table.currentBalance,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get customerUuid => $composableBuilder(
      column: $table.customerUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get customerName => $composableBuilder(
      column: $table.customerName, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get customerEmail => $composableBuilder(
      column: $table.customerEmail, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get customerPhone => $composableBuilder(
      column: $table.customerPhone, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get activatedAt => $composableBuilder(
      column: $table.activatedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get expiresAt => $composableBuilder(
      column: $table.expiresAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get lastUsedAt => $composableBuilder(
      column: $table.lastUsedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get pin => $composableBuilder(
      column: $table.pin, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get activatedByEmployeeUuid => $composableBuilder(
      column: $table.activatedByEmployeeUuid,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get activatedByEmployeeName => $composableBuilder(
      column: $table.activatedByEmployeeName,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get notes => $composableBuilder(
      column: $table.notes, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));
}

class $$GiftCardTableTableOrderingComposer
    extends Composer<_$AppDatabase, $GiftCardTableTable> {
  $$GiftCardTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get cardNumber => $composableBuilder(
      column: $table.cardNumber, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get barcode => $composableBuilder(
      column: $table.barcode, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get initialValue => $composableBuilder(
      column: $table.initialValue,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get currentBalance => $composableBuilder(
      column: $table.currentBalance,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get customerUuid => $composableBuilder(
      column: $table.customerUuid,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get customerName => $composableBuilder(
      column: $table.customerName,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get customerEmail => $composableBuilder(
      column: $table.customerEmail,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get customerPhone => $composableBuilder(
      column: $table.customerPhone,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get activatedAt => $composableBuilder(
      column: $table.activatedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get expiresAt => $composableBuilder(
      column: $table.expiresAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get lastUsedAt => $composableBuilder(
      column: $table.lastUsedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get pin => $composableBuilder(
      column: $table.pin, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get activatedByEmployeeUuid => $composableBuilder(
      column: $table.activatedByEmployeeUuid,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get activatedByEmployeeName => $composableBuilder(
      column: $table.activatedByEmployeeName,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get notes => $composableBuilder(
      column: $table.notes, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));
}

class $$GiftCardTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $GiftCardTableTable> {
  $$GiftCardTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get cardNumber => $composableBuilder(
      column: $table.cardNumber, builder: (column) => column);

  GeneratedColumn<String> get barcode =>
      $composableBuilder(column: $table.barcode, builder: (column) => column);

  GeneratedColumn<double> get initialValue => $composableBuilder(
      column: $table.initialValue, builder: (column) => column);

  GeneratedColumn<double> get currentBalance => $composableBuilder(
      column: $table.currentBalance, builder: (column) => column);

  GeneratedColumn<String> get customerUuid => $composableBuilder(
      column: $table.customerUuid, builder: (column) => column);

  GeneratedColumn<String> get customerName => $composableBuilder(
      column: $table.customerName, builder: (column) => column);

  GeneratedColumn<String> get customerEmail => $composableBuilder(
      column: $table.customerEmail, builder: (column) => column);

  GeneratedColumn<String> get customerPhone => $composableBuilder(
      column: $table.customerPhone, builder: (column) => column);

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<DateTime> get activatedAt => $composableBuilder(
      column: $table.activatedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get expiresAt =>
      $composableBuilder(column: $table.expiresAt, builder: (column) => column);

  GeneratedColumn<DateTime> get lastUsedAt => $composableBuilder(
      column: $table.lastUsedAt, builder: (column) => column);

  GeneratedColumn<String> get pin =>
      $composableBuilder(column: $table.pin, builder: (column) => column);

  GeneratedColumn<String> get activatedByEmployeeUuid => $composableBuilder(
      column: $table.activatedByEmployeeUuid, builder: (column) => column);

  GeneratedColumn<String> get activatedByEmployeeName => $composableBuilder(
      column: $table.activatedByEmployeeName, builder: (column) => column);

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$GiftCardTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $GiftCardTableTable,
    GiftCardTableData,
    $$GiftCardTableTableFilterComposer,
    $$GiftCardTableTableOrderingComposer,
    $$GiftCardTableTableAnnotationComposer,
    $$GiftCardTableTableCreateCompanionBuilder,
    $$GiftCardTableTableUpdateCompanionBuilder,
    (
      GiftCardTableData,
      BaseReferences<_$AppDatabase, $GiftCardTableTable, GiftCardTableData>
    ),
    GiftCardTableData,
    PrefetchHooks Function()> {
  $$GiftCardTableTableTableManager(_$AppDatabase db, $GiftCardTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$GiftCardTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$GiftCardTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$GiftCardTableTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String> cardNumber = const Value.absent(),
            Value<String?> barcode = const Value.absent(),
            Value<double> initialValue = const Value.absent(),
            Value<double> currentBalance = const Value.absent(),
            Value<String?> customerUuid = const Value.absent(),
            Value<String?> customerName = const Value.absent(),
            Value<String?> customerEmail = const Value.absent(),
            Value<String?> customerPhone = const Value.absent(),
            Value<String> status = const Value.absent(),
            Value<DateTime> activatedAt = const Value.absent(),
            Value<DateTime?> expiresAt = const Value.absent(),
            Value<DateTime?> lastUsedAt = const Value.absent(),
            Value<String?> pin = const Value.absent(),
            Value<String?> activatedByEmployeeUuid = const Value.absent(),
            Value<String?> activatedByEmployeeName = const Value.absent(),
            Value<String?> notes = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
          }) =>
              GiftCardTableCompanion(
            id: id,
            uuid: uuid,
            cardNumber: cardNumber,
            barcode: barcode,
            initialValue: initialValue,
            currentBalance: currentBalance,
            customerUuid: customerUuid,
            customerName: customerName,
            customerEmail: customerEmail,
            customerPhone: customerPhone,
            status: status,
            activatedAt: activatedAt,
            expiresAt: expiresAt,
            lastUsedAt: lastUsedAt,
            pin: pin,
            activatedByEmployeeUuid: activatedByEmployeeUuid,
            activatedByEmployeeName: activatedByEmployeeName,
            notes: notes,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            required String cardNumber,
            Value<String?> barcode = const Value.absent(),
            required double initialValue,
            Value<double> currentBalance = const Value.absent(),
            Value<String?> customerUuid = const Value.absent(),
            Value<String?> customerName = const Value.absent(),
            Value<String?> customerEmail = const Value.absent(),
            Value<String?> customerPhone = const Value.absent(),
            Value<String> status = const Value.absent(),
            required DateTime activatedAt,
            Value<DateTime?> expiresAt = const Value.absent(),
            Value<DateTime?> lastUsedAt = const Value.absent(),
            Value<String?> pin = const Value.absent(),
            Value<String?> activatedByEmployeeUuid = const Value.absent(),
            Value<String?> activatedByEmployeeName = const Value.absent(),
            Value<String?> notes = const Value.absent(),
            required DateTime createdAt,
            required DateTime updatedAt,
          }) =>
              GiftCardTableCompanion.insert(
            id: id,
            uuid: uuid,
            cardNumber: cardNumber,
            barcode: barcode,
            initialValue: initialValue,
            currentBalance: currentBalance,
            customerUuid: customerUuid,
            customerName: customerName,
            customerEmail: customerEmail,
            customerPhone: customerPhone,
            status: status,
            activatedAt: activatedAt,
            expiresAt: expiresAt,
            lastUsedAt: lastUsedAt,
            pin: pin,
            activatedByEmployeeUuid: activatedByEmployeeUuid,
            activatedByEmployeeName: activatedByEmployeeName,
            notes: notes,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$GiftCardTableTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $GiftCardTableTable,
    GiftCardTableData,
    $$GiftCardTableTableFilterComposer,
    $$GiftCardTableTableOrderingComposer,
    $$GiftCardTableTableAnnotationComposer,
    $$GiftCardTableTableCreateCompanionBuilder,
    $$GiftCardTableTableUpdateCompanionBuilder,
    (
      GiftCardTableData,
      BaseReferences<_$AppDatabase, $GiftCardTableTable, GiftCardTableData>
    ),
    GiftCardTableData,
    PrefetchHooks Function()>;
typedef $$GiftCardTransactionTableTableCreateCompanionBuilder
    = GiftCardTransactionTableCompanion Function({
  Value<int> id,
  required String uuid,
  required String giftCardUuid,
  required String transactionType,
  required double amount,
  required double balanceAfter,
  Value<String?> orderUuid,
  Value<String?> orderNumber,
  required String performedByUuid,
  required String performedByName,
  Value<String?> notes,
  required DateTime timestamp,
});
typedef $$GiftCardTransactionTableTableUpdateCompanionBuilder
    = GiftCardTransactionTableCompanion Function({
  Value<int> id,
  Value<String> uuid,
  Value<String> giftCardUuid,
  Value<String> transactionType,
  Value<double> amount,
  Value<double> balanceAfter,
  Value<String?> orderUuid,
  Value<String?> orderNumber,
  Value<String> performedByUuid,
  Value<String> performedByName,
  Value<String?> notes,
  Value<DateTime> timestamp,
});

class $$GiftCardTransactionTableTableFilterComposer
    extends Composer<_$AppDatabase, $GiftCardTransactionTableTable> {
  $$GiftCardTransactionTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get giftCardUuid => $composableBuilder(
      column: $table.giftCardUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get transactionType => $composableBuilder(
      column: $table.transactionType,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get amount => $composableBuilder(
      column: $table.amount, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get balanceAfter => $composableBuilder(
      column: $table.balanceAfter, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get orderUuid => $composableBuilder(
      column: $table.orderUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get orderNumber => $composableBuilder(
      column: $table.orderNumber, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get performedByUuid => $composableBuilder(
      column: $table.performedByUuid,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get performedByName => $composableBuilder(
      column: $table.performedByName,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get notes => $composableBuilder(
      column: $table.notes, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get timestamp => $composableBuilder(
      column: $table.timestamp, builder: (column) => ColumnFilters(column));
}

class $$GiftCardTransactionTableTableOrderingComposer
    extends Composer<_$AppDatabase, $GiftCardTransactionTableTable> {
  $$GiftCardTransactionTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get giftCardUuid => $composableBuilder(
      column: $table.giftCardUuid,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get transactionType => $composableBuilder(
      column: $table.transactionType,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get amount => $composableBuilder(
      column: $table.amount, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get balanceAfter => $composableBuilder(
      column: $table.balanceAfter,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get orderUuid => $composableBuilder(
      column: $table.orderUuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get orderNumber => $composableBuilder(
      column: $table.orderNumber, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get performedByUuid => $composableBuilder(
      column: $table.performedByUuid,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get performedByName => $composableBuilder(
      column: $table.performedByName,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get notes => $composableBuilder(
      column: $table.notes, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get timestamp => $composableBuilder(
      column: $table.timestamp, builder: (column) => ColumnOrderings(column));
}

class $$GiftCardTransactionTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $GiftCardTransactionTableTable> {
  $$GiftCardTransactionTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get giftCardUuid => $composableBuilder(
      column: $table.giftCardUuid, builder: (column) => column);

  GeneratedColumn<String> get transactionType => $composableBuilder(
      column: $table.transactionType, builder: (column) => column);

  GeneratedColumn<double> get amount =>
      $composableBuilder(column: $table.amount, builder: (column) => column);

  GeneratedColumn<double> get balanceAfter => $composableBuilder(
      column: $table.balanceAfter, builder: (column) => column);

  GeneratedColumn<String> get orderUuid =>
      $composableBuilder(column: $table.orderUuid, builder: (column) => column);

  GeneratedColumn<String> get orderNumber => $composableBuilder(
      column: $table.orderNumber, builder: (column) => column);

  GeneratedColumn<String> get performedByUuid => $composableBuilder(
      column: $table.performedByUuid, builder: (column) => column);

  GeneratedColumn<String> get performedByName => $composableBuilder(
      column: $table.performedByName, builder: (column) => column);

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<DateTime> get timestamp =>
      $composableBuilder(column: $table.timestamp, builder: (column) => column);
}

class $$GiftCardTransactionTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $GiftCardTransactionTableTable,
    GiftCardTransactionTableData,
    $$GiftCardTransactionTableTableFilterComposer,
    $$GiftCardTransactionTableTableOrderingComposer,
    $$GiftCardTransactionTableTableAnnotationComposer,
    $$GiftCardTransactionTableTableCreateCompanionBuilder,
    $$GiftCardTransactionTableTableUpdateCompanionBuilder,
    (
      GiftCardTransactionTableData,
      BaseReferences<_$AppDatabase, $GiftCardTransactionTableTable,
          GiftCardTransactionTableData>
    ),
    GiftCardTransactionTableData,
    PrefetchHooks Function()> {
  $$GiftCardTransactionTableTableTableManager(
      _$AppDatabase db, $GiftCardTransactionTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$GiftCardTransactionTableTableFilterComposer(
                  $db: db, $table: table),
          createOrderingComposer: () =>
              $$GiftCardTransactionTableTableOrderingComposer(
                  $db: db, $table: table),
          createComputedFieldComposer: () =>
              $$GiftCardTransactionTableTableAnnotationComposer(
                  $db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String> giftCardUuid = const Value.absent(),
            Value<String> transactionType = const Value.absent(),
            Value<double> amount = const Value.absent(),
            Value<double> balanceAfter = const Value.absent(),
            Value<String?> orderUuid = const Value.absent(),
            Value<String?> orderNumber = const Value.absent(),
            Value<String> performedByUuid = const Value.absent(),
            Value<String> performedByName = const Value.absent(),
            Value<String?> notes = const Value.absent(),
            Value<DateTime> timestamp = const Value.absent(),
          }) =>
              GiftCardTransactionTableCompanion(
            id: id,
            uuid: uuid,
            giftCardUuid: giftCardUuid,
            transactionType: transactionType,
            amount: amount,
            balanceAfter: balanceAfter,
            orderUuid: orderUuid,
            orderNumber: orderNumber,
            performedByUuid: performedByUuid,
            performedByName: performedByName,
            notes: notes,
            timestamp: timestamp,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            required String giftCardUuid,
            required String transactionType,
            required double amount,
            required double balanceAfter,
            Value<String?> orderUuid = const Value.absent(),
            Value<String?> orderNumber = const Value.absent(),
            required String performedByUuid,
            required String performedByName,
            Value<String?> notes = const Value.absent(),
            required DateTime timestamp,
          }) =>
              GiftCardTransactionTableCompanion.insert(
            id: id,
            uuid: uuid,
            giftCardUuid: giftCardUuid,
            transactionType: transactionType,
            amount: amount,
            balanceAfter: balanceAfter,
            orderUuid: orderUuid,
            orderNumber: orderNumber,
            performedByUuid: performedByUuid,
            performedByName: performedByName,
            notes: notes,
            timestamp: timestamp,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$GiftCardTransactionTableTableProcessedTableManager
    = ProcessedTableManager<
        _$AppDatabase,
        $GiftCardTransactionTableTable,
        GiftCardTransactionTableData,
        $$GiftCardTransactionTableTableFilterComposer,
        $$GiftCardTransactionTableTableOrderingComposer,
        $$GiftCardTransactionTableTableAnnotationComposer,
        $$GiftCardTransactionTableTableCreateCompanionBuilder,
        $$GiftCardTransactionTableTableUpdateCompanionBuilder,
        (
          GiftCardTransactionTableData,
          BaseReferences<_$AppDatabase, $GiftCardTransactionTableTable,
              GiftCardTransactionTableData>
        ),
        GiftCardTransactionTableData,
        PrefetchHooks Function()>;
typedef $$LoyaltyProgramTableTableCreateCompanionBuilder
    = LoyaltyProgramTableCompanion Function({
  Value<int> id,
  required String uuid,
  Value<String> name,
  Value<double> pointsPerCurrency,
  Value<double> exchangeRate,
  Value<String?> tiersJson,
  Value<DateTime> updatedAt,
});
typedef $$LoyaltyProgramTableTableUpdateCompanionBuilder
    = LoyaltyProgramTableCompanion Function({
  Value<int> id,
  Value<String> uuid,
  Value<String> name,
  Value<double> pointsPerCurrency,
  Value<double> exchangeRate,
  Value<String?> tiersJson,
  Value<DateTime> updatedAt,
});

class $$LoyaltyProgramTableTableFilterComposer
    extends Composer<_$AppDatabase, $LoyaltyProgramTableTable> {
  $$LoyaltyProgramTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get pointsPerCurrency => $composableBuilder(
      column: $table.pointsPerCurrency,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get exchangeRate => $composableBuilder(
      column: $table.exchangeRate, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get tiersJson => $composableBuilder(
      column: $table.tiersJson, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));
}

class $$LoyaltyProgramTableTableOrderingComposer
    extends Composer<_$AppDatabase, $LoyaltyProgramTableTable> {
  $$LoyaltyProgramTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get pointsPerCurrency => $composableBuilder(
      column: $table.pointsPerCurrency,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get exchangeRate => $composableBuilder(
      column: $table.exchangeRate,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get tiersJson => $composableBuilder(
      column: $table.tiersJson, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));
}

class $$LoyaltyProgramTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $LoyaltyProgramTableTable> {
  $$LoyaltyProgramTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<double> get pointsPerCurrency => $composableBuilder(
      column: $table.pointsPerCurrency, builder: (column) => column);

  GeneratedColumn<double> get exchangeRate => $composableBuilder(
      column: $table.exchangeRate, builder: (column) => column);

  GeneratedColumn<String> get tiersJson =>
      $composableBuilder(column: $table.tiersJson, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$LoyaltyProgramTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $LoyaltyProgramTableTable,
    LoyaltyProgramData,
    $$LoyaltyProgramTableTableFilterComposer,
    $$LoyaltyProgramTableTableOrderingComposer,
    $$LoyaltyProgramTableTableAnnotationComposer,
    $$LoyaltyProgramTableTableCreateCompanionBuilder,
    $$LoyaltyProgramTableTableUpdateCompanionBuilder,
    (
      LoyaltyProgramData,
      BaseReferences<_$AppDatabase, $LoyaltyProgramTableTable,
          LoyaltyProgramData>
    ),
    LoyaltyProgramData,
    PrefetchHooks Function()> {
  $$LoyaltyProgramTableTableTableManager(
      _$AppDatabase db, $LoyaltyProgramTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$LoyaltyProgramTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$LoyaltyProgramTableTableOrderingComposer(
                  $db: db, $table: table),
          createComputedFieldComposer: () =>
              $$LoyaltyProgramTableTableAnnotationComposer(
                  $db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String> name = const Value.absent(),
            Value<double> pointsPerCurrency = const Value.absent(),
            Value<double> exchangeRate = const Value.absent(),
            Value<String?> tiersJson = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
          }) =>
              LoyaltyProgramTableCompanion(
            id: id,
            uuid: uuid,
            name: name,
            pointsPerCurrency: pointsPerCurrency,
            exchangeRate: exchangeRate,
            tiersJson: tiersJson,
            updatedAt: updatedAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            Value<String> name = const Value.absent(),
            Value<double> pointsPerCurrency = const Value.absent(),
            Value<double> exchangeRate = const Value.absent(),
            Value<String?> tiersJson = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
          }) =>
              LoyaltyProgramTableCompanion.insert(
            id: id,
            uuid: uuid,
            name: name,
            pointsPerCurrency: pointsPerCurrency,
            exchangeRate: exchangeRate,
            tiersJson: tiersJson,
            updatedAt: updatedAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$LoyaltyProgramTableTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $LoyaltyProgramTableTable,
    LoyaltyProgramData,
    $$LoyaltyProgramTableTableFilterComposer,
    $$LoyaltyProgramTableTableOrderingComposer,
    $$LoyaltyProgramTableTableAnnotationComposer,
    $$LoyaltyProgramTableTableCreateCompanionBuilder,
    $$LoyaltyProgramTableTableUpdateCompanionBuilder,
    (
      LoyaltyProgramData,
      BaseReferences<_$AppDatabase, $LoyaltyProgramTableTable,
          LoyaltyProgramData>
    ),
    LoyaltyProgramData,
    PrefetchHooks Function()>;
typedef $$LoyaltyMemberTableTableCreateCompanionBuilder
    = LoyaltyMemberTableCompanion Function({
  Value<int> id,
  required String uuid,
  required String customerUuid,
  Value<double> pointsBalance,
  Value<double> lifetimePoints,
  Value<String> currentTier,
  Value<DateTime> joinedAt,
  Value<DateTime?> lastTransactionAt,
});
typedef $$LoyaltyMemberTableTableUpdateCompanionBuilder
    = LoyaltyMemberTableCompanion Function({
  Value<int> id,
  Value<String> uuid,
  Value<String> customerUuid,
  Value<double> pointsBalance,
  Value<double> lifetimePoints,
  Value<String> currentTier,
  Value<DateTime> joinedAt,
  Value<DateTime?> lastTransactionAt,
});

class $$LoyaltyMemberTableTableFilterComposer
    extends Composer<_$AppDatabase, $LoyaltyMemberTableTable> {
  $$LoyaltyMemberTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get customerUuid => $composableBuilder(
      column: $table.customerUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get pointsBalance => $composableBuilder(
      column: $table.pointsBalance, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get lifetimePoints => $composableBuilder(
      column: $table.lifetimePoints,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get currentTier => $composableBuilder(
      column: $table.currentTier, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get joinedAt => $composableBuilder(
      column: $table.joinedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get lastTransactionAt => $composableBuilder(
      column: $table.lastTransactionAt,
      builder: (column) => ColumnFilters(column));
}

class $$LoyaltyMemberTableTableOrderingComposer
    extends Composer<_$AppDatabase, $LoyaltyMemberTableTable> {
  $$LoyaltyMemberTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get customerUuid => $composableBuilder(
      column: $table.customerUuid,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get pointsBalance => $composableBuilder(
      column: $table.pointsBalance,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get lifetimePoints => $composableBuilder(
      column: $table.lifetimePoints,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get currentTier => $composableBuilder(
      column: $table.currentTier, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get joinedAt => $composableBuilder(
      column: $table.joinedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get lastTransactionAt => $composableBuilder(
      column: $table.lastTransactionAt,
      builder: (column) => ColumnOrderings(column));
}

class $$LoyaltyMemberTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $LoyaltyMemberTableTable> {
  $$LoyaltyMemberTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get customerUuid => $composableBuilder(
      column: $table.customerUuid, builder: (column) => column);

  GeneratedColumn<double> get pointsBalance => $composableBuilder(
      column: $table.pointsBalance, builder: (column) => column);

  GeneratedColumn<double> get lifetimePoints => $composableBuilder(
      column: $table.lifetimePoints, builder: (column) => column);

  GeneratedColumn<String> get currentTier => $composableBuilder(
      column: $table.currentTier, builder: (column) => column);

  GeneratedColumn<DateTime> get joinedAt =>
      $composableBuilder(column: $table.joinedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get lastTransactionAt => $composableBuilder(
      column: $table.lastTransactionAt, builder: (column) => column);
}

class $$LoyaltyMemberTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $LoyaltyMemberTableTable,
    LoyaltyMemberData,
    $$LoyaltyMemberTableTableFilterComposer,
    $$LoyaltyMemberTableTableOrderingComposer,
    $$LoyaltyMemberTableTableAnnotationComposer,
    $$LoyaltyMemberTableTableCreateCompanionBuilder,
    $$LoyaltyMemberTableTableUpdateCompanionBuilder,
    (
      LoyaltyMemberData,
      BaseReferences<_$AppDatabase, $LoyaltyMemberTableTable, LoyaltyMemberData>
    ),
    LoyaltyMemberData,
    PrefetchHooks Function()> {
  $$LoyaltyMemberTableTableTableManager(
      _$AppDatabase db, $LoyaltyMemberTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$LoyaltyMemberTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$LoyaltyMemberTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$LoyaltyMemberTableTableAnnotationComposer(
                  $db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String> customerUuid = const Value.absent(),
            Value<double> pointsBalance = const Value.absent(),
            Value<double> lifetimePoints = const Value.absent(),
            Value<String> currentTier = const Value.absent(),
            Value<DateTime> joinedAt = const Value.absent(),
            Value<DateTime?> lastTransactionAt = const Value.absent(),
          }) =>
              LoyaltyMemberTableCompanion(
            id: id,
            uuid: uuid,
            customerUuid: customerUuid,
            pointsBalance: pointsBalance,
            lifetimePoints: lifetimePoints,
            currentTier: currentTier,
            joinedAt: joinedAt,
            lastTransactionAt: lastTransactionAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            required String customerUuid,
            Value<double> pointsBalance = const Value.absent(),
            Value<double> lifetimePoints = const Value.absent(),
            Value<String> currentTier = const Value.absent(),
            Value<DateTime> joinedAt = const Value.absent(),
            Value<DateTime?> lastTransactionAt = const Value.absent(),
          }) =>
              LoyaltyMemberTableCompanion.insert(
            id: id,
            uuid: uuid,
            customerUuid: customerUuid,
            pointsBalance: pointsBalance,
            lifetimePoints: lifetimePoints,
            currentTier: currentTier,
            joinedAt: joinedAt,
            lastTransactionAt: lastTransactionAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$LoyaltyMemberTableTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $LoyaltyMemberTableTable,
    LoyaltyMemberData,
    $$LoyaltyMemberTableTableFilterComposer,
    $$LoyaltyMemberTableTableOrderingComposer,
    $$LoyaltyMemberTableTableAnnotationComposer,
    $$LoyaltyMemberTableTableCreateCompanionBuilder,
    $$LoyaltyMemberTableTableUpdateCompanionBuilder,
    (
      LoyaltyMemberData,
      BaseReferences<_$AppDatabase, $LoyaltyMemberTableTable, LoyaltyMemberData>
    ),
    LoyaltyMemberData,
    PrefetchHooks Function()>;
typedef $$LoyaltyTransactionTableTableCreateCompanionBuilder
    = LoyaltyTransactionTableCompanion Function({
  Value<int> id,
  required String uuid,
  required String memberUuid,
  required String type,
  required double pointsDelta,
  Value<String?> orderUuid,
  Value<String?> rewardUuid,
  Value<String?> reason,
  Value<DateTime> createdAt,
});
typedef $$LoyaltyTransactionTableTableUpdateCompanionBuilder
    = LoyaltyTransactionTableCompanion Function({
  Value<int> id,
  Value<String> uuid,
  Value<String> memberUuid,
  Value<String> type,
  Value<double> pointsDelta,
  Value<String?> orderUuid,
  Value<String?> rewardUuid,
  Value<String?> reason,
  Value<DateTime> createdAt,
});

class $$LoyaltyTransactionTableTableFilterComposer
    extends Composer<_$AppDatabase, $LoyaltyTransactionTableTable> {
  $$LoyaltyTransactionTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get memberUuid => $composableBuilder(
      column: $table.memberUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get type => $composableBuilder(
      column: $table.type, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get pointsDelta => $composableBuilder(
      column: $table.pointsDelta, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get orderUuid => $composableBuilder(
      column: $table.orderUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get rewardUuid => $composableBuilder(
      column: $table.rewardUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get reason => $composableBuilder(
      column: $table.reason, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));
}

class $$LoyaltyTransactionTableTableOrderingComposer
    extends Composer<_$AppDatabase, $LoyaltyTransactionTableTable> {
  $$LoyaltyTransactionTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get memberUuid => $composableBuilder(
      column: $table.memberUuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get type => $composableBuilder(
      column: $table.type, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get pointsDelta => $composableBuilder(
      column: $table.pointsDelta, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get orderUuid => $composableBuilder(
      column: $table.orderUuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get rewardUuid => $composableBuilder(
      column: $table.rewardUuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get reason => $composableBuilder(
      column: $table.reason, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));
}

class $$LoyaltyTransactionTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $LoyaltyTransactionTableTable> {
  $$LoyaltyTransactionTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get memberUuid => $composableBuilder(
      column: $table.memberUuid, builder: (column) => column);

  GeneratedColumn<String> get type =>
      $composableBuilder(column: $table.type, builder: (column) => column);

  GeneratedColumn<double> get pointsDelta => $composableBuilder(
      column: $table.pointsDelta, builder: (column) => column);

  GeneratedColumn<String> get orderUuid =>
      $composableBuilder(column: $table.orderUuid, builder: (column) => column);

  GeneratedColumn<String> get rewardUuid => $composableBuilder(
      column: $table.rewardUuid, builder: (column) => column);

  GeneratedColumn<String> get reason =>
      $composableBuilder(column: $table.reason, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);
}

class $$LoyaltyTransactionTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $LoyaltyTransactionTableTable,
    LoyaltyTransactionData,
    $$LoyaltyTransactionTableTableFilterComposer,
    $$LoyaltyTransactionTableTableOrderingComposer,
    $$LoyaltyTransactionTableTableAnnotationComposer,
    $$LoyaltyTransactionTableTableCreateCompanionBuilder,
    $$LoyaltyTransactionTableTableUpdateCompanionBuilder,
    (
      LoyaltyTransactionData,
      BaseReferences<_$AppDatabase, $LoyaltyTransactionTableTable,
          LoyaltyTransactionData>
    ),
    LoyaltyTransactionData,
    PrefetchHooks Function()> {
  $$LoyaltyTransactionTableTableTableManager(
      _$AppDatabase db, $LoyaltyTransactionTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$LoyaltyTransactionTableTableFilterComposer(
                  $db: db, $table: table),
          createOrderingComposer: () =>
              $$LoyaltyTransactionTableTableOrderingComposer(
                  $db: db, $table: table),
          createComputedFieldComposer: () =>
              $$LoyaltyTransactionTableTableAnnotationComposer(
                  $db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String> memberUuid = const Value.absent(),
            Value<String> type = const Value.absent(),
            Value<double> pointsDelta = const Value.absent(),
            Value<String?> orderUuid = const Value.absent(),
            Value<String?> rewardUuid = const Value.absent(),
            Value<String?> reason = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
          }) =>
              LoyaltyTransactionTableCompanion(
            id: id,
            uuid: uuid,
            memberUuid: memberUuid,
            type: type,
            pointsDelta: pointsDelta,
            orderUuid: orderUuid,
            rewardUuid: rewardUuid,
            reason: reason,
            createdAt: createdAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            required String memberUuid,
            required String type,
            required double pointsDelta,
            Value<String?> orderUuid = const Value.absent(),
            Value<String?> rewardUuid = const Value.absent(),
            Value<String?> reason = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
          }) =>
              LoyaltyTransactionTableCompanion.insert(
            id: id,
            uuid: uuid,
            memberUuid: memberUuid,
            type: type,
            pointsDelta: pointsDelta,
            orderUuid: orderUuid,
            rewardUuid: rewardUuid,
            reason: reason,
            createdAt: createdAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$LoyaltyTransactionTableTableProcessedTableManager
    = ProcessedTableManager<
        _$AppDatabase,
        $LoyaltyTransactionTableTable,
        LoyaltyTransactionData,
        $$LoyaltyTransactionTableTableFilterComposer,
        $$LoyaltyTransactionTableTableOrderingComposer,
        $$LoyaltyTransactionTableTableAnnotationComposer,
        $$LoyaltyTransactionTableTableCreateCompanionBuilder,
        $$LoyaltyTransactionTableTableUpdateCompanionBuilder,
        (
          LoyaltyTransactionData,
          BaseReferences<_$AppDatabase, $LoyaltyTransactionTableTable,
              LoyaltyTransactionData>
        ),
        LoyaltyTransactionData,
        PrefetchHooks Function()>;
typedef $$LoyaltyRewardTableTableCreateCompanionBuilder
    = LoyaltyRewardTableCompanion Function({
  Value<int> id,
  required String uuid,
  required String name,
  Value<String?> description,
  required double pointsCost,
  required String discountType,
  required double discountValue,
  Value<String?> applicableProductUuid,
  Value<bool> isActive,
});
typedef $$LoyaltyRewardTableTableUpdateCompanionBuilder
    = LoyaltyRewardTableCompanion Function({
  Value<int> id,
  Value<String> uuid,
  Value<String> name,
  Value<String?> description,
  Value<double> pointsCost,
  Value<String> discountType,
  Value<double> discountValue,
  Value<String?> applicableProductUuid,
  Value<bool> isActive,
});

class $$LoyaltyRewardTableTableFilterComposer
    extends Composer<_$AppDatabase, $LoyaltyRewardTableTable> {
  $$LoyaltyRewardTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get description => $composableBuilder(
      column: $table.description, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get pointsCost => $composableBuilder(
      column: $table.pointsCost, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get discountType => $composableBuilder(
      column: $table.discountType, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get discountValue => $composableBuilder(
      column: $table.discountValue, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get applicableProductUuid => $composableBuilder(
      column: $table.applicableProductUuid,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isActive => $composableBuilder(
      column: $table.isActive, builder: (column) => ColumnFilters(column));
}

class $$LoyaltyRewardTableTableOrderingComposer
    extends Composer<_$AppDatabase, $LoyaltyRewardTableTable> {
  $$LoyaltyRewardTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get description => $composableBuilder(
      column: $table.description, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get pointsCost => $composableBuilder(
      column: $table.pointsCost, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get discountType => $composableBuilder(
      column: $table.discountType,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get discountValue => $composableBuilder(
      column: $table.discountValue,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get applicableProductUuid => $composableBuilder(
      column: $table.applicableProductUuid,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isActive => $composableBuilder(
      column: $table.isActive, builder: (column) => ColumnOrderings(column));
}

class $$LoyaltyRewardTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $LoyaltyRewardTableTable> {
  $$LoyaltyRewardTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get description => $composableBuilder(
      column: $table.description, builder: (column) => column);

  GeneratedColumn<double> get pointsCost => $composableBuilder(
      column: $table.pointsCost, builder: (column) => column);

  GeneratedColumn<String> get discountType => $composableBuilder(
      column: $table.discountType, builder: (column) => column);

  GeneratedColumn<double> get discountValue => $composableBuilder(
      column: $table.discountValue, builder: (column) => column);

  GeneratedColumn<String> get applicableProductUuid => $composableBuilder(
      column: $table.applicableProductUuid, builder: (column) => column);

  GeneratedColumn<bool> get isActive =>
      $composableBuilder(column: $table.isActive, builder: (column) => column);
}

class $$LoyaltyRewardTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $LoyaltyRewardTableTable,
    LoyaltyRewardData,
    $$LoyaltyRewardTableTableFilterComposer,
    $$LoyaltyRewardTableTableOrderingComposer,
    $$LoyaltyRewardTableTableAnnotationComposer,
    $$LoyaltyRewardTableTableCreateCompanionBuilder,
    $$LoyaltyRewardTableTableUpdateCompanionBuilder,
    (
      LoyaltyRewardData,
      BaseReferences<_$AppDatabase, $LoyaltyRewardTableTable, LoyaltyRewardData>
    ),
    LoyaltyRewardData,
    PrefetchHooks Function()> {
  $$LoyaltyRewardTableTableTableManager(
      _$AppDatabase db, $LoyaltyRewardTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$LoyaltyRewardTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$LoyaltyRewardTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$LoyaltyRewardTableTableAnnotationComposer(
                  $db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String> name = const Value.absent(),
            Value<String?> description = const Value.absent(),
            Value<double> pointsCost = const Value.absent(),
            Value<String> discountType = const Value.absent(),
            Value<double> discountValue = const Value.absent(),
            Value<String?> applicableProductUuid = const Value.absent(),
            Value<bool> isActive = const Value.absent(),
          }) =>
              LoyaltyRewardTableCompanion(
            id: id,
            uuid: uuid,
            name: name,
            description: description,
            pointsCost: pointsCost,
            discountType: discountType,
            discountValue: discountValue,
            applicableProductUuid: applicableProductUuid,
            isActive: isActive,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            required String name,
            Value<String?> description = const Value.absent(),
            required double pointsCost,
            required String discountType,
            required double discountValue,
            Value<String?> applicableProductUuid = const Value.absent(),
            Value<bool> isActive = const Value.absent(),
          }) =>
              LoyaltyRewardTableCompanion.insert(
            id: id,
            uuid: uuid,
            name: name,
            description: description,
            pointsCost: pointsCost,
            discountType: discountType,
            discountValue: discountValue,
            applicableProductUuid: applicableProductUuid,
            isActive: isActive,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$LoyaltyRewardTableTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $LoyaltyRewardTableTable,
    LoyaltyRewardData,
    $$LoyaltyRewardTableTableFilterComposer,
    $$LoyaltyRewardTableTableOrderingComposer,
    $$LoyaltyRewardTableTableAnnotationComposer,
    $$LoyaltyRewardTableTableCreateCompanionBuilder,
    $$LoyaltyRewardTableTableUpdateCompanionBuilder,
    (
      LoyaltyRewardData,
      BaseReferences<_$AppDatabase, $LoyaltyRewardTableTable, LoyaltyRewardData>
    ),
    LoyaltyRewardData,
    PrefetchHooks Function()>;
typedef $$TipTableTableCreateCompanionBuilder = TipTableCompanion Function({
  Value<int> id,
  required String uuid,
  required String orderUuid,
  required String orderNumber,
  required String tipType,
  required double amount,
  required String processedByUuid,
  required String processedByName,
  Value<bool> isPooled,
  Value<String?> poolUuid,
  Value<String?> notes,
  required DateTime createdAt,
});
typedef $$TipTableTableUpdateCompanionBuilder = TipTableCompanion Function({
  Value<int> id,
  Value<String> uuid,
  Value<String> orderUuid,
  Value<String> orderNumber,
  Value<String> tipType,
  Value<double> amount,
  Value<String> processedByUuid,
  Value<String> processedByName,
  Value<bool> isPooled,
  Value<String?> poolUuid,
  Value<String?> notes,
  Value<DateTime> createdAt,
});

class $$TipTableTableFilterComposer
    extends Composer<_$AppDatabase, $TipTableTable> {
  $$TipTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get orderUuid => $composableBuilder(
      column: $table.orderUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get orderNumber => $composableBuilder(
      column: $table.orderNumber, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get tipType => $composableBuilder(
      column: $table.tipType, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get amount => $composableBuilder(
      column: $table.amount, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get processedByUuid => $composableBuilder(
      column: $table.processedByUuid,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get processedByName => $composableBuilder(
      column: $table.processedByName,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isPooled => $composableBuilder(
      column: $table.isPooled, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get poolUuid => $composableBuilder(
      column: $table.poolUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get notes => $composableBuilder(
      column: $table.notes, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));
}

class $$TipTableTableOrderingComposer
    extends Composer<_$AppDatabase, $TipTableTable> {
  $$TipTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get orderUuid => $composableBuilder(
      column: $table.orderUuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get orderNumber => $composableBuilder(
      column: $table.orderNumber, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get tipType => $composableBuilder(
      column: $table.tipType, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get amount => $composableBuilder(
      column: $table.amount, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get processedByUuid => $composableBuilder(
      column: $table.processedByUuid,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get processedByName => $composableBuilder(
      column: $table.processedByName,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isPooled => $composableBuilder(
      column: $table.isPooled, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get poolUuid => $composableBuilder(
      column: $table.poolUuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get notes => $composableBuilder(
      column: $table.notes, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));
}

class $$TipTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $TipTableTable> {
  $$TipTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get orderUuid =>
      $composableBuilder(column: $table.orderUuid, builder: (column) => column);

  GeneratedColumn<String> get orderNumber => $composableBuilder(
      column: $table.orderNumber, builder: (column) => column);

  GeneratedColumn<String> get tipType =>
      $composableBuilder(column: $table.tipType, builder: (column) => column);

  GeneratedColumn<double> get amount =>
      $composableBuilder(column: $table.amount, builder: (column) => column);

  GeneratedColumn<String> get processedByUuid => $composableBuilder(
      column: $table.processedByUuid, builder: (column) => column);

  GeneratedColumn<String> get processedByName => $composableBuilder(
      column: $table.processedByName, builder: (column) => column);

  GeneratedColumn<bool> get isPooled =>
      $composableBuilder(column: $table.isPooled, builder: (column) => column);

  GeneratedColumn<String> get poolUuid =>
      $composableBuilder(column: $table.poolUuid, builder: (column) => column);

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);
}

class $$TipTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $TipTableTable,
    TipTableData,
    $$TipTableTableFilterComposer,
    $$TipTableTableOrderingComposer,
    $$TipTableTableAnnotationComposer,
    $$TipTableTableCreateCompanionBuilder,
    $$TipTableTableUpdateCompanionBuilder,
    (TipTableData, BaseReferences<_$AppDatabase, $TipTableTable, TipTableData>),
    TipTableData,
    PrefetchHooks Function()> {
  $$TipTableTableTableManager(_$AppDatabase db, $TipTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$TipTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$TipTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$TipTableTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String> orderUuid = const Value.absent(),
            Value<String> orderNumber = const Value.absent(),
            Value<String> tipType = const Value.absent(),
            Value<double> amount = const Value.absent(),
            Value<String> processedByUuid = const Value.absent(),
            Value<String> processedByName = const Value.absent(),
            Value<bool> isPooled = const Value.absent(),
            Value<String?> poolUuid = const Value.absent(),
            Value<String?> notes = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
          }) =>
              TipTableCompanion(
            id: id,
            uuid: uuid,
            orderUuid: orderUuid,
            orderNumber: orderNumber,
            tipType: tipType,
            amount: amount,
            processedByUuid: processedByUuid,
            processedByName: processedByName,
            isPooled: isPooled,
            poolUuid: poolUuid,
            notes: notes,
            createdAt: createdAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            required String orderUuid,
            required String orderNumber,
            required String tipType,
            required double amount,
            required String processedByUuid,
            required String processedByName,
            Value<bool> isPooled = const Value.absent(),
            Value<String?> poolUuid = const Value.absent(),
            Value<String?> notes = const Value.absent(),
            required DateTime createdAt,
          }) =>
              TipTableCompanion.insert(
            id: id,
            uuid: uuid,
            orderUuid: orderUuid,
            orderNumber: orderNumber,
            tipType: tipType,
            amount: amount,
            processedByUuid: processedByUuid,
            processedByName: processedByName,
            isPooled: isPooled,
            poolUuid: poolUuid,
            notes: notes,
            createdAt: createdAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$TipTableTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $TipTableTable,
    TipTableData,
    $$TipTableTableFilterComposer,
    $$TipTableTableOrderingComposer,
    $$TipTableTableAnnotationComposer,
    $$TipTableTableCreateCompanionBuilder,
    $$TipTableTableUpdateCompanionBuilder,
    (TipTableData, BaseReferences<_$AppDatabase, $TipTableTable, TipTableData>),
    TipTableData,
    PrefetchHooks Function()>;
typedef $$TipPoolConfigTableTableCreateCompanionBuilder
    = TipPoolConfigTableCompanion Function({
  Value<int> id,
  required String uuid,
  required String name,
  Value<String> method,
  Value<bool> isActive,
  Value<String> rolePercentagesJson,
  Value<String> rolePointsJson,
  Value<String> excludedRolesJson,
  required DateTime createdAt,
  required DateTime updatedAt,
});
typedef $$TipPoolConfigTableTableUpdateCompanionBuilder
    = TipPoolConfigTableCompanion Function({
  Value<int> id,
  Value<String> uuid,
  Value<String> name,
  Value<String> method,
  Value<bool> isActive,
  Value<String> rolePercentagesJson,
  Value<String> rolePointsJson,
  Value<String> excludedRolesJson,
  Value<DateTime> createdAt,
  Value<DateTime> updatedAt,
});

class $$TipPoolConfigTableTableFilterComposer
    extends Composer<_$AppDatabase, $TipPoolConfigTableTable> {
  $$TipPoolConfigTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get method => $composableBuilder(
      column: $table.method, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isActive => $composableBuilder(
      column: $table.isActive, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get rolePercentagesJson => $composableBuilder(
      column: $table.rolePercentagesJson,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get rolePointsJson => $composableBuilder(
      column: $table.rolePointsJson,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get excludedRolesJson => $composableBuilder(
      column: $table.excludedRolesJson,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));
}

class $$TipPoolConfigTableTableOrderingComposer
    extends Composer<_$AppDatabase, $TipPoolConfigTableTable> {
  $$TipPoolConfigTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get method => $composableBuilder(
      column: $table.method, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isActive => $composableBuilder(
      column: $table.isActive, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get rolePercentagesJson => $composableBuilder(
      column: $table.rolePercentagesJson,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get rolePointsJson => $composableBuilder(
      column: $table.rolePointsJson,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get excludedRolesJson => $composableBuilder(
      column: $table.excludedRolesJson,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));
}

class $$TipPoolConfigTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $TipPoolConfigTableTable> {
  $$TipPoolConfigTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get method =>
      $composableBuilder(column: $table.method, builder: (column) => column);

  GeneratedColumn<bool> get isActive =>
      $composableBuilder(column: $table.isActive, builder: (column) => column);

  GeneratedColumn<String> get rolePercentagesJson => $composableBuilder(
      column: $table.rolePercentagesJson, builder: (column) => column);

  GeneratedColumn<String> get rolePointsJson => $composableBuilder(
      column: $table.rolePointsJson, builder: (column) => column);

  GeneratedColumn<String> get excludedRolesJson => $composableBuilder(
      column: $table.excludedRolesJson, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$TipPoolConfigTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $TipPoolConfigTableTable,
    TipPoolConfigTableData,
    $$TipPoolConfigTableTableFilterComposer,
    $$TipPoolConfigTableTableOrderingComposer,
    $$TipPoolConfigTableTableAnnotationComposer,
    $$TipPoolConfigTableTableCreateCompanionBuilder,
    $$TipPoolConfigTableTableUpdateCompanionBuilder,
    (
      TipPoolConfigTableData,
      BaseReferences<_$AppDatabase, $TipPoolConfigTableTable,
          TipPoolConfigTableData>
    ),
    TipPoolConfigTableData,
    PrefetchHooks Function()> {
  $$TipPoolConfigTableTableTableManager(
      _$AppDatabase db, $TipPoolConfigTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$TipPoolConfigTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$TipPoolConfigTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$TipPoolConfigTableTableAnnotationComposer(
                  $db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String> name = const Value.absent(),
            Value<String> method = const Value.absent(),
            Value<bool> isActive = const Value.absent(),
            Value<String> rolePercentagesJson = const Value.absent(),
            Value<String> rolePointsJson = const Value.absent(),
            Value<String> excludedRolesJson = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
          }) =>
              TipPoolConfigTableCompanion(
            id: id,
            uuid: uuid,
            name: name,
            method: method,
            isActive: isActive,
            rolePercentagesJson: rolePercentagesJson,
            rolePointsJson: rolePointsJson,
            excludedRolesJson: excludedRolesJson,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            required String name,
            Value<String> method = const Value.absent(),
            Value<bool> isActive = const Value.absent(),
            Value<String> rolePercentagesJson = const Value.absent(),
            Value<String> rolePointsJson = const Value.absent(),
            Value<String> excludedRolesJson = const Value.absent(),
            required DateTime createdAt,
            required DateTime updatedAt,
          }) =>
              TipPoolConfigTableCompanion.insert(
            id: id,
            uuid: uuid,
            name: name,
            method: method,
            isActive: isActive,
            rolePercentagesJson: rolePercentagesJson,
            rolePointsJson: rolePointsJson,
            excludedRolesJson: excludedRolesJson,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$TipPoolConfigTableTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $TipPoolConfigTableTable,
    TipPoolConfigTableData,
    $$TipPoolConfigTableTableFilterComposer,
    $$TipPoolConfigTableTableOrderingComposer,
    $$TipPoolConfigTableTableAnnotationComposer,
    $$TipPoolConfigTableTableCreateCompanionBuilder,
    $$TipPoolConfigTableTableUpdateCompanionBuilder,
    (
      TipPoolConfigTableData,
      BaseReferences<_$AppDatabase, $TipPoolConfigTableTable,
          TipPoolConfigTableData>
    ),
    TipPoolConfigTableData,
    PrefetchHooks Function()>;
typedef $$TipDistributionTableTableCreateCompanionBuilder
    = TipDistributionTableCompanion Function({
  Value<int> id,
  required String uuid,
  required String tipUuid,
  required String employeeUuid,
  required String employeeName,
  required String employeeRole,
  required double amount,
  required double percentage,
  Value<double?> hoursWorked,
  Value<double?> pointsEarned,
  Value<bool> isPaidOut,
  Value<DateTime?> paidOutAt,
  Value<String?> paidOutByUuid,
  required DateTime distributedAt,
});
typedef $$TipDistributionTableTableUpdateCompanionBuilder
    = TipDistributionTableCompanion Function({
  Value<int> id,
  Value<String> uuid,
  Value<String> tipUuid,
  Value<String> employeeUuid,
  Value<String> employeeName,
  Value<String> employeeRole,
  Value<double> amount,
  Value<double> percentage,
  Value<double?> hoursWorked,
  Value<double?> pointsEarned,
  Value<bool> isPaidOut,
  Value<DateTime?> paidOutAt,
  Value<String?> paidOutByUuid,
  Value<DateTime> distributedAt,
});

class $$TipDistributionTableTableFilterComposer
    extends Composer<_$AppDatabase, $TipDistributionTableTable> {
  $$TipDistributionTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get tipUuid => $composableBuilder(
      column: $table.tipUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get employeeUuid => $composableBuilder(
      column: $table.employeeUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get employeeName => $composableBuilder(
      column: $table.employeeName, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get employeeRole => $composableBuilder(
      column: $table.employeeRole, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get amount => $composableBuilder(
      column: $table.amount, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get percentage => $composableBuilder(
      column: $table.percentage, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get hoursWorked => $composableBuilder(
      column: $table.hoursWorked, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get pointsEarned => $composableBuilder(
      column: $table.pointsEarned, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isPaidOut => $composableBuilder(
      column: $table.isPaidOut, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get paidOutAt => $composableBuilder(
      column: $table.paidOutAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get paidOutByUuid => $composableBuilder(
      column: $table.paidOutByUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get distributedAt => $composableBuilder(
      column: $table.distributedAt, builder: (column) => ColumnFilters(column));
}

class $$TipDistributionTableTableOrderingComposer
    extends Composer<_$AppDatabase, $TipDistributionTableTable> {
  $$TipDistributionTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get tipUuid => $composableBuilder(
      column: $table.tipUuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get employeeUuid => $composableBuilder(
      column: $table.employeeUuid,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get employeeName => $composableBuilder(
      column: $table.employeeName,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get employeeRole => $composableBuilder(
      column: $table.employeeRole,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get amount => $composableBuilder(
      column: $table.amount, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get percentage => $composableBuilder(
      column: $table.percentage, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get hoursWorked => $composableBuilder(
      column: $table.hoursWorked, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get pointsEarned => $composableBuilder(
      column: $table.pointsEarned,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isPaidOut => $composableBuilder(
      column: $table.isPaidOut, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get paidOutAt => $composableBuilder(
      column: $table.paidOutAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get paidOutByUuid => $composableBuilder(
      column: $table.paidOutByUuid,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get distributedAt => $composableBuilder(
      column: $table.distributedAt,
      builder: (column) => ColumnOrderings(column));
}

class $$TipDistributionTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $TipDistributionTableTable> {
  $$TipDistributionTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get tipUuid =>
      $composableBuilder(column: $table.tipUuid, builder: (column) => column);

  GeneratedColumn<String> get employeeUuid => $composableBuilder(
      column: $table.employeeUuid, builder: (column) => column);

  GeneratedColumn<String> get employeeName => $composableBuilder(
      column: $table.employeeName, builder: (column) => column);

  GeneratedColumn<String> get employeeRole => $composableBuilder(
      column: $table.employeeRole, builder: (column) => column);

  GeneratedColumn<double> get amount =>
      $composableBuilder(column: $table.amount, builder: (column) => column);

  GeneratedColumn<double> get percentage => $composableBuilder(
      column: $table.percentage, builder: (column) => column);

  GeneratedColumn<double> get hoursWorked => $composableBuilder(
      column: $table.hoursWorked, builder: (column) => column);

  GeneratedColumn<double> get pointsEarned => $composableBuilder(
      column: $table.pointsEarned, builder: (column) => column);

  GeneratedColumn<bool> get isPaidOut =>
      $composableBuilder(column: $table.isPaidOut, builder: (column) => column);

  GeneratedColumn<DateTime> get paidOutAt =>
      $composableBuilder(column: $table.paidOutAt, builder: (column) => column);

  GeneratedColumn<String> get paidOutByUuid => $composableBuilder(
      column: $table.paidOutByUuid, builder: (column) => column);

  GeneratedColumn<DateTime> get distributedAt => $composableBuilder(
      column: $table.distributedAt, builder: (column) => column);
}

class $$TipDistributionTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $TipDistributionTableTable,
    TipDistributionTableData,
    $$TipDistributionTableTableFilterComposer,
    $$TipDistributionTableTableOrderingComposer,
    $$TipDistributionTableTableAnnotationComposer,
    $$TipDistributionTableTableCreateCompanionBuilder,
    $$TipDistributionTableTableUpdateCompanionBuilder,
    (
      TipDistributionTableData,
      BaseReferences<_$AppDatabase, $TipDistributionTableTable,
          TipDistributionTableData>
    ),
    TipDistributionTableData,
    PrefetchHooks Function()> {
  $$TipDistributionTableTableTableManager(
      _$AppDatabase db, $TipDistributionTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$TipDistributionTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$TipDistributionTableTableOrderingComposer(
                  $db: db, $table: table),
          createComputedFieldComposer: () =>
              $$TipDistributionTableTableAnnotationComposer(
                  $db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String> tipUuid = const Value.absent(),
            Value<String> employeeUuid = const Value.absent(),
            Value<String> employeeName = const Value.absent(),
            Value<String> employeeRole = const Value.absent(),
            Value<double> amount = const Value.absent(),
            Value<double> percentage = const Value.absent(),
            Value<double?> hoursWorked = const Value.absent(),
            Value<double?> pointsEarned = const Value.absent(),
            Value<bool> isPaidOut = const Value.absent(),
            Value<DateTime?> paidOutAt = const Value.absent(),
            Value<String?> paidOutByUuid = const Value.absent(),
            Value<DateTime> distributedAt = const Value.absent(),
          }) =>
              TipDistributionTableCompanion(
            id: id,
            uuid: uuid,
            tipUuid: tipUuid,
            employeeUuid: employeeUuid,
            employeeName: employeeName,
            employeeRole: employeeRole,
            amount: amount,
            percentage: percentage,
            hoursWorked: hoursWorked,
            pointsEarned: pointsEarned,
            isPaidOut: isPaidOut,
            paidOutAt: paidOutAt,
            paidOutByUuid: paidOutByUuid,
            distributedAt: distributedAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            required String tipUuid,
            required String employeeUuid,
            required String employeeName,
            required String employeeRole,
            required double amount,
            required double percentage,
            Value<double?> hoursWorked = const Value.absent(),
            Value<double?> pointsEarned = const Value.absent(),
            Value<bool> isPaidOut = const Value.absent(),
            Value<DateTime?> paidOutAt = const Value.absent(),
            Value<String?> paidOutByUuid = const Value.absent(),
            required DateTime distributedAt,
          }) =>
              TipDistributionTableCompanion.insert(
            id: id,
            uuid: uuid,
            tipUuid: tipUuid,
            employeeUuid: employeeUuid,
            employeeName: employeeName,
            employeeRole: employeeRole,
            amount: amount,
            percentage: percentage,
            hoursWorked: hoursWorked,
            pointsEarned: pointsEarned,
            isPaidOut: isPaidOut,
            paidOutAt: paidOutAt,
            paidOutByUuid: paidOutByUuid,
            distributedAt: distributedAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$TipDistributionTableTableProcessedTableManager
    = ProcessedTableManager<
        _$AppDatabase,
        $TipDistributionTableTable,
        TipDistributionTableData,
        $$TipDistributionTableTableFilterComposer,
        $$TipDistributionTableTableOrderingComposer,
        $$TipDistributionTableTableAnnotationComposer,
        $$TipDistributionTableTableCreateCompanionBuilder,
        $$TipDistributionTableTableUpdateCompanionBuilder,
        (
          TipDistributionTableData,
          BaseReferences<_$AppDatabase, $TipDistributionTableTable,
              TipDistributionTableData>
        ),
        TipDistributionTableData,
        PrefetchHooks Function()>;
typedef $$SplitBillTableTableCreateCompanionBuilder = SplitBillTableCompanion
    Function({
  Value<int> id,
  required String uuid,
  required String orderUuid,
  required String orderNumber,
  required double originalTotal,
  required int guestCount,
  required String splitMode,
  Value<String> status,
  required String createdByUuid,
  required String createdByName,
  required DateTime createdAt,
  Value<DateTime?> completedAt,
});
typedef $$SplitBillTableTableUpdateCompanionBuilder = SplitBillTableCompanion
    Function({
  Value<int> id,
  Value<String> uuid,
  Value<String> orderUuid,
  Value<String> orderNumber,
  Value<double> originalTotal,
  Value<int> guestCount,
  Value<String> splitMode,
  Value<String> status,
  Value<String> createdByUuid,
  Value<String> createdByName,
  Value<DateTime> createdAt,
  Value<DateTime?> completedAt,
});

class $$SplitBillTableTableFilterComposer
    extends Composer<_$AppDatabase, $SplitBillTableTable> {
  $$SplitBillTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get orderUuid => $composableBuilder(
      column: $table.orderUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get orderNumber => $composableBuilder(
      column: $table.orderNumber, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get originalTotal => $composableBuilder(
      column: $table.originalTotal, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get guestCount => $composableBuilder(
      column: $table.guestCount, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get splitMode => $composableBuilder(
      column: $table.splitMode, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get createdByUuid => $composableBuilder(
      column: $table.createdByUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get createdByName => $composableBuilder(
      column: $table.createdByName, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get completedAt => $composableBuilder(
      column: $table.completedAt, builder: (column) => ColumnFilters(column));
}

class $$SplitBillTableTableOrderingComposer
    extends Composer<_$AppDatabase, $SplitBillTableTable> {
  $$SplitBillTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get orderUuid => $composableBuilder(
      column: $table.orderUuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get orderNumber => $composableBuilder(
      column: $table.orderNumber, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get originalTotal => $composableBuilder(
      column: $table.originalTotal,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get guestCount => $composableBuilder(
      column: $table.guestCount, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get splitMode => $composableBuilder(
      column: $table.splitMode, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get createdByUuid => $composableBuilder(
      column: $table.createdByUuid,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get createdByName => $composableBuilder(
      column: $table.createdByName,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get completedAt => $composableBuilder(
      column: $table.completedAt, builder: (column) => ColumnOrderings(column));
}

class $$SplitBillTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $SplitBillTableTable> {
  $$SplitBillTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get orderUuid =>
      $composableBuilder(column: $table.orderUuid, builder: (column) => column);

  GeneratedColumn<String> get orderNumber => $composableBuilder(
      column: $table.orderNumber, builder: (column) => column);

  GeneratedColumn<double> get originalTotal => $composableBuilder(
      column: $table.originalTotal, builder: (column) => column);

  GeneratedColumn<int> get guestCount => $composableBuilder(
      column: $table.guestCount, builder: (column) => column);

  GeneratedColumn<String> get splitMode =>
      $composableBuilder(column: $table.splitMode, builder: (column) => column);

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<String> get createdByUuid => $composableBuilder(
      column: $table.createdByUuid, builder: (column) => column);

  GeneratedColumn<String> get createdByName => $composableBuilder(
      column: $table.createdByName, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get completedAt => $composableBuilder(
      column: $table.completedAt, builder: (column) => column);
}

class $$SplitBillTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $SplitBillTableTable,
    SplitBillTableData,
    $$SplitBillTableTableFilterComposer,
    $$SplitBillTableTableOrderingComposer,
    $$SplitBillTableTableAnnotationComposer,
    $$SplitBillTableTableCreateCompanionBuilder,
    $$SplitBillTableTableUpdateCompanionBuilder,
    (
      SplitBillTableData,
      BaseReferences<_$AppDatabase, $SplitBillTableTable, SplitBillTableData>
    ),
    SplitBillTableData,
    PrefetchHooks Function()> {
  $$SplitBillTableTableTableManager(
      _$AppDatabase db, $SplitBillTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$SplitBillTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$SplitBillTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$SplitBillTableTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String> orderUuid = const Value.absent(),
            Value<String> orderNumber = const Value.absent(),
            Value<double> originalTotal = const Value.absent(),
            Value<int> guestCount = const Value.absent(),
            Value<String> splitMode = const Value.absent(),
            Value<String> status = const Value.absent(),
            Value<String> createdByUuid = const Value.absent(),
            Value<String> createdByName = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<DateTime?> completedAt = const Value.absent(),
          }) =>
              SplitBillTableCompanion(
            id: id,
            uuid: uuid,
            orderUuid: orderUuid,
            orderNumber: orderNumber,
            originalTotal: originalTotal,
            guestCount: guestCount,
            splitMode: splitMode,
            status: status,
            createdByUuid: createdByUuid,
            createdByName: createdByName,
            createdAt: createdAt,
            completedAt: completedAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            required String orderUuid,
            required String orderNumber,
            required double originalTotal,
            required int guestCount,
            required String splitMode,
            Value<String> status = const Value.absent(),
            required String createdByUuid,
            required String createdByName,
            required DateTime createdAt,
            Value<DateTime?> completedAt = const Value.absent(),
          }) =>
              SplitBillTableCompanion.insert(
            id: id,
            uuid: uuid,
            orderUuid: orderUuid,
            orderNumber: orderNumber,
            originalTotal: originalTotal,
            guestCount: guestCount,
            splitMode: splitMode,
            status: status,
            createdByUuid: createdByUuid,
            createdByName: createdByName,
            createdAt: createdAt,
            completedAt: completedAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$SplitBillTableTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $SplitBillTableTable,
    SplitBillTableData,
    $$SplitBillTableTableFilterComposer,
    $$SplitBillTableTableOrderingComposer,
    $$SplitBillTableTableAnnotationComposer,
    $$SplitBillTableTableCreateCompanionBuilder,
    $$SplitBillTableTableUpdateCompanionBuilder,
    (
      SplitBillTableData,
      BaseReferences<_$AppDatabase, $SplitBillTableTable, SplitBillTableData>
    ),
    SplitBillTableData,
    PrefetchHooks Function()>;
typedef $$GuestBillTableTableCreateCompanionBuilder = GuestBillTableCompanion
    Function({
  Value<int> id,
  required String uuid,
  required String splitBillUuid,
  required int guestNumber,
  Value<String?> guestName,
  required double totalAmount,
  Value<double?> tipAmount,
  Value<bool> isPaid,
  Value<String?> paymentMethod,
  Value<String?> paymentTransactionUuid,
  Value<DateTime?> paidAt,
});
typedef $$GuestBillTableTableUpdateCompanionBuilder = GuestBillTableCompanion
    Function({
  Value<int> id,
  Value<String> uuid,
  Value<String> splitBillUuid,
  Value<int> guestNumber,
  Value<String?> guestName,
  Value<double> totalAmount,
  Value<double?> tipAmount,
  Value<bool> isPaid,
  Value<String?> paymentMethod,
  Value<String?> paymentTransactionUuid,
  Value<DateTime?> paidAt,
});

class $$GuestBillTableTableFilterComposer
    extends Composer<_$AppDatabase, $GuestBillTableTable> {
  $$GuestBillTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get splitBillUuid => $composableBuilder(
      column: $table.splitBillUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get guestNumber => $composableBuilder(
      column: $table.guestNumber, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get guestName => $composableBuilder(
      column: $table.guestName, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get totalAmount => $composableBuilder(
      column: $table.totalAmount, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get tipAmount => $composableBuilder(
      column: $table.tipAmount, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isPaid => $composableBuilder(
      column: $table.isPaid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get paymentMethod => $composableBuilder(
      column: $table.paymentMethod, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get paymentTransactionUuid => $composableBuilder(
      column: $table.paymentTransactionUuid,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get paidAt => $composableBuilder(
      column: $table.paidAt, builder: (column) => ColumnFilters(column));
}

class $$GuestBillTableTableOrderingComposer
    extends Composer<_$AppDatabase, $GuestBillTableTable> {
  $$GuestBillTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get splitBillUuid => $composableBuilder(
      column: $table.splitBillUuid,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get guestNumber => $composableBuilder(
      column: $table.guestNumber, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get guestName => $composableBuilder(
      column: $table.guestName, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get totalAmount => $composableBuilder(
      column: $table.totalAmount, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get tipAmount => $composableBuilder(
      column: $table.tipAmount, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isPaid => $composableBuilder(
      column: $table.isPaid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get paymentMethod => $composableBuilder(
      column: $table.paymentMethod,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get paymentTransactionUuid => $composableBuilder(
      column: $table.paymentTransactionUuid,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get paidAt => $composableBuilder(
      column: $table.paidAt, builder: (column) => ColumnOrderings(column));
}

class $$GuestBillTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $GuestBillTableTable> {
  $$GuestBillTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get splitBillUuid => $composableBuilder(
      column: $table.splitBillUuid, builder: (column) => column);

  GeneratedColumn<int> get guestNumber => $composableBuilder(
      column: $table.guestNumber, builder: (column) => column);

  GeneratedColumn<String> get guestName =>
      $composableBuilder(column: $table.guestName, builder: (column) => column);

  GeneratedColumn<double> get totalAmount => $composableBuilder(
      column: $table.totalAmount, builder: (column) => column);

  GeneratedColumn<double> get tipAmount =>
      $composableBuilder(column: $table.tipAmount, builder: (column) => column);

  GeneratedColumn<bool> get isPaid =>
      $composableBuilder(column: $table.isPaid, builder: (column) => column);

  GeneratedColumn<String> get paymentMethod => $composableBuilder(
      column: $table.paymentMethod, builder: (column) => column);

  GeneratedColumn<String> get paymentTransactionUuid => $composableBuilder(
      column: $table.paymentTransactionUuid, builder: (column) => column);

  GeneratedColumn<DateTime> get paidAt =>
      $composableBuilder(column: $table.paidAt, builder: (column) => column);
}

class $$GuestBillTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $GuestBillTableTable,
    GuestBillTableData,
    $$GuestBillTableTableFilterComposer,
    $$GuestBillTableTableOrderingComposer,
    $$GuestBillTableTableAnnotationComposer,
    $$GuestBillTableTableCreateCompanionBuilder,
    $$GuestBillTableTableUpdateCompanionBuilder,
    (
      GuestBillTableData,
      BaseReferences<_$AppDatabase, $GuestBillTableTable, GuestBillTableData>
    ),
    GuestBillTableData,
    PrefetchHooks Function()> {
  $$GuestBillTableTableTableManager(
      _$AppDatabase db, $GuestBillTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$GuestBillTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$GuestBillTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$GuestBillTableTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String> splitBillUuid = const Value.absent(),
            Value<int> guestNumber = const Value.absent(),
            Value<String?> guestName = const Value.absent(),
            Value<double> totalAmount = const Value.absent(),
            Value<double?> tipAmount = const Value.absent(),
            Value<bool> isPaid = const Value.absent(),
            Value<String?> paymentMethod = const Value.absent(),
            Value<String?> paymentTransactionUuid = const Value.absent(),
            Value<DateTime?> paidAt = const Value.absent(),
          }) =>
              GuestBillTableCompanion(
            id: id,
            uuid: uuid,
            splitBillUuid: splitBillUuid,
            guestNumber: guestNumber,
            guestName: guestName,
            totalAmount: totalAmount,
            tipAmount: tipAmount,
            isPaid: isPaid,
            paymentMethod: paymentMethod,
            paymentTransactionUuid: paymentTransactionUuid,
            paidAt: paidAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            required String splitBillUuid,
            required int guestNumber,
            Value<String?> guestName = const Value.absent(),
            required double totalAmount,
            Value<double?> tipAmount = const Value.absent(),
            Value<bool> isPaid = const Value.absent(),
            Value<String?> paymentMethod = const Value.absent(),
            Value<String?> paymentTransactionUuid = const Value.absent(),
            Value<DateTime?> paidAt = const Value.absent(),
          }) =>
              GuestBillTableCompanion.insert(
            id: id,
            uuid: uuid,
            splitBillUuid: splitBillUuid,
            guestNumber: guestNumber,
            guestName: guestName,
            totalAmount: totalAmount,
            tipAmount: tipAmount,
            isPaid: isPaid,
            paymentMethod: paymentMethod,
            paymentTransactionUuid: paymentTransactionUuid,
            paidAt: paidAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$GuestBillTableTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $GuestBillTableTable,
    GuestBillTableData,
    $$GuestBillTableTableFilterComposer,
    $$GuestBillTableTableOrderingComposer,
    $$GuestBillTableTableAnnotationComposer,
    $$GuestBillTableTableCreateCompanionBuilder,
    $$GuestBillTableTableUpdateCompanionBuilder,
    (
      GuestBillTableData,
      BaseReferences<_$AppDatabase, $GuestBillTableTable, GuestBillTableData>
    ),
    GuestBillTableData,
    PrefetchHooks Function()>;
typedef $$SplitBillItemTableTableCreateCompanionBuilder
    = SplitBillItemTableCompanion Function({
  Value<int> id,
  required String uuid,
  required String guestBillUuid,
  required String orderItemUuid,
  required String productName,
  required double price,
  required int quantity,
  Value<int> shareCount,
  Value<int> shareIndex,
});
typedef $$SplitBillItemTableTableUpdateCompanionBuilder
    = SplitBillItemTableCompanion Function({
  Value<int> id,
  Value<String> uuid,
  Value<String> guestBillUuid,
  Value<String> orderItemUuid,
  Value<String> productName,
  Value<double> price,
  Value<int> quantity,
  Value<int> shareCount,
  Value<int> shareIndex,
});

class $$SplitBillItemTableTableFilterComposer
    extends Composer<_$AppDatabase, $SplitBillItemTableTable> {
  $$SplitBillItemTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get guestBillUuid => $composableBuilder(
      column: $table.guestBillUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get orderItemUuid => $composableBuilder(
      column: $table.orderItemUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get productName => $composableBuilder(
      column: $table.productName, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get price => $composableBuilder(
      column: $table.price, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get quantity => $composableBuilder(
      column: $table.quantity, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get shareCount => $composableBuilder(
      column: $table.shareCount, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get shareIndex => $composableBuilder(
      column: $table.shareIndex, builder: (column) => ColumnFilters(column));
}

class $$SplitBillItemTableTableOrderingComposer
    extends Composer<_$AppDatabase, $SplitBillItemTableTable> {
  $$SplitBillItemTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get guestBillUuid => $composableBuilder(
      column: $table.guestBillUuid,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get orderItemUuid => $composableBuilder(
      column: $table.orderItemUuid,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get productName => $composableBuilder(
      column: $table.productName, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get price => $composableBuilder(
      column: $table.price, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get quantity => $composableBuilder(
      column: $table.quantity, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get shareCount => $composableBuilder(
      column: $table.shareCount, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get shareIndex => $composableBuilder(
      column: $table.shareIndex, builder: (column) => ColumnOrderings(column));
}

class $$SplitBillItemTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $SplitBillItemTableTable> {
  $$SplitBillItemTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get guestBillUuid => $composableBuilder(
      column: $table.guestBillUuid, builder: (column) => column);

  GeneratedColumn<String> get orderItemUuid => $composableBuilder(
      column: $table.orderItemUuid, builder: (column) => column);

  GeneratedColumn<String> get productName => $composableBuilder(
      column: $table.productName, builder: (column) => column);

  GeneratedColumn<double> get price =>
      $composableBuilder(column: $table.price, builder: (column) => column);

  GeneratedColumn<int> get quantity =>
      $composableBuilder(column: $table.quantity, builder: (column) => column);

  GeneratedColumn<int> get shareCount => $composableBuilder(
      column: $table.shareCount, builder: (column) => column);

  GeneratedColumn<int> get shareIndex => $composableBuilder(
      column: $table.shareIndex, builder: (column) => column);
}

class $$SplitBillItemTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $SplitBillItemTableTable,
    SplitBillItemTableData,
    $$SplitBillItemTableTableFilterComposer,
    $$SplitBillItemTableTableOrderingComposer,
    $$SplitBillItemTableTableAnnotationComposer,
    $$SplitBillItemTableTableCreateCompanionBuilder,
    $$SplitBillItemTableTableUpdateCompanionBuilder,
    (
      SplitBillItemTableData,
      BaseReferences<_$AppDatabase, $SplitBillItemTableTable,
          SplitBillItemTableData>
    ),
    SplitBillItemTableData,
    PrefetchHooks Function()> {
  $$SplitBillItemTableTableTableManager(
      _$AppDatabase db, $SplitBillItemTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$SplitBillItemTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$SplitBillItemTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$SplitBillItemTableTableAnnotationComposer(
                  $db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String> guestBillUuid = const Value.absent(),
            Value<String> orderItemUuid = const Value.absent(),
            Value<String> productName = const Value.absent(),
            Value<double> price = const Value.absent(),
            Value<int> quantity = const Value.absent(),
            Value<int> shareCount = const Value.absent(),
            Value<int> shareIndex = const Value.absent(),
          }) =>
              SplitBillItemTableCompanion(
            id: id,
            uuid: uuid,
            guestBillUuid: guestBillUuid,
            orderItemUuid: orderItemUuid,
            productName: productName,
            price: price,
            quantity: quantity,
            shareCount: shareCount,
            shareIndex: shareIndex,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            required String guestBillUuid,
            required String orderItemUuid,
            required String productName,
            required double price,
            required int quantity,
            Value<int> shareCount = const Value.absent(),
            Value<int> shareIndex = const Value.absent(),
          }) =>
              SplitBillItemTableCompanion.insert(
            id: id,
            uuid: uuid,
            guestBillUuid: guestBillUuid,
            orderItemUuid: orderItemUuid,
            productName: productName,
            price: price,
            quantity: quantity,
            shareCount: shareCount,
            shareIndex: shareIndex,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$SplitBillItemTableTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $SplitBillItemTableTable,
    SplitBillItemTableData,
    $$SplitBillItemTableTableFilterComposer,
    $$SplitBillItemTableTableOrderingComposer,
    $$SplitBillItemTableTableAnnotationComposer,
    $$SplitBillItemTableTableCreateCompanionBuilder,
    $$SplitBillItemTableTableUpdateCompanionBuilder,
    (
      SplitBillItemTableData,
      BaseReferences<_$AppDatabase, $SplitBillItemTableTable,
          SplitBillItemTableData>
    ),
    SplitBillItemTableData,
    PrefetchHooks Function()>;
typedef $$DiscountTableTableCreateCompanionBuilder = DiscountTableCompanion
    Function({
  Value<int> id,
  required String uuid,
  required String name,
  required String code,
  Value<String?> description,
  required String type,
  required String scope,
  Value<String> status,
  Value<double?> percentageOff,
  Value<double?> fixedAmountOff,
  Value<int?> buyQuantity,
  Value<int?> getQuantity,
  Value<double?> getDiscountPercent,
  Value<String> tiersJson,
  Value<String> applicableProductUuidsJson,
  Value<String> applicableCategoryUuidsJson,
  Value<String> applicableCustomerUuidsJson,
  Value<double?> minOrderAmount,
  Value<double?> maxDiscountAmount,
  Value<int?> maxUsesTotal,
  Value<int?> maxUsesPerCustomer,
  Value<int> currentUsageCount,
  Value<DateTime?> validFrom,
  Value<DateTime?> validUntil,
  Value<String> validDaysOfWeekJson,
  Value<String?> validTimeStart,
  Value<String?> validTimeEnd,
  Value<bool> canStackWithOthers,
  Value<int> stackPriority,
  required DateTime createdAt,
  Value<DateTime?> updatedAt,
});
typedef $$DiscountTableTableUpdateCompanionBuilder = DiscountTableCompanion
    Function({
  Value<int> id,
  Value<String> uuid,
  Value<String> name,
  Value<String> code,
  Value<String?> description,
  Value<String> type,
  Value<String> scope,
  Value<String> status,
  Value<double?> percentageOff,
  Value<double?> fixedAmountOff,
  Value<int?> buyQuantity,
  Value<int?> getQuantity,
  Value<double?> getDiscountPercent,
  Value<String> tiersJson,
  Value<String> applicableProductUuidsJson,
  Value<String> applicableCategoryUuidsJson,
  Value<String> applicableCustomerUuidsJson,
  Value<double?> minOrderAmount,
  Value<double?> maxDiscountAmount,
  Value<int?> maxUsesTotal,
  Value<int?> maxUsesPerCustomer,
  Value<int> currentUsageCount,
  Value<DateTime?> validFrom,
  Value<DateTime?> validUntil,
  Value<String> validDaysOfWeekJson,
  Value<String?> validTimeStart,
  Value<String?> validTimeEnd,
  Value<bool> canStackWithOthers,
  Value<int> stackPriority,
  Value<DateTime> createdAt,
  Value<DateTime?> updatedAt,
});

class $$DiscountTableTableFilterComposer
    extends Composer<_$AppDatabase, $DiscountTableTable> {
  $$DiscountTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get code => $composableBuilder(
      column: $table.code, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get description => $composableBuilder(
      column: $table.description, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get type => $composableBuilder(
      column: $table.type, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get scope => $composableBuilder(
      column: $table.scope, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get percentageOff => $composableBuilder(
      column: $table.percentageOff, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get fixedAmountOff => $composableBuilder(
      column: $table.fixedAmountOff,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get buyQuantity => $composableBuilder(
      column: $table.buyQuantity, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get getQuantity => $composableBuilder(
      column: $table.getQuantity, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get getDiscountPercent => $composableBuilder(
      column: $table.getDiscountPercent,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get tiersJson => $composableBuilder(
      column: $table.tiersJson, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get applicableProductUuidsJson => $composableBuilder(
      column: $table.applicableProductUuidsJson,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get applicableCategoryUuidsJson => $composableBuilder(
      column: $table.applicableCategoryUuidsJson,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get applicableCustomerUuidsJson => $composableBuilder(
      column: $table.applicableCustomerUuidsJson,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get minOrderAmount => $composableBuilder(
      column: $table.minOrderAmount,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get maxDiscountAmount => $composableBuilder(
      column: $table.maxDiscountAmount,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get maxUsesTotal => $composableBuilder(
      column: $table.maxUsesTotal, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get maxUsesPerCustomer => $composableBuilder(
      column: $table.maxUsesPerCustomer,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get currentUsageCount => $composableBuilder(
      column: $table.currentUsageCount,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get validFrom => $composableBuilder(
      column: $table.validFrom, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get validUntil => $composableBuilder(
      column: $table.validUntil, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get validDaysOfWeekJson => $composableBuilder(
      column: $table.validDaysOfWeekJson,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get validTimeStart => $composableBuilder(
      column: $table.validTimeStart,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get validTimeEnd => $composableBuilder(
      column: $table.validTimeEnd, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get canStackWithOthers => $composableBuilder(
      column: $table.canStackWithOthers,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get stackPriority => $composableBuilder(
      column: $table.stackPriority, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));
}

class $$DiscountTableTableOrderingComposer
    extends Composer<_$AppDatabase, $DiscountTableTable> {
  $$DiscountTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get code => $composableBuilder(
      column: $table.code, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get description => $composableBuilder(
      column: $table.description, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get type => $composableBuilder(
      column: $table.type, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get scope => $composableBuilder(
      column: $table.scope, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get percentageOff => $composableBuilder(
      column: $table.percentageOff,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get fixedAmountOff => $composableBuilder(
      column: $table.fixedAmountOff,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get buyQuantity => $composableBuilder(
      column: $table.buyQuantity, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get getQuantity => $composableBuilder(
      column: $table.getQuantity, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get getDiscountPercent => $composableBuilder(
      column: $table.getDiscountPercent,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get tiersJson => $composableBuilder(
      column: $table.tiersJson, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get applicableProductUuidsJson => $composableBuilder(
      column: $table.applicableProductUuidsJson,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get applicableCategoryUuidsJson => $composableBuilder(
      column: $table.applicableCategoryUuidsJson,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get applicableCustomerUuidsJson => $composableBuilder(
      column: $table.applicableCustomerUuidsJson,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get minOrderAmount => $composableBuilder(
      column: $table.minOrderAmount,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get maxDiscountAmount => $composableBuilder(
      column: $table.maxDiscountAmount,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get maxUsesTotal => $composableBuilder(
      column: $table.maxUsesTotal,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get maxUsesPerCustomer => $composableBuilder(
      column: $table.maxUsesPerCustomer,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get currentUsageCount => $composableBuilder(
      column: $table.currentUsageCount,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get validFrom => $composableBuilder(
      column: $table.validFrom, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get validUntil => $composableBuilder(
      column: $table.validUntil, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get validDaysOfWeekJson => $composableBuilder(
      column: $table.validDaysOfWeekJson,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get validTimeStart => $composableBuilder(
      column: $table.validTimeStart,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get validTimeEnd => $composableBuilder(
      column: $table.validTimeEnd,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get canStackWithOthers => $composableBuilder(
      column: $table.canStackWithOthers,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get stackPriority => $composableBuilder(
      column: $table.stackPriority,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));
}

class $$DiscountTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $DiscountTableTable> {
  $$DiscountTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get code =>
      $composableBuilder(column: $table.code, builder: (column) => column);

  GeneratedColumn<String> get description => $composableBuilder(
      column: $table.description, builder: (column) => column);

  GeneratedColumn<String> get type =>
      $composableBuilder(column: $table.type, builder: (column) => column);

  GeneratedColumn<String> get scope =>
      $composableBuilder(column: $table.scope, builder: (column) => column);

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<double> get percentageOff => $composableBuilder(
      column: $table.percentageOff, builder: (column) => column);

  GeneratedColumn<double> get fixedAmountOff => $composableBuilder(
      column: $table.fixedAmountOff, builder: (column) => column);

  GeneratedColumn<int> get buyQuantity => $composableBuilder(
      column: $table.buyQuantity, builder: (column) => column);

  GeneratedColumn<int> get getQuantity => $composableBuilder(
      column: $table.getQuantity, builder: (column) => column);

  GeneratedColumn<double> get getDiscountPercent => $composableBuilder(
      column: $table.getDiscountPercent, builder: (column) => column);

  GeneratedColumn<String> get tiersJson =>
      $composableBuilder(column: $table.tiersJson, builder: (column) => column);

  GeneratedColumn<String> get applicableProductUuidsJson => $composableBuilder(
      column: $table.applicableProductUuidsJson, builder: (column) => column);

  GeneratedColumn<String> get applicableCategoryUuidsJson => $composableBuilder(
      column: $table.applicableCategoryUuidsJson, builder: (column) => column);

  GeneratedColumn<String> get applicableCustomerUuidsJson => $composableBuilder(
      column: $table.applicableCustomerUuidsJson, builder: (column) => column);

  GeneratedColumn<double> get minOrderAmount => $composableBuilder(
      column: $table.minOrderAmount, builder: (column) => column);

  GeneratedColumn<double> get maxDiscountAmount => $composableBuilder(
      column: $table.maxDiscountAmount, builder: (column) => column);

  GeneratedColumn<int> get maxUsesTotal => $composableBuilder(
      column: $table.maxUsesTotal, builder: (column) => column);

  GeneratedColumn<int> get maxUsesPerCustomer => $composableBuilder(
      column: $table.maxUsesPerCustomer, builder: (column) => column);

  GeneratedColumn<int> get currentUsageCount => $composableBuilder(
      column: $table.currentUsageCount, builder: (column) => column);

  GeneratedColumn<DateTime> get validFrom =>
      $composableBuilder(column: $table.validFrom, builder: (column) => column);

  GeneratedColumn<DateTime> get validUntil => $composableBuilder(
      column: $table.validUntil, builder: (column) => column);

  GeneratedColumn<String> get validDaysOfWeekJson => $composableBuilder(
      column: $table.validDaysOfWeekJson, builder: (column) => column);

  GeneratedColumn<String> get validTimeStart => $composableBuilder(
      column: $table.validTimeStart, builder: (column) => column);

  GeneratedColumn<String> get validTimeEnd => $composableBuilder(
      column: $table.validTimeEnd, builder: (column) => column);

  GeneratedColumn<bool> get canStackWithOthers => $composableBuilder(
      column: $table.canStackWithOthers, builder: (column) => column);

  GeneratedColumn<int> get stackPriority => $composableBuilder(
      column: $table.stackPriority, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$DiscountTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $DiscountTableTable,
    DiscountTableData,
    $$DiscountTableTableFilterComposer,
    $$DiscountTableTableOrderingComposer,
    $$DiscountTableTableAnnotationComposer,
    $$DiscountTableTableCreateCompanionBuilder,
    $$DiscountTableTableUpdateCompanionBuilder,
    (
      DiscountTableData,
      BaseReferences<_$AppDatabase, $DiscountTableTable, DiscountTableData>
    ),
    DiscountTableData,
    PrefetchHooks Function()> {
  $$DiscountTableTableTableManager(_$AppDatabase db, $DiscountTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$DiscountTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$DiscountTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$DiscountTableTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String> name = const Value.absent(),
            Value<String> code = const Value.absent(),
            Value<String?> description = const Value.absent(),
            Value<String> type = const Value.absent(),
            Value<String> scope = const Value.absent(),
            Value<String> status = const Value.absent(),
            Value<double?> percentageOff = const Value.absent(),
            Value<double?> fixedAmountOff = const Value.absent(),
            Value<int?> buyQuantity = const Value.absent(),
            Value<int?> getQuantity = const Value.absent(),
            Value<double?> getDiscountPercent = const Value.absent(),
            Value<String> tiersJson = const Value.absent(),
            Value<String> applicableProductUuidsJson = const Value.absent(),
            Value<String> applicableCategoryUuidsJson = const Value.absent(),
            Value<String> applicableCustomerUuidsJson = const Value.absent(),
            Value<double?> minOrderAmount = const Value.absent(),
            Value<double?> maxDiscountAmount = const Value.absent(),
            Value<int?> maxUsesTotal = const Value.absent(),
            Value<int?> maxUsesPerCustomer = const Value.absent(),
            Value<int> currentUsageCount = const Value.absent(),
            Value<DateTime?> validFrom = const Value.absent(),
            Value<DateTime?> validUntil = const Value.absent(),
            Value<String> validDaysOfWeekJson = const Value.absent(),
            Value<String?> validTimeStart = const Value.absent(),
            Value<String?> validTimeEnd = const Value.absent(),
            Value<bool> canStackWithOthers = const Value.absent(),
            Value<int> stackPriority = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<DateTime?> updatedAt = const Value.absent(),
          }) =>
              DiscountTableCompanion(
            id: id,
            uuid: uuid,
            name: name,
            code: code,
            description: description,
            type: type,
            scope: scope,
            status: status,
            percentageOff: percentageOff,
            fixedAmountOff: fixedAmountOff,
            buyQuantity: buyQuantity,
            getQuantity: getQuantity,
            getDiscountPercent: getDiscountPercent,
            tiersJson: tiersJson,
            applicableProductUuidsJson: applicableProductUuidsJson,
            applicableCategoryUuidsJson: applicableCategoryUuidsJson,
            applicableCustomerUuidsJson: applicableCustomerUuidsJson,
            minOrderAmount: minOrderAmount,
            maxDiscountAmount: maxDiscountAmount,
            maxUsesTotal: maxUsesTotal,
            maxUsesPerCustomer: maxUsesPerCustomer,
            currentUsageCount: currentUsageCount,
            validFrom: validFrom,
            validUntil: validUntil,
            validDaysOfWeekJson: validDaysOfWeekJson,
            validTimeStart: validTimeStart,
            validTimeEnd: validTimeEnd,
            canStackWithOthers: canStackWithOthers,
            stackPriority: stackPriority,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            required String name,
            required String code,
            Value<String?> description = const Value.absent(),
            required String type,
            required String scope,
            Value<String> status = const Value.absent(),
            Value<double?> percentageOff = const Value.absent(),
            Value<double?> fixedAmountOff = const Value.absent(),
            Value<int?> buyQuantity = const Value.absent(),
            Value<int?> getQuantity = const Value.absent(),
            Value<double?> getDiscountPercent = const Value.absent(),
            Value<String> tiersJson = const Value.absent(),
            Value<String> applicableProductUuidsJson = const Value.absent(),
            Value<String> applicableCategoryUuidsJson = const Value.absent(),
            Value<String> applicableCustomerUuidsJson = const Value.absent(),
            Value<double?> minOrderAmount = const Value.absent(),
            Value<double?> maxDiscountAmount = const Value.absent(),
            Value<int?> maxUsesTotal = const Value.absent(),
            Value<int?> maxUsesPerCustomer = const Value.absent(),
            Value<int> currentUsageCount = const Value.absent(),
            Value<DateTime?> validFrom = const Value.absent(),
            Value<DateTime?> validUntil = const Value.absent(),
            Value<String> validDaysOfWeekJson = const Value.absent(),
            Value<String?> validTimeStart = const Value.absent(),
            Value<String?> validTimeEnd = const Value.absent(),
            Value<bool> canStackWithOthers = const Value.absent(),
            Value<int> stackPriority = const Value.absent(),
            required DateTime createdAt,
            Value<DateTime?> updatedAt = const Value.absent(),
          }) =>
              DiscountTableCompanion.insert(
            id: id,
            uuid: uuid,
            name: name,
            code: code,
            description: description,
            type: type,
            scope: scope,
            status: status,
            percentageOff: percentageOff,
            fixedAmountOff: fixedAmountOff,
            buyQuantity: buyQuantity,
            getQuantity: getQuantity,
            getDiscountPercent: getDiscountPercent,
            tiersJson: tiersJson,
            applicableProductUuidsJson: applicableProductUuidsJson,
            applicableCategoryUuidsJson: applicableCategoryUuidsJson,
            applicableCustomerUuidsJson: applicableCustomerUuidsJson,
            minOrderAmount: minOrderAmount,
            maxDiscountAmount: maxDiscountAmount,
            maxUsesTotal: maxUsesTotal,
            maxUsesPerCustomer: maxUsesPerCustomer,
            currentUsageCount: currentUsageCount,
            validFrom: validFrom,
            validUntil: validUntil,
            validDaysOfWeekJson: validDaysOfWeekJson,
            validTimeStart: validTimeStart,
            validTimeEnd: validTimeEnd,
            canStackWithOthers: canStackWithOthers,
            stackPriority: stackPriority,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$DiscountTableTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $DiscountTableTable,
    DiscountTableData,
    $$DiscountTableTableFilterComposer,
    $$DiscountTableTableOrderingComposer,
    $$DiscountTableTableAnnotationComposer,
    $$DiscountTableTableCreateCompanionBuilder,
    $$DiscountTableTableUpdateCompanionBuilder,
    (
      DiscountTableData,
      BaseReferences<_$AppDatabase, $DiscountTableTable, DiscountTableData>
    ),
    DiscountTableData,
    PrefetchHooks Function()>;
typedef $$AppliedDiscountTableTableCreateCompanionBuilder
    = AppliedDiscountTableCompanion Function({
  Value<int> id,
  required String uuid,
  required String orderUuid,
  required String discountUuid,
  required String discountName,
  required String discountCode,
  required String type,
  required double discountAmount,
  Value<String?> appliedToItemUuid,
  Value<String?> appliedToItemName,
  required DateTime appliedAt,
  Value<String?> appliedByUuid,
});
typedef $$AppliedDiscountTableTableUpdateCompanionBuilder
    = AppliedDiscountTableCompanion Function({
  Value<int> id,
  Value<String> uuid,
  Value<String> orderUuid,
  Value<String> discountUuid,
  Value<String> discountName,
  Value<String> discountCode,
  Value<String> type,
  Value<double> discountAmount,
  Value<String?> appliedToItemUuid,
  Value<String?> appliedToItemName,
  Value<DateTime> appliedAt,
  Value<String?> appliedByUuid,
});

class $$AppliedDiscountTableTableFilterComposer
    extends Composer<_$AppDatabase, $AppliedDiscountTableTable> {
  $$AppliedDiscountTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get orderUuid => $composableBuilder(
      column: $table.orderUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get discountUuid => $composableBuilder(
      column: $table.discountUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get discountName => $composableBuilder(
      column: $table.discountName, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get discountCode => $composableBuilder(
      column: $table.discountCode, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get type => $composableBuilder(
      column: $table.type, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get discountAmount => $composableBuilder(
      column: $table.discountAmount,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get appliedToItemUuid => $composableBuilder(
      column: $table.appliedToItemUuid,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get appliedToItemName => $composableBuilder(
      column: $table.appliedToItemName,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get appliedAt => $composableBuilder(
      column: $table.appliedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get appliedByUuid => $composableBuilder(
      column: $table.appliedByUuid, builder: (column) => ColumnFilters(column));
}

class $$AppliedDiscountTableTableOrderingComposer
    extends Composer<_$AppDatabase, $AppliedDiscountTableTable> {
  $$AppliedDiscountTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get orderUuid => $composableBuilder(
      column: $table.orderUuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get discountUuid => $composableBuilder(
      column: $table.discountUuid,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get discountName => $composableBuilder(
      column: $table.discountName,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get discountCode => $composableBuilder(
      column: $table.discountCode,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get type => $composableBuilder(
      column: $table.type, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get discountAmount => $composableBuilder(
      column: $table.discountAmount,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get appliedToItemUuid => $composableBuilder(
      column: $table.appliedToItemUuid,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get appliedToItemName => $composableBuilder(
      column: $table.appliedToItemName,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get appliedAt => $composableBuilder(
      column: $table.appliedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get appliedByUuid => $composableBuilder(
      column: $table.appliedByUuid,
      builder: (column) => ColumnOrderings(column));
}

class $$AppliedDiscountTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $AppliedDiscountTableTable> {
  $$AppliedDiscountTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get orderUuid =>
      $composableBuilder(column: $table.orderUuid, builder: (column) => column);

  GeneratedColumn<String> get discountUuid => $composableBuilder(
      column: $table.discountUuid, builder: (column) => column);

  GeneratedColumn<String> get discountName => $composableBuilder(
      column: $table.discountName, builder: (column) => column);

  GeneratedColumn<String> get discountCode => $composableBuilder(
      column: $table.discountCode, builder: (column) => column);

  GeneratedColumn<String> get type =>
      $composableBuilder(column: $table.type, builder: (column) => column);

  GeneratedColumn<double> get discountAmount => $composableBuilder(
      column: $table.discountAmount, builder: (column) => column);

  GeneratedColumn<String> get appliedToItemUuid => $composableBuilder(
      column: $table.appliedToItemUuid, builder: (column) => column);

  GeneratedColumn<String> get appliedToItemName => $composableBuilder(
      column: $table.appliedToItemName, builder: (column) => column);

  GeneratedColumn<DateTime> get appliedAt =>
      $composableBuilder(column: $table.appliedAt, builder: (column) => column);

  GeneratedColumn<String> get appliedByUuid => $composableBuilder(
      column: $table.appliedByUuid, builder: (column) => column);
}

class $$AppliedDiscountTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $AppliedDiscountTableTable,
    AppliedDiscountTableData,
    $$AppliedDiscountTableTableFilterComposer,
    $$AppliedDiscountTableTableOrderingComposer,
    $$AppliedDiscountTableTableAnnotationComposer,
    $$AppliedDiscountTableTableCreateCompanionBuilder,
    $$AppliedDiscountTableTableUpdateCompanionBuilder,
    (
      AppliedDiscountTableData,
      BaseReferences<_$AppDatabase, $AppliedDiscountTableTable,
          AppliedDiscountTableData>
    ),
    AppliedDiscountTableData,
    PrefetchHooks Function()> {
  $$AppliedDiscountTableTableTableManager(
      _$AppDatabase db, $AppliedDiscountTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$AppliedDiscountTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$AppliedDiscountTableTableOrderingComposer(
                  $db: db, $table: table),
          createComputedFieldComposer: () =>
              $$AppliedDiscountTableTableAnnotationComposer(
                  $db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String> orderUuid = const Value.absent(),
            Value<String> discountUuid = const Value.absent(),
            Value<String> discountName = const Value.absent(),
            Value<String> discountCode = const Value.absent(),
            Value<String> type = const Value.absent(),
            Value<double> discountAmount = const Value.absent(),
            Value<String?> appliedToItemUuid = const Value.absent(),
            Value<String?> appliedToItemName = const Value.absent(),
            Value<DateTime> appliedAt = const Value.absent(),
            Value<String?> appliedByUuid = const Value.absent(),
          }) =>
              AppliedDiscountTableCompanion(
            id: id,
            uuid: uuid,
            orderUuid: orderUuid,
            discountUuid: discountUuid,
            discountName: discountName,
            discountCode: discountCode,
            type: type,
            discountAmount: discountAmount,
            appliedToItemUuid: appliedToItemUuid,
            appliedToItemName: appliedToItemName,
            appliedAt: appliedAt,
            appliedByUuid: appliedByUuid,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            required String orderUuid,
            required String discountUuid,
            required String discountName,
            required String discountCode,
            required String type,
            required double discountAmount,
            Value<String?> appliedToItemUuid = const Value.absent(),
            Value<String?> appliedToItemName = const Value.absent(),
            required DateTime appliedAt,
            Value<String?> appliedByUuid = const Value.absent(),
          }) =>
              AppliedDiscountTableCompanion.insert(
            id: id,
            uuid: uuid,
            orderUuid: orderUuid,
            discountUuid: discountUuid,
            discountName: discountName,
            discountCode: discountCode,
            type: type,
            discountAmount: discountAmount,
            appliedToItemUuid: appliedToItemUuid,
            appliedToItemName: appliedToItemName,
            appliedAt: appliedAt,
            appliedByUuid: appliedByUuid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$AppliedDiscountTableTableProcessedTableManager
    = ProcessedTableManager<
        _$AppDatabase,
        $AppliedDiscountTableTable,
        AppliedDiscountTableData,
        $$AppliedDiscountTableTableFilterComposer,
        $$AppliedDiscountTableTableOrderingComposer,
        $$AppliedDiscountTableTableAnnotationComposer,
        $$AppliedDiscountTableTableCreateCompanionBuilder,
        $$AppliedDiscountTableTableUpdateCompanionBuilder,
        (
          AppliedDiscountTableData,
          BaseReferences<_$AppDatabase, $AppliedDiscountTableTable,
              AppliedDiscountTableData>
        ),
        AppliedDiscountTableData,
        PrefetchHooks Function()>;
typedef $$WaitlistTableTableCreateCompanionBuilder = WaitlistTableCompanion
    Function({
  Value<int> id,
  required String uuid,
  required String guestName,
  required String phoneNumber,
  required int partySize,
  Value<String?> specialRequests,
  Value<bool> highchairNeeded,
  Value<bool> wheelchairAccessible,
  Value<String?> tablePreference,
  Value<String> status,
  required DateTime createdAt,
  Value<DateTime?> quotedWaitTime,
  Value<DateTime?> notifiedAt,
  Value<DateTime?> seatedAt,
  Value<String?> seatedTableUuid,
  Value<int?> queuePosition,
});
typedef $$WaitlistTableTableUpdateCompanionBuilder = WaitlistTableCompanion
    Function({
  Value<int> id,
  Value<String> uuid,
  Value<String> guestName,
  Value<String> phoneNumber,
  Value<int> partySize,
  Value<String?> specialRequests,
  Value<bool> highchairNeeded,
  Value<bool> wheelchairAccessible,
  Value<String?> tablePreference,
  Value<String> status,
  Value<DateTime> createdAt,
  Value<DateTime?> quotedWaitTime,
  Value<DateTime?> notifiedAt,
  Value<DateTime?> seatedAt,
  Value<String?> seatedTableUuid,
  Value<int?> queuePosition,
});

class $$WaitlistTableTableFilterComposer
    extends Composer<_$AppDatabase, $WaitlistTableTable> {
  $$WaitlistTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get guestName => $composableBuilder(
      column: $table.guestName, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get phoneNumber => $composableBuilder(
      column: $table.phoneNumber, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get partySize => $composableBuilder(
      column: $table.partySize, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get specialRequests => $composableBuilder(
      column: $table.specialRequests,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get highchairNeeded => $composableBuilder(
      column: $table.highchairNeeded,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get wheelchairAccessible => $composableBuilder(
      column: $table.wheelchairAccessible,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get tablePreference => $composableBuilder(
      column: $table.tablePreference,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get quotedWaitTime => $composableBuilder(
      column: $table.quotedWaitTime,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get notifiedAt => $composableBuilder(
      column: $table.notifiedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get seatedAt => $composableBuilder(
      column: $table.seatedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get seatedTableUuid => $composableBuilder(
      column: $table.seatedTableUuid,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get queuePosition => $composableBuilder(
      column: $table.queuePosition, builder: (column) => ColumnFilters(column));
}

class $$WaitlistTableTableOrderingComposer
    extends Composer<_$AppDatabase, $WaitlistTableTable> {
  $$WaitlistTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get guestName => $composableBuilder(
      column: $table.guestName, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get phoneNumber => $composableBuilder(
      column: $table.phoneNumber, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get partySize => $composableBuilder(
      column: $table.partySize, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get specialRequests => $composableBuilder(
      column: $table.specialRequests,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get highchairNeeded => $composableBuilder(
      column: $table.highchairNeeded,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get wheelchairAccessible => $composableBuilder(
      column: $table.wheelchairAccessible,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get tablePreference => $composableBuilder(
      column: $table.tablePreference,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get quotedWaitTime => $composableBuilder(
      column: $table.quotedWaitTime,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get notifiedAt => $composableBuilder(
      column: $table.notifiedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get seatedAt => $composableBuilder(
      column: $table.seatedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get seatedTableUuid => $composableBuilder(
      column: $table.seatedTableUuid,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get queuePosition => $composableBuilder(
      column: $table.queuePosition,
      builder: (column) => ColumnOrderings(column));
}

class $$WaitlistTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $WaitlistTableTable> {
  $$WaitlistTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get guestName =>
      $composableBuilder(column: $table.guestName, builder: (column) => column);

  GeneratedColumn<String> get phoneNumber => $composableBuilder(
      column: $table.phoneNumber, builder: (column) => column);

  GeneratedColumn<int> get partySize =>
      $composableBuilder(column: $table.partySize, builder: (column) => column);

  GeneratedColumn<String> get specialRequests => $composableBuilder(
      column: $table.specialRequests, builder: (column) => column);

  GeneratedColumn<bool> get highchairNeeded => $composableBuilder(
      column: $table.highchairNeeded, builder: (column) => column);

  GeneratedColumn<bool> get wheelchairAccessible => $composableBuilder(
      column: $table.wheelchairAccessible, builder: (column) => column);

  GeneratedColumn<String> get tablePreference => $composableBuilder(
      column: $table.tablePreference, builder: (column) => column);

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get quotedWaitTime => $composableBuilder(
      column: $table.quotedWaitTime, builder: (column) => column);

  GeneratedColumn<DateTime> get notifiedAt => $composableBuilder(
      column: $table.notifiedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get seatedAt =>
      $composableBuilder(column: $table.seatedAt, builder: (column) => column);

  GeneratedColumn<String> get seatedTableUuid => $composableBuilder(
      column: $table.seatedTableUuid, builder: (column) => column);

  GeneratedColumn<int> get queuePosition => $composableBuilder(
      column: $table.queuePosition, builder: (column) => column);
}

class $$WaitlistTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $WaitlistTableTable,
    WaitlistTableData,
    $$WaitlistTableTableFilterComposer,
    $$WaitlistTableTableOrderingComposer,
    $$WaitlistTableTableAnnotationComposer,
    $$WaitlistTableTableCreateCompanionBuilder,
    $$WaitlistTableTableUpdateCompanionBuilder,
    (
      WaitlistTableData,
      BaseReferences<_$AppDatabase, $WaitlistTableTable, WaitlistTableData>
    ),
    WaitlistTableData,
    PrefetchHooks Function()> {
  $$WaitlistTableTableTableManager(_$AppDatabase db, $WaitlistTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$WaitlistTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$WaitlistTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$WaitlistTableTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String> guestName = const Value.absent(),
            Value<String> phoneNumber = const Value.absent(),
            Value<int> partySize = const Value.absent(),
            Value<String?> specialRequests = const Value.absent(),
            Value<bool> highchairNeeded = const Value.absent(),
            Value<bool> wheelchairAccessible = const Value.absent(),
            Value<String?> tablePreference = const Value.absent(),
            Value<String> status = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<DateTime?> quotedWaitTime = const Value.absent(),
            Value<DateTime?> notifiedAt = const Value.absent(),
            Value<DateTime?> seatedAt = const Value.absent(),
            Value<String?> seatedTableUuid = const Value.absent(),
            Value<int?> queuePosition = const Value.absent(),
          }) =>
              WaitlistTableCompanion(
            id: id,
            uuid: uuid,
            guestName: guestName,
            phoneNumber: phoneNumber,
            partySize: partySize,
            specialRequests: specialRequests,
            highchairNeeded: highchairNeeded,
            wheelchairAccessible: wheelchairAccessible,
            tablePreference: tablePreference,
            status: status,
            createdAt: createdAt,
            quotedWaitTime: quotedWaitTime,
            notifiedAt: notifiedAt,
            seatedAt: seatedAt,
            seatedTableUuid: seatedTableUuid,
            queuePosition: queuePosition,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            required String guestName,
            required String phoneNumber,
            required int partySize,
            Value<String?> specialRequests = const Value.absent(),
            Value<bool> highchairNeeded = const Value.absent(),
            Value<bool> wheelchairAccessible = const Value.absent(),
            Value<String?> tablePreference = const Value.absent(),
            Value<String> status = const Value.absent(),
            required DateTime createdAt,
            Value<DateTime?> quotedWaitTime = const Value.absent(),
            Value<DateTime?> notifiedAt = const Value.absent(),
            Value<DateTime?> seatedAt = const Value.absent(),
            Value<String?> seatedTableUuid = const Value.absent(),
            Value<int?> queuePosition = const Value.absent(),
          }) =>
              WaitlistTableCompanion.insert(
            id: id,
            uuid: uuid,
            guestName: guestName,
            phoneNumber: phoneNumber,
            partySize: partySize,
            specialRequests: specialRequests,
            highchairNeeded: highchairNeeded,
            wheelchairAccessible: wheelchairAccessible,
            tablePreference: tablePreference,
            status: status,
            createdAt: createdAt,
            quotedWaitTime: quotedWaitTime,
            notifiedAt: notifiedAt,
            seatedAt: seatedAt,
            seatedTableUuid: seatedTableUuid,
            queuePosition: queuePosition,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$WaitlistTableTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $WaitlistTableTable,
    WaitlistTableData,
    $$WaitlistTableTableFilterComposer,
    $$WaitlistTableTableOrderingComposer,
    $$WaitlistTableTableAnnotationComposer,
    $$WaitlistTableTableCreateCompanionBuilder,
    $$WaitlistTableTableUpdateCompanionBuilder,
    (
      WaitlistTableData,
      BaseReferences<_$AppDatabase, $WaitlistTableTable, WaitlistTableData>
    ),
    WaitlistTableData,
    PrefetchHooks Function()>;
typedef $$StaffAlertTableTableCreateCompanionBuilder = StaffAlertTableCompanion
    Function({
  Value<int> id,
  required String uuid,
  required String type,
  required String priority,
  required String title,
  required String message,
  Value<String> status,
  Value<String> targetRolesJson,
  Value<String> targetUserUuidsJson,
  Value<bool> broadcastToAll,
  Value<String?> relatedOrderUuid,
  Value<String?> relatedTableUuid,
  Value<String?> relatedCustomerUuid,
  Value<String?> actionLabel,
  Value<String?> actionRoute,
  required DateTime createdAt,
  Value<DateTime?> expiresAt,
  Value<DateTime?> acknowledgedAt,
  Value<String?> acknowledgedByUuid,
  Value<DateTime?> resolvedAt,
  Value<String?> resolvedByUuid,
  Value<bool> playSound,
  Value<bool> vibrate,
});
typedef $$StaffAlertTableTableUpdateCompanionBuilder = StaffAlertTableCompanion
    Function({
  Value<int> id,
  Value<String> uuid,
  Value<String> type,
  Value<String> priority,
  Value<String> title,
  Value<String> message,
  Value<String> status,
  Value<String> targetRolesJson,
  Value<String> targetUserUuidsJson,
  Value<bool> broadcastToAll,
  Value<String?> relatedOrderUuid,
  Value<String?> relatedTableUuid,
  Value<String?> relatedCustomerUuid,
  Value<String?> actionLabel,
  Value<String?> actionRoute,
  Value<DateTime> createdAt,
  Value<DateTime?> expiresAt,
  Value<DateTime?> acknowledgedAt,
  Value<String?> acknowledgedByUuid,
  Value<DateTime?> resolvedAt,
  Value<String?> resolvedByUuid,
  Value<bool> playSound,
  Value<bool> vibrate,
});

class $$StaffAlertTableTableFilterComposer
    extends Composer<_$AppDatabase, $StaffAlertTableTable> {
  $$StaffAlertTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get type => $composableBuilder(
      column: $table.type, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get priority => $composableBuilder(
      column: $table.priority, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get title => $composableBuilder(
      column: $table.title, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get message => $composableBuilder(
      column: $table.message, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get targetRolesJson => $composableBuilder(
      column: $table.targetRolesJson,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get targetUserUuidsJson => $composableBuilder(
      column: $table.targetUserUuidsJson,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get broadcastToAll => $composableBuilder(
      column: $table.broadcastToAll,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get relatedOrderUuid => $composableBuilder(
      column: $table.relatedOrderUuid,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get relatedTableUuid => $composableBuilder(
      column: $table.relatedTableUuid,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get relatedCustomerUuid => $composableBuilder(
      column: $table.relatedCustomerUuid,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get actionLabel => $composableBuilder(
      column: $table.actionLabel, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get actionRoute => $composableBuilder(
      column: $table.actionRoute, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get expiresAt => $composableBuilder(
      column: $table.expiresAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get acknowledgedAt => $composableBuilder(
      column: $table.acknowledgedAt,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get acknowledgedByUuid => $composableBuilder(
      column: $table.acknowledgedByUuid,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get resolvedAt => $composableBuilder(
      column: $table.resolvedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get resolvedByUuid => $composableBuilder(
      column: $table.resolvedByUuid,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get playSound => $composableBuilder(
      column: $table.playSound, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get vibrate => $composableBuilder(
      column: $table.vibrate, builder: (column) => ColumnFilters(column));
}

class $$StaffAlertTableTableOrderingComposer
    extends Composer<_$AppDatabase, $StaffAlertTableTable> {
  $$StaffAlertTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get type => $composableBuilder(
      column: $table.type, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get priority => $composableBuilder(
      column: $table.priority, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get title => $composableBuilder(
      column: $table.title, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get message => $composableBuilder(
      column: $table.message, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get targetRolesJson => $composableBuilder(
      column: $table.targetRolesJson,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get targetUserUuidsJson => $composableBuilder(
      column: $table.targetUserUuidsJson,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get broadcastToAll => $composableBuilder(
      column: $table.broadcastToAll,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get relatedOrderUuid => $composableBuilder(
      column: $table.relatedOrderUuid,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get relatedTableUuid => $composableBuilder(
      column: $table.relatedTableUuid,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get relatedCustomerUuid => $composableBuilder(
      column: $table.relatedCustomerUuid,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get actionLabel => $composableBuilder(
      column: $table.actionLabel, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get actionRoute => $composableBuilder(
      column: $table.actionRoute, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get expiresAt => $composableBuilder(
      column: $table.expiresAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get acknowledgedAt => $composableBuilder(
      column: $table.acknowledgedAt,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get acknowledgedByUuid => $composableBuilder(
      column: $table.acknowledgedByUuid,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get resolvedAt => $composableBuilder(
      column: $table.resolvedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get resolvedByUuid => $composableBuilder(
      column: $table.resolvedByUuid,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get playSound => $composableBuilder(
      column: $table.playSound, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get vibrate => $composableBuilder(
      column: $table.vibrate, builder: (column) => ColumnOrderings(column));
}

class $$StaffAlertTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $StaffAlertTableTable> {
  $$StaffAlertTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get type =>
      $composableBuilder(column: $table.type, builder: (column) => column);

  GeneratedColumn<String> get priority =>
      $composableBuilder(column: $table.priority, builder: (column) => column);

  GeneratedColumn<String> get title =>
      $composableBuilder(column: $table.title, builder: (column) => column);

  GeneratedColumn<String> get message =>
      $composableBuilder(column: $table.message, builder: (column) => column);

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<String> get targetRolesJson => $composableBuilder(
      column: $table.targetRolesJson, builder: (column) => column);

  GeneratedColumn<String> get targetUserUuidsJson => $composableBuilder(
      column: $table.targetUserUuidsJson, builder: (column) => column);

  GeneratedColumn<bool> get broadcastToAll => $composableBuilder(
      column: $table.broadcastToAll, builder: (column) => column);

  GeneratedColumn<String> get relatedOrderUuid => $composableBuilder(
      column: $table.relatedOrderUuid, builder: (column) => column);

  GeneratedColumn<String> get relatedTableUuid => $composableBuilder(
      column: $table.relatedTableUuid, builder: (column) => column);

  GeneratedColumn<String> get relatedCustomerUuid => $composableBuilder(
      column: $table.relatedCustomerUuid, builder: (column) => column);

  GeneratedColumn<String> get actionLabel => $composableBuilder(
      column: $table.actionLabel, builder: (column) => column);

  GeneratedColumn<String> get actionRoute => $composableBuilder(
      column: $table.actionRoute, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get expiresAt =>
      $composableBuilder(column: $table.expiresAt, builder: (column) => column);

  GeneratedColumn<DateTime> get acknowledgedAt => $composableBuilder(
      column: $table.acknowledgedAt, builder: (column) => column);

  GeneratedColumn<String> get acknowledgedByUuid => $composableBuilder(
      column: $table.acknowledgedByUuid, builder: (column) => column);

  GeneratedColumn<DateTime> get resolvedAt => $composableBuilder(
      column: $table.resolvedAt, builder: (column) => column);

  GeneratedColumn<String> get resolvedByUuid => $composableBuilder(
      column: $table.resolvedByUuid, builder: (column) => column);

  GeneratedColumn<bool> get playSound =>
      $composableBuilder(column: $table.playSound, builder: (column) => column);

  GeneratedColumn<bool> get vibrate =>
      $composableBuilder(column: $table.vibrate, builder: (column) => column);
}

class $$StaffAlertTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $StaffAlertTableTable,
    StaffAlertTableData,
    $$StaffAlertTableTableFilterComposer,
    $$StaffAlertTableTableOrderingComposer,
    $$StaffAlertTableTableAnnotationComposer,
    $$StaffAlertTableTableCreateCompanionBuilder,
    $$StaffAlertTableTableUpdateCompanionBuilder,
    (
      StaffAlertTableData,
      BaseReferences<_$AppDatabase, $StaffAlertTableTable, StaffAlertTableData>
    ),
    StaffAlertTableData,
    PrefetchHooks Function()> {
  $$StaffAlertTableTableTableManager(
      _$AppDatabase db, $StaffAlertTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$StaffAlertTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$StaffAlertTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$StaffAlertTableTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String> type = const Value.absent(),
            Value<String> priority = const Value.absent(),
            Value<String> title = const Value.absent(),
            Value<String> message = const Value.absent(),
            Value<String> status = const Value.absent(),
            Value<String> targetRolesJson = const Value.absent(),
            Value<String> targetUserUuidsJson = const Value.absent(),
            Value<bool> broadcastToAll = const Value.absent(),
            Value<String?> relatedOrderUuid = const Value.absent(),
            Value<String?> relatedTableUuid = const Value.absent(),
            Value<String?> relatedCustomerUuid = const Value.absent(),
            Value<String?> actionLabel = const Value.absent(),
            Value<String?> actionRoute = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<DateTime?> expiresAt = const Value.absent(),
            Value<DateTime?> acknowledgedAt = const Value.absent(),
            Value<String?> acknowledgedByUuid = const Value.absent(),
            Value<DateTime?> resolvedAt = const Value.absent(),
            Value<String?> resolvedByUuid = const Value.absent(),
            Value<bool> playSound = const Value.absent(),
            Value<bool> vibrate = const Value.absent(),
          }) =>
              StaffAlertTableCompanion(
            id: id,
            uuid: uuid,
            type: type,
            priority: priority,
            title: title,
            message: message,
            status: status,
            targetRolesJson: targetRolesJson,
            targetUserUuidsJson: targetUserUuidsJson,
            broadcastToAll: broadcastToAll,
            relatedOrderUuid: relatedOrderUuid,
            relatedTableUuid: relatedTableUuid,
            relatedCustomerUuid: relatedCustomerUuid,
            actionLabel: actionLabel,
            actionRoute: actionRoute,
            createdAt: createdAt,
            expiresAt: expiresAt,
            acknowledgedAt: acknowledgedAt,
            acknowledgedByUuid: acknowledgedByUuid,
            resolvedAt: resolvedAt,
            resolvedByUuid: resolvedByUuid,
            playSound: playSound,
            vibrate: vibrate,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            required String type,
            required String priority,
            required String title,
            required String message,
            Value<String> status = const Value.absent(),
            Value<String> targetRolesJson = const Value.absent(),
            Value<String> targetUserUuidsJson = const Value.absent(),
            Value<bool> broadcastToAll = const Value.absent(),
            Value<String?> relatedOrderUuid = const Value.absent(),
            Value<String?> relatedTableUuid = const Value.absent(),
            Value<String?> relatedCustomerUuid = const Value.absent(),
            Value<String?> actionLabel = const Value.absent(),
            Value<String?> actionRoute = const Value.absent(),
            required DateTime createdAt,
            Value<DateTime?> expiresAt = const Value.absent(),
            Value<DateTime?> acknowledgedAt = const Value.absent(),
            Value<String?> acknowledgedByUuid = const Value.absent(),
            Value<DateTime?> resolvedAt = const Value.absent(),
            Value<String?> resolvedByUuid = const Value.absent(),
            Value<bool> playSound = const Value.absent(),
            Value<bool> vibrate = const Value.absent(),
          }) =>
              StaffAlertTableCompanion.insert(
            id: id,
            uuid: uuid,
            type: type,
            priority: priority,
            title: title,
            message: message,
            status: status,
            targetRolesJson: targetRolesJson,
            targetUserUuidsJson: targetUserUuidsJson,
            broadcastToAll: broadcastToAll,
            relatedOrderUuid: relatedOrderUuid,
            relatedTableUuid: relatedTableUuid,
            relatedCustomerUuid: relatedCustomerUuid,
            actionLabel: actionLabel,
            actionRoute: actionRoute,
            createdAt: createdAt,
            expiresAt: expiresAt,
            acknowledgedAt: acknowledgedAt,
            acknowledgedByUuid: acknowledgedByUuid,
            resolvedAt: resolvedAt,
            resolvedByUuid: resolvedByUuid,
            playSound: playSound,
            vibrate: vibrate,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$StaffAlertTableTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $StaffAlertTableTable,
    StaffAlertTableData,
    $$StaffAlertTableTableFilterComposer,
    $$StaffAlertTableTableOrderingComposer,
    $$StaffAlertTableTableAnnotationComposer,
    $$StaffAlertTableTableCreateCompanionBuilder,
    $$StaffAlertTableTableUpdateCompanionBuilder,
    (
      StaffAlertTableData,
      BaseReferences<_$AppDatabase, $StaffAlertTableTable, StaffAlertTableData>
    ),
    StaffAlertTableData,
    PrefetchHooks Function()>;
typedef $$KitchenTicketTableTableCreateCompanionBuilder
    = KitchenTicketTableCompanion Function({
  Value<int> id,
  required String uuid,
  required String orderUuid,
  required String orderNumber,
  Value<String?> tableUuid,
  Value<String?> guestTableName,
  Value<String?> serverName,
  Value<String> status,
  required DateTime firedAt,
  Value<DateTime?> startedAt,
  Value<DateTime?> completedAt,
  Value<DateTime?> targetTime,
  Value<String?> note,
  Value<bool> isRush,
});
typedef $$KitchenTicketTableTableUpdateCompanionBuilder
    = KitchenTicketTableCompanion Function({
  Value<int> id,
  Value<String> uuid,
  Value<String> orderUuid,
  Value<String> orderNumber,
  Value<String?> tableUuid,
  Value<String?> guestTableName,
  Value<String?> serverName,
  Value<String> status,
  Value<DateTime> firedAt,
  Value<DateTime?> startedAt,
  Value<DateTime?> completedAt,
  Value<DateTime?> targetTime,
  Value<String?> note,
  Value<bool> isRush,
});

final class $$KitchenTicketTableTableReferences extends BaseReferences<
    _$AppDatabase, $KitchenTicketTableTable, KitchenTicketTableData> {
  $$KitchenTicketTableTableReferences(
      super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$KitchenItemTableTable, List<KitchenItemTableData>>
      _kitchenItemTableRefsTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.kitchenItemTable,
              aliasName: $_aliasNameGenerator(
                  db.kitchenTicketTable.uuid, db.kitchenItemTable.ticketUuid));

  $$KitchenItemTableTableProcessedTableManager get kitchenItemTableRefs {
    final manager =
        $$KitchenItemTableTableTableManager($_db, $_db.kitchenItemTable).filter(
            (f) => f.ticketUuid.uuid.sqlEquals($_itemColumn<String>('uuid')!));

    final cache =
        $_typedResult.readTableOrNull(_kitchenItemTableRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $$KitchenTicketTableTableFilterComposer
    extends Composer<_$AppDatabase, $KitchenTicketTableTable> {
  $$KitchenTicketTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get orderUuid => $composableBuilder(
      column: $table.orderUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get orderNumber => $composableBuilder(
      column: $table.orderNumber, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get tableUuid => $composableBuilder(
      column: $table.tableUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get guestTableName => $composableBuilder(
      column: $table.guestTableName,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get serverName => $composableBuilder(
      column: $table.serverName, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get firedAt => $composableBuilder(
      column: $table.firedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get startedAt => $composableBuilder(
      column: $table.startedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get completedAt => $composableBuilder(
      column: $table.completedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get targetTime => $composableBuilder(
      column: $table.targetTime, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get note => $composableBuilder(
      column: $table.note, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isRush => $composableBuilder(
      column: $table.isRush, builder: (column) => ColumnFilters(column));

  Expression<bool> kitchenItemTableRefs(
      Expression<bool> Function($$KitchenItemTableTableFilterComposer f) f) {
    final $$KitchenItemTableTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.uuid,
        referencedTable: $db.kitchenItemTable,
        getReferencedColumn: (t) => t.ticketUuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$KitchenItemTableTableFilterComposer(
              $db: $db,
              $table: $db.kitchenItemTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$KitchenTicketTableTableOrderingComposer
    extends Composer<_$AppDatabase, $KitchenTicketTableTable> {
  $$KitchenTicketTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get orderUuid => $composableBuilder(
      column: $table.orderUuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get orderNumber => $composableBuilder(
      column: $table.orderNumber, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get tableUuid => $composableBuilder(
      column: $table.tableUuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get guestTableName => $composableBuilder(
      column: $table.guestTableName,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get serverName => $composableBuilder(
      column: $table.serverName, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get firedAt => $composableBuilder(
      column: $table.firedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get startedAt => $composableBuilder(
      column: $table.startedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get completedAt => $composableBuilder(
      column: $table.completedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get targetTime => $composableBuilder(
      column: $table.targetTime, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get note => $composableBuilder(
      column: $table.note, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isRush => $composableBuilder(
      column: $table.isRush, builder: (column) => ColumnOrderings(column));
}

class $$KitchenTicketTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $KitchenTicketTableTable> {
  $$KitchenTicketTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get orderUuid =>
      $composableBuilder(column: $table.orderUuid, builder: (column) => column);

  GeneratedColumn<String> get orderNumber => $composableBuilder(
      column: $table.orderNumber, builder: (column) => column);

  GeneratedColumn<String> get tableUuid =>
      $composableBuilder(column: $table.tableUuid, builder: (column) => column);

  GeneratedColumn<String> get guestTableName => $composableBuilder(
      column: $table.guestTableName, builder: (column) => column);

  GeneratedColumn<String> get serverName => $composableBuilder(
      column: $table.serverName, builder: (column) => column);

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<DateTime> get firedAt =>
      $composableBuilder(column: $table.firedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get startedAt =>
      $composableBuilder(column: $table.startedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get completedAt => $composableBuilder(
      column: $table.completedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get targetTime => $composableBuilder(
      column: $table.targetTime, builder: (column) => column);

  GeneratedColumn<String> get note =>
      $composableBuilder(column: $table.note, builder: (column) => column);

  GeneratedColumn<bool> get isRush =>
      $composableBuilder(column: $table.isRush, builder: (column) => column);

  Expression<T> kitchenItemTableRefs<T extends Object>(
      Expression<T> Function($$KitchenItemTableTableAnnotationComposer a) f) {
    final $$KitchenItemTableTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.uuid,
        referencedTable: $db.kitchenItemTable,
        getReferencedColumn: (t) => t.ticketUuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$KitchenItemTableTableAnnotationComposer(
              $db: $db,
              $table: $db.kitchenItemTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$KitchenTicketTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $KitchenTicketTableTable,
    KitchenTicketTableData,
    $$KitchenTicketTableTableFilterComposer,
    $$KitchenTicketTableTableOrderingComposer,
    $$KitchenTicketTableTableAnnotationComposer,
    $$KitchenTicketTableTableCreateCompanionBuilder,
    $$KitchenTicketTableTableUpdateCompanionBuilder,
    (KitchenTicketTableData, $$KitchenTicketTableTableReferences),
    KitchenTicketTableData,
    PrefetchHooks Function({bool kitchenItemTableRefs})> {
  $$KitchenTicketTableTableTableManager(
      _$AppDatabase db, $KitchenTicketTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$KitchenTicketTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$KitchenTicketTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$KitchenTicketTableTableAnnotationComposer(
                  $db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String> orderUuid = const Value.absent(),
            Value<String> orderNumber = const Value.absent(),
            Value<String?> tableUuid = const Value.absent(),
            Value<String?> guestTableName = const Value.absent(),
            Value<String?> serverName = const Value.absent(),
            Value<String> status = const Value.absent(),
            Value<DateTime> firedAt = const Value.absent(),
            Value<DateTime?> startedAt = const Value.absent(),
            Value<DateTime?> completedAt = const Value.absent(),
            Value<DateTime?> targetTime = const Value.absent(),
            Value<String?> note = const Value.absent(),
            Value<bool> isRush = const Value.absent(),
          }) =>
              KitchenTicketTableCompanion(
            id: id,
            uuid: uuid,
            orderUuid: orderUuid,
            orderNumber: orderNumber,
            tableUuid: tableUuid,
            guestTableName: guestTableName,
            serverName: serverName,
            status: status,
            firedAt: firedAt,
            startedAt: startedAt,
            completedAt: completedAt,
            targetTime: targetTime,
            note: note,
            isRush: isRush,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            required String orderUuid,
            required String orderNumber,
            Value<String?> tableUuid = const Value.absent(),
            Value<String?> guestTableName = const Value.absent(),
            Value<String?> serverName = const Value.absent(),
            Value<String> status = const Value.absent(),
            required DateTime firedAt,
            Value<DateTime?> startedAt = const Value.absent(),
            Value<DateTime?> completedAt = const Value.absent(),
            Value<DateTime?> targetTime = const Value.absent(),
            Value<String?> note = const Value.absent(),
            Value<bool> isRush = const Value.absent(),
          }) =>
              KitchenTicketTableCompanion.insert(
            id: id,
            uuid: uuid,
            orderUuid: orderUuid,
            orderNumber: orderNumber,
            tableUuid: tableUuid,
            guestTableName: guestTableName,
            serverName: serverName,
            status: status,
            firedAt: firedAt,
            startedAt: startedAt,
            completedAt: completedAt,
            targetTime: targetTime,
            note: note,
            isRush: isRush,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$KitchenTicketTableTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: ({kitchenItemTableRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (kitchenItemTableRefs) db.kitchenItemTable
              ],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (kitchenItemTableRefs)
                    await $_getPrefetchedData<KitchenTicketTableData,
                            $KitchenTicketTableTable, KitchenItemTableData>(
                        currentTable: table,
                        referencedTable: $$KitchenTicketTableTableReferences
                            ._kitchenItemTableRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$KitchenTicketTableTableReferences(db, table, p0)
                                .kitchenItemTableRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.ticketUuid == item.uuid),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $$KitchenTicketTableTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $KitchenTicketTableTable,
    KitchenTicketTableData,
    $$KitchenTicketTableTableFilterComposer,
    $$KitchenTicketTableTableOrderingComposer,
    $$KitchenTicketTableTableAnnotationComposer,
    $$KitchenTicketTableTableCreateCompanionBuilder,
    $$KitchenTicketTableTableUpdateCompanionBuilder,
    (KitchenTicketTableData, $$KitchenTicketTableTableReferences),
    KitchenTicketTableData,
    PrefetchHooks Function({bool kitchenItemTableRefs})>;
typedef $$KitchenItemTableTableCreateCompanionBuilder
    = KitchenItemTableCompanion Function({
  Value<int> id,
  required String uuid,
  required String ticketUuid,
  required String orderItemUuid,
  required String name,
  required int quantity,
  Value<String> modifiersJson,
  Value<String?> note,
  Value<String> course,
  Value<String> status,
});
typedef $$KitchenItemTableTableUpdateCompanionBuilder
    = KitchenItemTableCompanion Function({
  Value<int> id,
  Value<String> uuid,
  Value<String> ticketUuid,
  Value<String> orderItemUuid,
  Value<String> name,
  Value<int> quantity,
  Value<String> modifiersJson,
  Value<String?> note,
  Value<String> course,
  Value<String> status,
});

final class $$KitchenItemTableTableReferences extends BaseReferences<
    _$AppDatabase, $KitchenItemTableTable, KitchenItemTableData> {
  $$KitchenItemTableTableReferences(
      super.$_db, super.$_table, super.$_typedResult);

  static $KitchenTicketTableTable _ticketUuidTable(_$AppDatabase db) =>
      db.kitchenTicketTable.createAlias($_aliasNameGenerator(
          db.kitchenItemTable.ticketUuid, db.kitchenTicketTable.uuid));

  $$KitchenTicketTableTableProcessedTableManager get ticketUuid {
    final $_column = $_itemColumn<String>('ticket_uuid')!;

    final manager =
        $$KitchenTicketTableTableTableManager($_db, $_db.kitchenTicketTable)
            .filter((f) => f.uuid.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_ticketUuidTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }
}

class $$KitchenItemTableTableFilterComposer
    extends Composer<_$AppDatabase, $KitchenItemTableTable> {
  $$KitchenItemTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get orderItemUuid => $composableBuilder(
      column: $table.orderItemUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get quantity => $composableBuilder(
      column: $table.quantity, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get modifiersJson => $composableBuilder(
      column: $table.modifiersJson, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get note => $composableBuilder(
      column: $table.note, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get course => $composableBuilder(
      column: $table.course, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnFilters(column));

  $$KitchenTicketTableTableFilterComposer get ticketUuid {
    final $$KitchenTicketTableTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.ticketUuid,
        referencedTable: $db.kitchenTicketTable,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$KitchenTicketTableTableFilterComposer(
              $db: $db,
              $table: $db.kitchenTicketTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$KitchenItemTableTableOrderingComposer
    extends Composer<_$AppDatabase, $KitchenItemTableTable> {
  $$KitchenItemTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get orderItemUuid => $composableBuilder(
      column: $table.orderItemUuid,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get quantity => $composableBuilder(
      column: $table.quantity, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get modifiersJson => $composableBuilder(
      column: $table.modifiersJson,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get note => $composableBuilder(
      column: $table.note, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get course => $composableBuilder(
      column: $table.course, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnOrderings(column));

  $$KitchenTicketTableTableOrderingComposer get ticketUuid {
    final $$KitchenTicketTableTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.ticketUuid,
        referencedTable: $db.kitchenTicketTable,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$KitchenTicketTableTableOrderingComposer(
              $db: $db,
              $table: $db.kitchenTicketTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$KitchenItemTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $KitchenItemTableTable> {
  $$KitchenItemTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get orderItemUuid => $composableBuilder(
      column: $table.orderItemUuid, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<int> get quantity =>
      $composableBuilder(column: $table.quantity, builder: (column) => column);

  GeneratedColumn<String> get modifiersJson => $composableBuilder(
      column: $table.modifiersJson, builder: (column) => column);

  GeneratedColumn<String> get note =>
      $composableBuilder(column: $table.note, builder: (column) => column);

  GeneratedColumn<String> get course =>
      $composableBuilder(column: $table.course, builder: (column) => column);

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  $$KitchenTicketTableTableAnnotationComposer get ticketUuid {
    final $$KitchenTicketTableTableAnnotationComposer composer =
        $composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.ticketUuid,
            referencedTable: $db.kitchenTicketTable,
            getReferencedColumn: (t) => t.uuid,
            builder: (joinBuilder,
                    {$addJoinBuilderToRootComposer,
                    $removeJoinBuilderFromRootComposer}) =>
                $$KitchenTicketTableTableAnnotationComposer(
                  $db: $db,
                  $table: $db.kitchenTicketTable,
                  $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                  joinBuilder: joinBuilder,
                  $removeJoinBuilderFromRootComposer:
                      $removeJoinBuilderFromRootComposer,
                ));
    return composer;
  }
}

class $$KitchenItemTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $KitchenItemTableTable,
    KitchenItemTableData,
    $$KitchenItemTableTableFilterComposer,
    $$KitchenItemTableTableOrderingComposer,
    $$KitchenItemTableTableAnnotationComposer,
    $$KitchenItemTableTableCreateCompanionBuilder,
    $$KitchenItemTableTableUpdateCompanionBuilder,
    (KitchenItemTableData, $$KitchenItemTableTableReferences),
    KitchenItemTableData,
    PrefetchHooks Function({bool ticketUuid})> {
  $$KitchenItemTableTableTableManager(
      _$AppDatabase db, $KitchenItemTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$KitchenItemTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$KitchenItemTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$KitchenItemTableTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String> ticketUuid = const Value.absent(),
            Value<String> orderItemUuid = const Value.absent(),
            Value<String> name = const Value.absent(),
            Value<int> quantity = const Value.absent(),
            Value<String> modifiersJson = const Value.absent(),
            Value<String?> note = const Value.absent(),
            Value<String> course = const Value.absent(),
            Value<String> status = const Value.absent(),
          }) =>
              KitchenItemTableCompanion(
            id: id,
            uuid: uuid,
            ticketUuid: ticketUuid,
            orderItemUuid: orderItemUuid,
            name: name,
            quantity: quantity,
            modifiersJson: modifiersJson,
            note: note,
            course: course,
            status: status,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            required String ticketUuid,
            required String orderItemUuid,
            required String name,
            required int quantity,
            Value<String> modifiersJson = const Value.absent(),
            Value<String?> note = const Value.absent(),
            Value<String> course = const Value.absent(),
            Value<String> status = const Value.absent(),
          }) =>
              KitchenItemTableCompanion.insert(
            id: id,
            uuid: uuid,
            ticketUuid: ticketUuid,
            orderItemUuid: orderItemUuid,
            name: name,
            quantity: quantity,
            modifiersJson: modifiersJson,
            note: note,
            course: course,
            status: status,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$KitchenItemTableTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: ({ticketUuid = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (ticketUuid) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.ticketUuid,
                    referencedTable:
                        $$KitchenItemTableTableReferences._ticketUuidTable(db),
                    referencedColumn: $$KitchenItemTableTableReferences
                        ._ticketUuidTable(db)
                        .uuid,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ));
}

typedef $$KitchenItemTableTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $KitchenItemTableTable,
    KitchenItemTableData,
    $$KitchenItemTableTableFilterComposer,
    $$KitchenItemTableTableOrderingComposer,
    $$KitchenItemTableTableAnnotationComposer,
    $$KitchenItemTableTableCreateCompanionBuilder,
    $$KitchenItemTableTableUpdateCompanionBuilder,
    (KitchenItemTableData, $$KitchenItemTableTableReferences),
    KitchenItemTableData,
    PrefetchHooks Function({bool ticketUuid})>;
typedef $$CustomerFeedbackTableTableCreateCompanionBuilder
    = CustomerFeedbackTableCompanion Function({
  Value<int> id,
  required String uuid,
  required String orderUuid,
  Value<String?> customerUuid,
  required int rating,
  Value<String> sentiment,
  Value<String?> tags,
  Value<String?> comment,
  Value<bool> isActioned,
  required DateTime createdAt,
});
typedef $$CustomerFeedbackTableTableUpdateCompanionBuilder
    = CustomerFeedbackTableCompanion Function({
  Value<int> id,
  Value<String> uuid,
  Value<String> orderUuid,
  Value<String?> customerUuid,
  Value<int> rating,
  Value<String> sentiment,
  Value<String?> tags,
  Value<String?> comment,
  Value<bool> isActioned,
  Value<DateTime> createdAt,
});

final class $$CustomerFeedbackTableTableReferences extends BaseReferences<
    _$AppDatabase, $CustomerFeedbackTableTable, CustomerFeedbackTableData> {
  $$CustomerFeedbackTableTableReferences(
      super.$_db, super.$_table, super.$_typedResult);

  static $OrderTableTable _orderUuidTable(_$AppDatabase db) =>
      db.orderTable.createAlias($_aliasNameGenerator(
          db.customerFeedbackTable.orderUuid, db.orderTable.uuid));

  $$OrderTableTableProcessedTableManager get orderUuid {
    final $_column = $_itemColumn<String>('order_uuid')!;

    final manager = $$OrderTableTableTableManager($_db, $_db.orderTable)
        .filter((f) => f.uuid.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_orderUuidTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static $CustomerTableTable _customerUuidTable(_$AppDatabase db) =>
      db.customerTable.createAlias($_aliasNameGenerator(
          db.customerFeedbackTable.customerUuid, db.customerTable.uuid));

  $$CustomerTableTableProcessedTableManager? get customerUuid {
    final $_column = $_itemColumn<String>('customer_uuid');
    if ($_column == null) return null;
    final manager = $$CustomerTableTableTableManager($_db, $_db.customerTable)
        .filter((f) => f.uuid.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_customerUuidTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }
}

class $$CustomerFeedbackTableTableFilterComposer
    extends Composer<_$AppDatabase, $CustomerFeedbackTableTable> {
  $$CustomerFeedbackTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get rating => $composableBuilder(
      column: $table.rating, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get sentiment => $composableBuilder(
      column: $table.sentiment, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get tags => $composableBuilder(
      column: $table.tags, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get comment => $composableBuilder(
      column: $table.comment, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isActioned => $composableBuilder(
      column: $table.isActioned, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  $$OrderTableTableFilterComposer get orderUuid {
    final $$OrderTableTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.orderUuid,
        referencedTable: $db.orderTable,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$OrderTableTableFilterComposer(
              $db: $db,
              $table: $db.orderTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$CustomerTableTableFilterComposer get customerUuid {
    final $$CustomerTableTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.customerUuid,
        referencedTable: $db.customerTable,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$CustomerTableTableFilterComposer(
              $db: $db,
              $table: $db.customerTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$CustomerFeedbackTableTableOrderingComposer
    extends Composer<_$AppDatabase, $CustomerFeedbackTableTable> {
  $$CustomerFeedbackTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get rating => $composableBuilder(
      column: $table.rating, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get sentiment => $composableBuilder(
      column: $table.sentiment, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get tags => $composableBuilder(
      column: $table.tags, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get comment => $composableBuilder(
      column: $table.comment, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isActioned => $composableBuilder(
      column: $table.isActioned, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  $$OrderTableTableOrderingComposer get orderUuid {
    final $$OrderTableTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.orderUuid,
        referencedTable: $db.orderTable,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$OrderTableTableOrderingComposer(
              $db: $db,
              $table: $db.orderTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$CustomerTableTableOrderingComposer get customerUuid {
    final $$CustomerTableTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.customerUuid,
        referencedTable: $db.customerTable,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$CustomerTableTableOrderingComposer(
              $db: $db,
              $table: $db.customerTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$CustomerFeedbackTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $CustomerFeedbackTableTable> {
  $$CustomerFeedbackTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<int> get rating =>
      $composableBuilder(column: $table.rating, builder: (column) => column);

  GeneratedColumn<String> get sentiment =>
      $composableBuilder(column: $table.sentiment, builder: (column) => column);

  GeneratedColumn<String> get tags =>
      $composableBuilder(column: $table.tags, builder: (column) => column);

  GeneratedColumn<String> get comment =>
      $composableBuilder(column: $table.comment, builder: (column) => column);

  GeneratedColumn<bool> get isActioned => $composableBuilder(
      column: $table.isActioned, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  $$OrderTableTableAnnotationComposer get orderUuid {
    final $$OrderTableTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.orderUuid,
        referencedTable: $db.orderTable,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$OrderTableTableAnnotationComposer(
              $db: $db,
              $table: $db.orderTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$CustomerTableTableAnnotationComposer get customerUuid {
    final $$CustomerTableTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.customerUuid,
        referencedTable: $db.customerTable,
        getReferencedColumn: (t) => t.uuid,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$CustomerTableTableAnnotationComposer(
              $db: $db,
              $table: $db.customerTable,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$CustomerFeedbackTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $CustomerFeedbackTableTable,
    CustomerFeedbackTableData,
    $$CustomerFeedbackTableTableFilterComposer,
    $$CustomerFeedbackTableTableOrderingComposer,
    $$CustomerFeedbackTableTableAnnotationComposer,
    $$CustomerFeedbackTableTableCreateCompanionBuilder,
    $$CustomerFeedbackTableTableUpdateCompanionBuilder,
    (CustomerFeedbackTableData, $$CustomerFeedbackTableTableReferences),
    CustomerFeedbackTableData,
    PrefetchHooks Function({bool orderUuid, bool customerUuid})> {
  $$CustomerFeedbackTableTableTableManager(
      _$AppDatabase db, $CustomerFeedbackTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$CustomerFeedbackTableTableFilterComposer(
                  $db: db, $table: table),
          createOrderingComposer: () =>
              $$CustomerFeedbackTableTableOrderingComposer(
                  $db: db, $table: table),
          createComputedFieldComposer: () =>
              $$CustomerFeedbackTableTableAnnotationComposer(
                  $db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String> orderUuid = const Value.absent(),
            Value<String?> customerUuid = const Value.absent(),
            Value<int> rating = const Value.absent(),
            Value<String> sentiment = const Value.absent(),
            Value<String?> tags = const Value.absent(),
            Value<String?> comment = const Value.absent(),
            Value<bool> isActioned = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
          }) =>
              CustomerFeedbackTableCompanion(
            id: id,
            uuid: uuid,
            orderUuid: orderUuid,
            customerUuid: customerUuid,
            rating: rating,
            sentiment: sentiment,
            tags: tags,
            comment: comment,
            isActioned: isActioned,
            createdAt: createdAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            required String orderUuid,
            Value<String?> customerUuid = const Value.absent(),
            required int rating,
            Value<String> sentiment = const Value.absent(),
            Value<String?> tags = const Value.absent(),
            Value<String?> comment = const Value.absent(),
            Value<bool> isActioned = const Value.absent(),
            required DateTime createdAt,
          }) =>
              CustomerFeedbackTableCompanion.insert(
            id: id,
            uuid: uuid,
            orderUuid: orderUuid,
            customerUuid: customerUuid,
            rating: rating,
            sentiment: sentiment,
            tags: tags,
            comment: comment,
            isActioned: isActioned,
            createdAt: createdAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$CustomerFeedbackTableTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: ({orderUuid = false, customerUuid = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (orderUuid) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.orderUuid,
                    referencedTable: $$CustomerFeedbackTableTableReferences
                        ._orderUuidTable(db),
                    referencedColumn: $$CustomerFeedbackTableTableReferences
                        ._orderUuidTable(db)
                        .uuid,
                  ) as T;
                }
                if (customerUuid) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.customerUuid,
                    referencedTable: $$CustomerFeedbackTableTableReferences
                        ._customerUuidTable(db),
                    referencedColumn: $$CustomerFeedbackTableTableReferences
                        ._customerUuidTable(db)
                        .uuid,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ));
}

typedef $$CustomerFeedbackTableTableProcessedTableManager
    = ProcessedTableManager<
        _$AppDatabase,
        $CustomerFeedbackTableTable,
        CustomerFeedbackTableData,
        $$CustomerFeedbackTableTableFilterComposer,
        $$CustomerFeedbackTableTableOrderingComposer,
        $$CustomerFeedbackTableTableAnnotationComposer,
        $$CustomerFeedbackTableTableCreateCompanionBuilder,
        $$CustomerFeedbackTableTableUpdateCompanionBuilder,
        (CustomerFeedbackTableData, $$CustomerFeedbackTableTableReferences),
        CustomerFeedbackTableData,
        PrefetchHooks Function({bool orderUuid, bool customerUuid})>;
typedef $$AuditLogTableTableCreateCompanionBuilder = AuditLogTableCompanion
    Function({
  Value<int> id,
  required DateTime timestamp,
  required String cashierId,
  required String cashierName,
  required String supervisorId,
  required String supervisorName,
  required String supervisorRole,
  required String action,
  Value<String?> orderUuid,
  Value<String?> orderItemUuid,
  required String detail,
  Value<String?> shiftSessionUuid,
  Value<String?> stationId,
  Value<bool> isSynced,
});
typedef $$AuditLogTableTableUpdateCompanionBuilder = AuditLogTableCompanion
    Function({
  Value<int> id,
  Value<DateTime> timestamp,
  Value<String> cashierId,
  Value<String> cashierName,
  Value<String> supervisorId,
  Value<String> supervisorName,
  Value<String> supervisorRole,
  Value<String> action,
  Value<String?> orderUuid,
  Value<String?> orderItemUuid,
  Value<String> detail,
  Value<String?> shiftSessionUuid,
  Value<String?> stationId,
  Value<bool> isSynced,
});

class $$AuditLogTableTableFilterComposer
    extends Composer<_$AppDatabase, $AuditLogTableTable> {
  $$AuditLogTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get timestamp => $composableBuilder(
      column: $table.timestamp, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get cashierId => $composableBuilder(
      column: $table.cashierId, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get cashierName => $composableBuilder(
      column: $table.cashierName, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get supervisorId => $composableBuilder(
      column: $table.supervisorId, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get supervisorName => $composableBuilder(
      column: $table.supervisorName,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get supervisorRole => $composableBuilder(
      column: $table.supervisorRole,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get action => $composableBuilder(
      column: $table.action, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get orderUuid => $composableBuilder(
      column: $table.orderUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get orderItemUuid => $composableBuilder(
      column: $table.orderItemUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get detail => $composableBuilder(
      column: $table.detail, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get shiftSessionUuid => $composableBuilder(
      column: $table.shiftSessionUuid,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get stationId => $composableBuilder(
      column: $table.stationId, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isSynced => $composableBuilder(
      column: $table.isSynced, builder: (column) => ColumnFilters(column));
}

class $$AuditLogTableTableOrderingComposer
    extends Composer<_$AppDatabase, $AuditLogTableTable> {
  $$AuditLogTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get timestamp => $composableBuilder(
      column: $table.timestamp, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get cashierId => $composableBuilder(
      column: $table.cashierId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get cashierName => $composableBuilder(
      column: $table.cashierName, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get supervisorId => $composableBuilder(
      column: $table.supervisorId,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get supervisorName => $composableBuilder(
      column: $table.supervisorName,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get supervisorRole => $composableBuilder(
      column: $table.supervisorRole,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get action => $composableBuilder(
      column: $table.action, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get orderUuid => $composableBuilder(
      column: $table.orderUuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get orderItemUuid => $composableBuilder(
      column: $table.orderItemUuid,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get detail => $composableBuilder(
      column: $table.detail, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get shiftSessionUuid => $composableBuilder(
      column: $table.shiftSessionUuid,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get stationId => $composableBuilder(
      column: $table.stationId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isSynced => $composableBuilder(
      column: $table.isSynced, builder: (column) => ColumnOrderings(column));
}

class $$AuditLogTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $AuditLogTableTable> {
  $$AuditLogTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<DateTime> get timestamp =>
      $composableBuilder(column: $table.timestamp, builder: (column) => column);

  GeneratedColumn<String> get cashierId =>
      $composableBuilder(column: $table.cashierId, builder: (column) => column);

  GeneratedColumn<String> get cashierName => $composableBuilder(
      column: $table.cashierName, builder: (column) => column);

  GeneratedColumn<String> get supervisorId => $composableBuilder(
      column: $table.supervisorId, builder: (column) => column);

  GeneratedColumn<String> get supervisorName => $composableBuilder(
      column: $table.supervisorName, builder: (column) => column);

  GeneratedColumn<String> get supervisorRole => $composableBuilder(
      column: $table.supervisorRole, builder: (column) => column);

  GeneratedColumn<String> get action =>
      $composableBuilder(column: $table.action, builder: (column) => column);

  GeneratedColumn<String> get orderUuid =>
      $composableBuilder(column: $table.orderUuid, builder: (column) => column);

  GeneratedColumn<String> get orderItemUuid => $composableBuilder(
      column: $table.orderItemUuid, builder: (column) => column);

  GeneratedColumn<String> get detail =>
      $composableBuilder(column: $table.detail, builder: (column) => column);

  GeneratedColumn<String> get shiftSessionUuid => $composableBuilder(
      column: $table.shiftSessionUuid, builder: (column) => column);

  GeneratedColumn<String> get stationId =>
      $composableBuilder(column: $table.stationId, builder: (column) => column);

  GeneratedColumn<bool> get isSynced =>
      $composableBuilder(column: $table.isSynced, builder: (column) => column);
}

class $$AuditLogTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $AuditLogTableTable,
    AuditLogTableData,
    $$AuditLogTableTableFilterComposer,
    $$AuditLogTableTableOrderingComposer,
    $$AuditLogTableTableAnnotationComposer,
    $$AuditLogTableTableCreateCompanionBuilder,
    $$AuditLogTableTableUpdateCompanionBuilder,
    (
      AuditLogTableData,
      BaseReferences<_$AppDatabase, $AuditLogTableTable, AuditLogTableData>
    ),
    AuditLogTableData,
    PrefetchHooks Function()> {
  $$AuditLogTableTableTableManager(_$AppDatabase db, $AuditLogTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$AuditLogTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$AuditLogTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$AuditLogTableTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<DateTime> timestamp = const Value.absent(),
            Value<String> cashierId = const Value.absent(),
            Value<String> cashierName = const Value.absent(),
            Value<String> supervisorId = const Value.absent(),
            Value<String> supervisorName = const Value.absent(),
            Value<String> supervisorRole = const Value.absent(),
            Value<String> action = const Value.absent(),
            Value<String?> orderUuid = const Value.absent(),
            Value<String?> orderItemUuid = const Value.absent(),
            Value<String> detail = const Value.absent(),
            Value<String?> shiftSessionUuid = const Value.absent(),
            Value<String?> stationId = const Value.absent(),
            Value<bool> isSynced = const Value.absent(),
          }) =>
              AuditLogTableCompanion(
            id: id,
            timestamp: timestamp,
            cashierId: cashierId,
            cashierName: cashierName,
            supervisorId: supervisorId,
            supervisorName: supervisorName,
            supervisorRole: supervisorRole,
            action: action,
            orderUuid: orderUuid,
            orderItemUuid: orderItemUuid,
            detail: detail,
            shiftSessionUuid: shiftSessionUuid,
            stationId: stationId,
            isSynced: isSynced,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required DateTime timestamp,
            required String cashierId,
            required String cashierName,
            required String supervisorId,
            required String supervisorName,
            required String supervisorRole,
            required String action,
            Value<String?> orderUuid = const Value.absent(),
            Value<String?> orderItemUuid = const Value.absent(),
            required String detail,
            Value<String?> shiftSessionUuid = const Value.absent(),
            Value<String?> stationId = const Value.absent(),
            Value<bool> isSynced = const Value.absent(),
          }) =>
              AuditLogTableCompanion.insert(
            id: id,
            timestamp: timestamp,
            cashierId: cashierId,
            cashierName: cashierName,
            supervisorId: supervisorId,
            supervisorName: supervisorName,
            supervisorRole: supervisorRole,
            action: action,
            orderUuid: orderUuid,
            orderItemUuid: orderItemUuid,
            detail: detail,
            shiftSessionUuid: shiftSessionUuid,
            stationId: stationId,
            isSynced: isSynced,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$AuditLogTableTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $AuditLogTableTable,
    AuditLogTableData,
    $$AuditLogTableTableFilterComposer,
    $$AuditLogTableTableOrderingComposer,
    $$AuditLogTableTableAnnotationComposer,
    $$AuditLogTableTableCreateCompanionBuilder,
    $$AuditLogTableTableUpdateCompanionBuilder,
    (
      AuditLogTableData,
      BaseReferences<_$AppDatabase, $AuditLogTableTable, AuditLogTableData>
    ),
    AuditLogTableData,
    PrefetchHooks Function()>;
typedef $$PrintJobTableTableCreateCompanionBuilder = PrintJobTableCompanion
    Function({
  Value<int> id,
  required String uuid,
  required String targetPrinterAddress,
  required String targetPrinterType,
  required Uint8List bytes,
  Value<String> status,
  required DateTime createdAt,
  Value<int> retryCount,
});
typedef $$PrintJobTableTableUpdateCompanionBuilder = PrintJobTableCompanion
    Function({
  Value<int> id,
  Value<String> uuid,
  Value<String> targetPrinterAddress,
  Value<String> targetPrinterType,
  Value<Uint8List> bytes,
  Value<String> status,
  Value<DateTime> createdAt,
  Value<int> retryCount,
});

class $$PrintJobTableTableFilterComposer
    extends Composer<_$AppDatabase, $PrintJobTableTable> {
  $$PrintJobTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get targetPrinterAddress => $composableBuilder(
      column: $table.targetPrinterAddress,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get targetPrinterType => $composableBuilder(
      column: $table.targetPrinterType,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<Uint8List> get bytes => $composableBuilder(
      column: $table.bytes, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get retryCount => $composableBuilder(
      column: $table.retryCount, builder: (column) => ColumnFilters(column));
}

class $$PrintJobTableTableOrderingComposer
    extends Composer<_$AppDatabase, $PrintJobTableTable> {
  $$PrintJobTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get targetPrinterAddress => $composableBuilder(
      column: $table.targetPrinterAddress,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get targetPrinterType => $composableBuilder(
      column: $table.targetPrinterType,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<Uint8List> get bytes => $composableBuilder(
      column: $table.bytes, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get retryCount => $composableBuilder(
      column: $table.retryCount, builder: (column) => ColumnOrderings(column));
}

class $$PrintJobTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $PrintJobTableTable> {
  $$PrintJobTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get targetPrinterAddress => $composableBuilder(
      column: $table.targetPrinterAddress, builder: (column) => column);

  GeneratedColumn<String> get targetPrinterType => $composableBuilder(
      column: $table.targetPrinterType, builder: (column) => column);

  GeneratedColumn<Uint8List> get bytes =>
      $composableBuilder(column: $table.bytes, builder: (column) => column);

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<int> get retryCount => $composableBuilder(
      column: $table.retryCount, builder: (column) => column);
}

class $$PrintJobTableTableTableManager extends RootTableManager<
    _$AppDatabase,
    $PrintJobTableTable,
    PrintJobTableData,
    $$PrintJobTableTableFilterComposer,
    $$PrintJobTableTableOrderingComposer,
    $$PrintJobTableTableAnnotationComposer,
    $$PrintJobTableTableCreateCompanionBuilder,
    $$PrintJobTableTableUpdateCompanionBuilder,
    (
      PrintJobTableData,
      BaseReferences<_$AppDatabase, $PrintJobTableTable, PrintJobTableData>
    ),
    PrintJobTableData,
    PrefetchHooks Function()> {
  $$PrintJobTableTableTableManager(_$AppDatabase db, $PrintJobTableTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$PrintJobTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$PrintJobTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$PrintJobTableTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String> targetPrinterAddress = const Value.absent(),
            Value<String> targetPrinterType = const Value.absent(),
            Value<Uint8List> bytes = const Value.absent(),
            Value<String> status = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<int> retryCount = const Value.absent(),
          }) =>
              PrintJobTableCompanion(
            id: id,
            uuid: uuid,
            targetPrinterAddress: targetPrinterAddress,
            targetPrinterType: targetPrinterType,
            bytes: bytes,
            status: status,
            createdAt: createdAt,
            retryCount: retryCount,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            required String targetPrinterAddress,
            required String targetPrinterType,
            required Uint8List bytes,
            Value<String> status = const Value.absent(),
            required DateTime createdAt,
            Value<int> retryCount = const Value.absent(),
          }) =>
              PrintJobTableCompanion.insert(
            id: id,
            uuid: uuid,
            targetPrinterAddress: targetPrinterAddress,
            targetPrinterType: targetPrinterType,
            bytes: bytes,
            status: status,
            createdAt: createdAt,
            retryCount: retryCount,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $$PrintJobTableTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $PrintJobTableTable,
    PrintJobTableData,
    $$PrintJobTableTableFilterComposer,
    $$PrintJobTableTableOrderingComposer,
    $$PrintJobTableTableAnnotationComposer,
    $$PrintJobTableTableCreateCompanionBuilder,
    $$PrintJobTableTableUpdateCompanionBuilder,
    (
      PrintJobTableData,
      BaseReferences<_$AppDatabase, $PrintJobTableTable, PrintJobTableData>
    ),
    PrintJobTableData,
    PrefetchHooks Function()>;

class $AppDatabaseManager {
  final _$AppDatabase _db;
  $AppDatabaseManager(this._db);
  $$ZoneTableTableTableManager get zoneTable =>
      $$ZoneTableTableTableManager(_db, _db.zoneTable);
  $$TenantConfigTableTableTableManager get tenantConfigTable =>
      $$TenantConfigTableTableTableManager(_db, _db.tenantConfigTable);
  $$RestaurantTableTableTableManager get restaurantTable =>
      $$RestaurantTableTableTableManager(_db, _db.restaurantTable);
  $$ReservationTableTableTableManager get reservationTable =>
      $$ReservationTableTableTableManager(_db, _db.reservationTable);
  $$EmployeeTableTableTableManager get employeeTable =>
      $$EmployeeTableTableTableManager(_db, _db.employeeTable);
  $$CategoryTableTableTableManager get categoryTable =>
      $$CategoryTableTableTableManager(_db, _db.categoryTable);
  $$ProductTableTableTableManager get productTable =>
      $$ProductTableTableTableManager(_db, _db.productTable);
  $$ModifierGroupTableTableTableManager get modifierGroupTable =>
      $$ModifierGroupTableTableTableManager(_db, _db.modifierGroupTable);
  $$ModifierItemTableTableTableManager get modifierItemTable =>
      $$ModifierItemTableTableTableManager(_db, _db.modifierItemTable);
  $$ProductModifierLinkTableTableTableManager get productModifierLinkTable =>
      $$ProductModifierLinkTableTableTableManager(
          _db, _db.productModifierLinkTable);
  $$IngredientTableTableTableManager get ingredientTable =>
      $$IngredientTableTableTableManager(_db, _db.ingredientTable);
  $$RecipeTableTableTableManager get recipeTable =>
      $$RecipeTableTableTableManager(_db, _db.recipeTable);
  $$CustomerTableTableTableManager get customerTable =>
      $$CustomerTableTableTableManager(_db, _db.customerTable);
  $$OrderTableTableTableManager get orderTable =>
      $$OrderTableTableTableManager(_db, _db.orderTable);
  $$OrderItemTableTableTableManager get orderItemTable =>
      $$OrderItemTableTableTableManager(_db, _db.orderItemTable);
  $$InventoryLedgerTableTableTableManager get inventoryLedgerTable =>
      $$InventoryLedgerTableTableTableManager(_db, _db.inventoryLedgerTable);
  $$InventoryCacheTableTableTableManager get inventoryCacheTable =>
      $$InventoryCacheTableTableTableManager(_db, _db.inventoryCacheTable);
  $$LocalStocksTableTableTableManager get localStocksTable =>
      $$LocalStocksTableTableTableManager(_db, _db.localStocksTable);
  $$SupplierTableTableTableManager get supplierTable =>
      $$SupplierTableTableTableManager(_db, _db.supplierTable);
  $$ProductSupplierTableTableTableManager get productSupplierTable =>
      $$ProductSupplierTableTableTableManager(_db, _db.productSupplierTable);
  $$PurchaseOrderTableTableTableManager get purchaseOrderTable =>
      $$PurchaseOrderTableTableTableManager(_db, _db.purchaseOrderTable);
  $$PurchaseOrderItemTableTableTableManager get purchaseOrderItemTable =>
      $$PurchaseOrderItemTableTableTableManager(
          _db, _db.purchaseOrderItemTable);
  $$ShiftSessionTableTableTableManager get shiftSessionTable =>
      $$ShiftSessionTableTableTableManager(_db, _db.shiftSessionTable);
  $$SyncQueueTableTableManager get syncQueue =>
      $$SyncQueueTableTableManager(_db, _db.syncQueue);
  $$CashTransactionTableTableTableManager get cashTransactionTable =>
      $$CashTransactionTableTableTableManager(_db, _db.cashTransactionTable);
  $$WasteTableTableTableManager get wasteTable =>
      $$WasteTableTableTableManager(_db, _db.wasteTable);
  $$MarketingCampaignTableTableTableManager get marketingCampaignTable =>
      $$MarketingCampaignTableTableTableManager(
          _db, _db.marketingCampaignTable);
  $$CampaignRunHistoryTableTableTableManager get campaignRunHistoryTable =>
      $$CampaignRunHistoryTableTableTableManager(
          _db, _db.campaignRunHistoryTable);
  $$DeliveryChannelTableTableTableManager get deliveryChannelTable =>
      $$DeliveryChannelTableTableTableManager(_db, _db.deliveryChannelTable);
  $$DeliveryOrderMetadataTableTableTableManager
      get deliveryOrderMetadataTable =>
          $$DeliveryOrderMetadataTableTableTableManager(
              _db, _db.deliveryOrderMetadataTable);
  $$CashDrawerTableTableTableManager get cashDrawerTable =>
      $$CashDrawerTableTableTableManager(_db, _db.cashDrawerTable);
  $$CashEventTableTableTableManager get cashEventTable =>
      $$CashEventTableTableTableManager(_db, _db.cashEventTable);
  $$CustomerNoteTableTableTableManager get customerNoteTable =>
      $$CustomerNoteTableTableTableManager(_db, _db.customerNoteTable);
  $$CustomerTagTableTableTableManager get customerTagTable =>
      $$CustomerTagTableTableTableManager(_db, _db.customerTagTable);
  $$PaymentTransactionTableTableTableManager get paymentTransactionTable =>
      $$PaymentTransactionTableTableTableManager(
          _db, _db.paymentTransactionTable);
  $$StockCountTableTableTableManager get stockCountTable =>
      $$StockCountTableTableTableManager(_db, _db.stockCountTable);
  $$StockCountItemTableTableTableManager get stockCountItemTable =>
      $$StockCountItemTableTableTableManager(_db, _db.stockCountItemTable);
  $$WarehouseTableTableTableManager get warehouseTable =>
      $$WarehouseTableTableTableManager(_db, _db.warehouseTable);
  $$StockLevelTableTableTableManager get stockLevelTable =>
      $$StockLevelTableTableTableManager(_db, _db.stockLevelTable);
  $$BatchTableTableTableManager get batchTable =>
      $$BatchTableTableTableManager(_db, _db.batchTable);
  $$StockAlertTableTableTableManager get stockAlertTable =>
      $$StockAlertTableTableTableManager(_db, _db.stockAlertTable);
  $$StockTransferTableTableTableManager get stockTransferTable =>
      $$StockTransferTableTableTableManager(_db, _db.stockTransferTable);
  $$StockTransferItemTableTableTableManager get stockTransferItemTable =>
      $$StockTransferItemTableTableTableManager(
          _db, _db.stockTransferItemTable);
  $$StockAlertConfigTableTableTableManager get stockAlertConfigTable =>
      $$StockAlertConfigTableTableTableManager(_db, _db.stockAlertConfigTable);
  $$StockMovementTableTableTableManager get stockMovementTable =>
      $$StockMovementTableTableTableManager(_db, _db.stockMovementTable);
  $$TimeEntryTableTableTableManager get timeEntryTable =>
      $$TimeEntryTableTableTableManager(_db, _db.timeEntryTable);
  $$ScheduledShiftTableTableTableManager get scheduledShiftTable =>
      $$ScheduledShiftTableTableTableManager(_db, _db.scheduledShiftTable);
  $$EmployeeExtendedTableTableTableManager get employeeExtendedTable =>
      $$EmployeeExtendedTableTableTableManager(_db, _db.employeeExtendedTable);
  $$GiftCardTableTableTableManager get giftCardTable =>
      $$GiftCardTableTableTableManager(_db, _db.giftCardTable);
  $$GiftCardTransactionTableTableTableManager get giftCardTransactionTable =>
      $$GiftCardTransactionTableTableTableManager(
          _db, _db.giftCardTransactionTable);
  $$LoyaltyProgramTableTableTableManager get loyaltyProgramTable =>
      $$LoyaltyProgramTableTableTableManager(_db, _db.loyaltyProgramTable);
  $$LoyaltyMemberTableTableTableManager get loyaltyMemberTable =>
      $$LoyaltyMemberTableTableTableManager(_db, _db.loyaltyMemberTable);
  $$LoyaltyTransactionTableTableTableManager get loyaltyTransactionTable =>
      $$LoyaltyTransactionTableTableTableManager(
          _db, _db.loyaltyTransactionTable);
  $$LoyaltyRewardTableTableTableManager get loyaltyRewardTable =>
      $$LoyaltyRewardTableTableTableManager(_db, _db.loyaltyRewardTable);
  $$TipTableTableTableManager get tipTable =>
      $$TipTableTableTableManager(_db, _db.tipTable);
  $$TipPoolConfigTableTableTableManager get tipPoolConfigTable =>
      $$TipPoolConfigTableTableTableManager(_db, _db.tipPoolConfigTable);
  $$TipDistributionTableTableTableManager get tipDistributionTable =>
      $$TipDistributionTableTableTableManager(_db, _db.tipDistributionTable);
  $$SplitBillTableTableTableManager get splitBillTable =>
      $$SplitBillTableTableTableManager(_db, _db.splitBillTable);
  $$GuestBillTableTableTableManager get guestBillTable =>
      $$GuestBillTableTableTableManager(_db, _db.guestBillTable);
  $$SplitBillItemTableTableTableManager get splitBillItemTable =>
      $$SplitBillItemTableTableTableManager(_db, _db.splitBillItemTable);
  $$DiscountTableTableTableManager get discountTable =>
      $$DiscountTableTableTableManager(_db, _db.discountTable);
  $$AppliedDiscountTableTableTableManager get appliedDiscountTable =>
      $$AppliedDiscountTableTableTableManager(_db, _db.appliedDiscountTable);
  $$WaitlistTableTableTableManager get waitlistTable =>
      $$WaitlistTableTableTableManager(_db, _db.waitlistTable);
  $$StaffAlertTableTableTableManager get staffAlertTable =>
      $$StaffAlertTableTableTableManager(_db, _db.staffAlertTable);
  $$KitchenTicketTableTableTableManager get kitchenTicketTable =>
      $$KitchenTicketTableTableTableManager(_db, _db.kitchenTicketTable);
  $$KitchenItemTableTableTableManager get kitchenItemTable =>
      $$KitchenItemTableTableTableManager(_db, _db.kitchenItemTable);
  $$CustomerFeedbackTableTableTableManager get customerFeedbackTable =>
      $$CustomerFeedbackTableTableTableManager(_db, _db.customerFeedbackTable);
  $$AuditLogTableTableTableManager get auditLogTable =>
      $$AuditLogTableTableTableManager(_db, _db.auditLogTable);
  $$PrintJobTableTableTableManager get printJobTable =>
      $$PrintJobTableTableTableManager(_db, _db.printJobTable);
}
